###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        17/Oct/2018  09:51:23
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TPoolingNand.cpp
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TPoolingNand.cpp -D
#        IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D HAVE_CONFIG_H
#        -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\TPoolingNand.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\TPoolingNand.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TPoolingNand.cpp
      1          /*
      2              Title:
      3              Author:   VN Asliuk(Cardian)
      4              Date:     05.09.2013 12:05:05
      5              Purpose:
      6              Software:
      7              Hardware:
      8              Note:
      9          */
     10          //------------------------------------------------------------------------------------
     11          #include "TPoolingNand.h"
     12          #include "TNandWrite.h"
     13          #include "TDevice.h"
     14          #include "TGuiObjectsV2.h"
     15          
     16          //#include "TSound.h"
     17          
     18          //------------------------------------------------------------------------------------
     19          xTaskHandle TPoolingNand::xhPoolingNand;
     20          //------------------------------------------------------------------------------------
     21          bool TPoolingNand::Pool1WRConfirm = false;
     22          bool TPoolingNand::Pool1REQ = false;
     23          bool TPoolingNand::Pool2REQ = false;
     24          bool TPoolingNand::Pool3REQ = false;
     25          bool TPoolingNand::Pool4REQ = false;

   \                                 In section .bss, align 4
     26          BYTE TPoolingNand::Pool1[POOL1SIZE];
   \                     _ZN12TPoolingNand5Pool1E:
   \   00000000                      DS8 12288

   \                                 In section .bss, align 4
     27          BYTE TPoolingNand::Pool2[POOL2SIZE];
   \                     _ZN12TPoolingNand5Pool2E:
   \   00000000                      DS8 6144

   \                                 In section .bss, align 4
     28          BYTE TPoolingNand::Pool3[POOL3SIZE];
   \                     _ZN12TPoolingNand5Pool3E:
   \   00000000                      DS8 16

   \                                 In section .bss, align 4
     29          BYTE TPoolingNand::Pool4[POOL4SIZE];
   \                     _ZN12TPoolingNand5Pool4E:
   \   00000000                      DS8 16
     30          stPoolParams TPoolingNand::Pool1Params;

   \                                 In section .bss, align 4
     31          stPoolParams TPoolingNand::Pool2Params;
   \                     _ZN12TPoolingNand11Pool2ParamsE:
   \   00000000                      DS8 16
     32          stPoolParams TPoolingNand::Pool3Params;
     33          stPoolParams TPoolingNand::Pool4Params;
     34          int TPoolingNand::CriticalError = perrNoErr;
     35          int TPoolingNand::InDataActivity = -1;  
     36          bool TPoolingNand::wrTaskSuspended = true;
     37          //bool TPoolingNand::wrTaskReadParams = true;
     38          //------------------------------------------------------------------------------------

   \                                 In section .bss, align 1
     39          bool TPoolingNand::WriteOut = false;
   \                     _ZN12TPoolingNand8WriteOutE:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
   \                     _ZN12TPoolingNand11Pool1ParamsE:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN12TPoolingNand14Pool1WRConfirmE:
   \   00000010   0x00               DC8 0
   \                     _ZN12TPoolingNand8Pool1REQE:
   \   00000011   0x00               DC8 0
   \                     _ZN12TPoolingNand8Pool2REQE:
   \   00000012   0x00               DC8 0
   \                     _ZN12TPoolingNand8Pool3REQE:
   \   00000013   0x00               DC8 0
   \                     _ZN12TPoolingNand8Pool4REQE:
   \   00000014   0x00               DC8 0
   \                     _ZN12TPoolingNand15wrTaskSuspendedE:
   \   00000015   0x01               DC8 1
     40          //------------------------------------------------------------------------------------
     41          BYTE TPoolingNand::PoolState = 0;
   \                     _ZN12TPoolingNand9PoolStateE:
   \   00000016   0x00               DC8 0
     42          bool TaskRun = false;
   \                     TaskRun:
   \   00000017   0x00               DC8 0
   \                     _ZN12TPoolingNand11Pool3ParamsE:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN12TPoolingNand11Pool4ParamsE:
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     _ZN12TPoolingNand13xhPoolingNandE:
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN12TPoolingNand13CriticalErrorE:
   \   0000003C   0x00000000         DC32 0
   \                     _ZN12TPoolingNand14InDataActivityE:
   \   00000040   0xFFFFFFFF         DC32 -1
     43          extern bool StopModePeriod;
     44          //------------------------------------------------------------------------------------
     45          

   \                                 In section .text, align 2, keep-with-next
     46          void TPoolingNand::PO_Init()
     47          {
   \                     _ZN12TPoolingNand7PO_InitEv: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
     48            xTaskCreate(TASK_PoolingNand,
     49                        (signed char *) "PoolingNand",
     50                        configMINIMAL_STACK_SIZE,
     51                        NULL, 
     52                        tskIDLE_PRIORITY+2,
     53                        &xhPoolingNand);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable5
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9003             STR      R0,[SP, #+12]
   \   0000000A   0x9002             STR      R0,[SP, #+8]
   \   0000000C   0xF104 0x0038      ADD      R0,R4,#+56
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0x2280             MOVS     R2,#+128
   \   0000001A   0x.... 0x....      ADR.W    R1,?_0
   \   0000001E   0x.... 0x....      ADR.W    R0,_ZN12TPoolingNand16TASK_PoolingNandEPv
   \   00000022   0x.... 0x....      BL       xTaskGenericCreate
     54            CriticalError = perrNoErr;            
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x63E0             STR      R0,[R4, #+60]
     55          }
   \   0000002A   0xBD1F             POP      {R0-R4,PC}       ;; return
     56          //------------------------------------------------------------------------------------
     57          

   \                                 In section .text, align 4, keep-with-next
     58          void TPoolingNand::TASK_PoolingNand(void *pvParameters)
     59          {
   \                     _ZN12TPoolingNand16TASK_PoolingNandEPv: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable5
   \   00000008   0xE001             B.N      ??TASK_PoolingNand_0
     60            volatile int FixIn;
     61            volatile int FixSize;
     62            wfType Type;
     63            
     64            while(1)
     65            {
     66              if(PoolState == 0)
     67              {
     68                wrTaskSuspended = true;
     69          //      GPIO_ResetBits( GPIOA, GPIO_Pin_8 );
     70                 vTaskSuspend(NULL);
     71          //      GPIO_SetBits( GPIOA, GPIO_Pin_8 );
     72                wrTaskSuspended = false;
     73              }
     74          //    vTaskDelay(20/portTICK_RATE_MS); 
     75              
     76              if(CriticalError != perrNoErr)
     77              {
     78          #ifdef WRITE_LED
     79          //!!!      TDevice::LedOn();
     80          #endif
     81                while(1) vTaskDelay(2/portTICK_RATE_MS); 
     82              }
     83              
     84              if(Pool1REQ)
     85              {
     86          //      GPIO_SetBits( GPIOA, GPIO_Pin_8 );
     87                if(Pool1Params.QueueSize == 0) 
     88                {
     89                  Pool1REQ = false; //106
   \                     ??TASK_PoolingNand_1: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x7460             STRB     R0,[R4, #+17]
     90          //        GPIO_ResetBits( GPIOA, GPIO_Pin_8 );
     91                  continue;
     92                }
   \                     ??TASK_PoolingNand_0: (+1)
   \   0000000E   0x7DA0             LDRB     R0,[R4, #+22]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD106             BNE.N    ??TASK_PoolingNand_2
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x7560             STRB     R0,[R4, #+21]
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       vTaskSuspend
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7560             STRB     R0,[R4, #+21]
   \                     ??TASK_PoolingNand_2: (+1)
   \   00000022   0x6BE0             LDR      R0,[R4, #+60]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??TASK_PoolingNand_3
   \                     ??TASK_PoolingNand_4: (+1)
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       vTaskDelay
   \   0000002E   0xE7FB             B.N      ??TASK_PoolingNand_4
   \                     ??TASK_PoolingNand_3: (+1)
   \   00000030   0x7C60             LDRB     R0,[R4, #+17]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD056             BEQ.N    ??TASK_PoolingNand_5
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD0E6             BEQ.N    ??TASK_PoolingNand_1
     93                  
     94          #ifdef WRITE_LED
     95          //!!!      TDevice::LedOn();
     96          #endif
     97          
     98                taskENTER_CRITICAL();
   \   0000003C   0x.... 0x....      BL       vPortEnterCritical
     99                FixIn = Pool1Params.InPtr;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x9001             STR      R0,[SP, #+4]
    100                FixSize = Pool1Params.QueueSize;
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x9000             STR      R0,[SP, #+0]
    101                Pool1Params.QueueSize = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6060             STR      R0,[R4, #+4]
    102                taskEXIT_CRITICAL();
   \   0000004C   0x.... 0x....      BL       vPortExitCritical
    103                
    104                Type = *((wfType*)&Pool1Params.BlockWFType);
   \   00000050   0x68A6             LDR      R6,[R4, #+8]
   \   00000052   0xE002             B.N      ??TASK_PoolingNand_6
    105                
    106                while(!TNandWrite::NW_BeginDataWFrame(Type,Pool1Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_7: (+1)
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x.... 0x....      BL       vTaskDelay
   \                     ??TASK_PoolingNand_6: (+1)
   \   0000005A   0x68E1             LDR      R1,[R4, #+12]
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       _ZN10TNandWrite18NW_BeginDataWFrameE6wfTypej
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD0F6             BEQ.N    ??TASK_PoolingNand_7
    107                  
    108                int _fin = FixIn;
   \   00000066   0x9801             LDR      R0,[SP, #+4]
    109                int isz_diff = (_fin-FixSize);
   \   00000068   0x9900             LDR      R1,[SP, #+0]
   \   0000006A   0x1A45             SUBS     R5,R0,R1
    110                
    111                if(isz_diff < 0)
   \   0000006C   0x....             LDR.N    R6,??DataTable5_1
   \   0000006E   0xD51A             BPL.N    ??TASK_PoolingNand_8
    112                {
    113                  int OutPtr = POOL1SIZE + isz_diff;
   \   00000070   0xF505 0x5540      ADD      R5,R5,#+12288
    114                  int cSz = POOL1SIZE - OutPtr;
   \   00000074   0xF5C5 0x5740      RSB      R7,R5,#+12288
   \   00000078   0xE002             B.N      ??TASK_PoolingNand_9
    115                  while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool1[OutPtr],cSz)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_10: (+1)
   \   0000007A   0x2002             MOVS     R0,#+2
   \   0000007C   0x.... 0x....      BL       vTaskDelay
   \                     ??TASK_PoolingNand_9: (+1)
   \   00000080   0x4639             MOV      R1,R7
   \   00000082   0x19A8             ADDS     R0,R5,R6
   \   00000084   0x.... 0x....      BL       _ZN10TNandWrite27NW_UpdateDataSectorOfWFrameEPKhj
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD0F6             BEQ.N    ??TASK_PoolingNand_10
    116                  while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool1[0],FixIn)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_11: (+1)
   \   0000008C   0x9901             LDR      R1,[SP, #+4]
   \   0000008E   0x4630             MOV      R0,R6
   \   00000090   0x.... 0x....      BL       _ZN10TNandWrite27NW_UpdateDataSectorOfWFrameEPKhj
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD10C             BNE.N    ??TASK_PoolingNand_12
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x.... 0x....      BL       vTaskDelay
   \   0000009E   0xE7F5             B.N      ??TASK_PoolingNand_11
    117                }  
    118                else  
    119                {
    120                  while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool1[isz_diff],FixSize)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_13: (+1)
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0x.... 0x....      BL       vTaskDelay
   \                     ??TASK_PoolingNand_8: (+1)
   \   000000A6   0x9900             LDR      R1,[SP, #+0]
   \   000000A8   0x19A8             ADDS     R0,R5,R6
   \   000000AA   0x.... 0x....      BL       _ZN10TNandWrite27NW_UpdateDataSectorOfWFrameEPKhj
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD0F6             BEQ.N    ??TASK_PoolingNand_13
    121                }
    122                
    123                while(!TNandWrite::NW_EndDataWFrame(false,&Pool1Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_12: (+1)
   \   000000B2   0xF104 0x010C      ADD      R1,R4,#+12
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      BL       _ZN10TNandWrite16NW_EndDataWFrameEbPj
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD103             BNE.N    ??TASK_PoolingNand_14
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0x.... 0x....      BL       vTaskDelay
   \   000000C6   0xE7F4             B.N      ??TASK_PoolingNand_12
    124                  
    125                Pool1REQ = false;
   \                     ??TASK_PoolingNand_14: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x7460             STRB     R0,[R4, #+17]
    126          /*      
    127                if (!start_confirmed)
    128                {
    129                  TSound::PlaySound(_modiShortBeep);
    130                  start_confirmed = true;
    131                }
    132          */      
    133                Pool1WRConfirm = true;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x7420             STRB     R0,[R4, #+16]
    134                
    135                
    136          //      vTaskDelay(20/portTICK_RATE_MS); 
    137          #ifdef WRITE_LED
    138                TDevice::LedOff();
    139          #endif
    140                TaskRun = false;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x75E0             STRB     R0,[R4, #+23]
    141                if(TNandWrite::NandWrProcc == false) 
   \   000000D4   0x....             LDR.N    R0,??DataTable5_2
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD198             BNE.N    ??TASK_PoolingNand_0
    142                {
    143          //        GPIO_ResetBits( GPIOA, GPIO_Pin_8 );
    144                  StopModePeriod = false;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x....             LDR.N    R1,??DataTable5_3
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   \   000000E2   0xE794             B.N      ??TASK_PoolingNand_0
    145                }
    146                continue;  
    147              }
    148              StopModePeriod = false;
   \                     ??TASK_PoolingNand_5: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x....             LDR.N    R1,??DataTable5_3
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
    149          //    GPIO_ResetBits( GPIOA, GPIO_Pin_8 );
    150              if(Pool2REQ)
   \   000000EA   0x7CA0             LDRB     R0,[R4, #+18]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD04C             BEQ.N    ??TASK_PoolingNand_15
    151              {
    152                if(Pool2Params.QueueSize == 0) 
   \   000000F0   0x....             LDR.N    R5,??DataTable5_4
   \   000000F2   0x6868             LDR      R0,[R5, #+4]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD045             BEQ.N    ??TASK_PoolingNand_16
    153                {
    154                  Pool2REQ = false;
    155                  continue;
    156                }
    157          #ifdef WRITE_LED
    158          //!!!      TDevice::LedOn();
    159          #endif
    160                taskENTER_CRITICAL();
   \   000000F8   0x.... 0x....      BL       vPortEnterCritical
    161                FixIn = Pool2Params.InPtr;
   \   000000FC   0x6828             LDR      R0,[R5, #+0]
   \   000000FE   0x9001             STR      R0,[SP, #+4]
    162                FixSize = Pool2Params.QueueSize;
   \   00000100   0x6868             LDR      R0,[R5, #+4]
   \   00000102   0x9000             STR      R0,[SP, #+0]
    163                Pool2Params.QueueSize = 0;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x6068             STR      R0,[R5, #+4]
    164                taskEXIT_CRITICAL();
   \   00000108   0x.... 0x....      BL       vPortExitCritical
    165                
    166                Type = *((wfType*)&Pool2Params.BlockWFType);
   \   0000010C   0x68AE             LDR      R6,[R5, #+8]
   \   0000010E   0xE002             B.N      ??TASK_PoolingNand_17
    167                
    168                while(!TNandWrite::NW_BeginDataWFrame(Type,Pool2Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_18: (+1)
   \   00000110   0x2002             MOVS     R0,#+2
   \   00000112   0x.... 0x....      BL       vTaskDelay
   \                     ??TASK_PoolingNand_17: (+1)
   \   00000116   0x68E9             LDR      R1,[R5, #+12]
   \   00000118   0x4630             MOV      R0,R6
   \   0000011A   0x.... 0x....      BL       _ZN10TNandWrite18NW_BeginDataWFrameE6wfTypej
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD0F6             BEQ.N    ??TASK_PoolingNand_18
    169                  
    170                int _fin = FixIn;
   \   00000122   0x9801             LDR      R0,[SP, #+4]
    171                int isz_diff = (_fin-FixSize);
   \   00000124   0x9900             LDR      R1,[SP, #+0]
   \   00000126   0x1A46             SUBS     R6,R0,R1
    172                if(isz_diff < 0)
   \   00000128   0x....             LDR.N    R7,??DataTable5_5
   \   0000012A   0xD51A             BPL.N    ??TASK_PoolingNand_19
    173                {
    174                  int OutPtr = POOL2SIZE + isz_diff;
   \   0000012C   0xF506 0x56C0      ADD      R6,R6,#+6144
    175                  int cSz = POOL2SIZE - OutPtr;
   \   00000130   0xF5C6 0x58C0      RSB      R8,R6,#+6144
   \   00000134   0xE002             B.N      ??TASK_PoolingNand_20
    176                  while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool2[OutPtr],cSz)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_21: (+1)
   \   00000136   0x2002             MOVS     R0,#+2
   \   00000138   0x.... 0x....      BL       vTaskDelay
   \                     ??TASK_PoolingNand_20: (+1)
   \   0000013C   0x4641             MOV      R1,R8
   \   0000013E   0x19F0             ADDS     R0,R6,R7
   \   00000140   0x.... 0x....      BL       _ZN10TNandWrite27NW_UpdateDataSectorOfWFrameEPKhj
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD0F6             BEQ.N    ??TASK_PoolingNand_21
    177                  while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool2[0],FixIn)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_22: (+1)
   \   00000148   0x9901             LDR      R1,[SP, #+4]
   \   0000014A   0x4638             MOV      R0,R7
   \   0000014C   0x.... 0x....      BL       _ZN10TNandWrite27NW_UpdateDataSectorOfWFrameEPKhj
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD10C             BNE.N    ??TASK_PoolingNand_23
   \   00000154   0x2002             MOVS     R0,#+2
   \   00000156   0x.... 0x....      BL       vTaskDelay
   \   0000015A   0xE7F5             B.N      ??TASK_PoolingNand_22
    178                }  
    179                else  
    180                {
    181                  while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool2[isz_diff],FixSize)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_24: (+1)
   \   0000015C   0x2002             MOVS     R0,#+2
   \   0000015E   0x.... 0x....      BL       vTaskDelay
   \                     ??TASK_PoolingNand_19: (+1)
   \   00000162   0x9900             LDR      R1,[SP, #+0]
   \   00000164   0x19F0             ADDS     R0,R6,R7
   \   00000166   0x.... 0x....      BL       _ZN10TNandWrite27NW_UpdateDataSectorOfWFrameEPKhj
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD0F6             BEQ.N    ??TASK_PoolingNand_24
    182                }
    183                
    184                while(!TNandWrite::NW_EndDataWFrame(false,&Pool2Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
   \                     ??TASK_PoolingNand_23: (+1)
   \   0000016E   0xF105 0x010C      ADD      R1,R5,#+12
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0x.... 0x....      BL       _ZN10TNandWrite16NW_EndDataWFrameEbPj
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD103             BNE.N    ??TASK_PoolingNand_16
   \   0000017C   0x2002             MOVS     R0,#+2
   \   0000017E   0x.... 0x....      BL       vTaskDelay
   \   00000182   0xE7F4             B.N      ??TASK_PoolingNand_23
    185                  
    186                Pool2REQ = false;
   \                     ??TASK_PoolingNand_16: (+1)
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x74A0             STRB     R0,[R4, #+18]
    187          //      vTaskDelay(20/portTICK_RATE_MS); 
    188                #ifdef WRITE_LED
    189                  TDevice::LedOff();
    190                #endif
    191                continue;  
   \   00000188   0xE741             B.N      ??TASK_PoolingNand_0
    192              }
    193          //    if(Pool3REQ)
    194          //    {
    195          //      if(Pool3Params.QueueSize == 0) continue;
    196          //      #ifdef WRITE_LED
    197          //        TDevice::LedOn();
    198          //      #endif
    199          //      taskENTER_CRITICAL();
    200          //      FixIn = Pool3Params.InPtr;
    201          //      FixSize = Pool3Params.QueueSize;
    202          //      Pool3Params.QueueSize = 0;
    203          //      taskEXIT_CRITICAL();
    204          //      
    205          //      Type = *((wfType*)&Pool3Params.BlockWFType);
    206          //      
    207          //      while(!TNandWrite::NW_BeginDataWFrame(Type,Pool3Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
    208          //        
    209          //      int _fin = FixIn;
    210          //      int isz_diff = (_fin-FixSize);
    211          //      if(isz_diff < 0)
    212          //      {
    213          //        int OutPtr = POOL3SIZE + isz_diff;
    214          //        int cSz = POOL3SIZE - OutPtr;
    215          //        while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool3[OutPtr],cSz)) vTaskDelay(2/portTICK_RATE_MS); 
    216          //        while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool3[0],FixIn)) vTaskDelay(2/portTICK_RATE_MS); 
    217          //      }  
    218          //      else  
    219          //      {
    220          //        while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool3[isz_diff],FixSize)) vTaskDelay(2/portTICK_RATE_MS); 
    221          //      }
    222          //      
    223          //      while(!TNandWrite::NW_EndDataWFrame(false,&Pool3Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
    224          //        
    225          //      Pool3REQ = false;
    226          //      vTaskDelay(2/portTICK_RATE_MS); 
    227          //      #ifdef WRITE_LED
    228          //        TDevice::LedOff();
    229          //      #endif
    230          //      continue;  
    231          //    }
    232          //    if(Pool4REQ)
    233          //    {
    234          //      if(Pool4Params.QueueSize == 0) continue;
    235          //      #ifdef WRITE_LED
    236          //        TDevice::LedOn();
    237          //      #endif
    238          //      taskENTER_CRITICAL();
    239          //      FixIn = Pool4Params.InPtr;
    240          //      FixSize = Pool4Params.QueueSize;
    241          //      Pool4Params.QueueSize = 0;
    242          //      taskEXIT_CRITICAL();
    243          //      
    244          //      Type = *((wfType*)&Pool4Params.BlockWFType);
    245          //      
    246          //      while(!TNandWrite::NW_BeginDataWFrame(Type,Pool4Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
    247          //        
    248          //      int _fin = FixIn;
    249          //      int isz_diff = (_fin-FixSize);
    250          //      if(isz_diff < 0)
    251          //      {
    252          //        int OutPtr = POOL4SIZE + isz_diff;
    253          //        int cSz = POOL4SIZE - OutPtr;
    254          //        while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool4[OutPtr],cSz)) vTaskDelay(2/portTICK_RATE_MS); 
    255          //        while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool4[0],FixIn)) vTaskDelay(2/portTICK_RATE_MS); 
    256          //      }  
    257          //      else  
    258          //      {
    259          //        while(!TNandWrite::NW_UpdateDataSectorOfWFrame(&Pool4[isz_diff],FixSize)) vTaskDelay(2/portTICK_RATE_MS); 
    260          //      }
    261          //      
    262          //      while(!TNandWrite::NW_EndDataWFrame(false,&Pool4Params.BlockTakeSample)) vTaskDelay(2/portTICK_RATE_MS); 
    263          //        
    264          //      Pool4REQ = false;
    265          //      vTaskDelay(2/portTICK_RATE_MS); 
    266          //      #ifdef WRITE_LED
    267          //        TDevice::LedOff();
    268          //      #endif
    269          //      continue;  
    270          //    }
    271              
    272              vTaskDelay(2/portTICK_RATE_MS);     
   \                     ??TASK_PoolingNand_15: (+1)
   \   0000018A   0x2002             MOVS     R0,#+2
   \   0000018C   0x.... 0x....      BL       vTaskDelay
   \   00000190   0xE73D             B.N      ??TASK_PoolingNand_0
    273            }
    274          }
    275          //------------------------------------------------------------------------------------
    276              

   \                                 In section .text, align 2, keep-with-next
    277          void TPoolingNand::AddDataToPool(int pool,BYTE *data,int Size,bool FromIsr)
    278          {
   \                     _ZN12TPoolingNand13AddDataToPoolEiPhib: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   \   00000008   0x461E             MOV      R6,R3
    279            InDataActivity = DATAACTIVITYTOUT;
   \   0000000A   0x....             LDR.N    R7,??DataTable5
   \   0000000C   0x2164             MOVS     R1,#+100
   \   0000000E   0x6439             STR      R1,[R7, #+64]
    280            switch(pool)
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD002             BEQ.N    ??AddDataToPool_0
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD03A             BEQ.N    ??AddDataToPool_1
   \   00000018   0xE04B             B.N      ??AddDataToPool_2
    281            {
    282              case 1:
    283                {
    284                  if((PoolState & 0x01) == 0) break;
   \                     ??AddDataToPool_0: (+1)
   \   0000001A   0x7DB8             LDRB     R0,[R7, #+22]
   \   0000001C   0x07C0             LSLS     R0,R0,#+31
   \   0000001E   0xD548             BPL.N    ??AddDataToPool_2
    285                  for(int i = 0;i < Size;i++)
   \   00000020   0xF04F 0x0800      MOV      R8,#+0
   \   00000024   0xE003             B.N      ??AddDataToPool_3
    286                  {
    287                    Pool1[Pool1Params.InPtr++] = data[i];
    288                    if(Pool1Params.InPtr >= POOL1SIZE) Pool1Params.InPtr = 0;
    289                    Pool1Params.QueueSize++;
    290                    if(Pool1Params.QueueSize > POOL1SIZE) 
    291                    {
    292                      CriticalError = perrPool1Ovr;
    293                      TGuiObjects::ToolbarSet(TBFM_ERROR,1);
    294                      vTaskSuspend(xhPoolingNand);
    295                      return;
    296                    }
    297                    const int percsz0 = ((POOL1SIZE * POOL1THRESHOLD) / 100);  
    298                    if(Pool1Params.QueueSize > percsz0) 
    299                    {
    300                      Pool1REQ = true;
    301                      if(wrTaskSuspended)
    302                      {  
    303                        TaskRun = true;
    304                        if(FromIsr)
    305                          xTaskResumeFromISR(xhPoolingNand);
    306                        else  
    307                          vTaskResume(xhPoolingNand);
   \                     ??AddDataToPool_4: (+1)
   \   00000026   0x.... 0x....      BL       vTaskResume
   \                     ??AddDataToPool_5: (+1)
   \   0000002A   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??AddDataToPool_3: (+1)
   \   0000002E   0x45A8             CMP      R8,R5
   \   00000030   0xDA3F             BGE.N    ??AddDataToPool_2
   \   00000032   0x6838             LDR      R0,[R7, #+0]
   \   00000034   0xF818 0x1004      LDRB     R1,[R8, R4]
   \   00000038   0x....             LDR.N    R2,??DataTable5_1
   \   0000003A   0x5481             STRB     R1,[R0, R2]
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x6038             STR      R0,[R7, #+0]
   \   00000040   0xF5B0 0x5F40      CMP      R0,#+12288
   \   00000044   0xDB01             BLT.N    ??AddDataToPool_6
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6038             STR      R0,[R7, #+0]
   \                     ??AddDataToPool_6: (+1)
   \   0000004A   0x6878             LDR      R0,[R7, #+4]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x6078             STR      R0,[R7, #+4]
   \   00000050   0xF5B0 0x5F40      CMP      R0,#+12288
   \   00000054   0xDD0B             BLE.N    ??AddDataToPool_7
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x63F8             STR      R0,[R7, #+60]
   \   0000005A   0x4601             MOV      R1,R0
   \   0000005C   0xF44F 0x3000      MOV      R0,#+131072
   \   00000060   0x.... 0x....      BL       _ZN11TGuiObjects10ToolbarSetEib
   \   00000064   0x6BB8             LDR      R0,[R7, #+56]
   \   00000066   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   0000006A   0x.... 0x....      B.W      vTaskSuspend
   \                     ??AddDataToPool_7: (+1)
   \   0000006E   0xF5B0 0x5FC0      CMP      R0,#+6144
   \   00000072   0xDDDA             BLE.N    ??AddDataToPool_5
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x7478             STRB     R0,[R7, #+17]
   \   00000078   0x7D78             LDRB     R0,[R7, #+21]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD0D5             BEQ.N    ??AddDataToPool_5
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0x75F8             STRB     R0,[R7, #+23]
   \   00000082   0x6BB8             LDR      R0,[R7, #+56]
   \   00000084   0x2E00             CMP      R6,#+0
   \   00000086   0xD0CE             BEQ.N    ??AddDataToPool_4
   \   00000088   0x.... 0x....      BL       xTaskResumeFromISR
   \   0000008C   0xE7CD             B.N      ??AddDataToPool_5
    308                      }
    309                    }
    310          //          else GPIO_ResetBits( GPIOA, GPIO_Pin_8 );
    311                  }
    312          //        if(TaskRun == false) GPIO_ResetBits( GPIOA, GPIO_Pin_8 );
    313                }
    314                break;
    315              case 2:
    316                {
    317                  if((PoolState & 0x02) == 0) break;
   \                     ??AddDataToPool_1: (+1)
   \   0000008E   0x7DB8             LDRB     R0,[R7, #+22]
   \   00000090   0x0780             LSLS     R0,R0,#+30
   \   00000092   0xD50E             BPL.N    ??AddDataToPool_2
    318                  if((Pool2Params.QueueSize+Size) > POOL2SIZE)
   \   00000094   0x.... 0x....      LDR.W    R8,??DataTable5_4
   \   00000098   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   0000009C   0x1828             ADDS     R0,R5,R0
   \   0000009E   0xF5B0 0x5FC0      CMP      R0,#+6144
   \   000000A2   0xDD08             BLE.N    ??AddDataToPool_8
    319                  {
    320                    TGuiObjects::ToolbarSet(TBFM_ERROR,1);
   \   000000A4   0x2101             MOVS     R1,#+1
   \   000000A6   0xF44F 0x3000      MOV      R0,#+131072
   \   000000AA   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000AE   0x.... 0x....      B.W      _ZN11TGuiObjects10ToolbarSetEib
    321                    break;
    322                  }
    323                  for(int i = 0;i < Size;i++)
    324                  {
    325                    Pool2[Pool2Params.InPtr] = data[i];
    326                    Pool2Params.QueueSize++;
    327          //          if(Pool2Params.QueueSize > POOL2SIZE) 
    328          //            {
    329          //              Pool2Params.QueueSize--;
    330          ////              CriticalError = perrPool2Ovr;
    331          //              TGuiObjects::ToolbarSet(TBFM_ERROR,1);
    332          ////              vTaskSuspend(xhPoolingNand);
    333          //              return;
    334          //            }
    335                    Pool2Params.InPtr++;
    336                    if(Pool2Params.InPtr >= POOL2SIZE) Pool2Params.InPtr = 0;
    337                    
    338                    const int percsz1 = ((POOL2SIZE * POOL2THRESHOLD) / 100);  
    339                    if(Pool2Params.QueueSize > percsz1) 
    340                      {
    341                        Pool2REQ = true;
    342                        if(wrTaskSuspended)
    343                        {  
    344                          if(FromIsr)
    345                            xTaskResumeFromISR(xhPoolingNand);
    346                          else  
    347                            vTaskResume(xhPoolingNand);
    348                        }
    349                      }
    350                  }
    351                }
    352                break;
    353          //    case 3:
    354          //      {
    355          //        if((PoolState & 0x04) == 0) break;
    356          //        for(int i = 0;i < Size;i++)
    357          //        {
    358          //          Pool3[Pool3Params.InPtr++] = data[i];
    359          //          if(Pool3Params.InPtr >= POOL3SIZE) Pool3Params.InPtr = 0;
    360          //          Pool3Params.QueueSize++;
    361          //          if(Pool3Params.QueueSize > POOL3SIZE) 
    362          //            {
    363          //              CriticalError = perrPool3Ovr;
    364          //              TGuiObjects::ToolbarSet(TBFM_ERROR,1);
    365          //              vTaskSuspend(xhPoolingNand);
    366          //              return;
    367          //            }
    368          //          const int percsz = ((POOL3SIZE * POOL3THRESHOLD) / 100);  
    369          //          if(Pool3Params.QueueSize > percsz) 
    370          //            {
    371          //              Pool3REQ = true;
    372          //              if(wrTaskSuspended)
    373          //              {  
    374          //                if(FromIsr)
    375          //                  xTaskResumeFromISR(xhPoolingNand);
    376          //                else  
    377          //                  vTaskResume(xhPoolingNand);
    378          //              }
    379          //            }
    380          //        }
    381          //      }
    382          //      break;
    383          //    case 4:
    384          //      {
    385          //        if((PoolState & 0x08) == 0) break;
    386          //        for(int i = 0;i < Size;i++)
    387          //        {
    388          //          Pool4[Pool4Params.InPtr++] = data[i];
    389          //          if(Pool4Params.InPtr >= POOL4SIZE) Pool4Params.InPtr = 0;
    390          //          Pool4Params.QueueSize++;
    391          //          if(Pool4Params.QueueSize > POOL4SIZE) 
    392          //            {
    393          //              CriticalError = perrPool4Ovr;
    394          //              TGuiObjects::ToolbarSet(TBFM_ERROR,1);
    395          //              vTaskSuspend(xhPoolingNand);
    396          //              return;
    397          //            }
    398          //          const int percsz = ((POOL4SIZE * POOL4THRESHOLD) / 100);  
    399          //          if(Pool4Params.QueueSize > percsz) 
    400          //            {
    401          //              Pool4REQ = true;
    402          //              if(wrTaskSuspended)
    403          //              {  
    404          //                if(FromIsr)
    405          //                  xTaskResumeFromISR(xhPoolingNand);
    406          //                else  
    407          //                  vTaskResume(xhPoolingNand);
    408          //              }
    409          //            }
    410          //        }
    411          //      }
    412          //      break;
    413              default:
    414                return;  
    415            }
    416          }
   \                     ??AddDataToPool_2: (+1)
   \   000000B2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??AddDataToPool_8: (+1)
   \   000000B6   0xF04F 0x0900      MOV      R9,#+0
   \   000000BA   0xE003             B.N      ??AddDataToPool_9
   \                     ??AddDataToPool_10: (+1)
   \   000000BC   0x.... 0x....      BL       vTaskResume
   \                     ??AddDataToPool_11: (+1)
   \   000000C0   0xF109 0x0901      ADD      R9,R9,#+1
   \                     ??AddDataToPool_9: (+1)
   \   000000C4   0x45A9             CMP      R9,R5
   \   000000C6   0xDAF4             BGE.N    ??AddDataToPool_2
   \   000000C8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000CC   0xF819 0x1004      LDRB     R1,[R9, R4]
   \   000000D0   0x....             LDR.N    R2,??DataTable5_5
   \   000000D2   0x5481             STRB     R1,[R0, R2]
   \   000000D4   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \   000000D8   0x1C49             ADDS     R1,R1,#+1
   \   000000DA   0xF8C8 0x1004      STR      R1,[R8, #+4]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \   000000E4   0xF5B0 0x5FC0      CMP      R0,#+6144
   \   000000E8   0xDB02             BLT.N    ??AddDataToPool_12
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \                     ??AddDataToPool_12: (+1)
   \   000000F0   0xF5B1 0x6F40      CMP      R1,#+3072
   \   000000F4   0xDDE4             BLE.N    ??AddDataToPool_11
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x74B8             STRB     R0,[R7, #+18]
   \   000000FA   0x7D78             LDRB     R0,[R7, #+21]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD0DF             BEQ.N    ??AddDataToPool_11
   \   00000100   0x6BB8             LDR      R0,[R7, #+56]
   \   00000102   0x2E00             CMP      R6,#+0
   \   00000104   0xD0DA             BEQ.N    ??AddDataToPool_10
   \   00000106   0x.... 0x....      BL       xTaskResumeFromISR
   \   0000010A   0xE7D9             B.N      ??AddDataToPool_11
    417          //------------------------------------------------------------------------------------
    418          

   \                                 In section .text, align 2, keep-with-next
    419          void TPoolingNand::FinishPool(int pool)
    420          {
    421          //  wfType *wf;
    422            
    423            switch(pool)
   \                     _ZN12TPoolingNand10FinishPoolEi: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD006             BEQ.N    ??FinishPool_0
   \   00000004   0xD30F             BCC.N    ??FinishPool_1
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD016             BEQ.N    ??FinishPool_2
   \   0000000A   0xD30D             BCC.N    ??FinishPool_3
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD01B             BEQ.N    ??FinishPool_4
   \   00000010   0x4770             BX       LR
    424            {
    425              case 1: 
    426                Pool1REQ = true;
   \                     ??FinishPool_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable5
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x7441             STRB     R1,[R0, #+17]
    427                PoolState &= ~0x01;
   \   00000018   0x7D81             LDRB     R1,[R0, #+22]
   \   0000001A   0xF001 0x01FE      AND      R1,R1,#0xFE
   \   0000001E   0x7581             STRB     R1,[R0, #+22]
    428                break;
    429              case 2: 
    430                Pool2REQ = true;
    431                PoolState &= ~0x02;
    432                break;
    433              case 3: 
    434                Pool3REQ = true;
    435                PoolState &= ~0x04;
    436                break;
    437              case 4: 
    438                Pool4REQ = true;
    439                PoolState &= ~0x08;
    440                break;
    441              default:
    442                return;  
    443            }
    444            vTaskResume(xhPoolingNand);
   \                     ??FinishPool_5: (+1)
   \   00000020   0x6B80             LDR      R0,[R0, #+56]
   \   00000022   0x.... 0x....      B.W      vTaskResume
   \                     ??FinishPool_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
   \                     ??FinishPool_3: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable5
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x7481             STRB     R1,[R0, #+18]
   \   0000002E   0x7D81             LDRB     R1,[R0, #+22]
   \   00000030   0xF001 0x01FD      AND      R1,R1,#0xFD
   \   00000034   0x7581             STRB     R1,[R0, #+22]
   \   00000036   0xE7F3             B.N      ??FinishPool_5
   \                     ??FinishPool_2: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable5
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x74C1             STRB     R1,[R0, #+19]
   \   0000003E   0x7D81             LDRB     R1,[R0, #+22]
   \   00000040   0xF001 0x01FB      AND      R1,R1,#0xFB
   \   00000044   0x7581             STRB     R1,[R0, #+22]
   \   00000046   0xE7EB             B.N      ??FinishPool_5
   \                     ??FinishPool_4: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable5
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x7501             STRB     R1,[R0, #+20]
   \   0000004E   0x7D81             LDRB     R1,[R0, #+22]
   \   00000050   0xF001 0x01F7      AND      R1,R1,#0xF7
   \   00000054   0x7581             STRB     R1,[R0, #+22]
   \   00000056   0xE7E3             B.N      ??FinishPool_5
    445          }
    446          //------------------------------------------------------------------------------------
    447          

   \                                 In section .text, align 2, keep-with-next
    448          void TPoolingNand::SetupPool(int pool,wfType wftype)
    449          {
    450            uint32_t wft = *((uint32_t*) &wftype);
    451            
    452            switch(pool)
   \                     _ZN12TPoolingNand9SetupPoolEi6wfType: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD006             BEQ.N    ??SetupPool_0
   \   00000004   0xD311             BCC.N    ??SetupPool_1
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD01E             BEQ.N    ??SetupPool_2
   \   0000000A   0xD30F             BCC.N    ??SetupPool_3
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD028             BEQ.N    ??SetupPool_4
   \   00000010   0x4770             BX       LR
    453            {
    454              case 1:
    455                PoolState |= 0x01;
   \                     ??SetupPool_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable5
   \   00000014   0x7D82             LDRB     R2,[R0, #+22]
   \   00000016   0xF042 0x0201      ORR      R2,R2,#0x1
   \   0000001A   0x7582             STRB     R2,[R0, #+22]
    456                Pool1REQ = false;
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x7442             STRB     R2,[R0, #+17]
    457                Pool1Params.InPtr = 0;
   \   00000020   0x6002             STR      R2,[R0, #+0]
    458                Pool1Params.QueueSize = 0;
   \   00000022   0x6042             STR      R2,[R0, #+4]
    459                Pool1Params.BlockWFType = wft;
   \   00000024   0x6081             STR      R1,[R0, #+8]
    460                Pool1Params.BlockTakeSample = 0;
   \   00000026   0x4611             MOV      R1,R2
   \   00000028   0x60C1             STR      R1,[R0, #+12]
    461                break;
    462              case 2:
    463                PoolState |= 0x02;
    464                Pool2REQ = false;
    465                Pool2Params.InPtr = 0;
    466                Pool2Params.QueueSize = 0;
    467                Pool2Params.BlockWFType = wft;
    468                Pool2Params.BlockTakeSample = 0;
    469                break;
    470              case 3:
    471                PoolState |= 0x04;
    472                Pool3REQ = false;
    473                Pool3Params.InPtr = 0;
    474                Pool3Params.QueueSize = 0;
    475                Pool3Params.BlockWFType = wft;
    476                Pool3Params.BlockTakeSample = 0;
    477                break;
    478              case 4:
    479                PoolState |= 0x08;
    480                Pool4REQ = false;
    481                Pool4Params.InPtr = 0;
    482                Pool4Params.QueueSize = 0;
    483                Pool4Params.BlockWFType = wft;
    484                Pool4Params.BlockTakeSample = 0;
    485                break;
    486              default:
    487                return;  
    488            }
    489          }
   \                     ??SetupPool_1: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
   \                     ??SetupPool_3: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable5
   \   0000002E   0x7D82             LDRB     R2,[R0, #+22]
   \   00000030   0xF042 0x0202      ORR      R2,R2,#0x2
   \   00000034   0x7582             STRB     R2,[R0, #+22]
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x7482             STRB     R2,[R0, #+18]
   \   0000003A   0x....             LDR.N    R0,??DataTable5_4
   \   0000003C   0x6002             STR      R2,[R0, #+0]
   \   0000003E   0x6042             STR      R2,[R0, #+4]
   \   00000040   0x6081             STR      R1,[R0, #+8]
   \   00000042   0x4611             MOV      R1,R2
   \   00000044   0x60C1             STR      R1,[R0, #+12]
   \   00000046   0x4770             BX       LR
   \                     ??SetupPool_2: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable5
   \   0000004A   0x7D82             LDRB     R2,[R0, #+22]
   \   0000004C   0xF042 0x0204      ORR      R2,R2,#0x4
   \   00000050   0x7582             STRB     R2,[R0, #+22]
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x74C2             STRB     R2,[R0, #+19]
   \   00000056   0x6182             STR      R2,[R0, #+24]
   \   00000058   0x61C2             STR      R2,[R0, #+28]
   \   0000005A   0x6201             STR      R1,[R0, #+32]
   \   0000005C   0x4611             MOV      R1,R2
   \   0000005E   0x6241             STR      R1,[R0, #+36]
   \   00000060   0x4770             BX       LR
   \                     ??SetupPool_4: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable5
   \   00000064   0x7D82             LDRB     R2,[R0, #+22]
   \   00000066   0xF042 0x0208      ORR      R2,R2,#0x8
   \   0000006A   0x7582             STRB     R2,[R0, #+22]
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x7502             STRB     R2,[R0, #+20]
   \   00000070   0x6282             STR      R2,[R0, #+40]
   \   00000072   0x62C2             STR      R2,[R0, #+44]
   \   00000074   0x6301             STR      R1,[R0, #+48]
   \   00000076   0x4611             MOV      R1,R2
   \   00000078   0x6341             STR      R1,[R0, #+52]
   \   0000007A   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     _ZN12TPoolingNand11Pool1ParamsE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     _ZN12TPoolingNand5Pool1E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     _ZN10TNandWrite11NandWrProccE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     StopModePeriod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     _ZN12TPoolingNand11Pool2ParamsE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     _ZN12TPoolingNand5Pool2E

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x50 0x6F          DC8 "PoolingNand"
   \              0x6F 0x6C    
   \              0x69 0x6E    
   \              0x67 0x4E    
   \              0x61 0x6E    
   \              0x64 0x00    
    490          //------------------------------------------------------------------------------------

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   TPoolingNand::AddDataToPool(int, BYTE *, int, bool)
        32   -> TGuiObjects::ToolbarSet(int, bool)
         0   -> vTaskResume
        32   -> vTaskResume
        32   -> xTaskResumeFromISR
       0   TPoolingNand::FinishPool(int)
      24   TPoolingNand::PO_Init()
        24   -> xTaskGenericCreate
       0   TPoolingNand::SetupPool(int, wfType)
      32   TPoolingNand::TASK_PoolingNand(void *)
        32   -> TNandWrite::NW_BeginDataWFrame(wfType, uint32_t)
        32   -> TNandWrite::NW_EndDataWFrame(bool, uint32_t *)
        32   -> TNandWrite::NW_UpdateDataSectorOfWFrame(uint8_t const *, uint32_t)
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vTaskDelay
        32   -> vTaskSuspend


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
      12  ?_0
     268  TPoolingNand::AddDataToPool(int, BYTE *, int, bool)
      88  TPoolingNand::FinishPool(int)
      44  TPoolingNand::PO_Init()
   12288  TPoolingNand::Pool1
      68  TPoolingNand::Pool1Params
          TPoolingNand::Pool1WRConfirm
          TPoolingNand::Pool1REQ
          TPoolingNand::Pool2REQ
          TPoolingNand::Pool3REQ
          TPoolingNand::Pool4REQ
          TPoolingNand::wrTaskSuspended
          TPoolingNand::PoolState
          TaskRun
          TPoolingNand::Pool3Params
          TPoolingNand::Pool4Params
          TPoolingNand::xhPoolingNand
          TPoolingNand::CriticalError
          TPoolingNand::InDataActivity
    6144  TPoolingNand::Pool2
      16  TPoolingNand::Pool2Params
      16  TPoolingNand::Pool3
      16  TPoolingNand::Pool4
     124  TPoolingNand::SetupPool(int, wfType)
     402  TPoolingNand::TASK_PoolingNand(void *)
       1  TPoolingNand::WriteOut

 
 18 481 bytes in section .bss
     68 bytes in section .data
    962 bytes in section .text
 
    962 bytes of CODE memory
 18 549 bytes of DATA memory

Errors: none
Warnings: none
