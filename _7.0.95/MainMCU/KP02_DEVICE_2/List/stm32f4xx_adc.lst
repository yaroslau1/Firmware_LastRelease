###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        09/Oct/2018  16:32:35
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_adc.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_adc.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_adc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      9            *           + Initialization and Configuration (in addition to ADC multi mode 
     10            *             selection)
     11            *           + Analog Watchdog configuration
     12            *           + Temperature Sensor & Vrefint (Voltage Reference internal) & VBAT
     13            *             management 
     14            *           + Regular Channels Configuration
     15            *           + Regular Channels DMA Configuration
     16            *           + Injected channels Configuration
     17            *           + Interrupts and flags management
     18            *         
     19            @verbatim
     20           ===============================================================================
     21                               ##### How to use this driver #####
     22           ===============================================================================
     23              [..]
     24              (#) Enable the ADC interface clock using 
     25                  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADCx, ENABLE); 
     26                 
     27              (#) ADC pins configuration
     28                   (++) Enable the clock for the ADC GPIOs using the following function:
     29                       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);   
     30                   (++) Configure these ADC pins in analog mode using GPIO_Init();  
     31            
     32               (#) Configure the ADC Prescaler, conversion resolution and data 
     33                   alignment using the ADC_Init() function.
     34               (#) Activate the ADC peripheral using ADC_Cmd() function.
     35            
     36               *** Regular channels group configuration ***
     37               ============================================
     38               [..]    
     39                 (+) To configure the ADC regular channels group features, use 
     40                     ADC_Init() and ADC_RegularChannelConfig() functions.
     41                 (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     42                     function.
     43                 (+) To configurate and activate the Discontinuous mode, use the 
     44                     ADC_DiscModeChannelCountConfig() and ADC_DiscModeCmd() functions.
     45                 (+) To read the ADC converted values, use the ADC_GetConversionValue()
     46                     function.
     47            
     48               *** Multi mode ADCs Regular channels configuration ***
     49               ======================================================
     50               [..]
     51                 (+) Refer to "Regular channels group configuration" description to
     52                     configure the ADC1, ADC2 and ADC3 regular channels.        
     53                 (+) Select the Multi mode ADC regular channels features (dual or 
     54                     triple mode) using ADC_CommonInit() function and configure 
     55                     the DMA mode using ADC_MultiModeDMARequestAfterLastTransferCmd() 
     56                     functions.        
     57                 (+) Read the ADCs converted values using the 
     58                     ADC_GetMultiModeConversionValue() function.
     59            
     60               *** DMA for Regular channels group features configuration ***
     61               ============================================================= 
     62               [..]
     63                 (+) To enable the DMA mode for regular channels group, use the 
     64                     ADC_DMACmd() function.
     65                 (+) To enable the generation of DMA requests continuously at the end
     66                     of the last DMA transfer, use the ADC_DMARequestAfterLastTransferCmd() 
     67                     function.
     68            
     69               *** Injected channels group configuration ***
     70               =============================================    
     71               [..]
     72                 (+) To configure the ADC Injected channels group features, use 
     73                     ADC_InjectedChannelConfig() and  ADC_InjectedSequencerLengthConfig()
     74                     functions.
     75                 (+) To activate the continuous mode, use the ADC_continuousModeCmd()
     76                     function.
     77                 (+) To activate the Injected Discontinuous mode, use the 
     78                     ADC_InjectedDiscModeCmd() function.  
     79                 (+) To activate the AutoInjected mode, use the ADC_AutoInjectedConvCmd() 
     80                     function.        
     81                 (+) To read the ADC converted values, use the ADC_GetInjectedConversionValue() 
     82                     function.
     83            
     84              @endverbatim
     85            ******************************************************************************
     86            * @attention
     87            *
     88            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     89            *
     90            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     91            * You may not use this file except in compliance with the License.
     92            * You may obtain a copy of the License at:
     93            *
     94            *        http://www.st.com/software_license_agreement_liberty_v2
     95            *
     96            * Unless required by applicable law or agreed to in writing, software 
     97            * distributed under the License is distributed on an "AS IS" BASIS, 
     98            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     99            * See the License for the specific language governing permissions and
    100            * limitations under the License.
    101            *
    102            ******************************************************************************  
    103            */ 
    104          
    105          /* Includes ------------------------------------------------------------------*/
    106          #include "stm32f4xx_adc.h"
    107          #include "stm32f4xx_rcc.h"
    108          
    109          /** @addtogroup STM32F4xx_StdPeriph_Driver
    110            * @{
    111            */
    112          
    113          /** @defgroup ADC 
    114            * @brief ADC driver modules
    115            * @{
    116            */ 
    117          
    118          /* Private typedef -----------------------------------------------------------*/
    119          /* Private define ------------------------------------------------------------*/ 
    120          
    121          /* ADC DISCNUM mask */
    122          #define CR1_DISCNUM_RESET         ((uint32_t)0xFFFF1FFF)
    123          
    124          /* ADC AWDCH mask */
    125          #define CR1_AWDCH_RESET           ((uint32_t)0xFFFFFFE0)   
    126          
    127          /* ADC Analog watchdog enable mode mask */
    128          #define CR1_AWDMode_RESET         ((uint32_t)0xFF3FFDFF)   
    129          
    130          /* CR1 register Mask */
    131          #define CR1_CLEAR_MASK            ((uint32_t)0xFCFFFEFF)
    132          
    133          /* ADC EXTEN mask */
    134          #define CR2_EXTEN_RESET           ((uint32_t)0xCFFFFFFF)  
    135          
    136          /* ADC JEXTEN mask */
    137          #define CR2_JEXTEN_RESET          ((uint32_t)0xFFCFFFFF)  
    138          
    139          /* ADC JEXTSEL mask */
    140          #define CR2_JEXTSEL_RESET         ((uint32_t)0xFFF0FFFF)  
    141          
    142          /* CR2 register Mask */
    143          #define CR2_CLEAR_MASK            ((uint32_t)0xC0FFF7FD)
    144          
    145          /* ADC SQx mask */
    146          #define SQR3_SQ_SET               ((uint32_t)0x0000001F)  
    147          #define SQR2_SQ_SET               ((uint32_t)0x0000001F)  
    148          #define SQR1_SQ_SET               ((uint32_t)0x0000001F)  
    149          
    150          /* ADC L Mask */
    151          #define SQR1_L_RESET              ((uint32_t)0xFF0FFFFF) 
    152          
    153          /* ADC JSQx mask */
    154          #define JSQR_JSQ_SET              ((uint32_t)0x0000001F) 
    155          
    156          /* ADC JL mask */
    157          #define JSQR_JL_SET               ((uint32_t)0x00300000) 
    158          #define JSQR_JL_RESET             ((uint32_t)0xFFCFFFFF) 
    159          
    160          /* ADC SMPx mask */
    161          #define SMPR1_SMP_SET             ((uint32_t)0x00000007)  
    162          #define SMPR2_SMP_SET             ((uint32_t)0x00000007) 
    163          
    164          /* ADC JDRx registers offset */
    165          #define JDR_OFFSET                ((uint8_t)0x28) 
    166          
    167          /* ADC CDR register base address */
    168          #define CDR_ADDRESS               ((uint32_t)0x40012308)   
    169          
    170          /* ADC CCR register Mask */
    171          #define CR_CLEAR_MASK             ((uint32_t)0xFFFC30E0)  
    172          
    173          /* Private macro -------------------------------------------------------------*/
    174          /* Private variables ---------------------------------------------------------*/
    175          /* Private function prototypes -----------------------------------------------*/
    176          /* Private functions ---------------------------------------------------------*/
    177          
    178          /** @defgroup ADC_Private_Functions
    179            * @{
    180            */ 
    181          
    182          /** @defgroup ADC_Group1 Initialization and Configuration functions
    183           *  @brief    Initialization and Configuration functions 
    184           *
    185          @verbatim    
    186           ===============================================================================
    187                        ##### Initialization and Configuration functions #####
    188           ===============================================================================
    189              [..]  This section provides functions allowing to:
    190                (+) Initialize and configure the ADC Prescaler
    191                (+) ADC Conversion Resolution (12bit..6bit)
    192                (+) Scan Conversion Mode (multichannel or one channel) for regular group
    193                (+) ADC Continuous Conversion Mode (Continuous or Single conversion) for 
    194                    regular group
    195                (+) External trigger Edge and source of regular group, 
    196                (+) Converted data alignment (left or right)
    197                (+) The number of ADC conversions that will be done using the sequencer for 
    198                    regular channel group
    199                (+) Multi ADC mode selection
    200                (+) Direct memory access mode selection for multi ADC mode  
    201                (+) Delay between 2 sampling phases (used in dual or triple interleaved modes)
    202                (+) Enable or disable the ADC peripheral   
    203          @endverbatim
    204            * @{
    205            */
    206          
    207          /**
    208            * @brief  Deinitializes all ADCs peripherals registers to their default reset 
    209            *         values.
    210            * @param  None
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void ADC_DeInit(void)
    214          {
   \                     ADC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    215            /* Enable all ADCs reset state */
    216            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x7080      MOV      R0,#+256
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    217            
    218            /* Release all ADCs from reset state */
    219            RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF44F 0x7080      MOV      R0,#+256
   \   00000012   0xE8BD 0x4004      POP      {R2,LR}
   \   00000016   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    220          }
    221          
    222          /**
    223            * @brief  Initializes the ADCx peripheral according to the specified parameters 
    224            *         in the ADC_InitStruct.
    225            * @note   This function is used to configure the global features of the ADC ( 
    226            *         Resolution and Data Alignment), however, the rest of the configuration
    227            *         parameters are specific to the regular channels group (scan mode 
    228            *         activation, continuous mode activation, External trigger source and 
    229            *         edge, number of conversion in the regular channels group sequencer).  
    230            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    231            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    232            *         the configuration information for the specified ADC peripheral.
    233            * @retval None
    234            */

   \                                 In section .text, align 2, keep-with-next
    235          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    236          {
   \                     ADC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    237            uint32_t tmpreg1 = 0;
    238            uint8_t tmpreg2 = 0;
    239            /* Check the parameters */
    240            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00C             BEQ.N    ??ADC_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD008             BEQ.N    ??ADC_Init_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??ADC_Init_0
   \   0000001E   0x21F0             MOVS     R1,#+240
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000024   0x.... 0x....      BL       assert_failed
    241            assert_param(IS_ADC_RESOLUTION(ADC_InitStruct->ADC_Resolution)); 
   \                     ??ADC_Init_0: (+1)
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00D             BEQ.N    ??ADC_Init_1
   \   0000002E   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   00000032   0xD00A             BEQ.N    ??ADC_Init_1
   \   00000034   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   00000038   0xD007             BEQ.N    ??ADC_Init_1
   \   0000003A   0xF1B0 0x7F40      CMP      R0,#+50331648
   \   0000003E   0xD004             BEQ.N    ??ADC_Init_1
   \   00000040   0x21F1             MOVS     R1,#+241
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000046   0x.... 0x....      BL       assert_failed
    242            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
   \                     ??ADC_Init_1: (+1)
   \   0000004A   0x7928             LDRB     R0,[R5, #+4]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD006             BEQ.N    ??ADC_Init_2
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD004             BEQ.N    ??ADC_Init_2
   \   00000054   0x21F2             MOVS     R1,#+242
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   0000005A   0x.... 0x....      BL       assert_failed
    243            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode)); 
   \                     ??ADC_Init_2: (+1)
   \   0000005E   0x7968             LDRB     R0,[R5, #+5]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD006             BEQ.N    ??ADC_Init_3
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD004             BEQ.N    ??ADC_Init_3
   \   00000068   0x21F3             MOVS     R1,#+243
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   0000006E   0x.... 0x....      BL       assert_failed
    244            assert_param(IS_ADC_EXT_TRIG_EDGE(ADC_InitStruct->ADC_ExternalTrigConvEdge)); 
   \                     ??ADC_Init_3: (+1)
   \   00000072   0x68A8             LDR      R0,[R5, #+8]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD00D             BEQ.N    ??ADC_Init_4
   \   00000078   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   0000007C   0xD00A             BEQ.N    ??ADC_Init_4
   \   0000007E   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   00000082   0xD007             BEQ.N    ??ADC_Init_4
   \   00000084   0xF1B0 0x5F40      CMP      R0,#+805306368
   \   00000088   0xD004             BEQ.N    ??ADC_Init_4
   \   0000008A   0x21F4             MOVS     R1,#+244
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000090   0x.... 0x....      BL       assert_failed
    245            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));    
   \                     ??ADC_Init_4: (+1)
   \   00000094   0x68E8             LDR      R0,[R5, #+12]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD031             BEQ.N    ??ADC_Init_5
   \   0000009A   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   0000009E   0xD02E             BEQ.N    ??ADC_Init_5
   \   000000A0   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   000000A4   0xD02B             BEQ.N    ??ADC_Init_5
   \   000000A6   0xF1B0 0x7F40      CMP      R0,#+50331648
   \   000000AA   0xD028             BEQ.N    ??ADC_Init_5
   \   000000AC   0xF1B0 0x6F80      CMP      R0,#+67108864
   \   000000B0   0xD025             BEQ.N    ??ADC_Init_5
   \   000000B2   0xF1B0 0x6FA0      CMP      R0,#+83886080
   \   000000B6   0xD022             BEQ.N    ??ADC_Init_5
   \   000000B8   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \   000000BC   0xD01F             BEQ.N    ??ADC_Init_5
   \   000000BE   0xF1B0 0x6FE0      CMP      R0,#+117440512
   \   000000C2   0xD01C             BEQ.N    ??ADC_Init_5
   \   000000C4   0xF1B0 0x6F00      CMP      R0,#+134217728
   \   000000C8   0xD019             BEQ.N    ??ADC_Init_5
   \   000000CA   0xF1B0 0x6F10      CMP      R0,#+150994944
   \   000000CE   0xD016             BEQ.N    ??ADC_Init_5
   \   000000D0   0xF1B0 0x6F20      CMP      R0,#+167772160
   \   000000D4   0xD013             BEQ.N    ??ADC_Init_5
   \   000000D6   0xF1B0 0x6F30      CMP      R0,#+184549376
   \   000000DA   0xD010             BEQ.N    ??ADC_Init_5
   \   000000DC   0xF1B0 0x6F40      CMP      R0,#+201326592
   \   000000E0   0xD00D             BEQ.N    ??ADC_Init_5
   \   000000E2   0xF1B0 0x6F50      CMP      R0,#+218103808
   \   000000E6   0xD00A             BEQ.N    ??ADC_Init_5
   \   000000E8   0xF1B0 0x6F60      CMP      R0,#+234881024
   \   000000EC   0xD007             BEQ.N    ??ADC_Init_5
   \   000000EE   0xF1B0 0x6F70      CMP      R0,#+251658240
   \   000000F2   0xD004             BEQ.N    ??ADC_Init_5
   \   000000F4   0x21F5             MOVS     R1,#+245
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   000000FA   0x.... 0x....      BL       assert_failed
    246            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
   \                     ??ADC_Init_5: (+1)
   \   000000FE   0x6928             LDR      R0,[R5, #+16]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD007             BEQ.N    ??ADC_Init_6
   \   00000104   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000108   0xD004             BEQ.N    ??ADC_Init_6
   \   0000010A   0x21F6             MOVS     R1,#+246
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000110   0x.... 0x....      BL       assert_failed
    247            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
   \                     ??ADC_Init_6: (+1)
   \   00000114   0x7D28             LDRB     R0,[R5, #+20]
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD001             BEQ.N    ??ADC_Init_7
   \   0000011A   0x2811             CMP      R0,#+17
   \   0000011C   0xDB04             BLT.N    ??ADC_Init_8
   \                     ??ADC_Init_7: (+1)
   \   0000011E   0x21F7             MOVS     R1,#+247
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000124   0x.... 0x....      BL       assert_failed
    248            
    249            /*---------------------------- ADCx CR1 Configuration -----------------*/
    250            /* Get the ADCx CR1 value */
    251            tmpreg1 = ADCx->CR1;
   \                     ??ADC_Init_8: (+1)
   \   00000128   0x6860             LDR      R0,[R4, #+4]
    252            
    253            /* Clear RES and SCAN bits */
    254            tmpreg1 &= CR1_CLEAR_MASK;
    255            
    256            /* Configure ADCx: scan conversion mode and resolution */
    257            /* Set SCAN bit according to ADC_ScanConvMode value */
    258            /* Set RES bit according to ADC_Resolution value */ 
    259            tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
    260                                             ADC_InitStruct->ADC_Resolution);
    261            /* Write to ADCx CR1 */
    262            ADCx->CR1 = tmpreg1;
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable26  ;; 0xfcfffeff
   \   0000012E   0x4008             ANDS     R0,R1,R0
   \   00000130   0x7929             LDRB     R1,[R5, #+4]
   \   00000132   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000136   0x6829             LDR      R1,[R5, #+0]
   \   00000138   0x4308             ORRS     R0,R1,R0
   \   0000013A   0x6060             STR      R0,[R4, #+4]
    263            /*---------------------------- ADCx CR2 Configuration -----------------*/
    264            /* Get the ADCx CR2 value */
    265            tmpreg1 = ADCx->CR2;
   \   0000013C   0x68A0             LDR      R0,[R4, #+8]
    266            
    267            /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
    268            tmpreg1 &= CR2_CLEAR_MASK;
    269            
    270            /* Configure ADCx: external trigger event and edge, data alignment and 
    271               continuous conversion mode */
    272            /* Set ALIGN bit according to ADC_DataAlign value */
    273            /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
    274            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    275            /* Set CONT bit according to ADC_ContinuousConvMode value */
    276            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
    277                                  ADC_InitStruct->ADC_ExternalTrigConv | 
    278                                  ADC_InitStruct->ADC_ExternalTrigConvEdge | \
    279                                  ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    280                                  
    281            /* Write to ADCx CR2 */
    282            ADCx->CR2 = tmpreg1;
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable31  ;; 0xc0fff7fd
   \   00000142   0x4008             ANDS     R0,R1,R0
   \   00000144   0x6929             LDR      R1,[R5, #+16]
   \   00000146   0x4308             ORRS     R0,R1,R0
   \   00000148   0x68E9             LDR      R1,[R5, #+12]
   \   0000014A   0x4308             ORRS     R0,R1,R0
   \   0000014C   0x68A9             LDR      R1,[R5, #+8]
   \   0000014E   0x4308             ORRS     R0,R1,R0
   \   00000150   0x7969             LDRB     R1,[R5, #+5]
   \   00000152   0xEA40 0x0041      ORR      R0,R0,R1, LSL #+1
   \   00000156   0x60A0             STR      R0,[R4, #+8]
    283            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    284            /* Get the ADCx SQR1 value */
    285            tmpreg1 = ADCx->SQR1;
   \   00000158   0x6AE0             LDR      R0,[R4, #+44]
    286            
    287            /* Clear L bits */
    288            tmpreg1 &= SQR1_L_RESET;
    289            
    290            /* Configure ADCx: regular channel sequence length */
    291            /* Set L bits according to ADC_NbrOfConversion value */
    292            tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
    293            tmpreg1 |= ((uint32_t)tmpreg2 << 20);
    294            
    295            /* Write to ADCx SQR1 */
    296            ADCx->SQR1 = tmpreg1;
   \   0000015A   0xF420 0x0070      BIC      R0,R0,#0xF00000
   \   0000015E   0x7D29             LDRB     R1,[R5, #+20]
   \   00000160   0x1E49             SUBS     R1,R1,#+1
   \   00000162   0xB2C9             UXTB     R1,R1
   \   00000164   0xEA40 0x5001      ORR      R0,R0,R1, LSL #+20
   \   00000168   0x62E0             STR      R0,[R4, #+44]
    297          }
   \   0000016A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    298          
    299          /**
    300            * @brief  Fills each ADC_InitStruct member with its default value.
    301            * @note   This function is used to initialize the global features of the ADC ( 
    302            *         Resolution and Data Alignment), however, the rest of the configuration
    303            *         parameters are specific to the regular channels group (scan mode 
    304            *         activation, continuous mode activation, External trigger source and 
    305            *         edge, number of conversion in the regular channels group sequencer).  
    306            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure which will 
    307            *         be initialized.
    308            * @retval None
    309            */

   \                                 In section .text, align 2, keep-with-next
    310          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    311          {
    312            /* Initialize the ADC_Mode member */
    313            ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
   \                     ADC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    314          
    315            /* initialize the ADC_ScanConvMode member */
    316            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
   \   00000004   0x7101             STRB     R1,[R0, #+4]
    317          
    318            /* Initialize the ADC_ContinuousConvMode member */
    319            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
   \   00000006   0x7141             STRB     R1,[R0, #+5]
    320          
    321            /* Initialize the ADC_ExternalTrigConvEdge member */
    322            ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
   \   00000008   0x6081             STR      R1,[R0, #+8]
    323          
    324            /* Initialize the ADC_ExternalTrigConv member */
    325            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
   \   0000000A   0x60C1             STR      R1,[R0, #+12]
    326          
    327            /* Initialize the ADC_DataAlign member */
    328            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
   \   0000000C   0x6101             STR      R1,[R0, #+16]
    329          
    330            /* Initialize the ADC_NbrOfConversion member */
    331            ADC_InitStruct->ADC_NbrOfConversion = 1;
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x7501             STRB     R1,[R0, #+20]
    332          }
   \   00000012   0x4770             BX       LR               ;; return
    333          
    334          /**
    335            * @brief  Initializes the ADCs peripherals according to the specified parameters 
    336            *         in the ADC_CommonInitStruct.
    337            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
    338            *         that contains the configuration information for  All ADCs peripherals.
    339            * @retval None
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    342          {
   \                     ADC_CommonInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    343            uint32_t tmpreg1 = 0;
    344            /* Check the parameters */
    345            assert_param(IS_ADC_MODE(ADC_CommonInitStruct->ADC_Mode));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01D             BEQ.N    ??ADC_CommonInit_0
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD01B             BEQ.N    ??ADC_CommonInit_0
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD019             BEQ.N    ??ADC_CommonInit_0
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD017             BEQ.N    ??ADC_CommonInit_0
   \   00000016   0x2806             CMP      R0,#+6
   \   00000018   0xD015             BEQ.N    ??ADC_CommonInit_0
   \   0000001A   0x2807             CMP      R0,#+7
   \   0000001C   0xD013             BEQ.N    ??ADC_CommonInit_0
   \   0000001E   0x2809             CMP      R0,#+9
   \   00000020   0xD011             BEQ.N    ??ADC_CommonInit_0
   \   00000022   0x2811             CMP      R0,#+17
   \   00000024   0xD00F             BEQ.N    ??ADC_CommonInit_0
   \   00000026   0x2812             CMP      R0,#+18
   \   00000028   0xD00D             BEQ.N    ??ADC_CommonInit_0
   \   0000002A   0x2815             CMP      R0,#+21
   \   0000002C   0xD00B             BEQ.N    ??ADC_CommonInit_0
   \   0000002E   0x2816             CMP      R0,#+22
   \   00000030   0xD009             BEQ.N    ??ADC_CommonInit_0
   \   00000032   0x2817             CMP      R0,#+23
   \   00000034   0xD007             BEQ.N    ??ADC_CommonInit_0
   \   00000036   0x2819             CMP      R0,#+25
   \   00000038   0xD005             BEQ.N    ??ADC_CommonInit_0
   \   0000003A   0xF240 0x1159      MOVW     R1,#+345
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000042   0x.... 0x....      BL       assert_failed
    346            assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
   \                     ??ADC_CommonInit_0: (+1)
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD00E             BEQ.N    ??ADC_CommonInit_1
   \   0000004C   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000050   0xD00B             BEQ.N    ??ADC_CommonInit_1
   \   00000052   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000056   0xD008             BEQ.N    ??ADC_CommonInit_1
   \   00000058   0xF5B0 0x3F40      CMP      R0,#+196608
   \   0000005C   0xD005             BEQ.N    ??ADC_CommonInit_1
   \   0000005E   0xF44F 0x71AD      MOV      R1,#+346
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000066   0x.... 0x....      BL       assert_failed
    347            assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
   \                     ??ADC_CommonInit_1: (+1)
   \   0000006A   0x68A0             LDR      R0,[R4, #+8]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD00E             BEQ.N    ??ADC_CommonInit_2
   \   00000070   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000074   0xD00B             BEQ.N    ??ADC_CommonInit_2
   \   00000076   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000007A   0xD008             BEQ.N    ??ADC_CommonInit_2
   \   0000007C   0xF5B0 0x4F40      CMP      R0,#+49152
   \   00000080   0xD005             BEQ.N    ??ADC_CommonInit_2
   \   00000082   0xF240 0x115B      MOVW     R1,#+347
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   0000008A   0x.... 0x....      BL       assert_failed
    348            assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
   \                     ??ADC_CommonInit_2: (+1)
   \   0000008E   0x68E0             LDR      R0,[R4, #+12]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD032             BEQ.N    ??ADC_CommonInit_3
   \   00000094   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000098   0xD02F             BEQ.N    ??ADC_CommonInit_3
   \   0000009A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000009E   0xD02C             BEQ.N    ??ADC_CommonInit_3
   \   000000A0   0xF5B0 0x7F40      CMP      R0,#+768
   \   000000A4   0xD029             BEQ.N    ??ADC_CommonInit_3
   \   000000A6   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000AA   0xD026             BEQ.N    ??ADC_CommonInit_3
   \   000000AC   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   000000B0   0xD023             BEQ.N    ??ADC_CommonInit_3
   \   000000B2   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   000000B6   0xD020             BEQ.N    ??ADC_CommonInit_3
   \   000000B8   0xF5B0 0x6FE0      CMP      R0,#+1792
   \   000000BC   0xD01D             BEQ.N    ??ADC_CommonInit_3
   \   000000BE   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000C2   0xD01A             BEQ.N    ??ADC_CommonInit_3
   \   000000C4   0xF5B0 0x6F10      CMP      R0,#+2304
   \   000000C8   0xD017             BEQ.N    ??ADC_CommonInit_3
   \   000000CA   0xF5B0 0x6F20      CMP      R0,#+2560
   \   000000CE   0xD014             BEQ.N    ??ADC_CommonInit_3
   \   000000D0   0xF5B0 0x6F30      CMP      R0,#+2816
   \   000000D4   0xD011             BEQ.N    ??ADC_CommonInit_3
   \   000000D6   0xF5B0 0x6F40      CMP      R0,#+3072
   \   000000DA   0xD00E             BEQ.N    ??ADC_CommonInit_3
   \   000000DC   0xF5B0 0x6F50      CMP      R0,#+3328
   \   000000E0   0xD00B             BEQ.N    ??ADC_CommonInit_3
   \   000000E2   0xF5B0 0x6F60      CMP      R0,#+3584
   \   000000E6   0xD008             BEQ.N    ??ADC_CommonInit_3
   \   000000E8   0xF5B0 0x6F70      CMP      R0,#+3840
   \   000000EC   0xD005             BEQ.N    ??ADC_CommonInit_3
   \   000000EE   0xF44F 0x71AE      MOV      R1,#+348
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   000000F6   0x.... 0x....      BL       assert_failed
    349            /*---------------------------- ADC CCR Configuration -----------------*/
    350            /* Get the ADC CCR value */
    351            tmpreg1 = ADC->CCR;
   \                     ??ADC_CommonInit_3: (+1)
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40012304
   \   000000FE   0x6801             LDR      R1,[R0, #+0]
    352            
    353            /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    354            tmpreg1 &= CR_CLEAR_MASK;
    355            
    356            /* Configure ADCx: Multi mode, Delay between two sampling time, ADC prescaler,
    357               and DMA access mode for multimode */
    358            /* Set MULTI bits according to ADC_Mode value */
    359            /* Set ADCPRE bits according to ADC_Prescaler value */
    360            /* Set DMA bits according to ADC_DMAAccessMode value */
    361            /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
    362            tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
    363                                  ADC_CommonInitStruct->ADC_Prescaler | 
    364                                  ADC_CommonInitStruct->ADC_DMAAccessMode | 
    365                                  ADC_CommonInitStruct->ADC_TwoSamplingDelay);
    366                                  
    367            /* Write to ADC CCR */
    368            ADC->CCR = tmpreg1;
   \   00000100   0x.... 0x....      LDR.W    R2,??DataTable34  ;; 0xfffc30e0
   \   00000104   0x4011             ANDS     R1,R2,R1
   \   00000106   0x6822             LDR      R2,[R4, #+0]
   \   00000108   0x4311             ORRS     R1,R2,R1
   \   0000010A   0x6862             LDR      R2,[R4, #+4]
   \   0000010C   0x4311             ORRS     R1,R2,R1
   \   0000010E   0x68A2             LDR      R2,[R4, #+8]
   \   00000110   0x4311             ORRS     R1,R2,R1
   \   00000112   0x68E2             LDR      R2,[R4, #+12]
   \   00000114   0x4311             ORRS     R1,R2,R1
   \   00000116   0x6001             STR      R1,[R0, #+0]
    369          }
   \   00000118   0xBD10             POP      {R4,PC}          ;; return
    370          
    371          /**
    372            * @brief  Fills each ADC_CommonInitStruct member with its default value.
    373            * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure
    374            *         which will be initialized.
    375            * @retval None
    376            */

   \                                 In section .text, align 2, keep-with-next
    377          void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
    378          {
    379            /* Initialize the ADC_Mode member */
    380            ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
   \                     ADC_CommonStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    381          
    382            /* initialize the ADC_Prescaler member */
    383            ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    384          
    385            /* Initialize the ADC_DMAAccessMode member */
    386            ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    387          
    388            /* Initialize the ADC_TwoSamplingDelay member */
    389            ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    390          }
   \   0000000A   0x4770             BX       LR               ;; return
    391          
    392          /**
    393            * @brief  Enables or disables the specified ADC peripheral.
    394            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    395            * @param  NewState: new state of the ADCx peripheral. 
    396            *          This parameter can be: ENABLE or DISABLE.
    397            * @retval None
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    400          {
   \                     ADC_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    401            /* Check the parameters */
    402            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_Cmd_0
   \   0000001E   0xF44F 0x71C9      MOV      R1,#+402
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000026   0x.... 0x....      BL       assert_failed
    403            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_Cmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??ADC_Cmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??ADC_Cmd_1
   \   00000032   0xF240 0x1193      MOVW     R1,#+403
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   0000003A   0x.... 0x....      BL       assert_failed
    404            if (NewState != DISABLE)
   \                     ??ADC_Cmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0xD003             BEQ.N    ??ADC_Cmd_2
    405            {
    406              /* Set the ADON bit to wake up the ADC from power down mode */
    407              ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
   \   00000044   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000048   0x60A0             STR      R0,[R4, #+8]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    408            }
    409            else
    410            {
    411              /* Disable the selected ADC peripheral */
    412              ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
   \                     ??ADC_Cmd_2: (+1)
   \   0000004C   0x0840             LSRS     R0,R0,#+1
   \   0000004E   0x0040             LSLS     R0,R0,#+1
   \   00000050   0x60A0             STR      R0,[R4, #+8]
    413            }
    414          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    415          /**
    416            * @}
    417            */
    418          
    419          /** @defgroup ADC_Group2 Analog Watchdog configuration functions
    420           *  @brief    Analog Watchdog configuration functions 
    421           *
    422          @verbatim   
    423           ===============================================================================
    424                       ##### Analog Watchdog configuration functions #####
    425           ===============================================================================  
    426              [..] This section provides functions allowing to configure the Analog Watchdog
    427                   (AWD) feature in the ADC.
    428            
    429              [..] A typical configuration Analog Watchdog is done following these steps :
    430                (#) the ADC guarded channel(s) is (are) selected using the 
    431                    ADC_AnalogWatchdogSingleChannelConfig() function.
    432                (#) The Analog watchdog lower and higher threshold are configured using the  
    433                    ADC_AnalogWatchdogThresholdsConfig() function.
    434                (#) The Analog watchdog is enabled and configured to enable the check, on one
    435                    or more channels, using the  ADC_AnalogWatchdogCmd() function.
    436          @endverbatim
    437            * @{
    438            */
    439            
    440          /**
    441            * @brief  Enables or disables the analog watchdog on single/all regular or 
    442            *         injected channels
    443            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    444            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
    445            *         This parameter can be one of the following values:
    446            *            @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
    447            *            @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
    448            *            @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
    449            *            @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on all regular channel
    450            *            @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on all injected channel
    451            *            @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
    452            *            @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
    453            * @retval None	  
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
    456          {
   \                     ADC_AnalogWatchdogCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    457            uint32_t tmpreg = 0;
    458            /* Check the parameters */
    459            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_AnalogWatchdogCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_AnalogWatchdogCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_AnalogWatchdogCmd_0
   \   0000001E   0xF240 0x11CB      MOVW     R1,#+459
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000026   0x.... 0x....      BL       assert_failed
    460            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   \                     ??ADC_AnalogWatchdogCmd_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x800200
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD018             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable32  ;; 0x400200
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD014             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable32_1  ;; 0xc00200
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD010             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000042   0xF5B5 0x0F00      CMP      R5,#+8388608
   \   00000046   0xD00D             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000048   0xF5B5 0x0F80      CMP      R5,#+4194304
   \   0000004C   0xD00A             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   0000004E   0xF5B5 0x0F40      CMP      R5,#+12582912
   \   00000052   0xD007             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD005             BEQ.N    ??ADC_AnalogWatchdogCmd_1
   \   00000058   0xF44F 0x71E6      MOV      R1,#+460
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000060   0x.... 0x....      BL       assert_failed
    461            
    462            /* Get the old register value */
    463            tmpreg = ADCx->CR1;
   \                     ??ADC_AnalogWatchdogCmd_1: (+1)
   \   00000064   0x6860             LDR      R0,[R4, #+4]
    464            
    465            /* Clear AWDEN, JAWDEN and AWDSGL bits */
    466            tmpreg &= CR1_AWDMode_RESET;
    467            
    468            /* Set the analog watchdog enable mode */
    469            tmpreg |= ADC_AnalogWatchdog;
    470            
    471            /* Store the new register value */
    472            ADCx->CR1 = tmpreg;
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable35  ;; 0xff3ffdff
   \   0000006A   0x4008             ANDS     R0,R1,R0
   \   0000006C   0x4328             ORRS     R0,R5,R0
   \   0000006E   0x6060             STR      R0,[R4, #+4]
    473          }
   \   00000070   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    474          
    475          /**
    476            * @brief  Configures the high and low thresholds of the analog watchdog.
    477            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    478            * @param  HighThreshold: the ADC analog watchdog High threshold value.
    479            *          This parameter must be a 12-bit value.
    480            * @param  LowThreshold:  the ADC analog watchdog Low threshold value.
    481            *          This parameter must be a 12-bit value.
    482            * @retval None
    483            */

   \                                 In section .text, align 2, keep-with-next
    484          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
    485                                                  uint16_t LowThreshold)
    486          {
   \                     ADC_AnalogWatchdogThresholdsConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    487            /* Check the parameters */
    488            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??ADC_AnalogWatchdogThresholdsConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??ADC_AnalogWatchdogThresholdsConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??ADC_AnalogWatchdogThresholdsConfig_0
   \   00000020   0xF44F 0x71F4      MOV      R1,#+488
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000028   0x.... 0x....      BL       assert_failed
    489            assert_param(IS_ADC_THRESHOLD(HighThreshold));
   \                     ??ADC_AnalogWatchdogThresholdsConfig_0: (+1)
   \   0000002C   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000030   0xDB05             BLT.N    ??ADC_AnalogWatchdogThresholdsConfig_1
   \   00000032   0xF240 0x11E9      MOVW     R1,#+489
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   0000003A   0x.... 0x....      BL       assert_failed
    490            assert_param(IS_ADC_THRESHOLD(LowThreshold));
   \                     ??ADC_AnalogWatchdogThresholdsConfig_1: (+1)
   \   0000003E   0xF5B6 0x5F80      CMP      R6,#+4096
   \   00000042   0xDB05             BLT.N    ??ADC_AnalogWatchdogThresholdsConfig_2
   \   00000044   0xF44F 0x71F5      MOV      R1,#+490
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   0000004C   0x.... 0x....      BL       assert_failed
    491            
    492            /* Set the ADCx high threshold */
    493            ADCx->HTR = HighThreshold;
   \                     ??ADC_AnalogWatchdogThresholdsConfig_2: (+1)
   \   00000050   0x6265             STR      R5,[R4, #+36]
    494            
    495            /* Set the ADCx low threshold */
    496            ADCx->LTR = LowThreshold;
   \   00000052   0x62A6             STR      R6,[R4, #+40]
    497          }
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    498          
    499          /**
    500            * @brief  Configures the analog watchdog guarded single channel
    501            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    502            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
    503            *          This parameter can be one of the following values:
    504            *            @arg ADC_Channel_0: ADC Channel0 selected
    505            *            @arg ADC_Channel_1: ADC Channel1 selected
    506            *            @arg ADC_Channel_2: ADC Channel2 selected
    507            *            @arg ADC_Channel_3: ADC Channel3 selected
    508            *            @arg ADC_Channel_4: ADC Channel4 selected
    509            *            @arg ADC_Channel_5: ADC Channel5 selected
    510            *            @arg ADC_Channel_6: ADC Channel6 selected
    511            *            @arg ADC_Channel_7: ADC Channel7 selected
    512            *            @arg ADC_Channel_8: ADC Channel8 selected
    513            *            @arg ADC_Channel_9: ADC Channel9 selected
    514            *            @arg ADC_Channel_10: ADC Channel10 selected
    515            *            @arg ADC_Channel_11: ADC Channel11 selected
    516            *            @arg ADC_Channel_12: ADC Channel12 selected
    517            *            @arg ADC_Channel_13: ADC Channel13 selected
    518            *            @arg ADC_Channel_14: ADC Channel14 selected
    519            *            @arg ADC_Channel_15: ADC Channel15 selected
    520            *            @arg ADC_Channel_16: ADC Channel16 selected
    521            *            @arg ADC_Channel_17: ADC Channel17 selected
    522            *            @arg ADC_Channel_18: ADC Channel18 selected
    523            * @retval None
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
    526          {
   \                     ADC_AnalogWatchdogSingleChannelConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    527            uint32_t tmpreg = 0;
    528            /* Check the parameters */
    529            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_0
   \   0000001E   0xF240 0x2111      MOVW     R1,#+529
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable23_3
   \   00000026   0x.... 0x....      BL       assert_failed
    530            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_AnalogWatchdogSingleChannelConfig_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD02A             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD027             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000034   0x2802             CMP      R0,#+2
   \   00000036   0xD025             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000038   0x2803             CMP      R0,#+3
   \   0000003A   0xD023             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000003C   0x2804             CMP      R0,#+4
   \   0000003E   0xD021             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000040   0x2805             CMP      R0,#+5
   \   00000042   0xD01F             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000044   0x2806             CMP      R0,#+6
   \   00000046   0xD01D             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000048   0x2807             CMP      R0,#+7
   \   0000004A   0xD01B             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000004C   0x2808             CMP      R0,#+8
   \   0000004E   0xD019             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000050   0x2809             CMP      R0,#+9
   \   00000052   0xD017             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000054   0x280A             CMP      R0,#+10
   \   00000056   0xD015             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000058   0x280B             CMP      R0,#+11
   \   0000005A   0xD013             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000005C   0x280C             CMP      R0,#+12
   \   0000005E   0xD011             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000060   0x280D             CMP      R0,#+13
   \   00000062   0xD00F             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000064   0x280E             CMP      R0,#+14
   \   00000066   0xD00D             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000068   0x280F             CMP      R0,#+15
   \   0000006A   0xD00B             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   0000006C   0x2810             CMP      R0,#+16
   \   0000006E   0xD009             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000070   0x2811             CMP      R0,#+17
   \   00000072   0xD007             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000074   0x2812             CMP      R0,#+18
   \   00000076   0xD005             BEQ.N    ??ADC_AnalogWatchdogSingleChannelConfig_1
   \   00000078   0xF240 0x2112      MOVW     R1,#+530
   \   0000007C   0x.... 0x....      ADR.W    R0,?_0
   \   00000080   0x.... 0x....      BL       assert_failed
    531            
    532            /* Get the old register value */
    533            tmpreg = ADCx->CR1;
   \                     ??ADC_AnalogWatchdogSingleChannelConfig_1: (+1)
   \   00000084   0x6860             LDR      R0,[R4, #+4]
    534            
    535            /* Clear the Analog watchdog channel select bits */
    536            tmpreg &= CR1_AWDCH_RESET;
    537            
    538            /* Set the Analog watchdog channel */
    539            tmpreg |= ADC_Channel;
    540            
    541            /* Store the new register value */
    542            ADCx->CR1 = tmpreg;
   \   00000086   0x0940             LSRS     R0,R0,#+5
   \   00000088   0xEA55 0x1040      ORRS     R0,R5,R0, LSL #+5
   \   0000008C   0x6060             STR      R0,[R4, #+4]
    543          }
   \   0000008E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    544          /**
    545            * @}
    546            */
    547          
    548          /** @defgroup ADC_Group3 Temperature Sensor, Vrefint (Voltage Reference internal) 
    549           *            and VBAT (Voltage BATtery) management functions
    550           *  @brief   Temperature Sensor, Vrefint and VBAT management functions 
    551           *
    552          @verbatim   
    553           ===============================================================================
    554                ##### Temperature Sensor, Vrefint and VBAT management functions #####
    555           ===============================================================================  
    556              [..] This section provides functions allowing to enable/ disable the internal 
    557                   connections between the ADC and the Temperature Sensor, the Vrefint and 
    558                   the Vbat sources.
    559               
    560              [..] A typical configuration to get the Temperature sensor and Vrefint channels 
    561                   voltages is done following these steps :
    562                (#) Enable the internal connection of Temperature sensor and Vrefint sources 
    563                    with the ADC channels using ADC_TempSensorVrefintCmd() function. 
    564                (#) Select the ADC_Channel_TempSensor and/or ADC_Channel_Vrefint using 
    565                    ADC_RegularChannelConfig() or  ADC_InjectedChannelConfig() functions 
    566                (#) Get the voltage values, using ADC_GetConversionValue() or  
    567                    ADC_GetInjectedConversionValue().
    568          
    569              [..] A typical configuration to get the VBAT channel voltage is done following 
    570                   these steps :
    571                (#) Enable the internal connection of VBAT source with the ADC channel using 
    572                    ADC_VBATCmd() function. 
    573                (#) Select the ADC_Channel_Vbat using ADC_RegularChannelConfig() or  
    574                    ADC_InjectedChannelConfig() functions 
    575                (#) Get the voltage value, using ADC_GetConversionValue() or  
    576                    ADC_GetInjectedConversionValue().
    577           
    578          @endverbatim
    579            * @{
    580            */
    581            
    582            
    583          /**
    584            * @brief  Enables or disables the temperature sensor and Vrefint channels.
    585            * @param  NewState: new state of the temperature sensor and Vrefint channels.
    586            *          This parameter can be: ENABLE or DISABLE.
    587            * @retval None
    588            */

   \                                 In section .text, align 2, keep-with-next
    589          void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
    590          {
   \                     ADC_TempSensorVrefintCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    591            /* Check the parameters */
    592            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??ADC_TempSensorVrefintCmd_0
   \   0000000A   0xF44F 0x7114      MOV      R1,#+592
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    593            if (NewState != DISABLE)
   \                     ??ADC_TempSensorVrefintCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40012304
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??ADC_TempSensorVrefintCmd_1
    594            {
    595              /* Enable the temperature sensor and Vrefint channel*/
    596              ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
   \   00000020   0xF441 0x0100      ORR      R1,R1,#0x800000
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
    597            }
    598            else
    599            {
    600              /* Disable the temperature sensor and Vrefint channel*/
    601              ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
   \                     ??ADC_TempSensorVrefintCmd_1: (+1)
   \   00000028   0xF421 0x0100      BIC      R1,R1,#0x800000
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    602            }
    603          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    604          
    605          /**
    606            * @brief  Enables or disables the VBAT (Voltage Battery) channel.
    607            * 
    608            * @note   the Battery voltage measured is equal to VBAT/2 on STM32F40xx and 
    609            *         STM32F41xx devices and equal to VBAT/4 on STM32F42xx and STM32F43xx devices 
    610            *              
    611            * @param  NewState: new state of the VBAT channel.
    612            *          This parameter can be: ENABLE or DISABLE.
    613            * @retval None
    614            */

   \                                 In section .text, align 2, keep-with-next
    615          void ADC_VBATCmd(FunctionalState NewState)                             
    616          {
   \                     ADC_VBATCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    617            /* Check the parameters */
    618            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??ADC_VBATCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??ADC_VBATCmd_0
   \   0000000A   0xF240 0x216A      MOVW     R1,#+618
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    619            if (NewState != DISABLE)
   \                     ??ADC_VBATCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40012304
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??ADC_VBATCmd_1
    620            {
    621              /* Enable the VBAT channel*/
    622              ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
   \   00000020   0xF441 0x0180      ORR      R1,R1,#0x400000
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
    623            }
    624            else
    625            {
    626              /* Disable the VBAT channel*/
    627              ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
   \                     ??ADC_VBATCmd_1: (+1)
   \   00000028   0xF421 0x0180      BIC      R1,R1,#0x400000
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    628            }
    629          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    630          
    631          /**
    632            * @}
    633            */
    634          
    635          /** @defgroup ADC_Group4 Regular Channels Configuration functions
    636           *  @brief   Regular Channels Configuration functions 
    637           *
    638          @verbatim   
    639           ===============================================================================
    640                       ##### Regular Channels Configuration functions #####
    641           ===============================================================================  
    642          
    643              [..] This section provides functions allowing to manage the ADC's regular channels,
    644                   it is composed of 2 sub sections : 
    645            
    646                (#) Configuration and management functions for regular channels: This subsection 
    647                    provides functions allowing to configure the ADC regular channels :    
    648                   (++) Configure the rank in the regular group sequencer for each channel
    649                   (++) Configure the sampling time for each channel
    650                   (++) select the conversion Trigger for regular channels
    651                   (++) select the desired EOC event behavior configuration
    652                   (++) Activate the continuous Mode  (*)
    653                   (++) Activate the Discontinuous Mode 
    654                   -@@- Please Note that the following features for regular channels 
    655                       are configurated using the ADC_Init() function : 
    656                     (+@@) scan mode activation 
    657                     (+@@) continuous mode activation (**) 
    658                     (+@@) External trigger source  
    659                     (+@@) External trigger edge 
    660                     (+@@) number of conversion in the regular channels group sequencer.
    661               
    662                   -@@- (*) and (**) are performing the same configuration
    663               
    664                (#) Get the conversion data: This subsection provides an important function in 
    665                    the ADC peripheral since it returns the converted data of the current 
    666                    regular channel. When the Conversion value is read, the EOC Flag is 
    667                    automatically cleared.
    668               
    669                    -@- For multi ADC mode, the last ADC1, ADC2 and ADC3 regular conversions 
    670                        results data (in the selected multi mode) can be returned in the same 
    671                        time using ADC_GetMultiModeConversionValue() function. 
    672                   
    673          @endverbatim
    674            * @{
    675            */
    676          /**
    677            * @brief  Configures for the selected ADC regular channel its corresponding
    678            *         rank in the sequencer and its sample time.
    679            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    680            * @param  ADC_Channel: the ADC channel to configure. 
    681            *          This parameter can be one of the following values:
    682            *            @arg ADC_Channel_0: ADC Channel0 selected
    683            *            @arg ADC_Channel_1: ADC Channel1 selected
    684            *            @arg ADC_Channel_2: ADC Channel2 selected
    685            *            @arg ADC_Channel_3: ADC Channel3 selected
    686            *            @arg ADC_Channel_4: ADC Channel4 selected
    687            *            @arg ADC_Channel_5: ADC Channel5 selected
    688            *            @arg ADC_Channel_6: ADC Channel6 selected
    689            *            @arg ADC_Channel_7: ADC Channel7 selected
    690            *            @arg ADC_Channel_8: ADC Channel8 selected
    691            *            @arg ADC_Channel_9: ADC Channel9 selected
    692            *            @arg ADC_Channel_10: ADC Channel10 selected
    693            *            @arg ADC_Channel_11: ADC Channel11 selected
    694            *            @arg ADC_Channel_12: ADC Channel12 selected
    695            *            @arg ADC_Channel_13: ADC Channel13 selected
    696            *            @arg ADC_Channel_14: ADC Channel14 selected
    697            *            @arg ADC_Channel_15: ADC Channel15 selected
    698            *            @arg ADC_Channel_16: ADC Channel16 selected
    699            *            @arg ADC_Channel_17: ADC Channel17 selected
    700            *            @arg ADC_Channel_18: ADC Channel18 selected                       
    701            * @param  Rank: The rank in the regular group sequencer.
    702            *          This parameter must be between 1 to 16.
    703            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    704            *          This parameter can be one of the following values:
    705            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
    706            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
    707            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
    708            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
    709            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
    710            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
    711            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
    712            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
    713            * @retval None
    714            */

   \                                 In section .text, align 2, keep-with-next
    715          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    716          {
   \                     ADC_RegularChannelConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    717            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    718            /* Check the parameters */
    719            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00D             BEQ.N    ??ADC_RegularChannelConfig_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD009             BEQ.N    ??ADC_RegularChannelConfig_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD005             BEQ.N    ??ADC_RegularChannelConfig_0
   \   00000022   0xF240 0x21CF      MOVW     R1,#+719
   \   00000026   0x.... 0x....      ADR.W    R0,?_0
   \   0000002A   0x.... 0x....      BL       assert_failed
    720            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_RegularChannelConfig_0: (+1)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD02A             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD027             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD025             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD023             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD021             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000044   0x2805             CMP      R0,#+5
   \   00000046   0xD01F             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000048   0x2806             CMP      R0,#+6
   \   0000004A   0xD01D             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000004C   0x2807             CMP      R0,#+7
   \   0000004E   0xD01B             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000050   0x2808             CMP      R0,#+8
   \   00000052   0xD019             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000054   0x2809             CMP      R0,#+9
   \   00000056   0xD017             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000058   0x280A             CMP      R0,#+10
   \   0000005A   0xD015             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000005C   0x280B             CMP      R0,#+11
   \   0000005E   0xD013             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000060   0x280C             CMP      R0,#+12
   \   00000062   0xD011             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000064   0x280D             CMP      R0,#+13
   \   00000066   0xD00F             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000068   0x280E             CMP      R0,#+14
   \   0000006A   0xD00D             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000006C   0x280F             CMP      R0,#+15
   \   0000006E   0xD00B             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000070   0x2810             CMP      R0,#+16
   \   00000072   0xD009             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000074   0x2811             CMP      R0,#+17
   \   00000076   0xD007             BEQ.N    ??ADC_RegularChannelConfig_1
   \   00000078   0x2812             CMP      R0,#+18
   \   0000007A   0xD005             BEQ.N    ??ADC_RegularChannelConfig_1
   \   0000007C   0xF44F 0x7134      MOV      R1,#+720
   \   00000080   0x.... 0x....      ADR.W    R0,?_0
   \   00000084   0x.... 0x....      BL       assert_failed
    721            assert_param(IS_ADC_REGULAR_RANK(Rank));
   \                     ??ADC_RegularChannelConfig_1: (+1)
   \   00000088   0x2E00             CMP      R6,#+0
   \   0000008A   0xD001             BEQ.N    ??ADC_RegularChannelConfig_2
   \   0000008C   0x2E11             CMP      R6,#+17
   \   0000008E   0xDB05             BLT.N    ??ADC_RegularChannelConfig_3
   \                     ??ADC_RegularChannelConfig_2: (+1)
   \   00000090   0xF240 0x21D1      MOVW     R1,#+721
   \   00000094   0x.... 0x....      ADR.W    R0,?_0
   \   00000098   0x.... 0x....      BL       assert_failed
    722            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   \                     ??ADC_RegularChannelConfig_3: (+1)
   \   0000009C   0x2F00             CMP      R7,#+0
   \   0000009E   0xD014             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD011             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000A6   0x2802             CMP      R0,#+2
   \   000000A8   0xD00F             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000AA   0x2803             CMP      R0,#+3
   \   000000AC   0xD00D             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000AE   0x2804             CMP      R0,#+4
   \   000000B0   0xD00B             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000B2   0x2805             CMP      R0,#+5
   \   000000B4   0xD009             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000B6   0x2806             CMP      R0,#+6
   \   000000B8   0xD007             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000BA   0x2807             CMP      R0,#+7
   \   000000BC   0xD005             BEQ.N    ??ADC_RegularChannelConfig_4
   \   000000BE   0xF240 0x21D2      MOVW     R1,#+722
   \   000000C2   0x.... 0x....      ADR.W    R0,?_0
   \   000000C6   0x.... 0x....      BL       assert_failed
    723            
    724            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    725            if (ADC_Channel > ADC_Channel_9)
   \                     ??ADC_RegularChannelConfig_4: (+1)
   \   000000CA   0x2007             MOVS     R0,#+7
   \   000000CC   0x2D0A             CMP      R5,#+10
   \   000000CE   0xDB0C             BLT.N    ??ADC_RegularChannelConfig_5
    726            {
    727              /* Get the old register value */
    728              tmpreg1 = ADCx->SMPR1;
   \   000000D0   0x68E1             LDR      R1,[R4, #+12]
    729              
    730              /* Calculate the mask to clear */
    731              tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
    732              
    733              /* Clear the old sample time */
    734              tmpreg1 &= ~tmpreg2;
    735              
    736              /* Calculate the mask to set */
    737              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    738              
    739              /* Set the new sample time */
    740              tmpreg1 |= tmpreg2;
    741              
    742              /* Store the new register value */
    743              ADCx->SMPR1 = tmpreg1;
   \   000000D2   0xF1A5 0x020A      SUB      R2,R5,#+10
   \   000000D6   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \   000000DA   0x4090             LSLS     R0,R0,R2
   \   000000DC   0xEA21 0x0000      BIC      R0,R1,R0
   \   000000E0   0xFA07 0xF102      LSL      R1,R7,R2
   \   000000E4   0x4308             ORRS     R0,R1,R0
   \   000000E6   0x60E0             STR      R0,[R4, #+12]
   \   000000E8   0xE009             B.N      ??ADC_RegularChannelConfig_6
    744            }
    745            else /* ADC_Channel include in ADC_Channel_[0..9] */
    746            {
    747              /* Get the old register value */
    748              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_RegularChannelConfig_5: (+1)
   \   000000EA   0x6921             LDR      R1,[R4, #+16]
    749              
    750              /* Calculate the mask to clear */
    751              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
    752              
    753              /* Clear the old sample time */
    754              tmpreg1 &= ~tmpreg2;
    755              
    756              /* Calculate the mask to set */
    757              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    758              
    759              /* Set the new sample time */
    760              tmpreg1 |= tmpreg2;
    761              
    762              /* Store the new register value */
    763              ADCx->SMPR2 = tmpreg1;
   \   000000EC   0xEB05 0x0245      ADD      R2,R5,R5, LSL #+1
   \   000000F0   0x4090             LSLS     R0,R0,R2
   \   000000F2   0xEA21 0x0000      BIC      R0,R1,R0
   \   000000F6   0xFA07 0xF102      LSL      R1,R7,R2
   \   000000FA   0x4308             ORRS     R0,R1,R0
   \   000000FC   0x6120             STR      R0,[R4, #+16]
    764            }
    765            /* For Rank 1 to 6 */
    766            if (Rank < 7)
   \                     ??ADC_RegularChannelConfig_6: (+1)
   \   000000FE   0x4630             MOV      R0,R6
   \   00000100   0x211F             MOVS     R1,#+31
   \   00000102   0x2807             CMP      R0,#+7
   \   00000104   0xDA0A             BGE.N    ??ADC_RegularChannelConfig_7
    767            {
    768              /* Get the old register value */
    769              tmpreg1 = ADCx->SQR3;
   \   00000106   0x6B60             LDR      R0,[R4, #+52]
    770              
    771              /* Calculate the mask to clear */
    772              tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
    773              
    774              /* Clear the old SQx bits for the selected rank */
    775              tmpreg1 &= ~tmpreg2;
    776              
    777              /* Calculate the mask to set */
    778              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    779              
    780              /* Set the SQx bits for the selected rank */
    781              tmpreg1 |= tmpreg2;
    782              
    783              /* Store the new register value */
    784              ADCx->SQR3 = tmpreg1;
   \   00000108   0x1E72             SUBS     R2,R6,#+1
   \   0000010A   0xEB02 0x0282      ADD      R2,R2,R2, LSL #+2
   \   0000010E   0x4091             LSLS     R1,R1,R2
   \   00000110   0x4388             BICS     R0,R0,R1
   \   00000112   0xFA05 0xF102      LSL      R1,R5,R2
   \   00000116   0x4308             ORRS     R0,R1,R0
   \   00000118   0x6360             STR      R0,[R4, #+52]
   \   0000011A   0xBDF1             POP      {R0,R4-R7,PC}
    785            }
    786            /* For Rank 7 to 12 */
    787            else if (Rank < 13)
   \                     ??ADC_RegularChannelConfig_7: (+1)
   \   0000011C   0x280D             CMP      R0,#+13
   \   0000011E   0xDA0A             BGE.N    ??ADC_RegularChannelConfig_8
    788            {
    789              /* Get the old register value */
    790              tmpreg1 = ADCx->SQR2;
   \   00000120   0x6B20             LDR      R0,[R4, #+48]
    791              
    792              /* Calculate the mask to clear */
    793              tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
    794              
    795              /* Clear the old SQx bits for the selected rank */
    796              tmpreg1 &= ~tmpreg2;
    797              
    798              /* Calculate the mask to set */
    799              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    800              
    801              /* Set the SQx bits for the selected rank */
    802              tmpreg1 |= tmpreg2;
    803              
    804              /* Store the new register value */
    805              ADCx->SQR2 = tmpreg1;
   \   00000122   0x1FF2             SUBS     R2,R6,#+7
   \   00000124   0xEB02 0x0282      ADD      R2,R2,R2, LSL #+2
   \   00000128   0x4091             LSLS     R1,R1,R2
   \   0000012A   0x4388             BICS     R0,R0,R1
   \   0000012C   0xFA05 0xF102      LSL      R1,R5,R2
   \   00000130   0x4308             ORRS     R0,R1,R0
   \   00000132   0x6320             STR      R0,[R4, #+48]
   \   00000134   0xBDF1             POP      {R0,R4-R7,PC}
    806            }
    807            /* For Rank 13 to 16 */
    808            else
    809            {
    810              /* Get the old register value */
    811              tmpreg1 = ADCx->SQR1;
   \                     ??ADC_RegularChannelConfig_8: (+1)
   \   00000136   0x6AE0             LDR      R0,[R4, #+44]
    812              
    813              /* Calculate the mask to clear */
    814              tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
    815              
    816              /* Clear the old SQx bits for the selected rank */
    817              tmpreg1 &= ~tmpreg2;
    818              
    819              /* Calculate the mask to set */
    820              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    821              
    822              /* Set the SQx bits for the selected rank */
    823              tmpreg1 |= tmpreg2;
    824              
    825              /* Store the new register value */
    826              ADCx->SQR1 = tmpreg1;
   \   00000138   0xF1A6 0x020D      SUB      R2,R6,#+13
   \   0000013C   0xEB02 0x0282      ADD      R2,R2,R2, LSL #+2
   \   00000140   0x4091             LSLS     R1,R1,R2
   \   00000142   0x4388             BICS     R0,R0,R1
   \   00000144   0xFA05 0xF102      LSL      R1,R5,R2
   \   00000148   0x4308             ORRS     R0,R1,R0
   \   0000014A   0x62E0             STR      R0,[R4, #+44]
    827            }
    828          }
   \   0000014C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    829          
    830          /**
    831            * @brief  Enables the selected ADC software start conversion of the regular channels.
    832            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    833            * @retval None
    834            */

   \                                 In section .text, align 2, keep-with-next
    835          void ADC_SoftwareStartConv(ADC_TypeDef* ADCx)
    836          {
   \                     ADC_SoftwareStartConv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    837            /* Check the parameters */
    838            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??ADC_SoftwareStartConv_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??ADC_SoftwareStartConv_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??ADC_SoftwareStartConv_0
   \   0000001C   0xF240 0x3146      MOVW     R1,#+838
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
    839            
    840            /* Enable the selected ADC conversion for regular group */
    841            ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \                     ??ADC_SoftwareStartConv_0: (+1)
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   0000002E   0x60A0             STR      R0,[R4, #+8]
    842          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    843          
    844          /**
    845            * @brief  Gets the selected ADC Software start regular conversion Status.
    846            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    847            * @retval The new state of ADC software start conversion (SET or RESET).
    848            */

   \                                 In section .text, align 2, keep-with-next
    849          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    850          {
   \                     ADC_GetSoftwareStartConvStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    851            FlagStatus bitstatus = RESET;
    852            /* Check the parameters */
    853            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??ADC_GetSoftwareStartConvStatus_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??ADC_GetSoftwareStartConvStatus_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??ADC_GetSoftwareStartConvStatus_0
   \   0000001C   0xF240 0x3155      MOVW     R1,#+853
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
    854            
    855            /* Check the status of SWSTART bit */
    856            if ((ADCx->CR2 & ADC_CR2_SWSTART) != (uint32_t)RESET)
   \                     ??ADC_GetSoftwareStartConvStatus_0: (+1)
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
    857            {
    858              /* SWSTART bit is set */
    859              bitstatus = SET;
    860            }
    861            else
    862            {
    863              /* SWSTART bit is reset */
    864              bitstatus = RESET;
   \   0000002A   0x0F80             LSRS     R0,R0,#+30
   \   0000002C   0xF000 0x0001      AND      R0,R0,#0x1
    865            }
    866            
    867            /* Return the SWSTART bit status */
    868            return  bitstatus;
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    869          }
    870          
    871          
    872          /**
    873            * @brief  Enables or disables the EOC on each regular channel conversion
    874            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    875            * @param  NewState: new state of the selected ADC EOC flag rising
    876            *          This parameter can be: ENABLE or DISABLE.
    877            * @retval None
    878            */

   \                                 In section .text, align 2, keep-with-next
    879          void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    880          {
   \                     ADC_EOCOnEachRegularChannelCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    881            /* Check the parameters */
    882            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_0
   \   0000001E   0xF240 0x3172      MOVW     R1,#+882
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    883            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_EOCOnEachRegularChannelCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_1
   \   00000032   0xF240 0x3173      MOVW     R1,#+883
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    884            
    885            if (NewState != DISABLE)
   \                     ??ADC_EOCOnEachRegularChannelCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0xD003             BEQ.N    ??ADC_EOCOnEachRegularChannelCmd_2
    886            {
    887              /* Enable the selected ADC EOC rising on each regular channel conversion */
    888              ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
   \   00000044   0xF440 0x6080      ORR      R0,R0,#0x400
   \   00000048   0x60A0             STR      R0,[R4, #+8]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    889            }
    890            else
    891            {
    892              /* Disable the selected ADC EOC rising on each regular channel conversion */
    893              ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
   \                     ??ADC_EOCOnEachRegularChannelCmd_2: (+1)
   \   0000004C   0xF420 0x6080      BIC      R0,R0,#0x400
   \   00000050   0x60A0             STR      R0,[R4, #+8]
    894            }
    895          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    896          
    897          /**
    898            * @brief  Enables or disables the ADC continuous conversion mode 
    899            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    900            * @param  NewState: new state of the selected ADC continuous conversion mode
    901            *          This parameter can be: ENABLE or DISABLE.
    902            * @retval None
    903            */

   \                                 In section .text, align 2, keep-with-next
    904          void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    905          {
   \                     ADC_ContinuousModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    906            /* Check the parameters */
    907            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_ContinuousModeCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_ContinuousModeCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_ContinuousModeCmd_0
   \   0000001E   0xF240 0x318B      MOVW     R1,#+907
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    908            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_ContinuousModeCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??ADC_ContinuousModeCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??ADC_ContinuousModeCmd_1
   \   00000032   0xF44F 0x7163      MOV      R1,#+908
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    909            
    910            if (NewState != DISABLE)
   \                     ??ADC_ContinuousModeCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x68A0             LDR      R0,[R4, #+8]
   \   00000042   0xD003             BEQ.N    ??ADC_ContinuousModeCmd_2
    911            {
    912              /* Enable the selected ADC continuous conversion mode */
    913              ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
   \   00000044   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000048   0x60A0             STR      R0,[R4, #+8]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    914            }
    915            else
    916            {
    917              /* Disable the selected ADC continuous conversion mode */
    918              ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
   \                     ??ADC_ContinuousModeCmd_2: (+1)
   \   0000004C   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000050   0x60A0             STR      R0,[R4, #+8]
    919            }
    920          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    921          
    922          /**
    923            * @brief  Configures the discontinuous mode for the selected ADC regular group 
    924            *         channel.
    925            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    926            * @param  Number: specifies the discontinuous mode regular channel count value.
    927            *          This number must be between 1 and 8.
    928            * @retval None
    929            */

   \                                 In section .text, align 2, keep-with-next
    930          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    931          {
   \                     ADC_DiscModeChannelCountConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    932            uint32_t tmpreg1 = 0;
    933            uint32_t tmpreg2 = 0;
    934            
    935            /* Check the parameters */
    936            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_DiscModeChannelCountConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_DiscModeChannelCountConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_DiscModeChannelCountConfig_0
   \   0000001E   0xF44F 0x716A      MOV      R1,#+936
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    937            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
   \                     ??ADC_DiscModeChannelCountConfig_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD001             BEQ.N    ??ADC_DiscModeChannelCountConfig_1
   \   0000002E   0x2D09             CMP      R5,#+9
   \   00000030   0xDB05             BLT.N    ??ADC_DiscModeChannelCountConfig_2
   \                     ??ADC_DiscModeChannelCountConfig_1: (+1)
   \   00000032   0xF240 0x31A9      MOVW     R1,#+937
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    938            
    939            /* Get the old register value */
    940            tmpreg1 = ADCx->CR1;
   \                     ??ADC_DiscModeChannelCountConfig_2: (+1)
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
    941            
    942            /* Clear the old discontinuous mode channel count */
    943            tmpreg1 &= CR1_DISCNUM_RESET;
    944            
    945            /* Set the discontinuous mode channel count */
    946            tmpreg2 = Number - 1;
    947            tmpreg1 |= tmpreg2 << 13;
    948            
    949            /* Store the new register value */
    950            ADCx->CR1 = tmpreg1;
   \   00000040   0xF420 0x4060      BIC      R0,R0,#0xE000
   \   00000044   0x1E69             SUBS     R1,R5,#+1
   \   00000046   0xEA40 0x3041      ORR      R0,R0,R1, LSL #+13
   \   0000004A   0x6060             STR      R0,[R4, #+4]
    951          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    952          
    953          /**
    954            * @brief  Enables or disables the discontinuous mode on regular group channel 
    955            *         for the specified ADC
    956            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    957            * @param  NewState: new state of the selected ADC discontinuous mode on 
    958            *         regular group channel.
    959            *          This parameter can be: ENABLE or DISABLE.
    960            * @retval None
    961            */

   \                                 In section .text, align 2, keep-with-next
    962          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    963          {
   \                     ADC_DiscModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    964            /* Check the parameters */
    965            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable23  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_DiscModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable23_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_DiscModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_DiscModeCmd_0
   \   00000018   0xF240 0x31C5      MOVW     R1,#+965
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
    966            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DiscModeCmd_0: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_DiscModeCmd_1
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD005             BEQ.N    ??ADC_DiscModeCmd_1
   \   0000002C   0xF240 0x31C6      MOVW     R1,#+966
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
    967            
    968            if (NewState != DISABLE)
   \                     ??ADC_DiscModeCmd_1: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0xD003             BEQ.N    ??ADC_DiscModeCmd_2
    969            {
    970              /* Enable the selected ADC regular discontinuous mode */
    971              ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
   \   0000003E   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000042   0x6060             STR      R0,[R4, #+4]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
    972            }
    973            else
    974            {
    975              /* Disable the selected ADC regular discontinuous mode */
    976              ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
   \                     ??ADC_DiscModeCmd_2: (+1)
   \   00000046   0xF420 0x6000      BIC      R0,R0,#0x800
   \   0000004A   0x6060             STR      R0,[R4, #+4]
    977            }
    978          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    979          
    980          /**
    981            * @brief  Returns the last ADCx conversion result data for regular channel.
    982            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    983            * @retval The Data conversion value.
    984            */

   \                                 In section .text, align 2, keep-with-next
    985          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    986          {
   \                     ADC_GetConversionValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    987            /* Check the parameters */
    988            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x....             LDR.N    R0,??DataTable23  ;; 0x40012000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00B             BEQ.N    ??ADC_GetConversionValue_0
   \   0000000A   0x....             LDR.N    R0,??DataTable23_1  ;; 0x40012100
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??ADC_GetConversionValue_0
   \   00000010   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40012200
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??ADC_GetConversionValue_0
   \   00000016   0xF44F 0x7177      MOV      R1,#+988
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       assert_failed
    989            
    990            /* Return the selected ADC conversion value */
    991            return (uint16_t) ADCx->DR;
   \                     ??ADC_GetConversionValue_0: (+1)
   \   00000022   0x6CE0             LDR      R0,[R4, #+76]
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    992          }
    993          
    994          /**
    995            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    996            *         data in the selected multi mode.
    997            * @param  None  
    998            * @retval The Data conversion value.
    999            * @note   In dual mode, the value returned by this function is as following
   1000            *           Data[15:0] : these bits contain the regular data of ADC1.
   1001            *           Data[31:16]: these bits contain the regular data of ADC2.
   1002            * @note   In triple mode, the value returned by this function is as following
   1003            *           Data[15:0] : these bits contain alternatively the regular data of ADC1, ADC3 and ADC2.
   1004            *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
   1005            */

   \                                 In section .text, align 2, keep-with-next
   1006          uint32_t ADC_GetMultiModeConversionValue(void)
   1007          {
   1008            /* Return the multi mode conversion value */
   1009            return (*(__IO uint32_t *) CDR_ADDRESS);
   \                     ADC_GetMultiModeConversionValue: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable35_1  ;; 0x40012308
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   1010          }
   1011          /**
   1012            * @}
   1013            */
   1014          
   1015          /** @defgroup ADC_Group5 Regular Channels DMA Configuration functions
   1016           *  @brief   Regular Channels DMA Configuration functions 
   1017           *
   1018          @verbatim   
   1019           ===============================================================================
   1020                      ##### Regular Channels DMA Configuration functions #####
   1021           ===============================================================================  
   1022              [..] This section provides functions allowing to configure the DMA for ADC 
   1023                   regular channels.
   1024                   Since converted regular channel values are stored into a unique data 
   1025                   register, it is useful to use DMA for conversion of more than one regular 
   1026                   channel. This avoids the loss of the data already stored in the ADC 
   1027                   Data register.   
   1028                   When the DMA mode is enabled (using the ADC_DMACmd() function), after each
   1029                   conversion of a regular channel, a DMA request is generated.
   1030              [..] Depending on the "DMA disable selection for Independent ADC mode" 
   1031                   configuration (using the ADC_DMARequestAfterLastTransferCmd() function), 
   1032                   at the end of the last DMA transfer, two possibilities are allowed:
   1033                (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
   1034                (+) Requests can continue to be generated (feature ENABLED).  
   1035              [..] Depending on the "DMA disable selection for multi ADC mode" configuration 
   1036                   (using the void ADC_MultiModeDMARequestAfterLastTransferCmd() function), 
   1037                   at the end of the last DMA transfer, two possibilities are allowed:
   1038                  (+) No new DMA request is issued to the DMA controller (feature DISABLED) 
   1039                  (+) Requests can continue to be generated (feature ENABLED).
   1040          
   1041          @endverbatim
   1042            * @{
   1043            */
   1044            
   1045           /**
   1046            * @brief  Enables or disables the specified ADC DMA request.
   1047            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1048            * @param  NewState: new state of the selected ADC DMA transfer.
   1049            *          This parameter can be: ENABLE or DISABLE.
   1050            * @retval None
   1051            */

   \                                 In section .text, align 2, keep-with-next
   1052          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1053          {
   \                     ADC_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1054            /* Check the parameters */
   1055            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable23  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_DMACmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable23_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_DMACmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_DMACmd_0
   \   00000018   0xF240 0x411F      MOVW     R1,#+1055
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1056            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DMACmd_0: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_DMACmd_1
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD005             BEQ.N    ??ADC_DMACmd_1
   \   0000002C   0xF44F 0x6184      MOV      R1,#+1056
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
   1057            if (NewState != DISABLE)
   \                     ??ADC_DMACmd_1: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0xD003             BEQ.N    ??ADC_DMACmd_2
   1058            {
   1059              /* Enable the selected ADC DMA request */
   1060              ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
   \   0000003E   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000042   0x60A0             STR      R0,[R4, #+8]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1061            }
   1062            else
   1063            {
   1064              /* Disable the selected ADC DMA request */
   1065              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
   \                     ??ADC_DMACmd_2: (+1)
   \   00000046   0xF420 0x7080      BIC      R0,R0,#0x100
   \   0000004A   0x60A0             STR      R0,[R4, #+8]
   1066            }
   1067          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1068          
   1069          /**
   1070            * @brief  Enables or disables the ADC DMA request after last transfer (Single-ADC mode)  
   1071            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1072            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1073            *          This parameter can be: ENABLE or DISABLE.
   1074            * @retval None
   1075            */

   \                                 In section .text, align 2, keep-with-next
   1076          void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1077          {
   \                     ADC_DMARequestAfterLastTransferCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1078            /* Check the parameters */
   1079            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable23  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable23_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_0
   \   00000018   0xF240 0x4137      MOVW     R1,#+1079
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1080            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_DMARequestAfterLastTransferCmd_0: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_1
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD005             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_1
   \   0000002C   0xF44F 0x6187      MOV      R1,#+1080
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
   1081            if (NewState != DISABLE)
   \                     ??ADC_DMARequestAfterLastTransferCmd_1: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0x68A0             LDR      R0,[R4, #+8]
   \   0000003C   0xD003             BEQ.N    ??ADC_DMARequestAfterLastTransferCmd_2
   1082            {
   1083              /* Enable the selected ADC DMA request after last transfer */
   1084              ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
   \   0000003E   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000042   0x60A0             STR      R0,[R4, #+8]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1085            }
   1086            else
   1087            {
   1088              /* Disable the selected ADC DMA request after last transfer */
   1089              ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
   \                     ??ADC_DMARequestAfterLastTransferCmd_2: (+1)
   \   00000046   0xF420 0x7000      BIC      R0,R0,#0x200
   \   0000004A   0x60A0             STR      R0,[R4, #+8]
   1090            }
   1091          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1092          
   1093          /**
   1094            * @brief  Enables or disables the ADC DMA request after last transfer in multi ADC mode       
   1095            * @param  NewState: new state of the selected ADC DMA request after last transfer.
   1096            *          This parameter can be: ENABLE or DISABLE.
   1097            * @note   if Enabled, DMA requests are issued as long as data are converted and 
   1098            *         DMA mode for multi ADC mode (selected using ADC_CommonInit() function 
   1099            *         by ADC_CommonInitStruct.ADC_DMAAccessMode structure member) is 
   1100            *          ADC_DMAAccessMode_1, ADC_DMAAccessMode_2 or ADC_DMAAccessMode_3.     
   1101            * @retval None
   1102            */

   \                                 In section .text, align 2, keep-with-next
   1103          void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
   1104          {
   \                     ADC_MultiModeDMARequestAfterLastTransferCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1105            /* Check the parameters */
   1106            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??ADC_MultiModeDMARequestAfterLastTransferCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??ADC_MultiModeDMARequestAfterLastTransferCmd_0
   \   0000000A   0xF240 0x4152      MOVW     R1,#+1106
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1107            if (NewState != DISABLE)
   \                     ??ADC_MultiModeDMARequestAfterLastTransferCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40012304
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??ADC_MultiModeDMARequestAfterLastTransferCmd_1
   1108            {
   1109              /* Enable the selected ADC DMA request after last transfer */
   1110              ADC->CCR |= (uint32_t)ADC_CCR_DDS;
   \   00000020   0xF441 0x5100      ORR      R1,R1,#0x2000
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
   1111            }
   1112            else
   1113            {
   1114              /* Disable the selected ADC DMA request after last transfer */
   1115              ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
   \                     ??ADC_MultiModeDMARequestAfterLastTransferCmd_1: (+1)
   \   00000028   0xF421 0x5100      BIC      R1,R1,#0x2000
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   1116            }
   1117          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1118          /**
   1119            * @}
   1120            */
   1121          
   1122          /** @defgroup ADC_Group6 Injected channels Configuration functions
   1123           *  @brief   Injected channels Configuration functions 
   1124           *
   1125          @verbatim   
   1126           ===============================================================================
   1127                        ##### Injected channels Configuration functions #####
   1128           ===============================================================================  
   1129          
   1130              [..] This section provide functions allowing to configure the ADC Injected channels,
   1131                   it is composed of 2 sub sections : 
   1132              
   1133                (#) Configuration functions for Injected channels: This subsection provides 
   1134                    functions allowing to configure the ADC injected channels :    
   1135                  (++) Configure the rank in the injected group sequencer for each channel
   1136                  (++) Configure the sampling time for each channel    
   1137                  (++) Activate the Auto injected Mode  
   1138                  (++) Activate the Discontinuous Mode 
   1139                  (++) scan mode activation  
   1140                  (++) External/software trigger source   
   1141                  (++) External trigger edge 
   1142                  (++) injected channels sequencer.
   1143              
   1144                (#) Get the Specified Injected channel conversion data: This subsection 
   1145                    provides an important function in the ADC peripheral since it returns the 
   1146                    converted data of the specific injected channel.
   1147          
   1148          @endverbatim
   1149            * @{
   1150            */ 
   1151          /**
   1152            * @brief  Configures for the selected ADC injected channel its corresponding
   1153            *         rank in the sequencer and its sample time.
   1154            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1155            * @param  ADC_Channel: the ADC channel to configure. 
   1156            *          This parameter can be one of the following values:
   1157            *            @arg ADC_Channel_0: ADC Channel0 selected
   1158            *            @arg ADC_Channel_1: ADC Channel1 selected
   1159            *            @arg ADC_Channel_2: ADC Channel2 selected
   1160            *            @arg ADC_Channel_3: ADC Channel3 selected
   1161            *            @arg ADC_Channel_4: ADC Channel4 selected
   1162            *            @arg ADC_Channel_5: ADC Channel5 selected
   1163            *            @arg ADC_Channel_6: ADC Channel6 selected
   1164            *            @arg ADC_Channel_7: ADC Channel7 selected
   1165            *            @arg ADC_Channel_8: ADC Channel8 selected
   1166            *            @arg ADC_Channel_9: ADC Channel9 selected
   1167            *            @arg ADC_Channel_10: ADC Channel10 selected
   1168            *            @arg ADC_Channel_11: ADC Channel11 selected
   1169            *            @arg ADC_Channel_12: ADC Channel12 selected
   1170            *            @arg ADC_Channel_13: ADC Channel13 selected
   1171            *            @arg ADC_Channel_14: ADC Channel14 selected
   1172            *            @arg ADC_Channel_15: ADC Channel15 selected
   1173            *            @arg ADC_Channel_16: ADC Channel16 selected
   1174            *            @arg ADC_Channel_17: ADC Channel17 selected
   1175            *            @arg ADC_Channel_18: ADC Channel18 selected                       
   1176            * @param  Rank: The rank in the injected group sequencer. 
   1177            *          This parameter must be between 1 to 4.
   1178            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
   1179            *          This parameter can be one of the following values:
   1180            *            @arg ADC_SampleTime_3Cycles: Sample time equal to 3 cycles
   1181            *            @arg ADC_SampleTime_15Cycles: Sample time equal to 15 cycles
   1182            *            @arg ADC_SampleTime_28Cycles: Sample time equal to 28 cycles
   1183            *            @arg ADC_SampleTime_56Cycles: Sample time equal to 56 cycles	
   1184            *            @arg ADC_SampleTime_84Cycles: Sample time equal to 84 cycles	
   1185            *            @arg ADC_SampleTime_112Cycles: Sample time equal to 112 cycles	
   1186            *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
   1187            *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
   1188            * @retval None
   1189            */

   \                                 In section .text, align 2, keep-with-next
   1190          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1191          {
   \                     ADC_InjectedChannelConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   1192            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   1193            /* Check the parameters */
   1194            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable23  ;; 0x40012000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00B             BEQ.N    ??ADC_InjectedChannelConfig_0
   \   00000010   0x....             LDR.N    R0,??DataTable23_1  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD008             BEQ.N    ??ADC_InjectedChannelConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??ADC_InjectedChannelConfig_0
   \   0000001C   0xF240 0x41AA      MOVW     R1,#+1194
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
   1195            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   \                     ??ADC_InjectedChannelConfig_0: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD02A             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD027             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0xD025             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000036   0x2803             CMP      R0,#+3
   \   00000038   0xD023             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000003A   0x2804             CMP      R0,#+4
   \   0000003C   0xD021             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000003E   0x2805             CMP      R0,#+5
   \   00000040   0xD01F             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000042   0x2806             CMP      R0,#+6
   \   00000044   0xD01D             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000046   0x2807             CMP      R0,#+7
   \   00000048   0xD01B             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000004A   0x2808             CMP      R0,#+8
   \   0000004C   0xD019             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000004E   0x2809             CMP      R0,#+9
   \   00000050   0xD017             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000052   0x280A             CMP      R0,#+10
   \   00000054   0xD015             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000056   0x280B             CMP      R0,#+11
   \   00000058   0xD013             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000005A   0x280C             CMP      R0,#+12
   \   0000005C   0xD011             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000005E   0x280D             CMP      R0,#+13
   \   00000060   0xD00F             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000062   0x280E             CMP      R0,#+14
   \   00000064   0xD00D             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000066   0x280F             CMP      R0,#+15
   \   00000068   0xD00B             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000006A   0x2810             CMP      R0,#+16
   \   0000006C   0xD009             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   0000006E   0x2811             CMP      R0,#+17
   \   00000070   0xD007             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000072   0x2812             CMP      R0,#+18
   \   00000074   0xD005             BEQ.N    ??ADC_InjectedChannelConfig_1
   \   00000076   0xF240 0x41AB      MOVW     R1,#+1195
   \   0000007A   0x.... 0x....      ADR.W    R0,?_0
   \   0000007E   0x.... 0x....      BL       assert_failed
   1196            assert_param(IS_ADC_INJECTED_RANK(Rank));
   \                     ??ADC_InjectedChannelConfig_1: (+1)
   \   00000082   0x2E00             CMP      R6,#+0
   \   00000084   0xD001             BEQ.N    ??ADC_InjectedChannelConfig_2
   \   00000086   0x2E05             CMP      R6,#+5
   \   00000088   0xDB05             BLT.N    ??ADC_InjectedChannelConfig_3
   \                     ??ADC_InjectedChannelConfig_2: (+1)
   \   0000008A   0xF240 0x41AC      MOVW     R1,#+1196
   \   0000008E   0x.... 0x....      ADR.W    R0,?_0
   \   00000092   0x.... 0x....      BL       assert_failed
   1197            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   \                     ??ADC_InjectedChannelConfig_3: (+1)
   \   00000096   0x2F00             CMP      R7,#+0
   \   00000098   0xD014             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x2801             CMP      R0,#+1
   \   0000009E   0xD011             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000A0   0x2802             CMP      R0,#+2
   \   000000A2   0xD00F             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000A4   0x2803             CMP      R0,#+3
   \   000000A6   0xD00D             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000A8   0x2804             CMP      R0,#+4
   \   000000AA   0xD00B             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000AC   0x2805             CMP      R0,#+5
   \   000000AE   0xD009             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000B0   0x2806             CMP      R0,#+6
   \   000000B2   0xD007             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000B4   0x2807             CMP      R0,#+7
   \   000000B6   0xD005             BEQ.N    ??ADC_InjectedChannelConfig_4
   \   000000B8   0xF240 0x41AD      MOVW     R1,#+1197
   \   000000BC   0x.... 0x....      ADR.W    R0,?_0
   \   000000C0   0x.... 0x....      BL       assert_failed
   1198            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   1199            if (ADC_Channel > ADC_Channel_9)
   \                     ??ADC_InjectedChannelConfig_4: (+1)
   \   000000C4   0x2007             MOVS     R0,#+7
   \   000000C6   0x2D0A             CMP      R5,#+10
   \   000000C8   0xDB0C             BLT.N    ??ADC_InjectedChannelConfig_5
   1200            {
   1201              /* Get the old register value */
   1202              tmpreg1 = ADCx->SMPR1;
   \   000000CA   0x68E1             LDR      R1,[R4, #+12]
   1203              /* Calculate the mask to clear */
   1204              tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
   1205              /* Clear the old sample time */
   1206              tmpreg1 &= ~tmpreg2;
   1207              /* Calculate the mask to set */
   1208              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   1209              /* Set the new sample time */
   1210              tmpreg1 |= tmpreg2;
   1211              /* Store the new register value */
   1212              ADCx->SMPR1 = tmpreg1;
   \   000000CC   0xF1A5 0x020A      SUB      R2,R5,#+10
   \   000000D0   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \   000000D4   0x4090             LSLS     R0,R0,R2
   \   000000D6   0xEA21 0x0000      BIC      R0,R1,R0
   \   000000DA   0xFA07 0xF102      LSL      R1,R7,R2
   \   000000DE   0x4308             ORRS     R0,R1,R0
   \   000000E0   0x60E0             STR      R0,[R4, #+12]
   \   000000E2   0xE009             B.N      ??ADC_InjectedChannelConfig_6
   1213            }
   1214            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1215            {
   1216              /* Get the old register value */
   1217              tmpreg1 = ADCx->SMPR2;
   \                     ??ADC_InjectedChannelConfig_5: (+1)
   \   000000E4   0x6921             LDR      R1,[R4, #+16]
   1218              /* Calculate the mask to clear */
   1219              tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
   1220              /* Clear the old sample time */
   1221              tmpreg1 &= ~tmpreg2;
   1222              /* Calculate the mask to set */
   1223              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   1224              /* Set the new sample time */
   1225              tmpreg1 |= tmpreg2;
   1226              /* Store the new register value */
   1227              ADCx->SMPR2 = tmpreg1;
   \   000000E6   0xEB05 0x0245      ADD      R2,R5,R5, LSL #+1
   \   000000EA   0x4090             LSLS     R0,R0,R2
   \   000000EC   0xEA21 0x0000      BIC      R0,R1,R0
   \   000000F0   0xFA07 0xF102      LSL      R1,R7,R2
   \   000000F4   0x4308             ORRS     R0,R1,R0
   \   000000F6   0x6120             STR      R0,[R4, #+16]
   1228            }
   1229            /* Rank configuration */
   1230            /* Get the old register value */
   1231            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedChannelConfig_6: (+1)
   \   000000F8   0x6BA0             LDR      R0,[R4, #+56]
   1232            /* Get JL value: Number = JL+1 */
   1233            tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
   \   000000FA   0xF3C0 0x5101      UBFX     R1,R0,#+20,#+2
   1234            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1235            tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1236            /* Clear the old JSQx bits for the selected rank */
   1237            tmpreg1 &= ~tmpreg2;
   1238            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1239            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1240            /* Set the JSQx bits for the selected rank */
   1241            tmpreg1 |= tmpreg2;
   1242            /* Store the new register value */
   1243            ADCx->JSQR = tmpreg1;
   \   000000FE   0x1CF2             ADDS     R2,R6,#+3
   \   00000100   0x1A51             SUBS     R1,R2,R1
   \   00000102   0x1E49             SUBS     R1,R1,#+1
   \   00000104   0xEB01 0x0181      ADD      R1,R1,R1, LSL #+2
   \   00000108   0x221F             MOVS     R2,#+31
   \   0000010A   0x408A             LSLS     R2,R2,R1
   \   0000010C   0x4390             BICS     R0,R0,R2
   \   0000010E   0xFA05 0xF101      LSL      R1,R5,R1
   \   00000112   0x4308             ORRS     R0,R1,R0
   \   00000114   0x63A0             STR      R0,[R4, #+56]
   1244          }
   \   00000116   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1245          
   1246          /**
   1247            * @brief  Configures the sequencer length for injected channels
   1248            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1249            * @param  Length: The sequencer length. 
   1250            *          This parameter must be a number between 1 to 4.
   1251            * @retval None
   1252            */

   \                                 In section .text, align 2, keep-with-next
   1253          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1254          {
   \                     ADC_InjectedSequencerLengthConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1255            uint32_t tmpreg1 = 0;
   1256            uint32_t tmpreg2 = 0;
   1257            /* Check the parameters */
   1258            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable23  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_InjectedSequencerLengthConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable23_1  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_InjectedSequencerLengthConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_InjectedSequencerLengthConfig_0
   \   00000018   0xF240 0x41EA      MOVW     R1,#+1258
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1259            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   \                     ??ADC_InjectedSequencerLengthConfig_0: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD001             BEQ.N    ??ADC_InjectedSequencerLengthConfig_1
   \   00000028   0x2D05             CMP      R5,#+5
   \   0000002A   0xDB05             BLT.N    ??ADC_InjectedSequencerLengthConfig_2
   \                     ??ADC_InjectedSequencerLengthConfig_1: (+1)
   \   0000002C   0xF240 0x41EB      MOVW     R1,#+1259
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
   1260            
   1261            /* Get the old register value */
   1262            tmpreg1 = ADCx->JSQR;
   \                     ??ADC_InjectedSequencerLengthConfig_2: (+1)
   \   00000038   0x6BA0             LDR      R0,[R4, #+56]
   1263            
   1264            /* Clear the old injected sequence length JL bits */
   1265            tmpreg1 &= JSQR_JL_RESET;
   1266            
   1267            /* Set the injected sequence length JL bits */
   1268            tmpreg2 = Length - 1; 
   1269            tmpreg1 |= tmpreg2 << 20;
   1270            
   1271            /* Store the new register value */
   1272            ADCx->JSQR = tmpreg1;
   \   0000003A   0xF420 0x1040      BIC      R0,R0,#0x300000
   \   0000003E   0x1E69             SUBS     R1,R5,#+1
   \   00000040   0xEA40 0x5001      ORR      R0,R0,R1, LSL #+20
   \   00000044   0x63A0             STR      R0,[R4, #+56]
   1273          }
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1274          
   1275          /**
   1276            * @brief  Set the injected channels conversion value offset
   1277            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1278            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1279            *          This parameter can be one of the following values:
   1280            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1281            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1282            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1283            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1284            * @param  Offset: the offset value for the selected ADC injected channel
   1285            *          This parameter must be a 12bit value.
   1286            * @retval None
   1287            */

   \                                 In section .text, align 2, keep-with-next
   1288          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1289          {
   \                     ADC_SetInjectedOffset: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4614             MOV      R4,R2
   1290              __IO uint32_t tmp = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1291            /* Check the parameters */
   1292            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000E   0x....             LDR.N    R0,??DataTable23  ;; 0x40012000
   \   00000010   0x4285             CMP      R5,R0
   \   00000012   0xD00B             BEQ.N    ??ADC_SetInjectedOffset_0
   \   00000014   0x....             LDR.N    R0,??DataTable23_1  ;; 0x40012100
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD008             BEQ.N    ??ADC_SetInjectedOffset_0
   \   0000001A   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40012200
   \   0000001C   0x4285             CMP      R5,R0
   \   0000001E   0xD005             BEQ.N    ??ADC_SetInjectedOffset_0
   \   00000020   0xF240 0x510C      MOVW     R1,#+1292
   \   00000024   0x.... 0x....      ADR.W    R0,?_0
   \   00000028   0x.... 0x....      BL       assert_failed
   1293            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   \                     ??ADC_SetInjectedOffset_0: (+1)
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x2814             CMP      R0,#+20
   \   00000030   0xD00B             BEQ.N    ??ADC_SetInjectedOffset_1
   \   00000032   0x2818             CMP      R0,#+24
   \   00000034   0xD009             BEQ.N    ??ADC_SetInjectedOffset_1
   \   00000036   0x281C             CMP      R0,#+28
   \   00000038   0xD007             BEQ.N    ??ADC_SetInjectedOffset_1
   \   0000003A   0x2820             CMP      R0,#+32
   \   0000003C   0xD005             BEQ.N    ??ADC_SetInjectedOffset_1
   \   0000003E   0xF240 0x510D      MOVW     R1,#+1293
   \   00000042   0x.... 0x....      ADR.W    R0,?_0
   \   00000046   0x.... 0x....      BL       assert_failed
   1294            assert_param(IS_ADC_OFFSET(Offset));
   \                     ??ADC_SetInjectedOffset_1: (+1)
   \   0000004A   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000004E   0xDB05             BLT.N    ??ADC_SetInjectedOffset_2
   \   00000050   0xF240 0x510E      MOVW     R1,#+1294
   \   00000054   0x.... 0x....      ADR.W    R0,?_0
   \   00000058   0x.... 0x....      BL       assert_failed
   1295            
   1296            tmp = (uint32_t)ADCx;
   \                     ??ADC_SetInjectedOffset_2: (+1)
   \   0000005C   0x9500             STR      R5,[SP, #+0]
   1297            tmp += ADC_InjectedChannel;
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0xFA50 0xF086      UXTAB    R0,R0,R6
   \   00000064   0x9000             STR      R0,[SP, #+0]
   1298            
   1299            /* Set the selected injected channel data offset */
   1300           *(__IO uint32_t *) tmp = (uint32_t)Offset;
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x6004             STR      R4,[R0, #+0]
   1301          }
   \   0000006A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1302          
   1303           /**
   1304            * @brief  Configures the ADCx external trigger for injected channels conversion.
   1305            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1306            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.
   1307            *          This parameter can be one of the following values:                    
   1308            *            @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected 
   1309            *            @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected 
   1310            *            @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected 
   1311            *            @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected 
   1312            *            @arg ADC_ExternalTrigInjecConv_T3_CC2: Timer3 capture compare2 selected 
   1313            *            @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected 
   1314            *            @arg ADC_ExternalTrigInjecConv_T4_CC1: Timer4 capture compare1 selected                       
   1315            *            @arg ADC_ExternalTrigInjecConv_T4_CC2: Timer4 capture compare2 selected 
   1316            *            @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected                        
   1317            *            @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected 
   1318            *            @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected                        
   1319            *            @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected                        
   1320            *            @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected
   1321            *            @arg ADC_ExternalTrigInjecConv_T8_CC3: Timer8 capture compare3 selected                        
   1322            *            @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected 
   1323            *            @arg ADC_ExternalTrigInjecConv_Ext_IT15: External interrupt line 15 event selected                          
   1324            * @retval None
   1325            */

   \                                 In section .text, align 2, keep-with-next
   1326          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
   1327          {
   \                     ADC_ExternalTrigInjectedConvConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1328            uint32_t tmpreg = 0;
   1329            /* Check the parameters */
   1330            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable35_2  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable35_3  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_4  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_0
   \   0000001E   0xF240 0x5132      MOVW     R1,#+1330
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
   1331            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   \                     ??ADC_ExternalTrigInjectedConvConfig_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD032             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000002E   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000032   0xD02F             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000034   0xF5B5 0x3F00      CMP      R5,#+131072
   \   00000038   0xD02C             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000003A   0xF5B5 0x3F40      CMP      R5,#+196608
   \   0000003E   0xD029             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000040   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000044   0xD026             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000046   0xF5B5 0x2FA0      CMP      R5,#+327680
   \   0000004A   0xD023             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000004C   0xF5B5 0x2FC0      CMP      R5,#+393216
   \   00000050   0xD020             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000052   0xF5B5 0x2FE0      CMP      R5,#+458752
   \   00000056   0xD01D             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000058   0xF5B5 0x2F00      CMP      R5,#+524288
   \   0000005C   0xD01A             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000005E   0xF5B5 0x2F10      CMP      R5,#+589824
   \   00000062   0xD017             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000064   0xF5B5 0x2F20      CMP      R5,#+655360
   \   00000068   0xD014             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000006A   0xF5B5 0x2F30      CMP      R5,#+720896
   \   0000006E   0xD011             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000070   0xF5B5 0x2F40      CMP      R5,#+786432
   \   00000074   0xD00E             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000076   0xF5B5 0x2F50      CMP      R5,#+851968
   \   0000007A   0xD00B             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   0000007C   0xF5B5 0x2F60      CMP      R5,#+917504
   \   00000080   0xD008             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000082   0xF5B5 0x2F70      CMP      R5,#+983040
   \   00000086   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvConfig_1
   \   00000088   0xF240 0x5133      MOVW     R1,#+1331
   \   0000008C   0x.... 0x....      ADR.W    R0,?_0
   \   00000090   0x.... 0x....      BL       assert_failed
   1332            
   1333            /* Get the old register value */
   1334            tmpreg = ADCx->CR2;
   \                     ??ADC_ExternalTrigInjectedConvConfig_1: (+1)
   \   00000094   0x68A0             LDR      R0,[R4, #+8]
   1335            
   1336            /* Clear the old external event selection for injected group */
   1337            tmpreg &= CR2_JEXTSEL_RESET;
   1338            
   1339            /* Set the external event selection for injected group */
   1340            tmpreg |= ADC_ExternalTrigInjecConv;
   1341            
   1342            /* Store the new register value */
   1343            ADCx->CR2 = tmpreg;
   \   00000096   0xF420 0x2070      BIC      R0,R0,#0xF0000
   \   0000009A   0x4328             ORRS     R0,R5,R0
   \   0000009C   0x60A0             STR      R0,[R4, #+8]
   1344          }
   \   0000009E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1345          
   1346          /**
   1347            * @brief  Configures the ADCx external trigger edge for injected channels conversion.
   1348            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1349            * @param  ADC_ExternalTrigInjecConvEdge: specifies the ADC external trigger edge
   1350            *         to start injected conversion. 
   1351            *          This parameter can be one of the following values:
   1352            *            @arg ADC_ExternalTrigInjecConvEdge_None: external trigger disabled for 
   1353            *                                                     injected conversion
   1354            *            @arg ADC_ExternalTrigInjecConvEdge_Rising: detection on rising edge
   1355            *            @arg ADC_ExternalTrigInjecConvEdge_Falling: detection on falling edge
   1356            *            @arg ADC_ExternalTrigInjecConvEdge_RisingFalling: detection on both rising 
   1357            *                                                               and falling edge
   1358            * @retval None
   1359            */

   \                                 In section .text, align 2, keep-with-next
   1360          void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge)
   1361          {
   \                     ADC_ExternalTrigInjectedConvEdgeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1362            uint32_t tmpreg = 0;
   1363            /* Check the parameters */
   1364            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable35_2  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable35_3  ;; 0x40012100
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable35_4  ;; 0x40012200
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_0
   \   0000001E   0xF240 0x5154      MOVW     R1,#+1364
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
   1365            assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
   \                     ??ADC_ExternalTrigInjectedConvEdgeConfig_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD00E             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   0000002E   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000032   0xD00B             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000034   0xF5B5 0x1F00      CMP      R5,#+2097152
   \   00000038   0xD008             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   0000003A   0xF5B5 0x1F40      CMP      R5,#+3145728
   \   0000003E   0xD005             BEQ.N    ??ADC_ExternalTrigInjectedConvEdgeConfig_1
   \   00000040   0xF240 0x5155      MOVW     R1,#+1365
   \   00000044   0x.... 0x....      ADR.W    R0,?_0
   \   00000048   0x.... 0x....      BL       assert_failed
   1366            /* Get the old register value */
   1367            tmpreg = ADCx->CR2;
   \                     ??ADC_ExternalTrigInjectedConvEdgeConfig_1: (+1)
   \   0000004C   0x68A0             LDR      R0,[R4, #+8]
   1368            /* Clear the old external trigger edge for injected group */
   1369            tmpreg &= CR2_JEXTEN_RESET;
   1370            /* Set the new external trigger edge for injected group */
   1371            tmpreg |= ADC_ExternalTrigInjecConvEdge;
   1372            /* Store the new register value */
   1373            ADCx->CR2 = tmpreg;
   \   0000004E   0xF420 0x1040      BIC      R0,R0,#0x300000
   \   00000052   0x4328             ORRS     R0,R5,R0
   \   00000054   0x60A0             STR      R0,[R4, #+8]
   1374          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1375          
   1376          /**
   1377            * @brief  Enables the selected ADC software start conversion of the injected channels.
   1378            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1379            * @retval None
   1380            */

   \                                 In section .text, align 2, keep-with-next
   1381          void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
   1382          {
   \                     ADC_SoftwareStartInjectedConv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1383            /* Check the parameters */
   1384            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable35_2  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??ADC_SoftwareStartInjectedConv_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable35_3  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??ADC_SoftwareStartInjectedConv_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable35_4  ;; 0x40012200
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??ADC_SoftwareStartInjectedConv_0
   \   0000001C   0xF44F 0x61AD      MOV      R1,#+1384
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
   1385            /* Enable the selected ADC conversion for injected group */
   1386            ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
   \                     ??ADC_SoftwareStartInjectedConv_0: (+1)
   \   00000028   0x68A0             LDR      R0,[R4, #+8]
   \   0000002A   0xF440 0x0080      ORR      R0,R0,#0x400000
   \   0000002E   0x60A0             STR      R0,[R4, #+8]
   1387          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1388          
   1389          /**
   1390            * @brief  Gets the selected ADC Software start injected conversion Status.
   1391            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1392            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1393            */

   \                                 In section .text, align 2, keep-with-next
   1394          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1395          {
   \                     ADC_GetSoftwareStartInjectedConvCmdStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1396            FlagStatus bitstatus = RESET;
   1397            /* Check the parameters */
   1398            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000004   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00B             BEQ.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   \   0000000A   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   \   00000010   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??ADC_GetSoftwareStartInjectedConvCmdStatus_0
   \   00000016   0xF240 0x5176      MOVW     R1,#+1398
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       assert_failed
   1399            
   1400            /* Check the status of JSWSTART bit */
   1401            if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
   \                     ??ADC_GetSoftwareStartInjectedConvCmdStatus_0: (+1)
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   1402            {
   1403              /* JSWSTART bit is set */
   1404              bitstatus = SET;
   1405            }
   1406            else
   1407            {
   1408              /* JSWSTART bit is reset */
   1409              bitstatus = RESET;
   \   00000024   0x0D80             LSRS     R0,R0,#+22
   \   00000026   0xF000 0x0001      AND      R0,R0,#0x1
   1410            }
   1411            /* Return the JSWSTART bit status */
   1412            return  bitstatus;
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
   1413          }
   1414          
   1415          /**
   1416            * @brief  Enables or disables the selected ADC automatic injected group 
   1417            *         conversion after regular one.
   1418            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1419            * @param  NewState: new state of the selected ADC auto injected conversion
   1420            *          This parameter can be: ENABLE or DISABLE.
   1421            * @retval None
   1422            */

   \                                 In section .text, align 2, keep-with-next
   1423          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1424          {
   \                     ADC_AutoInjectedConvCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1425            /* Check the parameters */
   1426            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_AutoInjectedConvCmd_0
   \   00000018   0xF240 0x5192      MOVW     R1,#+1426
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1427            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_AutoInjectedConvCmd_0: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_AutoInjectedConvCmd_1
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD005             BEQ.N    ??ADC_AutoInjectedConvCmd_1
   \   0000002C   0xF240 0x5193      MOVW     R1,#+1427
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
   1428            if (NewState != DISABLE)
   \                     ??ADC_AutoInjectedConvCmd_1: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0xD003             BEQ.N    ??ADC_AutoInjectedConvCmd_2
   1429            {
   1430              /* Enable the selected ADC automatic injected group conversion */
   1431              ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
   \   0000003E   0xF440 0x6080      ORR      R0,R0,#0x400
   \   00000042   0x6060             STR      R0,[R4, #+4]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1432            }
   1433            else
   1434            {
   1435              /* Disable the selected ADC automatic injected group conversion */
   1436              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
   \                     ??ADC_AutoInjectedConvCmd_2: (+1)
   \   00000046   0xF420 0x6080      BIC      R0,R0,#0x400
   \   0000004A   0x6060             STR      R0,[R4, #+4]
   1437            }
   1438          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1439          
   1440          /**
   1441            * @brief  Enables or disables the discontinuous mode for injected group 
   1442            *         channel for the specified ADC
   1443            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1444            * @param  NewState: new state of the selected ADC discontinuous mode on injected
   1445            *         group channel.
   1446            *          This parameter can be: ENABLE or DISABLE.
   1447            * @retval None
   1448            */

   \                                 In section .text, align 2, keep-with-next
   1449          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1450          {
   \                     ADC_InjectedDiscModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1451            /* Check the parameters */
   1452            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_InjectedDiscModeCmd_0
   \   00000018   0xF240 0x51AC      MOVW     R1,#+1452
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1453            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_InjectedDiscModeCmd_0: (+1)
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??ADC_InjectedDiscModeCmd_1
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD005             BEQ.N    ??ADC_InjectedDiscModeCmd_1
   \   0000002C   0xF240 0x51AD      MOVW     R1,#+1453
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
   1454            if (NewState != DISABLE)
   \                     ??ADC_InjectedDiscModeCmd_1: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0xD003             BEQ.N    ??ADC_InjectedDiscModeCmd_2
   1455            {
   1456              /* Enable the selected ADC injected discontinuous mode */
   1457              ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
   \   0000003E   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000042   0x6060             STR      R0,[R4, #+4]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1458            }
   1459            else
   1460            {
   1461              /* Disable the selected ADC injected discontinuous mode */
   1462              ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
   \                     ??ADC_InjectedDiscModeCmd_2: (+1)
   \   00000046   0xF420 0x5080      BIC      R0,R0,#0x1000
   \   0000004A   0x6060             STR      R0,[R4, #+4]
   1463            }
   1464          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1465          
   1466          /**
   1467            * @brief  Returns the ADC injected channel conversion result
   1468            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1469            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1470            *          This parameter can be one of the following values:
   1471            *            @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1472            *            @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1473            *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1474            *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1475            * @retval The Data conversion value.
   1476            */

   \                                 In section .text, align 2, keep-with-next
   1477          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1478          {
   \                     ADC_GetInjectedConversionValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   1479            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1480            
   1481            /* Check the parameters */
   1482            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   0000000A   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD00B             BEQ.N    ??ADC_GetInjectedConversionValue_0
   \   00000010   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   00000012   0x4285             CMP      R5,R0
   \   00000014   0xD008             BEQ.N    ??ADC_GetInjectedConversionValue_0
   \   00000016   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000018   0x4285             CMP      R5,R0
   \   0000001A   0xD005             BEQ.N    ??ADC_GetInjectedConversionValue_0
   \   0000001C   0xF240 0x51CA      MOVW     R1,#+1482
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
   1483            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   \                     ??ADC_GetInjectedConversionValue_0: (+1)
   \   00000028   0x2C14             CMP      R4,#+20
   \   0000002A   0xD00B             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   0000002C   0x2C18             CMP      R4,#+24
   \   0000002E   0xD009             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000030   0x2C1C             CMP      R4,#+28
   \   00000032   0xD007             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000034   0x2C20             CMP      R4,#+32
   \   00000036   0xD005             BEQ.N    ??ADC_GetInjectedConversionValue_1
   \   00000038   0xF240 0x51CB      MOVW     R1,#+1483
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
   1484          
   1485            tmp = (uint32_t)ADCx;
   \                     ??ADC_GetInjectedConversionValue_1: (+1)
   \   00000044   0x9500             STR      R5,[SP, #+0]
   1486            tmp += ADC_InjectedChannel + JDR_OFFSET;
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0xF104 0x0128      ADD      R1,R4,#+40
   \   0000004C   0x1808             ADDS     R0,R1,R0
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   1487            
   1488            /* Returns the selected injected channel conversion data value */
   1489            return (uint16_t) (*(__IO uint32_t*)  tmp); 
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0xB280             UXTH     R0,R0
   \   00000056   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1490          }
   1491          /**
   1492            * @}
   1493            */
   1494          
   1495          /** @defgroup ADC_Group7 Interrupts and flags management functions
   1496           *  @brief   Interrupts and flags management functions
   1497           *
   1498          @verbatim   
   1499           ===============================================================================
   1500                      ##### Interrupts and flags management functions #####
   1501           ===============================================================================  
   1502          
   1503              [..] This section provides functions allowing to configure the ADC Interrupts 
   1504                   and to get the status and clear flags and Interrupts pending bits.
   1505            
   1506              [..] Each ADC provides 4 Interrupts sources and 6 Flags which can be divided
   1507                  into 3 groups:
   1508            
   1509            *** Flags and Interrupts for ADC regular channels ***
   1510            =====================================================
   1511              [..]
   1512                (+) Flags :
   1513                  (##) ADC_FLAG_OVR : Overrun detection when regular converted data are lost
   1514          
   1515                  (##) ADC_FLAG_EOC : Regular channel end of conversion ==> to indicate 
   1516                       (depending on EOCS bit, managed by ADC_EOCOnEachRegularChannelCmd() )
   1517                       the end of:
   1518                       (+++) a regular CHANNEL conversion 
   1519                       (+++) sequence of regular GROUP conversions .
   1520          
   1521                  (##) ADC_FLAG_STRT: Regular channel start ==> to indicate when regular 
   1522                       CHANNEL conversion starts.
   1523              [..]
   1524                (+) Interrupts :
   1525                  (##) ADC_IT_OVR : specifies the interrupt source for Overrun detection 
   1526                       event.  
   1527                  (##) ADC_IT_EOC : specifies the interrupt source for Regular channel end
   1528                       of conversion event.
   1529            
   1530            
   1531            *** Flags and Interrupts for ADC Injected channels ***
   1532            ======================================================
   1533              [..]
   1534                (+) Flags :
   1535                  (##) ADC_FLAG_JEOC : Injected channel end of conversion ==> to indicate 
   1536                       at the end of injected GROUP conversion  
   1537                        
   1538                  (##) ADC_FLAG_JSTRT: Injected channel start ==> to indicate hardware when 
   1539                       injected GROUP conversion starts.
   1540              [..]
   1541                (+) Interrupts :
   1542                  (##) ADC_IT_JEOC : specifies the interrupt source for Injected channel 
   1543                       end of conversion event.     
   1544          
   1545            *** General Flags and Interrupts for the ADC ***
   1546            ================================================ 
   1547              [..]
   1548                (+)Flags :
   1549                  (##) ADC_FLAG_AWD: Analog watchdog ==> to indicate if the converted voltage 
   1550                       crosses the programmed thresholds values.
   1551              [..]          
   1552                (+) Interrupts :
   1553                  (##) ADC_IT_AWD : specifies the interrupt source for Analog watchdog event. 
   1554          
   1555            
   1556              [..] The user should identify which mode will be used in his application to 
   1557                   manage the ADC controller events: Polling mode or Interrupt mode.
   1558            
   1559              [..] In the Polling Mode it is advised to use the following functions:
   1560                (+) ADC_GetFlagStatus() : to check if flags events occur. 
   1561                (+) ADC_ClearFlag()     : to clear the flags events.
   1562                
   1563              [..] In the Interrupt Mode it is advised to use the following functions:
   1564                (+) ADC_ITConfig()          : to enable or disable the interrupt source.
   1565                (+) ADC_GetITStatus()       : to check if Interrupt occurs.
   1566                (+) ADC_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1567                                             (corresponding Flag). 
   1568          @endverbatim
   1569            * @{
   1570            */ 
   1571          /**
   1572            * @brief  Enables or disables the specified ADC interrupts.
   1573            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1574            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
   1575            *          This parameter can be one of the following values:
   1576            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1577            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1578            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1579            *            @arg ADC_IT_OVR: Overrun interrupt enable                       
   1580            * @param  NewState: new state of the specified ADC interrupts.
   1581            *          This parameter can be: ENABLE or DISABLE.
   1582            * @retval None
   1583            */

   \                                 In section .text, align 2, keep-with-next
   1584          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)  
   1585          {
   \                     ADC_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   1586            uint32_t itmask = 0;
   1587            /* Check the parameters */
   1588            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00B             BEQ.N    ??ADC_ITConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??ADC_ITConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??ADC_ITConfig_0
   \   0000001A   0xF240 0x6134      MOVW     R1,#+1588
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
   1589            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??ADC_ITConfig_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??ADC_ITConfig_1
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??ADC_ITConfig_1
   \   0000002E   0xF240 0x6135      MOVW     R1,#+1589
   \   00000032   0x.... 0x....      ADR.W    R0,?_0
   \   00000036   0x.... 0x....      BL       assert_failed
   1590            assert_param(IS_ADC_IT(ADC_IT)); 
   \                     ??ADC_ITConfig_1: (+1)
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xF240 0x2105      MOVW     R1,#+517
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD010             BEQ.N    ??ADC_ITConfig_2
   \   00000044   0xF5B0 0x7F83      CMP      R0,#+262
   \   00000048   0xD00D             BEQ.N    ??ADC_ITConfig_2
   \   0000004A   0xF240 0x4107      MOVW     R1,#+1031
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD009             BEQ.N    ??ADC_ITConfig_2
   \   00000052   0xF242 0x011A      MOVW     R1,#+8218
   \   00000056   0x4288             CMP      R0,R1
   \   00000058   0xD005             BEQ.N    ??ADC_ITConfig_2
   \   0000005A   0xF240 0x6136      MOVW     R1,#+1590
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
   1591          
   1592            /* Get the ADC IT index */
   1593            itmask = (uint8_t)ADC_IT;
   1594            itmask = (uint32_t)0x01 << itmask;    
   \                     ??ADC_ITConfig_2: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x40B0             LSLS     R0,R0,R6
   1595          
   1596            if (NewState != DISABLE)
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0x6861             LDR      R1,[R4, #+4]
   \   0000006E   0xD002             BEQ.N    ??ADC_ITConfig_3
   1597            {
   1598              /* Enable the selected ADC interrupts */
   1599              ADCx->CR1 |= itmask;
   \   00000070   0x4308             ORRS     R0,R0,R1
   \   00000072   0x6060             STR      R0,[R4, #+4]
   \   00000074   0xBD70             POP      {R4-R6,PC}
   1600            }
   1601            else
   1602            {
   1603              /* Disable the selected ADC interrupts */
   1604              ADCx->CR1 &= (~(uint32_t)itmask);
   \                     ??ADC_ITConfig_3: (+1)
   \   00000076   0xEA21 0x0000      BIC      R0,R1,R0
   \   0000007A   0x6060             STR      R0,[R4, #+4]
   1605            }
   1606          }
   \   0000007C   0xBD70             POP      {R4-R6,PC}       ;; return
   1607          
   1608          /**
   1609            * @brief  Checks whether the specified ADC flag is set or not.
   1610            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1611            * @param  ADC_FLAG: specifies the flag to check. 
   1612            *          This parameter can be one of the following values:
   1613            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1614            *            @arg ADC_FLAG_EOC: End of conversion flag
   1615            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1616            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1617            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1618            *            @arg ADC_FLAG_OVR: Overrun flag                                                 
   1619            * @retval The new state of ADC_FLAG (SET or RESET).
   1620            */

   \                                 In section .text, align 2, keep-with-next
   1621          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1622          {
   \                     ADC_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1623            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1624            /* Check the parameters */
   1625            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00B             BEQ.N    ??ADC_GetFlagStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??ADC_GetFlagStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??ADC_GetFlagStatus_0
   \   0000001A   0xF240 0x6159      MOVW     R1,#+1625
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
   1626            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   \                     ??ADC_GetFlagStatus_0: (+1)
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD00F             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD00D             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD00B             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD009             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000038   0x2810             CMP      R0,#+16
   \   0000003A   0xD007             BEQ.N    ??ADC_GetFlagStatus_1
   \   0000003C   0x2820             CMP      R0,#+32
   \   0000003E   0xD005             BEQ.N    ??ADC_GetFlagStatus_1
   \   00000040   0xF240 0x615A      MOVW     R1,#+1626
   \   00000044   0x.... 0x....      ADR.W    R0,?_0
   \   00000048   0x.... 0x....      BL       assert_failed
   1627          
   1628            /* Check the status of the specified ADC flag */
   1629            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \                     ??ADC_GetFlagStatus_1: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x4228             TST      R0,R5
   \   00000050   0xD000             BEQ.N    ??ADC_GetFlagStatus_2
   1630            {
   1631              /* ADC_FLAG is set */
   1632              bitstatus = SET;
   \   00000052   0x2601             MOVS     R6,#+1
   1633            }
   1634            else
   1635            {
   1636              /* ADC_FLAG is reset */
   1637              bitstatus = RESET;
   1638            }
   1639            /* Return the ADC_FLAG status */
   1640            return  bitstatus;
   \                     ??ADC_GetFlagStatus_2: (+1)
   \   00000054   0x4630             MOV      R0,R6
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
   1641          }
   1642          
   1643          /**
   1644            * @brief  Clears the ADCx's pending flags.
   1645            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1646            * @param  ADC_FLAG: specifies the flag to clear. 
   1647            *          This parameter can be any combination of the following values:
   1648            *            @arg ADC_FLAG_AWD: Analog watchdog flag
   1649            *            @arg ADC_FLAG_EOC: End of conversion flag
   1650            *            @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1651            *            @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1652            *            @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1653            *            @arg ADC_FLAG_OVR: Overrun flag                          
   1654            * @retval None
   1655            */

   \                                 In section .text, align 2, keep-with-next
   1656          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1657          {
   \                     ADC_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1658            /* Check the parameters */
   1659            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_ClearFlag_0
   \   00000018   0xF240 0x617B      MOVW     R1,#+1659
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1660            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   \                     ??ADC_ClearFlag_0: (+1)
   \   00000024   0x20C0             MOVS     R0,#+192
   \   00000026   0x4205             TST      R5,R0
   \   00000028   0xD101             BNE.N    ??ADC_ClearFlag_1
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD105             BNE.N    ??ADC_ClearFlag_2
   \                     ??ADC_ClearFlag_1: (+1)
   \   0000002E   0xF240 0x617C      MOVW     R1,#+1660
   \   00000032   0x.... 0x....      ADR.W    R0,?_0
   \   00000036   0x.... 0x....      BL       assert_failed
   1661          
   1662            /* Clear the selected ADC flags */
   1663            ADCx->SR = ~(uint32_t)ADC_FLAG;
   \                     ??ADC_ClearFlag_2: (+1)
   \   0000003A   0x43E8             MVNS     R0,R5
   \   0000003C   0x6020             STR      R0,[R4, #+0]
   1664          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1665          
   1666          /**
   1667            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1668            * @param  ADCx:   where x can be 1, 2 or 3 to select the ADC peripheral.
   1669            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1670            *          This parameter can be one of the following values:
   1671            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1672            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1673            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1674            *            @arg ADC_IT_OVR: Overrun interrupt mask                        
   1675            * @retval The new state of ADC_IT (SET or RESET).
   1676            */

   \                                 In section .text, align 2, keep-with-next
   1677          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1678          {
   \                     ADC_GetITStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1679            ITStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1680            uint32_t itmask = 0, enablestatus = 0;
   1681          
   1682            /* Check the parameters */
   1683            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000008   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00B             BEQ.N    ??ADC_GetITStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??ADC_GetITStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??ADC_GetITStatus_0
   \   0000001A   0xF240 0x6193      MOVW     R1,#+1683
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
   1684            assert_param(IS_ADC_IT(ADC_IT));
   \                     ??ADC_GetITStatus_0: (+1)
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0xF240 0x2105      MOVW     R1,#+517
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD010             BEQ.N    ??ADC_GetITStatus_1
   \   00000030   0xF5B0 0x7F83      CMP      R0,#+262
   \   00000034   0xD00D             BEQ.N    ??ADC_GetITStatus_1
   \   00000036   0xF240 0x4107      MOVW     R1,#+1031
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD009             BEQ.N    ??ADC_GetITStatus_1
   \   0000003E   0xF242 0x011A      MOVW     R1,#+8218
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD005             BEQ.N    ??ADC_GetITStatus_1
   \   00000046   0xF240 0x6194      MOVW     R1,#+1684
   \   0000004A   0x.... 0x....      ADR.W    R0,?_0
   \   0000004E   0x.... 0x....      BL       assert_failed
   1685          
   1686            /* Get the ADC IT index */
   1687            itmask = ADC_IT >> 8;
   1688          
   1689            /* Get the ADC_IT enable bit status */
   1690            enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
   \                     ??ADC_GetITStatus_1: (+1)
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x40A9             LSLS     R1,R1,R5
   \   00000058   0x4008             ANDS     R0,R1,R0
   1691          
   1692            /* Check the status of the specified ADC interrupt */
   1693            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0xEA11 0x2F15      TST      R1,R5, LSR #+8
   \   00000060   0xD002             BEQ.N    ??ADC_GetITStatus_2
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD000             BEQ.N    ??ADC_GetITStatus_2
   1694            {
   1695              /* ADC_IT is set */
   1696              bitstatus = SET;
   \   00000066   0x2601             MOVS     R6,#+1
   1697            }
   1698            else
   1699            {
   1700              /* ADC_IT is reset */
   1701              bitstatus = RESET;
   1702            }
   1703            /* Return the ADC_IT status */
   1704            return  bitstatus;
   \                     ??ADC_GetITStatus_2: (+1)
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   1705          }
   1706          
   1707          /**
   1708            * @brief  Clears the ADCx's interrupt pending bits.
   1709            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1710            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1711            *          This parameter can be one of the following values:
   1712            *            @arg ADC_IT_EOC: End of conversion interrupt mask
   1713            *            @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1714            *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1715            *            @arg ADC_IT_OVR: Overrun interrupt mask                         
   1716            * @retval None
   1717            */

   \                                 In section .text, align 2, keep-with-next
   1718          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1719          {
   \                     ADC_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1720            uint8_t itmask = 0;
   1721            /* Check the parameters */
   1722            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   \   00000006   0x....             LDR.N    R0,??DataTable35_2  ;; 0x40012000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??ADC_ClearITPendingBit_0
   \   0000000C   0x....             LDR.N    R0,??DataTable35_3  ;; 0x40012100
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??ADC_ClearITPendingBit_0
   \   00000012   0x....             LDR.N    R0,??DataTable35_4  ;; 0x40012200
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??ADC_ClearITPendingBit_0
   \   00000018   0xF240 0x61BA      MOVW     R1,#+1722
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1723            assert_param(IS_ADC_IT(ADC_IT)); 
   \                     ??ADC_ClearITPendingBit_0: (+1)
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0xF240 0x2105      MOVW     R1,#+517
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD010             BEQ.N    ??ADC_ClearITPendingBit_1
   \   0000002E   0xF5B0 0x7F83      CMP      R0,#+262
   \   00000032   0xD00D             BEQ.N    ??ADC_ClearITPendingBit_1
   \   00000034   0xF240 0x4107      MOVW     R1,#+1031
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD009             BEQ.N    ??ADC_ClearITPendingBit_1
   \   0000003C   0xF242 0x011A      MOVW     R1,#+8218
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD005             BEQ.N    ??ADC_ClearITPendingBit_1
   \   00000044   0xF240 0x61BB      MOVW     R1,#+1723
   \   00000048   0x.... 0x....      ADR.W    R0,?_0
   \   0000004C   0x.... 0x....      BL       assert_failed
   1724            /* Get the ADC IT index */
   1725            itmask = (uint8_t)(ADC_IT >> 8);
   1726            /* Clear the selected ADC interrupt pending bits */
   1727            ADCx->SR = ~(uint32_t)itmask;
   \                     ??ADC_ClearITPendingBit_1: (+1)
   \   00000050   0x0A28             LSRS     R0,R5,#+8
   \   00000052   0x43C0             MVNS     R0,R0
   \   00000054   0x6020             STR      R0,[R4, #+0]
   1728          }                    
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x40012100         DC32     0x40012100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x40012200         DC32     0x40012200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0xFCFFFEFF         DC32     0xfcfffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x40012304         DC32     0x40012304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0xC0FFF7FD         DC32     0xc0fff7fd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x00800200         DC32     0x800200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   0x00400200         DC32     0x400200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \   00000000   0x00C00200         DC32     0xc00200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0xFFFC30E0         DC32     0xfffc30e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0xFF3FFDFF         DC32     0xff3ffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \   00000000   0x40012308         DC32     0x40012308

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_2:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_3:
   \   00000000   0x40012100         DC32     0x40012100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_4:
   \   00000000   0x40012200         DC32     0x40012200

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x61 0x64          DC8 61H, 64H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   00000066   0x00 0x00          DC8 0, 0
   1729          /**
   1730            * @}
   1731            */ 
   1732          
   1733          /**
   1734            * @}
   1735            */
   1736          
   1737          /**
   1738            * @}
   1739            */ 
   1740          
   1741          /**
   1742            * @}
   1743            */ 
   1744          
   1745          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_AnalogWatchdogCmd
        16   -> assert_failed
      16   ADC_AnalogWatchdogSingleChannelConfig
        16   -> assert_failed
      16   ADC_AnalogWatchdogThresholdsConfig
        16   -> assert_failed
      16   ADC_AutoInjectedConvCmd
        16   -> assert_failed
      16   ADC_ClearFlag
        16   -> assert_failed
      16   ADC_ClearITPendingBit
        16   -> assert_failed
      16   ADC_Cmd
        16   -> assert_failed
       8   ADC_CommonInit
         8   -> assert_failed
       0   ADC_CommonStructInit
      16   ADC_ContinuousModeCmd
        16   -> assert_failed
      16   ADC_DMACmd
        16   -> assert_failed
      16   ADC_DMARequestAfterLastTransferCmd
        16   -> assert_failed
       8   ADC_DeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
      16   ADC_DiscModeChannelCountConfig
        16   -> assert_failed
      16   ADC_DiscModeCmd
        16   -> assert_failed
      16   ADC_EOCOnEachRegularChannelCmd
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvConfig
        16   -> assert_failed
      16   ADC_ExternalTrigInjectedConvEdgeConfig
        16   -> assert_failed
       8   ADC_GetConversionValue
         8   -> assert_failed
      16   ADC_GetFlagStatus
        16   -> assert_failed
      16   ADC_GetITStatus
        16   -> assert_failed
      16   ADC_GetInjectedConversionValue
        16   -> assert_failed
       0   ADC_GetMultiModeConversionValue
       8   ADC_GetSoftwareStartConvStatus
         8   -> assert_failed
       8   ADC_GetSoftwareStartInjectedConvCmdStatus
         8   -> assert_failed
      16   ADC_ITConfig
        16   -> assert_failed
      16   ADC_Init
        16   -> assert_failed
      24   ADC_InjectedChannelConfig
        24   -> assert_failed
      16   ADC_InjectedDiscModeCmd
        16   -> assert_failed
      16   ADC_InjectedSequencerLengthConfig
        16   -> assert_failed
       8   ADC_MultiModeDMARequestAfterLastTransferCmd
         8   -> assert_failed
      24   ADC_RegularChannelConfig
        24   -> assert_failed
      24   ADC_SetInjectedOffset
        24   -> assert_failed
       8   ADC_SoftwareStartConv
         8   -> assert_failed
       8   ADC_SoftwareStartInjectedConv
         8   -> assert_failed
       0   ADC_StructInit
       8   ADC_TempSensorVrefintCmd
         8   -> assert_failed
       8   ADC_VBATCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable26
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable34
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable35_2
       4  ??DataTable35_3
       4  ??DataTable35_4
     104  ?_0
     114  ADC_AnalogWatchdogCmd
     144  ADC_AnalogWatchdogSingleChannelConfig
      86  ADC_AnalogWatchdogThresholdsConfig
      78  ADC_AutoInjectedConvCmd
      64  ADC_ClearFlag
      88  ADC_ClearITPendingBit
      84  ADC_Cmd
     282  ADC_CommonInit
      12  ADC_CommonStructInit
      84  ADC_ContinuousModeCmd
      78  ADC_DMACmd
      78  ADC_DMARequestAfterLastTransferCmd
      26  ADC_DeInit
      78  ADC_DiscModeChannelCountConfig
      78  ADC_DiscModeCmd
      84  ADC_EOCOnEachRegularChannelCmd
     160  ADC_ExternalTrigInjectedConvConfig
      88  ADC_ExternalTrigInjectedConvEdgeConfig
      40  ADC_GetConversionValue
      88  ADC_GetFlagStatus
     108  ADC_GetITStatus
      88  ADC_GetInjectedConversionValue
       8  ADC_GetMultiModeConversionValue
      50  ADC_GetSoftwareStartConvStatus
      44  ADC_GetSoftwareStartInjectedConvCmdStatus
     126  ADC_ITConfig
     364  ADC_Init
     280  ADC_InjectedChannelConfig
      78  ADC_InjectedDiscModeCmd
      72  ADC_InjectedSequencerLengthConfig
      48  ADC_MultiModeDMARequestAfterLastTransferCmd
     334  ADC_RegularChannelConfig
     108  ADC_SetInjectedOffset
      50  ADC_SoftwareStartConv
      50  ADC_SoftwareStartInjectedConv
      20  ADC_StructInit
      48  ADC_TempSensorVrefintCmd
      48  ADC_VBATCmd

 
 3 926 bytes in section .text
 
 3 926 bytes of CODE memory

Errors: none
Warnings: none
