###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        08/Oct/2018  09:58:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_usart.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_usart.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_usart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           + Initialization and Configuration
     11            *           + Data transfers
     12            *           + Multi-Processor Communication
     13            *           + LIN mode
     14            *           + Half-duplex mode
     15            *           + Smartcard mode
     16            *           + IrDA mode
     17            *           + DMA transfers management
     18            *           + Interrupts and flags management 
     19            *           
     20            @verbatim       
     21           ===============================================================================
     22                                  ##### How to use this driver #####
     23           ===============================================================================
     24              [..]
     25                (#) Enable peripheral clock using the following functions
     26                    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27                    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, 
     28                    UART4 or UART5.
     29            
     30                (#) According to the USART mode, enable the GPIO clocks using 
     31                    RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     32                    or/and SCLK). 
     33            
     34                (#) Peripheral's alternate function: 
     35                  (++) Connect the pin to the desired peripherals' Alternate 
     36                      Function (AF) using GPIO_PinAFConfig() function
     37                  (++) Configure the desired pin in alternate function by:
     38                      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     39                  (++) Select the type, pull-up/pull-down and output speed via 
     40                      GPIO_PuPd, GPIO_OType and GPIO_Speed members
     41                  (++) Call GPIO_Init() function
     42                    
     43                (#) Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     44                    flow control and Mode(Receiver/Transmitter) using the USART_Init()
     45                    function.
     46            
     47                (#) For synchronous mode, enable the clock and program the polarity,
     48                    phase and last bit using the USART_ClockInit() function.
     49            
     50                (#) Enable the NVIC and the corresponding interrupt using the function 
     51                   USART_ITConfig() if you need to use interrupt mode. 
     52            
     53                (#) When using the DMA mode 
     54                  (++) Configure the DMA using DMA_Init() function
     55                  (++) Active the needed channel Request using USART_DMACmd() function
     56             
     57                (#) Enable the USART using the USART_Cmd() function.
     58             
     59                (#) Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     60              
     61                -@- Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     62                    for more details
     63              
     64              [..]        
     65              In order to reach higher communication baudrates, it is possible to
     66              enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     67              This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     68              and before calling the function USART_Init().
     69                      
     70              @endverbatim        
     71            ******************************************************************************
     72            * @attention
     73            *
     74            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     75            *
     76            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     77            * You may not use this file except in compliance with the License.
     78            * You may obtain a copy of the License at:
     79            *
     80            *        http://www.st.com/software_license_agreement_liberty_v2
     81            *
     82            * Unless required by applicable law or agreed to in writing, software 
     83            * distributed under the License is distributed on an "AS IS" BASIS, 
     84            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     85            * See the License for the specific language governing permissions and
     86            * limitations under the License.
     87            *
     88            ******************************************************************************  
     89            */ 
     90          
     91          /* Includes ------------------------------------------------------------------*/
     92          #include "stm32f4xx_usart.h"
     93          #include "stm32f4xx_rcc.h"
     94          
     95          /** @addtogroup STM32F4xx_StdPeriph_Driver
     96            * @{
     97            */
     98          
     99          /** @defgroup USART 
    100            * @brief USART driver modules
    101            * @{
    102            */
    103          
    104          /* Private typedef -----------------------------------------------------------*/
    105          /* Private define ------------------------------------------------------------*/
    106          
    107          /*!< USART CR1 register clear Mask ((~(uint16_t)0xE9F3)) */
    108          #define CR1_CLEAR_MASK            ((uint16_t)(USART_CR1_M | USART_CR1_PCE | \
    109                                                        USART_CR1_PS | USART_CR1_TE | \
    110                                                        USART_CR1_RE))
    111          
    112          /*!< USART CR2 register clock bits clear Mask ((~(uint16_t)0xF0FF)) */
    113          #define CR2_CLOCK_CLEAR_MASK      ((uint16_t)(USART_CR2_CLKEN | USART_CR2_CPOL | \
    114                                                        USART_CR2_CPHA | USART_CR2_LBCL))
    115          
    116          /*!< USART CR3 register clear Mask ((~(uint16_t)0xFCFF)) */
    117          #define CR3_CLEAR_MASK            ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))
    118          
    119          /*!< USART Interrupts mask */
    120          #define IT_MASK                   ((uint16_t)0x001F)
    121          
    122          /* Private macro -------------------------------------------------------------*/
    123          /* Private variables ---------------------------------------------------------*/
    124          /* Private function prototypes -----------------------------------------------*/
    125          /* Private functions ---------------------------------------------------------*/
    126          
    127          /** @defgroup USART_Private_Functions
    128            * @{
    129            */
    130          
    131          /** @defgroup USART_Group1 Initialization and Configuration functions
    132           *  @brief   Initialization and Configuration functions 
    133           *
    134          @verbatim   
    135           ===============================================================================
    136                      ##### Initialization and Configuration functions #####
    137           ===============================================================================  
    138              [..]
    139              This subsection provides a set of functions allowing to initialize the USART 
    140              in asynchronous and in synchronous modes.
    141                (+) For the asynchronous mode only these parameters can be configured: 
    142                  (++) Baud Rate
    143                  (++) Word Length 
    144                  (++) Stop Bit
    145                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    146                       in the data register is transmitted but is changed by the parity bit.
    147                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    148                       the possible USART frame formats are as listed in the following table:
    149             +-------------------------------------------------------------+     
    150             |   M bit |  PCE bit  |            USART frame                |
    151             |---------------------|---------------------------------------|             
    152             |    0    |    0      |    | SB | 8 bit data | STB |          |
    153             |---------|-----------|---------------------------------------|  
    154             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    155             |---------|-----------|---------------------------------------|  
    156             |    1    |    0      |    | SB | 9 bit data | STB |          |
    157             |---------|-----------|---------------------------------------|  
    158             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    159             +-------------------------------------------------------------+            
    160                  (++) Hardware flow control
    161                  (++) Receiver/transmitter modes
    162          
    163              [..]
    164              The USART_Init() function follows the USART  asynchronous configuration 
    165              procedure (details for the procedure are available in reference manual (RM0090)).
    166          
    167               (+) For the synchronous mode in addition to the asynchronous mode parameters these 
    168                   parameters should be also configured:
    169                  (++) USART Clock Enabled
    170                  (++) USART polarity
    171                  (++) USART phase
    172                  (++) USART LastBit
    173            
    174              [..]
    175              These parameters can be configured using the USART_ClockInit() function.
    176          
    177          @endverbatim
    178            * @{
    179            */
    180            
    181          /**
    182            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    183            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    184            *         UART peripheral.
    185            * @retval None
    186            */

   \                                 In section .text, align 2, keep-with-next
    187          void USART_DeInit(USART_TypeDef* USARTx)
    188          {
   \                     USART_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    189            /* Check the parameters */
    190            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable15  ;; 0x40011000
   \   00000008   0x42AC             CMP      R4,R5
   \   0000000A   0xD020             BEQ.N    ??USART_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD01C             BEQ.N    ??USART_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD018             BEQ.N    ??USART_DeInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD014             BEQ.N    ??USART_DeInit_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD010             BEQ.N    ??USART_DeInit_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00C             BEQ.N    ??USART_DeInit_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD008             BEQ.N    ??USART_DeInit_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD004             BEQ.N    ??USART_DeInit_0
   \   00000044   0x21BE             MOVS     R1,#+190
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000004A   0x.... 0x....      BL       assert_failed
    191          
    192            if (USARTx == USART1)
   \                     ??USART_DeInit_0: (+1)
   \   0000004E   0x42AC             CMP      R4,R5
   \   00000050   0xD109             BNE.N    ??USART_DeInit_1
    193            {
    194              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2010             MOVS     R0,#+16
   \   00000056   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    195              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x2010             MOVS     R0,#+16
   \   0000005E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000062   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    196            }
    197            else if (USARTx == USART2)
   \                     ??USART_DeInit_1: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xD10B             BNE.N    ??USART_DeInit_2
    198            {
    199              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0xF44F 0x3000      MOV      R0,#+131072
   \   00000074   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    200              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0xF44F 0x3000      MOV      R0,#+131072
   \   0000007E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000082   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    201            }
    202            else if (USARTx == USART3)
   \                     ??USART_DeInit_2: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000008A   0x4284             CMP      R4,R0
   \   0000008C   0xD10B             BNE.N    ??USART_DeInit_3
    203            {
    204              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0xF44F 0x2080      MOV      R0,#+262144
   \   00000094   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    205              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0xF44F 0x2080      MOV      R0,#+262144
   \   0000009E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000A2   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    206            }    
    207            else if (USARTx == UART4)
   \                     ??USART_DeInit_3: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   000000AA   0x4284             CMP      R4,R0
   \   000000AC   0xD10B             BNE.N    ??USART_DeInit_4
    208            {
    209              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0xF44F 0x2000      MOV      R0,#+524288
   \   000000B4   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    210              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0xF44F 0x2000      MOV      R0,#+524288
   \   000000BE   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000C2   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    211            }
    212            else if (USARTx == UART5)
   \                     ??USART_DeInit_4: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   000000CA   0x4284             CMP      R4,R0
   \   000000CC   0xD10B             BNE.N    ??USART_DeInit_5
    213            {
    214              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0xF44F 0x1080      MOV      R0,#+1048576
   \   000000D4   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    215              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0xF44F 0x1080      MOV      R0,#+1048576
   \   000000DE   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000E2   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    216            }  
    217            else if (USARTx == USART6)
   \                     ??USART_DeInit_5: (+1)
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   000000EA   0x4284             CMP      R4,R0
   \   000000EC   0xD109             BNE.N    ??USART_DeInit_6
    218            {
    219              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
   \   000000EE   0x2101             MOVS     R1,#+1
   \   000000F0   0x2020             MOVS     R0,#+32
   \   000000F2   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    220              RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x2020             MOVS     R0,#+32
   \   000000FA   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000FE   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    221            }
    222            else if (USARTx == UART7)
   \                     ??USART_DeInit_6: (+1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   00000106   0x4284             CMP      R4,R0
   \   00000108   0xD10B             BNE.N    ??USART_DeInit_7
    223            {
    224              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, ENABLE);
   \   0000010A   0x2101             MOVS     R1,#+1
   \   0000010C   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000110   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    225              RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
   \   00000114   0x2100             MOVS     R1,#+0
   \   00000116   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000011A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000011E   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    226            }     
    227            else
    228            {
    229              if (USARTx == UART8)
   \                     ??USART_DeInit_7: (+1)
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000126   0x4284             CMP      R4,R0
   \   00000128   0xD10B             BNE.N    ??USART_DeInit_8
    230              { 
    231                RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, ENABLE);
   \   0000012A   0x2101             MOVS     R1,#+1
   \   0000012C   0xF04F 0x4000      MOV      R0,#-2147483648
   \   00000130   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    232                RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, DISABLE);
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0xF04F 0x4000      MOV      R0,#-2147483648
   \   0000013A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000013E   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    233              }
    234            }
    235          }
   \                     ??USART_DeInit_8: (+1)
   \   00000142   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    236          
    237          /**
    238            * @brief  Initializes the USARTx peripheral according to the specified
    239            *         parameters in the USART_InitStruct .
    240            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    241            *         UART peripheral.
    242            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
    243            *         the configuration information for the specified USART peripheral.
    244            * @retval None
    245            */

   \                                 In section .text, align 2, keep-with-next
    246          void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
    247          {
   \                     USART_Init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    248            uint32_t tmpreg = 0x00, apbclock = 0x00;
    249            uint32_t integerdivider = 0x00;
    250            uint32_t fractionaldivider = 0x00;
    251            RCC_ClocksTypeDef RCC_ClocksStatus;
    252          
    253            /* Check the parameters */
    254            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable15_7
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable15  ;; 0x40011000
   \   00000010   0x42BC             CMP      R4,R7
   \   00000012   0xD01F             BEQ.N    ??USART_Init_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD01B             BEQ.N    ??USART_Init_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD017             BEQ.N    ??USART_Init_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD013             BEQ.N    ??USART_Init_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00F             BEQ.N    ??USART_Init_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD00B             BEQ.N    ??USART_Init_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD007             BEQ.N    ??USART_Init_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD003             BEQ.N    ??USART_Init_0
   \   0000004C   0x21FE             MOVS     R1,#+254
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       assert_failed
    255            assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
   \                     ??USART_Init_0: (+1)
   \   00000054   0x6828             LDR      R0,[R5, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD003             BEQ.N    ??USART_Init_1
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable18_1  ;; 0x7270e1
   \   0000005E   0x4288             CMP      R0,R1
   \   00000060   0xD303             BCC.N    ??USART_Init_2
   \                     ??USART_Init_1: (+1)
   \   00000062   0x21FF             MOVS     R1,#+255
   \   00000064   0x4630             MOV      R0,R6
   \   00000066   0x.... 0x....      BL       assert_failed
    256            assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
   \                     ??USART_Init_2: (+1)
   \   0000006A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD007             BEQ.N    ??USART_Init_3
   \   00000070   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000074   0xD004             BEQ.N    ??USART_Init_3
   \   00000076   0xF44F 0x7180      MOV      R1,#+256
   \   0000007A   0x4630             MOV      R0,R6
   \   0000007C   0x.... 0x....      BL       assert_failed
    257            assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
   \                     ??USART_Init_3: (+1)
   \   00000080   0x88E8             LDRH     R0,[R5, #+6]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD00D             BEQ.N    ??USART_Init_4
   \   00000086   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000008A   0xD00A             BEQ.N    ??USART_Init_4
   \   0000008C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000090   0xD007             BEQ.N    ??USART_Init_4
   \   00000092   0xF5B0 0x5F40      CMP      R0,#+12288
   \   00000096   0xD004             BEQ.N    ??USART_Init_4
   \   00000098   0xF240 0x1101      MOVW     R1,#+257
   \   0000009C   0x4630             MOV      R0,R6
   \   0000009E   0x.... 0x....      BL       assert_failed
    258            assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
   \                     ??USART_Init_4: (+1)
   \   000000A2   0x8928             LDRH     R0,[R5, #+8]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD00A             BEQ.N    ??USART_Init_5
   \   000000A8   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000AC   0xD007             BEQ.N    ??USART_Init_5
   \   000000AE   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   000000B2   0xD004             BEQ.N    ??USART_Init_5
   \   000000B4   0xF44F 0x7181      MOV      R1,#+258
   \   000000B8   0x4630             MOV      R0,R6
   \   000000BA   0x.... 0x....      BL       assert_failed
    259            assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
   \                     ??USART_Init_5: (+1)
   \   000000BE   0x8968             LDRH     R0,[R5, #+10]
   \   000000C0   0xF64F 0x71F3      MOVW     R1,#+65523
   \   000000C4   0x4208             TST      R0,R1
   \   000000C6   0xD101             BNE.N    ??USART_Init_6
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD104             BNE.N    ??USART_Init_7
   \                     ??USART_Init_6: (+1)
   \   000000CC   0xF240 0x1103      MOVW     R1,#+259
   \   000000D0   0x4630             MOV      R0,R6
   \   000000D2   0x.... 0x....      BL       assert_failed
    260            assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
   \                     ??USART_Init_7: (+1)
   \   000000D6   0x89A8             LDRH     R0,[R5, #+12]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD00D             BEQ.N    ??USART_Init_8
   \   000000DC   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000E0   0xD00A             BEQ.N    ??USART_Init_8
   \   000000E2   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000E6   0xD007             BEQ.N    ??USART_Init_8
   \   000000E8   0xF5B0 0x7F40      CMP      R0,#+768
   \   000000EC   0xD004             BEQ.N    ??USART_Init_8
   \   000000EE   0xF44F 0x7182      MOV      R1,#+260
   \   000000F2   0x4630             MOV      R0,R6
   \   000000F4   0x.... 0x....      BL       assert_failed
    261          
    262            /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
    263            if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
   \                     ??USART_Init_8: (+1)
   \   000000F8   0x89A8             LDRH     R0,[R5, #+12]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD012             BEQ.N    ??USART_Init_9
    264            {
    265              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   000000FE   0x42BC             CMP      R4,R7
   \   00000100   0xD010             BEQ.N    ??USART_Init_9
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000106   0x4284             CMP      R4,R0
   \   00000108   0xD00C             BEQ.N    ??USART_Init_9
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000010E   0x4284             CMP      R4,R0
   \   00000110   0xD008             BEQ.N    ??USART_Init_9
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000116   0x4284             CMP      R4,R0
   \   00000118   0xD004             BEQ.N    ??USART_Init_9
   \   0000011A   0xF240 0x1109      MOVW     R1,#+265
   \   0000011E   0x4630             MOV      R0,R6
   \   00000120   0x.... 0x....      BL       assert_failed
    266            }
    267          
    268          /*---------------------------- USART CR2 Configuration -----------------------*/
    269            tmpreg = USARTx->CR2;
   \                     ??USART_Init_9: (+1)
   \   00000124   0x8A20             LDRH     R0,[R4, #+16]
    270          
    271            /* Clear STOP[13:12] bits */
    272            tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
    273          
    274            /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
    275                Set STOP[13:12] bits according to USART_StopBits value */
    276            tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
    277            
    278            /* Write to USART CR2 */
    279            USARTx->CR2 = (uint16_t)tmpreg;
   \   00000126   0xF64C 0x71FF      MOVW     R1,#+53247
   \   0000012A   0x4008             ANDS     R0,R1,R0
   \   0000012C   0x88E9             LDRH     R1,[R5, #+6]
   \   0000012E   0x4308             ORRS     R0,R1,R0
   \   00000130   0x8220             STRH     R0,[R4, #+16]
    280          
    281          /*---------------------------- USART CR1 Configuration -----------------------*/
    282            tmpreg = USARTx->CR1;
   \   00000132   0x89A0             LDRH     R0,[R4, #+12]
    283          
    284            /* Clear M, PCE, PS, TE and RE bits */
    285            tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
    286          
    287            /* Configure the USART Word Length, Parity and mode: 
    288               Set the M bits according to USART_WordLength value 
    289               Set PCE and PS bits according to USART_Parity value
    290               Set TE and RE bits according to USART_Mode value */
    291            tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
    292                      USART_InitStruct->USART_Mode;
    293          
    294            /* Write to USART CR1 */
    295            USARTx->CR1 = (uint16_t)tmpreg;
   \   00000134   0xF64E 0x11F3      MOVW     R1,#+59891
   \   00000138   0x4008             ANDS     R0,R1,R0
   \   0000013A   0x88A9             LDRH     R1,[R5, #+4]
   \   0000013C   0x4308             ORRS     R0,R1,R0
   \   0000013E   0x8929             LDRH     R1,[R5, #+8]
   \   00000140   0x4308             ORRS     R0,R1,R0
   \   00000142   0x8969             LDRH     R1,[R5, #+10]
   \   00000144   0x4308             ORRS     R0,R1,R0
   \   00000146   0x81A0             STRH     R0,[R4, #+12]
    296          
    297          /*---------------------------- USART CR3 Configuration -----------------------*/  
    298            tmpreg = USARTx->CR3;
   \   00000148   0x8AA0             LDRH     R0,[R4, #+20]
    299          
    300            /* Clear CTSE and RTSE bits */
    301            tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
    302          
    303            /* Configure the USART HFC : 
    304                Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
    305            tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
    306          
    307            /* Write to USART CR3 */
    308            USARTx->CR3 = (uint16_t)tmpreg;
   \   0000014A   0xF64F 0x41FF      MOVW     R1,#+64767
   \   0000014E   0x4008             ANDS     R0,R1,R0
   \   00000150   0x89A9             LDRH     R1,[R5, #+12]
   \   00000152   0x4308             ORRS     R0,R1,R0
   \   00000154   0x82A0             STRH     R0,[R4, #+20]
    309          
    310          /*---------------------------- USART BRR Configuration -----------------------*/
    311            /* Configure the USART Baud Rate */
    312            RCC_GetClocksFreq(&RCC_ClocksStatus);
   \   00000156   0xA800             ADD      R0,SP,#+0
   \   00000158   0x.... 0x....      BL       RCC_GetClocksFreq
    313          
    314            if ((USARTx == USART1) || (USARTx == USART6))
   \   0000015C   0x42BC             CMP      R4,R7
   \   0000015E   0xD003             BEQ.N    ??USART_Init_10
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000164   0x4284             CMP      R4,R0
   \   00000166   0xD101             BNE.N    ??USART_Init_11
    315            {
    316              apbclock = RCC_ClocksStatus.PCLK2_Frequency;
   \                     ??USART_Init_10: (+1)
   \   00000168   0x9803             LDR      R0,[SP, #+12]
   \   0000016A   0xE000             B.N      ??USART_Init_12
    317            }
    318            else
    319            {
    320              apbclock = RCC_ClocksStatus.PCLK1_Frequency;
   \                     ??USART_Init_11: (+1)
   \   0000016C   0x9802             LDR      R0,[SP, #+8]
    321            }
    322            
    323            /* Determine the integer part */
    324            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \                     ??USART_Init_12: (+1)
   \   0000016E   0x6829             LDR      R1,[R5, #+0]
   \   00000170   0x2219             MOVS     R2,#+25
   \   00000172   0x4350             MULS     R0,R2,R0
   \   00000174   0x89A2             LDRH     R2,[R4, #+12]
   \   00000176   0x0412             LSLS     R2,R2,#+16
   \   00000178   0xD503             BPL.N    ??USART_Init_13
    325            {
    326              /* Integer part computing in case Oversampling mode is 8 Samples */
    327              integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
   \   0000017A   0x0049             LSLS     R1,R1,#+1
   \   0000017C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000180   0xE002             B.N      ??USART_Init_14
    328            }
    329            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    330            {
    331              /* Integer part computing in case Oversampling mode is 16 Samples */
    332              integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
   \                     ??USART_Init_13: (+1)
   \   00000182   0x0089             LSLS     R1,R1,#+2
   \   00000184   0xFBB0 0xF1F1      UDIV     R1,R0,R1
    333            }
    334            tmpreg = (integerdivider / 100) << 4;
   \                     ??USART_Init_14: (+1)
   \   00000188   0x2064             MOVS     R0,#+100
   \   0000018A   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \   0000018E   0x0100             LSLS     R0,R0,#+4
    335          
    336            /* Determine the fractional part */
    337            fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
   \   00000190   0x0902             LSRS     R2,R0,#+4
   \   00000192   0x2364             MOVS     R3,#+100
   \   00000194   0xFB03 0x1112      MLS      R1,R3,R2,R1
    338          
    339            /* Implement the fractional part in the register */
    340            if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
   \   00000198   0x89A2             LDRH     R2,[R4, #+12]
   \   0000019A   0x0412             LSLS     R2,R2,#+16
   \   0000019C   0xD508             BPL.N    ??USART_Init_15
    341            {
    342              tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
   \   0000019E   0x00C9             LSLS     R1,R1,#+3
   \   000001A0   0x3132             ADDS     R1,R1,#+50
   \   000001A2   0x461A             MOV      R2,R3
   \   000001A4   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001A8   0xF001 0x0107      AND      R1,R1,#0x7
   \   000001AC   0x4308             ORRS     R0,R1,R0
   \   000001AE   0xE007             B.N      ??USART_Init_16
    343            }
    344            else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
    345            {
    346              tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
   \                     ??USART_Init_15: (+1)
   \   000001B0   0x0109             LSLS     R1,R1,#+4
   \   000001B2   0x3132             ADDS     R1,R1,#+50
   \   000001B4   0x461A             MOV      R2,R3
   \   000001B6   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000001BA   0xF001 0x010F      AND      R1,R1,#0xF
   \   000001BE   0x4308             ORRS     R0,R1,R0
    347            }
    348            
    349            /* Write to USART BRR register */
    350            USARTx->BRR = (uint16_t)tmpreg;
   \                     ??USART_Init_16: (+1)
   \   000001C0   0x8120             STRH     R0,[R4, #+8]
    351          }
   \   000001C2   0xB005             ADD      SP,SP,#+20
   \   000001C4   0xBDF0             POP      {R4-R7,PC}       ;; return
    352          
    353          /**
    354            * @brief  Fills each USART_InitStruct member with its default value.
    355            * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure which will
    356            *         be initialized.
    357            * @retval None
    358            */

   \                                 In section .text, align 2, keep-with-next
    359          void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
    360          {
    361            /* USART_InitStruct members default value */
    362            USART_InitStruct->USART_BaudRate = 9600;
   \                     USART_StructInit: (+1)
   \   00000000   0xF44F 0x5116      MOV      R1,#+9600
   \   00000004   0x6001             STR      R1,[R0, #+0]
    363            USART_InitStruct->USART_WordLength = USART_WordLength_8b;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    364            USART_InitStruct->USART_StopBits = USART_StopBits_1;
   \   0000000A   0x80C1             STRH     R1,[R0, #+6]
    365            USART_InitStruct->USART_Parity = USART_Parity_No ;
   \   0000000C   0x8101             STRH     R1,[R0, #+8]
    366            USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   0000000E   0x210C             MOVS     R1,#+12
   \   00000010   0x8141             STRH     R1,[R0, #+10]
    367            USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x8181             STRH     R1,[R0, #+12]
    368          }
   \   00000016   0x4770             BX       LR               ;; return
    369          
    370          /**
    371            * @brief  Initializes the USARTx peripheral Clock according to the 
    372            *         specified parameters in the USART_ClockInitStruct .
    373            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    374            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    375            *         contains the configuration information for the specified  USART peripheral.
    376            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    377            * @retval None
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
    380          {
   \                     USART_ClockInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    381            uint32_t tmpreg = 0x00;
    382            /* Check the parameters */
    383            assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD011             BEQ.N    ??USART_ClockInit_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??USART_ClockInit_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??USART_ClockInit_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??USART_ClockInit_0
   \   00000026   0xF240 0x117F      MOVW     R1,#+383
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000002E   0x.... 0x....      BL       assert_failed
    384            assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
   \                     ??USART_ClockInit_0: (+1)
   \   00000032   0x8828             LDRH     R0,[R5, #+0]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??USART_ClockInit_1
   \   00000038   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000003C   0xD005             BEQ.N    ??USART_ClockInit_1
   \   0000003E   0xF44F 0x71C0      MOV      R1,#+384
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000046   0x.... 0x....      BL       assert_failed
    385            assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
   \                     ??USART_ClockInit_1: (+1)
   \   0000004A   0x8868             LDRH     R0,[R5, #+2]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD008             BEQ.N    ??USART_ClockInit_2
   \   00000050   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000054   0xD005             BEQ.N    ??USART_ClockInit_2
   \   00000056   0xF240 0x1181      MOVW     R1,#+385
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000005E   0x.... 0x....      BL       assert_failed
    386            assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
   \                     ??USART_ClockInit_2: (+1)
   \   00000062   0x88A8             LDRH     R0,[R5, #+4]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD008             BEQ.N    ??USART_ClockInit_3
   \   00000068   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000006C   0xD005             BEQ.N    ??USART_ClockInit_3
   \   0000006E   0xF44F 0x71C1      MOV      R1,#+386
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000076   0x.... 0x....      BL       assert_failed
    387            assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
   \                     ??USART_ClockInit_3: (+1)
   \   0000007A   0x88E8             LDRH     R0,[R5, #+6]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD008             BEQ.N    ??USART_ClockInit_4
   \   00000080   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000084   0xD005             BEQ.N    ??USART_ClockInit_4
   \   00000086   0xF240 0x1183      MOVW     R1,#+387
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000008E   0x.... 0x....      BL       assert_failed
    388            
    389          /*---------------------------- USART CR2 Configuration -----------------------*/
    390            tmpreg = USARTx->CR2;
   \                     ??USART_ClockInit_4: (+1)
   \   00000092   0x8A20             LDRH     R0,[R4, #+16]
    391            /* Clear CLKEN, CPOL, CPHA and LBCL bits */
    392            tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
    393            /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
    394            /* Set CLKEN bit according to USART_Clock value */
    395            /* Set CPOL bit according to USART_CPOL value */
    396            /* Set CPHA bit according to USART_CPHA value */
    397            /* Set LBCL bit according to USART_LastBit value */
    398            tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
    399                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
    400            /* Write to USART CR2 */
    401            USARTx->CR2 = (uint16_t)tmpreg;
   \   00000094   0xF24F 0x01FF      MOVW     R1,#+61695
   \   00000098   0x4008             ANDS     R0,R1,R0
   \   0000009A   0x8829             LDRH     R1,[R5, #+0]
   \   0000009C   0x4308             ORRS     R0,R1,R0
   \   0000009E   0x8869             LDRH     R1,[R5, #+2]
   \   000000A0   0x4308             ORRS     R0,R1,R0
   \   000000A2   0x88A9             LDRH     R1,[R5, #+4]
   \   000000A4   0x4308             ORRS     R0,R1,R0
   \   000000A6   0x88E9             LDRH     R1,[R5, #+6]
   \   000000A8   0x4308             ORRS     R0,R1,R0
   \   000000AA   0x8220             STRH     R0,[R4, #+16]
    402          }
   \   000000AC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    403          
    404          /**
    405            * @brief  Fills each USART_ClockInitStruct member with its default value.
    406            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    407            *         which will be initialized.
    408            * @retval None
    409            */

   \                                 In section .text, align 2, keep-with-next
    410          void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
    411          {
    412            /* USART_ClockInitStruct members default value */
    413            USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
   \                     USART_ClockStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    414            USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    415            USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    416            USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    417          }
   \   0000000A   0x4770             BX       LR               ;; return
    418          
    419          /**
    420            * @brief  Enables or disables the specified USART peripheral.
    421            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    422            *         UART peripheral.
    423            * @param  NewState: new state of the USARTx peripheral.
    424            *          This parameter can be: ENABLE or DISABLE.
    425            * @retval None
    426            */

   \                                 In section .text, align 2, keep-with-next
    427          void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    428          {
   \                     USART_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    429            /* Check the parameters */
    430            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD021             BEQ.N    ??USART_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??USART_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??USART_Cmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??USART_Cmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??USART_Cmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??USART_Cmd_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??USART_Cmd_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??USART_Cmd_0
   \   00000046   0xF44F 0x71D7      MOV      R1,#+430
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000004E   0x.... 0x....      BL       assert_failed
    431            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_Cmd_0: (+1)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD007             BEQ.N    ??USART_Cmd_1
   \   00000056   0x2D01             CMP      R5,#+1
   \   00000058   0xD005             BEQ.N    ??USART_Cmd_1
   \   0000005A   0xF240 0x11AF      MOVW     R1,#+431
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000062   0x.... 0x....      BL       assert_failed
    432            
    433            if (NewState != DISABLE)
   \                     ??USART_Cmd_1: (+1)
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0x89A0             LDRH     R0,[R4, #+12]
   \   0000006A   0xD003             BEQ.N    ??USART_Cmd_2
    434            {
    435              /* Enable the selected USART by setting the UE bit in the CR1 register */
    436              USARTx->CR1 |= USART_CR1_UE;
   \   0000006C   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000070   0x81A0             STRH     R0,[R4, #+12]
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}
    437            }
    438            else
    439            {
    440              /* Disable the selected USART by clearing the UE bit in the CR1 register */
    441              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
   \                     ??USART_Cmd_2: (+1)
   \   00000074   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000078   0x4008             ANDS     R0,R1,R0
   \   0000007A   0x81A0             STRH     R0,[R4, #+12]
    442            }
    443          }
   \   0000007C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    444          
    445          /**
    446            * @brief  Sets the system clock prescaler.
    447            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    448            *         UART peripheral.
    449            * @param  USART_Prescaler: specifies the prescaler clock. 
    450            * @note   The function is used for IrDA mode with UART4 and UART5.   
    451            * @retval None
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
    454          { 
   \                     USART_SetPrescaler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    455            /* Check the parameters */
    456            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD021             BEQ.N    ??USART_SetPrescaler_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??USART_SetPrescaler_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??USART_SetPrescaler_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??USART_SetPrescaler_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??USART_SetPrescaler_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??USART_SetPrescaler_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??USART_SetPrescaler_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??USART_SetPrescaler_0
   \   00000046   0xF44F 0x71E4      MOV      R1,#+456
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000004E   0x.... 0x....      BL       assert_failed
    457            
    458            /* Clear the USART prescaler */
    459            USARTx->GTPR &= USART_GTPR_GT;
   \                     ??USART_SetPrescaler_0: (+1)
   \   00000052   0x8B20             LDRH     R0,[R4, #+24]
   \   00000054   0xF400 0x407F      AND      R0,R0,#0xFF00
   \   00000058   0x8320             STRH     R0,[R4, #+24]
    460            /* Set the USART prescaler */
    461            USARTx->GTPR |= USART_Prescaler;
   \   0000005A   0x8B20             LDRH     R0,[R4, #+24]
   \   0000005C   0x4328             ORRS     R0,R5,R0
   \   0000005E   0x8320             STRH     R0,[R4, #+24]
    462          }
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    463          
    464          /**
    465            * @brief  Enables or disables the USART's 8x oversampling mode.
    466            * @note   This function has to be called before calling USART_Init() function
    467            *         in order to have correct baudrate Divider value.
    468            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    469            *         UART peripheral.
    470            * @param  NewState: new state of the USART 8x oversampling mode.
    471            *          This parameter can be: ENABLE or DISABLE.
    472            * @retval None
    473            */

   \                                 In section .text, align 2, keep-with-next
    474          void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
    475          {
   \                     USART_OverSampling8Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    476            /* Check the parameters */
    477            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD021             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??USART_OverSampling8Cmd_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??USART_OverSampling8Cmd_0
   \   00000046   0xF240 0x11DD      MOVW     R1,#+477
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000004E   0x.... 0x....      BL       assert_failed
    478            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_OverSampling8Cmd_0: (+1)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD007             BEQ.N    ??USART_OverSampling8Cmd_1
   \   00000056   0x2D01             CMP      R5,#+1
   \   00000058   0xD005             BEQ.N    ??USART_OverSampling8Cmd_1
   \   0000005A   0xF44F 0x71EF      MOV      R1,#+478
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000062   0x.... 0x....      BL       assert_failed
    479            
    480            if (NewState != DISABLE)
   \                     ??USART_OverSampling8Cmd_1: (+1)
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0x89A0             LDRH     R0,[R4, #+12]
   \   0000006A   0xD003             BEQ.N    ??USART_OverSampling8Cmd_2
    481            {
    482              /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    483              USARTx->CR1 |= USART_CR1_OVER8;
   \   0000006C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000070   0x81A0             STRH     R0,[R4, #+12]
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}
    484            }
    485            else
    486            {
    487              /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    488              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
   \                     ??USART_OverSampling8Cmd_2: (+1)
   \   00000074   0x0440             LSLS     R0,R0,#+17
   \   00000076   0x0C40             LSRS     R0,R0,#+17
   \   00000078   0x81A0             STRH     R0,[R4, #+12]
    489            }
    490          }  
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    491          
    492          /**
    493            * @brief  Enables or disables the USART's one bit sampling method.
    494            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    495            *         UART peripheral.
    496            * @param  NewState: new state of the USART one bit sampling method.
    497            *          This parameter can be: ENABLE or DISABLE.
    498            * @retval None
    499            */

   \                                 In section .text, align 2, keep-with-next
    500          void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    501          {
   \                     USART_OneBitMethodCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    502            /* Check the parameters */
    503            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD021             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??USART_OneBitMethodCmd_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??USART_OneBitMethodCmd_0
   \   00000046   0xF240 0x11F7      MOVW     R1,#+503
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   0000004E   0x.... 0x....      BL       assert_failed
    504            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_OneBitMethodCmd_0: (+1)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD007             BEQ.N    ??USART_OneBitMethodCmd_1
   \   00000056   0x2D01             CMP      R5,#+1
   \   00000058   0xD005             BEQ.N    ??USART_OneBitMethodCmd_1
   \   0000005A   0xF44F 0x71FC      MOV      R1,#+504
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000062   0x.... 0x....      BL       assert_failed
    505            
    506            if (NewState != DISABLE)
   \                     ??USART_OneBitMethodCmd_1: (+1)
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000006A   0xD003             BEQ.N    ??USART_OneBitMethodCmd_2
    507            {
    508              /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    509              USARTx->CR3 |= USART_CR3_ONEBIT;
   \   0000006C   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000070   0x82A0             STRH     R0,[R4, #+20]
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}
    510            }
    511            else
    512            {
    513              /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    514              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
   \                     ??USART_OneBitMethodCmd_2: (+1)
   \   00000074   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000078   0x4008             ANDS     R0,R1,R0
   \   0000007A   0x82A0             STRH     R0,[R4, #+20]
    515            }
    516          }
   \   0000007C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    517          
    518          /**
    519            * @}
    520            */
    521          
    522          /** @defgroup USART_Group2 Data transfers functions
    523           *  @brief   Data transfers functions 
    524           *
    525          @verbatim   
    526           ===============================================================================
    527                                ##### Data transfers functions #####
    528           ===============================================================================  
    529              [..]
    530              This subsection provides a set of functions allowing to manage the USART data 
    531              transfers.
    532              [..]
    533              During an USART reception, data shifts in least significant bit first through 
    534              the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    535              between the internal bus and the received shift register.
    536              [..]
    537              When a transmission is taking place, a write instruction to the USART_DR register 
    538              stores the data in the TDR register and which is copied in the shift register 
    539              at the end of the current transmission.
    540              [..]
    541              The read access of the USART_DR register can be done using the USART_ReceiveData()
    542              function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    543              can be done using USART_SendData() function and stores the written data into 
    544              TDR buffer.
    545          
    546          @endverbatim
    547            * @{
    548            */
    549          
    550          /**
    551            * @brief  Transmits single data through the USARTx peripheral.
    552            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    553            *         UART peripheral.
    554            * @param  Data: the data to transmit.
    555            * @retval None
    556            */

   \                                 In section .text, align 2, keep-with-next
    557          void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
    558          {
   \                     USART_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    559            /* Check the parameters */
    560            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable15  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD020             BEQ.N    ??USART_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_1  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01C             BEQ.N    ??USART_SendData_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_2  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD018             BEQ.N    ??USART_SendData_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_3  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD014             BEQ.N    ??USART_SendData_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15_4  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD010             BEQ.N    ??USART_SendData_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00C             BEQ.N    ??USART_SendData_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable15_6  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD008             BEQ.N    ??USART_SendData_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD004             BEQ.N    ??USART_SendData_0
   \   00000046   0xF44F 0x710C      MOV      R1,#+560
   \   0000004A   0x....             LDR.N    R0,??DataTable15_7
   \   0000004C   0x.... 0x....      BL       assert_failed
    561            assert_param(IS_USART_DATA(Data)); 
   \                     ??USART_SendData_0: (+1)
   \   00000050   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000054   0xDB04             BLT.N    ??USART_SendData_1
   \   00000056   0xF240 0x2131      MOVW     R1,#+561
   \   0000005A   0x....             LDR.N    R0,??DataTable15_7
   \   0000005C   0x.... 0x....      BL       assert_failed
    562              
    563            /* Transmit Data */
    564            USARTx->DR = (Data & (uint16_t)0x01FF);
   \                     ??USART_SendData_1: (+1)
   \   00000060   0x05E8             LSLS     R0,R5,#+23
   \   00000062   0x0DC0             LSRS     R0,R0,#+23
   \   00000064   0x80A0             STRH     R0,[R4, #+4]
    565          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    566          
    567          /**
    568            * @brief  Returns the most recent received data by the USARTx peripheral.
    569            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    570            *         UART peripheral.
    571            * @retval The received data.
    572            */

   \                                 In section .text, align 2, keep-with-next
    573          uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
    574          {
   \                     USART_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    575            /* Check the parameters */
    576            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x....             LDR.N    R0,??DataTable15  ;; 0x40011000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD01A             BEQ.N    ??USART_ReceiveData_0
   \   0000000A   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40004400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD017             BEQ.N    ??USART_ReceiveData_0
   \   00000010   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40004800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD014             BEQ.N    ??USART_ReceiveData_0
   \   00000016   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40004c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD011             BEQ.N    ??USART_ReceiveData_0
   \   0000001C   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40005000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00E             BEQ.N    ??USART_ReceiveData_0
   \   00000022   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40011400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00B             BEQ.N    ??USART_ReceiveData_0
   \   00000028   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40007800
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD008             BEQ.N    ??USART_ReceiveData_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD004             BEQ.N    ??USART_ReceiveData_0
   \   00000036   0xF44F 0x7110      MOV      R1,#+576
   \   0000003A   0x....             LDR.N    R0,??DataTable15_7
   \   0000003C   0x.... 0x....      BL       assert_failed
    577            
    578            /* Receive Data */
    579            return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
   \                     ??USART_ReceiveData_0: (+1)
   \   00000040   0x88A0             LDRH     R0,[R4, #+4]
   \   00000042   0x05C0             LSLS     R0,R0,#+23
   \   00000044   0x0DC0             LSRS     R0,R0,#+23
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    580          }
    581          
    582          /**
    583            * @}
    584            */
    585          
    586          /** @defgroup USART_Group3 MultiProcessor Communication functions
    587           *  @brief   Multi-Processor Communication functions 
    588           *
    589          @verbatim   
    590           ===============================================================================
    591                        ##### Multi-Processor Communication functions #####
    592           ===============================================================================  
    593              [..]
    594              This subsection provides a set of functions allowing to manage the USART 
    595              multiprocessor communication.
    596              [..]
    597              For instance one of the USARTs can be the master, its TX output is connected 
    598              to the RX input of the other USART. The others are slaves, their respective 
    599              TX outputs are logically ANDed together and connected to the RX input of the 
    600              master.
    601              [..]
    602              USART multiprocessor communication is possible through the following procedure:
    603                (#) Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode 
    604                    transmitter or Mode receiver and hardware flow control values using 
    605                    the USART_Init() function.
    606                (#) Configures the USART address using the USART_SetAddress() function.
    607                (#) Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    608                    using USART_WakeUpConfig() function only for the slaves.
    609                (#) Enable the USART using the USART_Cmd() function.
    610                (#) Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    611              [..]
    612              The USART Slave exit from mute mode when receive the wake up condition.
    613          
    614          @endverbatim
    615            * @{
    616            */
    617          
    618          /**
    619            * @brief  Sets the address of the USART node.
    620            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    621            *         UART peripheral.
    622            * @param  USART_Address: Indicates the address of the USART node.
    623            * @retval None
    624            */

   \                                 In section .text, align 2, keep-with-next
    625          void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
    626          {
   \                     USART_SetAddress: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    627            /* Check the parameters */
    628            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable15  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD01A             BEQ.N    ??USART_SetAddress_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD017             BEQ.N    ??USART_SetAddress_0
   \   00000012   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??USART_SetAddress_0
   \   00000018   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_SetAddress_0
   \   0000001E   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00E             BEQ.N    ??USART_SetAddress_0
   \   00000024   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00B             BEQ.N    ??USART_SetAddress_0
   \   0000002A   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40007800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??USART_SetAddress_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40007c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD004             BEQ.N    ??USART_SetAddress_0
   \   00000038   0xF44F 0x711D      MOV      R1,#+628
   \   0000003C   0x....             LDR.N    R0,??DataTable15_7
   \   0000003E   0x.... 0x....      BL       assert_failed
    629            assert_param(IS_USART_ADDRESS(USART_Address)); 
   \                     ??USART_SetAddress_0: (+1)
   \   00000042   0x2D10             CMP      R5,#+16
   \   00000044   0xDB04             BLT.N    ??USART_SetAddress_1
   \   00000046   0xF240 0x2175      MOVW     R1,#+629
   \   0000004A   0x....             LDR.N    R0,??DataTable15_7
   \   0000004C   0x.... 0x....      BL       assert_failed
    630              
    631            /* Clear the USART address */
    632            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
   \                     ??USART_SetAddress_1: (+1)
   \   00000050   0x8A20             LDRH     R0,[R4, #+16]
   \   00000052   0xF64F 0x71F0      MOVW     R1,#+65520
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x8220             STRH     R0,[R4, #+16]
    633            /* Set the USART address node */
    634            USARTx->CR2 |= USART_Address;
   \   0000005A   0x8A20             LDRH     R0,[R4, #+16]
   \   0000005C   0x4328             ORRS     R0,R5,R0
   \   0000005E   0x8220             STRH     R0,[R4, #+16]
    635          }
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    636          
    637          /**
    638            * @brief  Determines if the USART is in mute mode or not.
    639            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    640            *         UART peripheral.
    641            * @param  NewState: new state of the USART mute mode.
    642            *          This parameter can be: ENABLE or DISABLE.
    643            * @retval None
    644            */

   \                                 In section .text, align 2, keep-with-next
    645          void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    646          {
   \                     USART_ReceiverWakeUpCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    647            /* Check the parameters */
    648            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable15  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD019             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD016             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD013             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD010             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000001E   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00D             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000024   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00A             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   0000002A   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40007800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD007             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000030   0x....             LDR.N    R0,??DataTable18  ;; 0x40007c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD004             BEQ.N    ??USART_ReceiverWakeUpCmd_0
   \   00000036   0xF44F 0x7122      MOV      R1,#+648
   \   0000003A   0x....             LDR.N    R0,??DataTable15_7
   \   0000003C   0x.... 0x....      BL       assert_failed
    649            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   \                     ??USART_ReceiverWakeUpCmd_0: (+1)
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD007             BEQ.N    ??USART_ReceiverWakeUpCmd_1
   \   00000044   0x2D01             CMP      R5,#+1
   \   00000046   0xD005             BEQ.N    ??USART_ReceiverWakeUpCmd_1
   \   00000048   0xF240 0x2189      MOVW     R1,#+649
   \   0000004C   0x.... 0x....      ADR.W    R0,?_0
   \   00000050   0x.... 0x....      BL       assert_failed
    650            
    651            if (NewState != DISABLE)
   \                     ??USART_ReceiverWakeUpCmd_1: (+1)
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0x89A0             LDRH     R0,[R4, #+12]
   \   00000058   0xD003             BEQ.N    ??USART_ReceiverWakeUpCmd_2
    652            {
    653              /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    654              USARTx->CR1 |= USART_CR1_RWU;
   \   0000005A   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000005E   0x81A0             STRH     R0,[R4, #+12]
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}
    655            }
    656            else
    657            {
    658              /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    659              USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
   \                     ??USART_ReceiverWakeUpCmd_2: (+1)
   \   00000062   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000066   0x4008             ANDS     R0,R1,R0
   \   00000068   0x81A0             STRH     R0,[R4, #+12]
    660            }
    661          }
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    662          /**
    663            * @brief  Selects the USART WakeUp method.
    664            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    665            *         UART peripheral.
    666            * @param  USART_WakeUp: specifies the USART wakeup method.
    667            *          This parameter can be one of the following values:
    668            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    669            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    670            * @retval None
    671            */

   \                                 In section .text, align 2, keep-with-next
    672          void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
    673          {
   \                     USART_WakeUpConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    674            /* Check the parameters */
    675            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable15  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD01B             BEQ.N    ??USART_WakeUpConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD018             BEQ.N    ??USART_WakeUpConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD015             BEQ.N    ??USART_WakeUpConfig_0
   \   00000018   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD012             BEQ.N    ??USART_WakeUpConfig_0
   \   0000001E   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00F             BEQ.N    ??USART_WakeUpConfig_0
   \   00000024   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00C             BEQ.N    ??USART_WakeUpConfig_0
   \   0000002A   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40007800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD009             BEQ.N    ??USART_WakeUpConfig_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD005             BEQ.N    ??USART_WakeUpConfig_0
   \   00000038   0xF240 0x21A3      MOVW     R1,#+675
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    676            assert_param(IS_USART_WAKEUP(USART_WakeUp));
   \                     ??USART_WakeUpConfig_0: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD008             BEQ.N    ??USART_WakeUpConfig_1
   \   00000048   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004C   0xD005             BEQ.N    ??USART_WakeUpConfig_1
   \   0000004E   0xF44F 0x7129      MOV      R1,#+676
   \   00000052   0x.... 0x....      ADR.W    R0,?_0
   \   00000056   0x.... 0x....      BL       assert_failed
    677            
    678            USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
   \                     ??USART_WakeUpConfig_1: (+1)
   \   0000005A   0x89A0             LDRH     R0,[R4, #+12]
   \   0000005C   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x81A0             STRH     R0,[R4, #+12]
    679            USARTx->CR1 |= USART_WakeUp;
   \   00000064   0x89A0             LDRH     R0,[R4, #+12]
   \   00000066   0x4328             ORRS     R0,R5,R0
   \   00000068   0x81A0             STRH     R0,[R4, #+12]
    680          }
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    681          
    682          /**
    683            * @}
    684            */
    685          
    686          /** @defgroup USART_Group4 LIN mode functions
    687           *  @brief   LIN mode functions 
    688           *
    689          @verbatim   
    690           ===============================================================================
    691                                  ##### LIN mode functions #####
    692           ===============================================================================  
    693              [..]
    694              This subsection provides a set of functions allowing to manage the USART LIN 
    695              Mode communication.
    696              [..]
    697              In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    698              the LIN standard.
    699              [..]
    700              Only this LIN Feature is supported by the USART IP:
    701                (+) LIN Master Synchronous Break send capability and LIN slave break detection
    702                    capability :  13-bit break generation and 10/11 bit break detection
    703          
    704              [..]
    705              USART LIN Master transmitter communication is possible through the following 
    706              procedure:
    707                (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    708                  Mode transmitter or Mode receiver and hardware flow control values using 
    709                  the USART_Init() function.
    710                (#) Enable the USART using the USART_Cmd() function.
    711                (#) Enable the LIN mode using the USART_LINCmd() function.
    712                (#) Send the break character using USART_SendBreak() function.
    713              [..]
    714              USART LIN Master receiver communication is possible through the following procedure:
    715                (#) Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    716                    Mode transmitter or Mode receiver and hardware flow control values using 
    717                    the USART_Init() function.
    718                (#) Enable the USART using the USART_Cmd() function.
    719                (#) Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    720                    function.
    721                (#) Enable the LIN mode using the USART_LINCmd() function.
    722          
    723                -@- In LIN mode, the following bits must be kept cleared:
    724                 (+@) CLKEN in the USART_CR2 register,
    725                 (+@) STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    726          
    727          @endverbatim
    728            * @{
    729            */
    730          
    731          /**
    732            * @brief  Sets the USART LIN Break detection length.
    733            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    734            *         UART peripheral.
    735            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    736            *          This parameter can be one of the following values:
    737            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    738            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    739            * @retval None
    740            */

   \                                 In section .text, align 2, keep-with-next
    741          void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
    742          {
   \                     USART_LINBreakDetectLengthConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    743            /* Check the parameters */
    744            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable15  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD01B             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD018             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD015             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000018   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD012             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000001E   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00F             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000024   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00C             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   0000002A   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40007800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD009             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD005             BEQ.N    ??USART_LINBreakDetectLengthConfig_0
   \   00000038   0xF44F 0x713A      MOV      R1,#+744
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    745            assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
   \                     ??USART_LINBreakDetectLengthConfig_0: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD007             BEQ.N    ??USART_LINBreakDetectLengthConfig_1
   \   00000048   0x2D20             CMP      R5,#+32
   \   0000004A   0xD005             BEQ.N    ??USART_LINBreakDetectLengthConfig_1
   \   0000004C   0xF240 0x21E9      MOVW     R1,#+745
   \   00000050   0x.... 0x....      ADR.W    R0,?_0
   \   00000054   0x.... 0x....      BL       assert_failed
    746            
    747            USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
   \                     ??USART_LINBreakDetectLengthConfig_1: (+1)
   \   00000058   0x8A20             LDRH     R0,[R4, #+16]
   \   0000005A   0xF64F 0x71DF      MOVW     R1,#+65503
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x8220             STRH     R0,[R4, #+16]
    748            USARTx->CR2 |= USART_LINBreakDetectLength;  
   \   00000062   0x8A20             LDRH     R0,[R4, #+16]
   \   00000064   0x4328             ORRS     R0,R5,R0
   \   00000066   0x8220             STRH     R0,[R4, #+16]
    749          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    750          
    751          /**
    752            * @brief  Enables or disables the USART's LIN mode.
    753            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    754            *         UART peripheral.
    755            * @param  NewState: new state of the USART LIN mode.
    756            *          This parameter can be: ENABLE or DISABLE.
    757            * @retval None
    758            */

   \                                 In section .text, align 2, keep-with-next
    759          void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    760          {
   \                     USART_LINCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    761            /* Check the parameters */
    762            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable15  ;; 0x40011000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD01B             BEQ.N    ??USART_LINCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD018             BEQ.N    ??USART_LINCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD015             BEQ.N    ??USART_LINCmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD012             BEQ.N    ??USART_LINCmd_0
   \   0000001E   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00F             BEQ.N    ??USART_LINCmd_0
   \   00000024   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00C             BEQ.N    ??USART_LINCmd_0
   \   0000002A   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40007800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD009             BEQ.N    ??USART_LINCmd_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD005             BEQ.N    ??USART_LINCmd_0
   \   00000038   0xF240 0x21FA      MOVW     R1,#+762
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    763            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_LINCmd_0: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD007             BEQ.N    ??USART_LINCmd_1
   \   00000048   0x2D01             CMP      R5,#+1
   \   0000004A   0xD005             BEQ.N    ??USART_LINCmd_1
   \   0000004C   0xF240 0x21FB      MOVW     R1,#+763
   \   00000050   0x.... 0x....      ADR.W    R0,?_0
   \   00000054   0x.... 0x....      BL       assert_failed
    764            
    765            if (NewState != DISABLE)
   \                     ??USART_LINCmd_1: (+1)
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0x8A20             LDRH     R0,[R4, #+16]
   \   0000005C   0xD003             BEQ.N    ??USART_LINCmd_2
    766            {
    767              /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    768              USARTx->CR2 |= USART_CR2_LINEN;
   \   0000005E   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000062   0x8220             STRH     R0,[R4, #+16]
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}
    769            }
    770            else
    771            {
    772              /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    773              USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
   \                     ??USART_LINCmd_2: (+1)
   \   00000066   0xF64B 0x71FF      MOVW     R1,#+49151
   \   0000006A   0x4008             ANDS     R0,R1,R0
   \   0000006C   0x8220             STRH     R0,[R4, #+16]
    774            }
    775          }
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    776          
    777          /**
    778            * @brief  Transmits break characters.
    779            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    780            *         UART peripheral.
    781            * @retval None
    782            */

   \                                 In section .text, align 2, keep-with-next
    783          void USART_SendBreak(USART_TypeDef* USARTx)
    784          {
   \                     USART_SendBreak: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    785            /* Check the parameters */
    786            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000004   0x....             LDR.N    R0,??DataTable15  ;; 0x40011000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD01B             BEQ.N    ??USART_SendBreak_0
   \   0000000A   0x....             LDR.N    R0,??DataTable15_1  ;; 0x40004400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD018             BEQ.N    ??USART_SendBreak_0
   \   00000010   0x....             LDR.N    R0,??DataTable15_2  ;; 0x40004800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??USART_SendBreak_0
   \   00000016   0x....             LDR.N    R0,??DataTable15_3  ;; 0x40004c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD012             BEQ.N    ??USART_SendBreak_0
   \   0000001C   0x....             LDR.N    R0,??DataTable15_4  ;; 0x40005000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD00F             BEQ.N    ??USART_SendBreak_0
   \   00000022   0x....             LDR.N    R0,??DataTable15_5  ;; 0x40011400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00C             BEQ.N    ??USART_SendBreak_0
   \   00000028   0x....             LDR.N    R0,??DataTable15_6  ;; 0x40007800
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??USART_SendBreak_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_SendBreak_0
   \   00000036   0xF240 0x3112      MOVW     R1,#+786
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
    787            
    788            /* Send break characters */
    789            USARTx->CR1 |= USART_CR1_SBK;
   \                     ??USART_SendBreak_0: (+1)
   \   00000042   0x89A0             LDRH     R0,[R4, #+12]
   \   00000044   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000048   0x81A0             STRH     R0,[R4, #+12]
    790          }
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    791          
    792          /**
    793            * @}
    794            */
    795          
    796          /** @defgroup USART_Group5 Halfduplex mode function
    797           *  @brief   Half-duplex mode function 
    798           *
    799          @verbatim   
    800           ===============================================================================
    801                              ##### Half-duplex mode function #####
    802           ===============================================================================  
    803              [..]
    804              This subsection provides a set of functions allowing to manage the USART 
    805              Half-duplex communication.
    806              [..]
    807              The USART can be configured to follow a single-wire half-duplex protocol where 
    808              the TX and RX lines are internally connected.
    809              [..]
    810              USART Half duplex communication is possible through the following procedure:
    811                (#) Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    812                    or Mode receiver and hardware flow control values using the USART_Init()
    813                    function.
    814                (#) Configures the USART address using the USART_SetAddress() function.
    815                (#) Enable the USART using the USART_Cmd() function.
    816                (#) Enable the half duplex mode using USART_HalfDuplexCmd() function.
    817          
    818          
    819              -@- The RX pin is no longer used
    820              -@- In Half-duplex mode the following bits must be kept cleared:
    821                (+@) LINEN and CLKEN bits in the USART_CR2 register.
    822                (+@) SCEN and IREN bits in the USART_CR3 register.
    823          
    824          @endverbatim
    825            * @{
    826            */
    827          
    828          /**
    829            * @brief  Enables or disables the USART's Half Duplex communication.
    830            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
    831            *         UART peripheral.
    832            * @param  NewState: new state of the USART Communication.
    833            *          This parameter can be: ENABLE or DISABLE.
    834            * @retval None
    835            */

   \                                 In section .text, align 2, keep-with-next
    836          void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    837          {
   \                     USART_HalfDuplexCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    838            /* Check the parameters */
    839            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD021             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_4  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable27_5  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable27_7  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??USART_HalfDuplexCmd_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??USART_HalfDuplexCmd_0
   \   00000046   0xF240 0x3147      MOVW     R1,#+839
   \   0000004A   0x.... 0x....      ADR.W    R0,?_0
   \   0000004E   0x.... 0x....      BL       assert_failed
    840            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_HalfDuplexCmd_0: (+1)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD007             BEQ.N    ??USART_HalfDuplexCmd_1
   \   00000056   0x2D01             CMP      R5,#+1
   \   00000058   0xD005             BEQ.N    ??USART_HalfDuplexCmd_1
   \   0000005A   0xF44F 0x7152      MOV      R1,#+840
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
    841            
    842            if (NewState != DISABLE)
   \                     ??USART_HalfDuplexCmd_1: (+1)
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000006A   0xD003             BEQ.N    ??USART_HalfDuplexCmd_2
    843            {
    844              /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    845              USARTx->CR3 |= USART_CR3_HDSEL;
   \   0000006C   0xF040 0x0008      ORR      R0,R0,#0x8
   \   00000070   0x82A0             STRH     R0,[R4, #+20]
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}
    846            }
    847            else
    848            {
    849              /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    850              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
   \                     ??USART_HalfDuplexCmd_2: (+1)
   \   00000074   0xF64F 0x71F7      MOVW     R1,#+65527
   \   00000078   0x4008             ANDS     R0,R1,R0
   \   0000007A   0x82A0             STRH     R0,[R4, #+20]
    851            }
    852          }
   \   0000007C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    853          
    854          /**
    855            * @}
    856            */
    857          
    858          
    859          /** @defgroup USART_Group6 Smartcard mode functions
    860           *  @brief   Smartcard mode functions 
    861           *
    862          @verbatim   
    863           ===============================================================================
    864                                        ##### Smartcard mode functions #####
    865           ===============================================================================  
    866              [..]
    867              This subsection provides a set of functions allowing to manage the USART 
    868              Smartcard communication.
    869              [..]
    870              The Smartcard interface is designed to support asynchronous protocol Smartcards as
    871              defined in the ISO 7816-3 standard.
    872              [..]
    873              The USART can provide a clock to the smartcard through the SCLK output.
    874              In smartcard mode, SCLK is not associated to the communication but is simply derived 
    875              from the internal peripheral input clock through a 5-bit prescaler.
    876              [..]
    877              Smartcard communication is possible through the following procedure:
    878                (#) Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    879                (#) Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    880                (#) Program the USART clock using the USART_ClockInit() function as following:
    881                  (++) USART Clock enabled
    882                  (++) USART CPOL Low
    883                  (++) USART CPHA on first edge
    884                  (++) USART Last Bit Clock Enabled
    885                (#) Program the Smartcard interface using the USART_Init() function as following:
    886                  (++) Word Length = 9 Bits
    887                  (++) 1.5 Stop Bit
    888                  (++) Even parity
    889                  (++) BaudRate = 12096 baud
    890                  (++) Hardware flow control disabled (RTS and CTS signals)
    891                  (++) Tx and Rx enabled
    892                (#) POptionally you can enable the parity error interrupt using the USART_ITConfig()
    893                    function
    894                (#) PEnable the USART using the USART_Cmd() function.
    895                (#) PEnable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    896                (#) PEnable the Smartcard interface using the USART_SmartCardCmd() function.
    897          
    898              Please refer to the ISO 7816-3 specification for more details.
    899          
    900                -@- It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    901                    to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    902                    between the two configurations.
    903                -@- In smartcard mode, the following bits must be kept cleared:
    904                  (+@) LINEN bit in the USART_CR2 register.
    905                  (+@) HDSEL and IREN bits in the USART_CR3 register.
    906                -@- Smartcard mode is available on USART peripherals only (not available on UART4 
    907                    and UART5 peripherals).
    908          
    909          @endverbatim
    910            * @{
    911            */
    912          
    913          /**
    914            * @brief  Sets the specified USART guard time.
    915            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    916            *         UART peripheral.
    917            * @param  USART_GuardTime: specifies the guard time.   
    918            * @retval None
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
    921          {    
   \                     USART_SetGuardTime: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    922            /* Check the parameters */
    923            assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD011             BEQ.N    ??USART_SetGuardTime_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??USART_SetGuardTime_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??USART_SetGuardTime_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??USART_SetGuardTime_0
   \   00000026   0xF240 0x319B      MOVW     R1,#+923
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
    924            
    925            /* Clear the USART Guard time */
    926            USARTx->GTPR &= USART_GTPR_PSC;
   \                     ??USART_SetGuardTime_0: (+1)
   \   00000032   0x8B20             LDRH     R0,[R4, #+24]
   \   00000034   0xB2C0             UXTB     R0,R0
   \   00000036   0x8320             STRH     R0,[R4, #+24]
    927            /* Set the USART guard time */
    928            USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
   \   00000038   0x8B20             LDRH     R0,[R4, #+24]
   \   0000003A   0xEA40 0x2005      ORR      R0,R0,R5, LSL #+8
   \   0000003E   0x8320             STRH     R0,[R4, #+24]
    929          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    930          
    931          /**
    932            * @brief  Enables or disables the USART's Smart Card mode.
    933            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    934            *         UART peripheral.
    935            * @param  NewState: new state of the Smart Card mode.
    936            *          This parameter can be: ENABLE or DISABLE.      
    937            * @retval None
    938            */

   \                                 In section .text, align 2, keep-with-next
    939          void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    940          {
   \                     USART_SmartCardCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    941            /* Check the parameters */
    942            assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD011             BEQ.N    ??USART_SmartCardCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??USART_SmartCardCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??USART_SmartCardCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??USART_SmartCardCmd_0
   \   00000026   0xF240 0x31AE      MOVW     R1,#+942
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
    943            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_SmartCardCmd_0: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD007             BEQ.N    ??USART_SmartCardCmd_1
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD005             BEQ.N    ??USART_SmartCardCmd_1
   \   0000003A   0xF240 0x31AF      MOVW     R1,#+943
   \   0000003E   0x.... 0x....      ADR.W    R0,?_0
   \   00000042   0x.... 0x....      BL       assert_failed
    944            if (NewState != DISABLE)
   \                     ??USART_SmartCardCmd_1: (+1)
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004A   0xD003             BEQ.N    ??USART_SmartCardCmd_2
    945            {
    946              /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    947              USARTx->CR3 |= USART_CR3_SCEN;
   \   0000004C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000050   0x82A0             STRH     R0,[R4, #+20]
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}
    948            }
    949            else
    950            {
    951              /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    952              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
   \                     ??USART_SmartCardCmd_2: (+1)
   \   00000054   0xF64F 0x71DF      MOVW     R1,#+65503
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x82A0             STRH     R0,[R4, #+20]
    953            }
    954          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    955          
    956          /**
    957            * @brief  Enables or disables NACK transmission.
    958            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    959            *         UART peripheral.
    960            * @param  NewState: new state of the NACK transmission.
    961            *          This parameter can be: ENABLE or DISABLE.  
    962            * @retval None
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
    965          {
   \                     USART_SmartCardNACKCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    966            /* Check the parameters */
    967            assert_param(IS_USART_1236_PERIPH(USARTx)); 
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD011             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??USART_SmartCardNACKCmd_0
   \   00000026   0xF240 0x31C7      MOVW     R1,#+967
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
    968            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_SmartCardNACKCmd_0: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD007             BEQ.N    ??USART_SmartCardNACKCmd_1
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD005             BEQ.N    ??USART_SmartCardNACKCmd_1
   \   0000003A   0xF44F 0x7172      MOV      R1,#+968
   \   0000003E   0x.... 0x....      ADR.W    R0,?_0
   \   00000042   0x.... 0x....      BL       assert_failed
    969            if (NewState != DISABLE)
   \                     ??USART_SmartCardNACKCmd_1: (+1)
   \   00000046   0x2D00             CMP      R5,#+0
   \   00000048   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000004A   0xD003             BEQ.N    ??USART_SmartCardNACKCmd_2
    970            {
    971              /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    972              USARTx->CR3 |= USART_CR3_NACK;
   \   0000004C   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000050   0x82A0             STRH     R0,[R4, #+20]
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}
    973            }
    974            else
    975            {
    976              /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    977              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
   \                     ??USART_SmartCardNACKCmd_2: (+1)
   \   00000054   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x82A0             STRH     R0,[R4, #+20]
    978            }
    979          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    980          
    981          /**
    982            * @}
    983            */
    984          
    985          /** @defgroup USART_Group7 IrDA mode functions
    986           *  @brief   IrDA mode functions 
    987           *
    988          @verbatim   
    989           ===============================================================================
    990                                  ##### IrDA mode functions #####
    991           ===============================================================================  
    992              [..]
    993              This subsection provides a set of functions allowing to manage the USART 
    994              IrDA communication.
    995              [..]
    996              IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    997              on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    998              is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    999              While receiving data, transmission should be avoided as the data to be transmitted
   1000              could be corrupted.
   1001              [..]
   1002              IrDA communication is possible through the following procedure:
   1003                (#) Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
   1004                    modes and hardware flow control values using the USART_Init() function.
   1005                (#) Enable the USART using the USART_Cmd() function.
   1006                (#) Configures the IrDA pulse width by configuring the prescaler using  
   1007                    the USART_SetPrescaler() function.
   1008                (#) Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
   1009                    using the USART_IrDAConfig() function.
   1010                (#) Enable the IrDA using the USART_IrDACmd() function.
   1011          
   1012                -@- A pulse of width less than two and greater than one PSC period(s) may or may
   1013                    not be rejected.
   1014                -@- The receiver set up time should be managed by software. The IrDA physical layer
   1015                    specification specifies a minimum of 10 ms delay between transmission and 
   1016                    reception (IrDA is a half duplex protocol).
   1017                -@- In IrDA mode, the following bits must be kept cleared:
   1018                  (+@) LINEN, STOP and CLKEN bits in the USART_CR2 register.
   1019                  (+@) SCEN and HDSEL bits in the USART_CR3 register.
   1020          
   1021          @endverbatim
   1022            * @{
   1023            */
   1024          
   1025          /**
   1026            * @brief  Configures the USART's IrDA interface.
   1027            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1028            *         UART peripheral.
   1029            * @param  USART_IrDAMode: specifies the IrDA mode.
   1030            *          This parameter can be one of the following values:
   1031            *            @arg USART_IrDAMode_LowPower
   1032            *            @arg USART_IrDAMode_Normal
   1033            * @retval None
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
   1036          {
   \                     USART_IrDAConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1037            /* Check the parameters */
   1038            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD021             BEQ.N    ??USART_IrDAConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??USART_IrDAConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??USART_IrDAConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_4  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??USART_IrDAConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable27_5  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??USART_IrDAConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??USART_IrDAConfig_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable27_7  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??USART_IrDAConfig_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??USART_IrDAConfig_0
   \   00000046   0xF240 0x410E      MOVW     R1,#+1038
   \   0000004A   0x.... 0x....      ADR.W    R0,?_0
   \   0000004E   0x.... 0x....      BL       assert_failed
   1039            assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
   \                     ??USART_IrDAConfig_0: (+1)
   \   00000052   0x2D04             CMP      R5,#+4
   \   00000054   0xD007             BEQ.N    ??USART_IrDAConfig_1
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD005             BEQ.N    ??USART_IrDAConfig_1
   \   0000005A   0xF240 0x410F      MOVW     R1,#+1039
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
   1040              
   1041            USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
   \                     ??USART_IrDAConfig_1: (+1)
   \   00000066   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000068   0xF64F 0x71FB      MOVW     R1,#+65531
   \   0000006C   0x4008             ANDS     R0,R1,R0
   \   0000006E   0x82A0             STRH     R0,[R4, #+20]
   1042            USARTx->CR3 |= USART_IrDAMode;
   \   00000070   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000072   0x4328             ORRS     R0,R5,R0
   \   00000074   0x82A0             STRH     R0,[R4, #+20]
   1043          }
   \   00000076   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1044          
   1045          /**
   1046            * @brief  Enables or disables the USART's IrDA interface.
   1047            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1048            *         UART peripheral.
   1049            * @param  NewState: new state of the IrDA mode.
   1050            *          This parameter can be: ENABLE or DISABLE.
   1051            * @retval None
   1052            */

   \                                 In section .text, align 2, keep-with-next
   1053          void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
   1054          {
   \                     USART_IrDACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1055            /* Check the parameters */
   1056            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x40011000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD021             BEQ.N    ??USART_IrDACmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01D             BEQ.N    ??USART_IrDACmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD019             BEQ.N    ??USART_IrDACmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable27_4  ;; 0x40004c00
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD015             BEQ.N    ??USART_IrDACmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable27_5  ;; 0x40005000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD011             BEQ.N    ??USART_IrDACmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00D             BEQ.N    ??USART_IrDACmd_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable27_7  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD009             BEQ.N    ??USART_IrDACmd_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD005             BEQ.N    ??USART_IrDACmd_0
   \   00000046   0xF44F 0x6184      MOV      R1,#+1056
   \   0000004A   0x.... 0x....      ADR.W    R0,?_0
   \   0000004E   0x.... 0x....      BL       assert_failed
   1057            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_IrDACmd_0: (+1)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD007             BEQ.N    ??USART_IrDACmd_1
   \   00000056   0x2D01             CMP      R5,#+1
   \   00000058   0xD005             BEQ.N    ??USART_IrDACmd_1
   \   0000005A   0xF240 0x4121      MOVW     R1,#+1057
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
   1058              
   1059            if (NewState != DISABLE)
   \                     ??USART_IrDACmd_1: (+1)
   \   00000066   0x2D00             CMP      R5,#+0
   \   00000068   0x8AA0             LDRH     R0,[R4, #+20]
   \   0000006A   0xD003             BEQ.N    ??USART_IrDACmd_2
   1060            {
   1061              /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
   1062              USARTx->CR3 |= USART_CR3_IREN;
   \   0000006C   0xF040 0x0002      ORR      R0,R0,#0x2
   \   00000070   0x82A0             STRH     R0,[R4, #+20]
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}
   1063            }
   1064            else
   1065            {
   1066              /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
   1067              USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
   \                     ??USART_IrDACmd_2: (+1)
   \   00000074   0xF64F 0x71FD      MOVW     R1,#+65533
   \   00000078   0x4008             ANDS     R0,R1,R0
   \   0000007A   0x82A0             STRH     R0,[R4, #+20]
   1068            }
   1069          }
   \   0000007C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1070          
   1071          /**
   1072            * @}
   1073            */
   1074          
   1075          /** @defgroup USART_Group8 DMA transfers management functions
   1076           *  @brief   DMA transfers management functions
   1077           *
   1078          @verbatim   
   1079           ===============================================================================
   1080                        ##### DMA transfers management functions #####
   1081           ===============================================================================  
   1082          
   1083          @endverbatim
   1084            * @{
   1085            */
   1086            
   1087          /**
   1088            * @brief  Enables or disables the USART's DMA interface.
   1089            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1090            *         UART peripheral.
   1091            * @param  USART_DMAReq: specifies the DMA request.
   1092            *          This parameter can be any combination of the following values:
   1093            *            @arg USART_DMAReq_Tx: USART DMA transmit request
   1094            *            @arg USART_DMAReq_Rx: USART DMA receive request
   1095            * @param  NewState: new state of the DMA Request sources.
   1096            *          This parameter can be: ENABLE or DISABLE.   
   1097            * @retval None
   1098            */

   \                                 In section .text, align 2, keep-with-next
   1099          void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
   1100          {
   \                     USART_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1101            /* Check the parameters */
   1102            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable27_1  ;; 0x40011000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD021             BEQ.N    ??USART_DMACmd_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD01D             BEQ.N    ??USART_DMACmd_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD019             BEQ.N    ??USART_DMACmd_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable27_4  ;; 0x40004c00
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD015             BEQ.N    ??USART_DMACmd_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable27_5  ;; 0x40005000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD011             BEQ.N    ??USART_DMACmd_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD00D             BEQ.N    ??USART_DMACmd_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable27_7  ;; 0x40007800
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD009             BEQ.N    ??USART_DMACmd_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD005             BEQ.N    ??USART_DMACmd_0
   \   00000048   0xF240 0x414E      MOVW     R1,#+1102
   \   0000004C   0x.... 0x....      ADR.W    R0,?_0
   \   00000050   0x.... 0x....      BL       assert_failed
   1103            assert_param(IS_USART_DMAREQ(USART_DMAReq));  
   \                     ??USART_DMACmd_0: (+1)
   \   00000054   0xF64F 0x703F      MOVW     R0,#+65343
   \   00000058   0x4205             TST      R5,R0
   \   0000005A   0xD101             BNE.N    ??USART_DMACmd_1
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD105             BNE.N    ??USART_DMACmd_2
   \                     ??USART_DMACmd_1: (+1)
   \   00000060   0xF240 0x414F      MOVW     R1,#+1103
   \   00000064   0x.... 0x....      ADR.W    R0,?_0
   \   00000068   0x.... 0x....      BL       assert_failed
   1104            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
   \                     ??USART_DMACmd_2: (+1)
   \   0000006C   0x2E00             CMP      R6,#+0
   \   0000006E   0xD007             BEQ.N    ??USART_DMACmd_3
   \   00000070   0x2E01             CMP      R6,#+1
   \   00000072   0xD005             BEQ.N    ??USART_DMACmd_3
   \   00000074   0xF44F 0x618A      MOV      R1,#+1104
   \   00000078   0x.... 0x....      ADR.W    R0,?_0
   \   0000007C   0x.... 0x....      BL       assert_failed
   1105          
   1106            if (NewState != DISABLE)
   \                     ??USART_DMACmd_3: (+1)
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0x8AA0             LDRH     R0,[R4, #+20]
   \   00000084   0xD002             BEQ.N    ??USART_DMACmd_4
   1107            {
   1108              /* Enable the DMA transfer for selected requests by setting the DMAT and/or
   1109                 DMAR bits in the USART CR3 register */
   1110              USARTx->CR3 |= USART_DMAReq;
   \   00000086   0x4328             ORRS     R0,R5,R0
   \   00000088   0x82A0             STRH     R0,[R4, #+20]
   \   0000008A   0xBD70             POP      {R4-R6,PC}
   1111            }
   1112            else
   1113            {
   1114              /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
   1115                 DMAR bits in the USART CR3 register */
   1116              USARTx->CR3 &= (uint16_t)~USART_DMAReq;
   \                     ??USART_DMACmd_4: (+1)
   \   0000008C   0x43A8             BICS     R0,R0,R5
   \   0000008E   0x82A0             STRH     R0,[R4, #+20]
   1117            }
   1118          }
   \   00000090   0xBD70             POP      {R4-R6,PC}       ;; return
   1119          
   1120          /**
   1121            * @}
   1122            */
   1123            
   1124          /** @defgroup USART_Group9 Interrupts and flags management functions
   1125           *  @brief   Interrupts and flags management functions 
   1126           *
   1127          @verbatim   
   1128           ===============================================================================
   1129                      ##### Interrupts and flags management functions #####
   1130           ===============================================================================  
   1131              [..]
   1132              This subsection provides a set of functions allowing to configure the USART 
   1133              Interrupts sources, DMA channels requests and check or clear the flags or 
   1134              pending bits status.
   1135              The user should identify which mode will be used in his application to manage 
   1136              the communication: Polling mode, Interrupt mode or DMA mode. 
   1137              
   1138              *** Polling Mode ***
   1139              ====================
   1140              [..]
   1141              In Polling Mode, the SPI communication can be managed by 10 flags:
   1142                (#) USART_FLAG_TXE : to indicate the status of the transmit buffer register
   1143                (#) USART_FLAG_RXNE : to indicate the status of the receive buffer register
   1144                (#) USART_FLAG_TC : to indicate the status of the transmit operation
   1145                (#) USART_FLAG_IDLE : to indicate the status of the Idle Line             
   1146                (#) USART_FLAG_CTS : to indicate the status of the nCTS input
   1147                (#) USART_FLAG_LBD : to indicate the status of the LIN break detection
   1148                (#) USART_FLAG_NE : to indicate if a noise error occur
   1149                (#) USART_FLAG_FE : to indicate if a frame error occur
   1150                (#) USART_FLAG_PE : to indicate if a parity error occur
   1151                (#) USART_FLAG_ORE : to indicate if an Overrun error occur
   1152              [..]
   1153              In this Mode it is advised to use the following functions:
   1154                (+) FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1155                (+) void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
   1156          
   1157              *** Interrupt Mode ***
   1158              ======================
   1159              [..]
   1160              In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
   1161              and 10 pending bits: 
   1162          
   1163                (#) Pending Bits:
   1164          
   1165                  (##) USART_IT_TXE : to indicate the status of the transmit buffer register
   1166                  (##) USART_IT_RXNE : to indicate the status of the receive buffer register
   1167                  (##) USART_IT_TC : to indicate the status of the transmit operation
   1168                  (##) USART_IT_IDLE : to indicate the status of the Idle Line             
   1169                  (##) USART_IT_CTS : to indicate the status of the nCTS input
   1170                  (##) USART_IT_LBD : to indicate the status of the LIN break detection
   1171                  (##) USART_IT_NE : to indicate if a noise error occur
   1172                  (##) USART_IT_FE : to indicate if a frame error occur
   1173                  (##) USART_IT_PE : to indicate if a parity error occur
   1174                  (##) USART_IT_ORE : to indicate if an Overrun error occur
   1175          
   1176                (#) Interrupt Source:
   1177          
   1178                  (##) USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1179                                      interrupt. 
   1180                  (##) USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1181                                       empty interrupt.
   1182                  (##) USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1183                                     interrupt. 
   1184                  (##) USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1185                  (##) USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1186                  (##) USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1187                                      interrupt. 
   1188                  (##) USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1189                  (##) USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1190          
   1191                -@@- Some parameters are coded in order to use them as interrupt source 
   1192                    or as pending bits.
   1193              [..]
   1194              In this Mode it is advised to use the following functions:
   1195                (+) void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1196                (+) ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1197                (+) void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1198          
   1199              *** DMA Mode ***
   1200              ================
   1201              [..]
   1202              In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1203                (#) USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1204                (#) USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1205              [..]
   1206              In this Mode it is advised to use the following function:
   1207                (+) void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1208          
   1209          @endverbatim
   1210            * @{
   1211            */
   1212          
   1213          /**
   1214            * @brief  Enables or disables the specified USART interrupts.
   1215            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1216            *         UART peripheral.
   1217            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1218            *          This parameter can be one of the following values:
   1219            *            @arg USART_IT_CTS:  CTS change interrupt
   1220            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1221            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1222            *            @arg USART_IT_TC:   Transmission complete interrupt
   1223            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1224            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1225            *            @arg USART_IT_PE:   Parity Error interrupt
   1226            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1227            * @param  NewState: new state of the specified USARTx interrupts.
   1228            *          This parameter can be: ENABLE or DISABLE.
   1229            * @retval None
   1230            */

   \                                 In section .text, align 2, keep-with-next
   1231          void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
   1232          {
   \                     USART_ITConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4614             MOV      R4,R2
   1233            uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
   1234            uint32_t usartxbase = 0x00;
   1235            /* Check the parameters */
   1236            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable27_1  ;; 0x40011000
   \   0000000E   0x42BD             CMP      R5,R7
   \   00000010   0xD021             BEQ.N    ??USART_ITConfig_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD01D             BEQ.N    ??USART_ITConfig_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001E   0x4285             CMP      R5,R0
   \   00000020   0xD019             BEQ.N    ??USART_ITConfig_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable27_4  ;; 0x40004c00
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD015             BEQ.N    ??USART_ITConfig_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable27_5  ;; 0x40005000
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD011             BEQ.N    ??USART_ITConfig_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD00D             BEQ.N    ??USART_ITConfig_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable27_7  ;; 0x40007800
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD009             BEQ.N    ??USART_ITConfig_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40007c00
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD005             BEQ.N    ??USART_ITConfig_0
   \   0000004A   0xF240 0x41D4      MOVW     R1,#+1236
   \   0000004E   0x.... 0x....      ADR.W    R0,?_0
   \   00000052   0x.... 0x....      BL       assert_failed
   1237            assert_param(IS_USART_CONFIG_IT(USART_IT));
   \                     ??USART_ITConfig_0: (+1)
   \   00000056   0x46B0             MOV      R8,R6
   \   00000058   0xF1B8 0x0F28      CMP      R8,#+40
   \   0000005C   0xD020             BEQ.N    ??USART_ITConfig_1
   \   0000005E   0xF240 0x7027      MOVW     R0,#+1831
   \   00000062   0x4580             CMP      R8,R0
   \   00000064   0xD01C             BEQ.N    ??USART_ITConfig_1
   \   00000066   0xF240 0x6026      MOVW     R0,#+1574
   \   0000006A   0x4580             CMP      R8,R0
   \   0000006C   0xD018             BEQ.N    ??USART_ITConfig_1
   \   0000006E   0xF240 0x5025      MOVW     R0,#+1317
   \   00000072   0x4580             CMP      R8,R0
   \   00000074   0xD014             BEQ.N    ??USART_ITConfig_1
   \   00000076   0xF240 0x4024      MOVW     R0,#+1060
   \   0000007A   0x4580             CMP      R8,R0
   \   0000007C   0xD010             BEQ.N    ??USART_ITConfig_1
   \   0000007E   0xF640 0x0046      MOVW     R0,#+2118
   \   00000082   0x4580             CMP      R8,R0
   \   00000084   0xD00C             BEQ.N    ??USART_ITConfig_1
   \   00000086   0xF640 0x106A      MOVW     R0,#+2410
   \   0000008A   0x4580             CMP      R8,R0
   \   0000008C   0xD008             BEQ.N    ??USART_ITConfig_1
   \   0000008E   0xF1B8 0x0F60      CMP      R8,#+96
   \   00000092   0xD005             BEQ.N    ??USART_ITConfig_1
   \   00000094   0xF240 0x41D5      MOVW     R1,#+1237
   \   00000098   0x.... 0x....      ADR.W    R0,?_0
   \   0000009C   0x.... 0x....      BL       assert_failed
   1238            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??USART_ITConfig_1: (+1)
   \   000000A0   0x2C00             CMP      R4,#+0
   \   000000A2   0xD007             BEQ.N    ??USART_ITConfig_2
   \   000000A4   0x2C01             CMP      R4,#+1
   \   000000A6   0xD005             BEQ.N    ??USART_ITConfig_2
   \   000000A8   0xF240 0x41D6      MOVW     R1,#+1238
   \   000000AC   0x.... 0x....      ADR.W    R0,?_0
   \   000000B0   0x.... 0x....      BL       assert_failed
   1239          
   1240            /* The CTS interrupt is not available for UART4 and UART5 */
   1241            if (USART_IT == USART_IT_CTS)
   \                     ??USART_ITConfig_2: (+1)
   \   000000B4   0xF640 0x106A      MOVW     R0,#+2410
   \   000000B8   0x4580             CMP      R8,R0
   \   000000BA   0xD113             BNE.N    ??USART_ITConfig_3
   1242            {
   1243              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   000000BC   0x42BD             CMP      R5,R7
   \   000000BE   0xD011             BEQ.N    ??USART_ITConfig_3
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   000000C4   0x4285             CMP      R5,R0
   \   000000C6   0xD00D             BEQ.N    ??USART_ITConfig_3
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   000000CC   0x4285             CMP      R5,R0
   \   000000CE   0xD009             BEQ.N    ??USART_ITConfig_3
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable27_6  ;; 0x40011400
   \   000000D4   0x4285             CMP      R5,R0
   \   000000D6   0xD005             BEQ.N    ??USART_ITConfig_3
   \   000000D8   0xF240 0x41DB      MOVW     R1,#+1243
   \   000000DC   0x.... 0x....      ADR.W    R0,?_0
   \   000000E0   0x.... 0x....      BL       assert_failed
   1244            } 
   1245              
   1246            usartxbase = (uint32_t)USARTx;
   1247          
   1248            /* Get the USART register index */
   1249            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \                     ??USART_ITConfig_3: (+1)
   \   000000E4   0x4630             MOV      R0,R6
   \   000000E6   0xB2C0             UXTB     R0,R0
   \   000000E8   0x0940             LSRS     R0,R0,#+5
   1250          
   1251            /* Get the interrupt position */
   1252            itpos = USART_IT & IT_MASK;
   1253            itmask = (((uint32_t)0x01) << itpos);
   \   000000EA   0x2101             MOVS     R1,#+1
   \   000000EC   0xF006 0x021F      AND      R2,R6,#0x1F
   \   000000F0   0x4091             LSLS     R1,R1,R2
   1254              
   1255            if (usartreg == 0x01) /* The IT is in CR1 register */
   \   000000F2   0x2801             CMP      R0,#+1
   \   000000F4   0xD102             BNE.N    ??USART_ITConfig_4
   1256            {
   1257              usartxbase += 0x0C;
   \   000000F6   0xF105 0x000C      ADD      R0,R5,#+12
   \   000000FA   0xE006             B.N      ??USART_ITConfig_5
   1258            }
   1259            else if (usartreg == 0x02) /* The IT is in CR2 register */
   \                     ??USART_ITConfig_4: (+1)
   \   000000FC   0x2802             CMP      R0,#+2
   \   000000FE   0xD102             BNE.N    ??USART_ITConfig_6
   1260            {
   1261              usartxbase += 0x10;
   \   00000100   0xF105 0x0010      ADD      R0,R5,#+16
   \   00000104   0xE001             B.N      ??USART_ITConfig_5
   1262            }
   1263            else /* The IT is in CR3 register */
   1264            {
   1265              usartxbase += 0x14; 
   \                     ??USART_ITConfig_6: (+1)
   \   00000106   0xF105 0x0014      ADD      R0,R5,#+20
   1266            }
   1267            if (NewState != DISABLE)
   \                     ??USART_ITConfig_5: (+1)
   \   0000010A   0x2C00             CMP      R4,#+0
   \   0000010C   0x6802             LDR      R2,[R0, #+0]
   \   0000010E   0xD002             BEQ.N    ??USART_ITConfig_7
   1268            {
   1269              *(__IO uint32_t*)usartxbase  |= itmask;
   \   00000110   0x4311             ORRS     R1,R1,R2
   \   00000112   0x6001             STR      R1,[R0, #+0]
   \   00000114   0xE002             B.N      ??USART_ITConfig_8
   1270            }
   1271            else
   1272            {
   1273              *(__IO uint32_t*)usartxbase &= ~itmask;
   \                     ??USART_ITConfig_7: (+1)
   \   00000116   0xEA22 0x0101      BIC      R1,R2,R1
   \   0000011A   0x6001             STR      R1,[R0, #+0]
   1274            }
   1275          }
   \                     ??USART_ITConfig_8: (+1)
   \   0000011C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1276          
   1277          /**
   1278            * @brief  Checks whether the specified USART flag is set or not.
   1279            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1280            *         UART peripheral.
   1281            * @param  USART_FLAG: specifies the flag to check.
   1282            *          This parameter can be one of the following values:
   1283            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1284            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1285            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1286            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1287            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1288            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1289            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1290            *            @arg USART_FLAG_NE:   Noise Error flag
   1291            *            @arg USART_FLAG_FE:   Framing Error flag
   1292            *            @arg USART_FLAG_PE:   Parity Error flag
   1293            * @retval The new state of USART_FLAG (SET or RESET).
   1294            */

   \                                 In section .text, align 2, keep-with-next
   1295          FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1296          {
   \                     USART_GetFlagStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1297            FlagStatus bitstatus = RESET;
   \   00000008   0x2600             MOVS     R6,#+0
   1298            /* Check the parameters */
   1299            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable27_1  ;; 0x40011000
   \   0000000E   0x42BC             CMP      R4,R7
   \   00000010   0xD01E             BEQ.N    ??USART_GetFlagStatus_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable27_2  ;; 0x40004400
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD01A             BEQ.N    ??USART_GetFlagStatus_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable27_3  ;; 0x40004800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD016             BEQ.N    ??USART_GetFlagStatus_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable27_4  ;; 0x40004c00
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD012             BEQ.N    ??USART_GetFlagStatus_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable27_5  ;; 0x40005000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD00E             BEQ.N    ??USART_GetFlagStatus_0
   \   00000032   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD00B             BEQ.N    ??USART_GetFlagStatus_0
   \   00000038   0x....             LDR.N    R0,??DataTable27_7  ;; 0x40007800
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD008             BEQ.N    ??USART_GetFlagStatus_0
   \   0000003E   0x....             LDR.N    R0,??DataTable27  ;; 0x40007c00
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD005             BEQ.N    ??USART_GetFlagStatus_0
   \   00000044   0xF240 0x5113      MOVW     R1,#+1299
   \   00000048   0x.... 0x....      ADR.W    R0,?_0
   \   0000004C   0x.... 0x....      BL       assert_failed
   1300            assert_param(IS_USART_FLAG(USART_FLAG));
   \                     ??USART_GetFlagStatus_0: (+1)
   \   00000050   0x46A8             MOV      R8,R5
   \   00000052   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000056   0xD020             BEQ.N    ??USART_GetFlagStatus_1
   \   00000058   0xF1B8 0x0F80      CMP      R8,#+128
   \   0000005C   0xD01D             BEQ.N    ??USART_GetFlagStatus_1
   \   0000005E   0xF1B8 0x0F40      CMP      R8,#+64
   \   00000062   0xD01A             BEQ.N    ??USART_GetFlagStatus_1
   \   00000064   0xF1B8 0x0F20      CMP      R8,#+32
   \   00000068   0xD017             BEQ.N    ??USART_GetFlagStatus_1
   \   0000006A   0xF1B8 0x0F10      CMP      R8,#+16
   \   0000006E   0xD014             BEQ.N    ??USART_GetFlagStatus_1
   \   00000070   0xF5B8 0x7F80      CMP      R8,#+256
   \   00000074   0xD011             BEQ.N    ??USART_GetFlagStatus_1
   \   00000076   0xF5B8 0x7F00      CMP      R8,#+512
   \   0000007A   0xD00E             BEQ.N    ??USART_GetFlagStatus_1
   \   0000007C   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000080   0xD00B             BEQ.N    ??USART_GetFlagStatus_1
   \   00000082   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000086   0xD008             BEQ.N    ??USART_GetFlagStatus_1
   \   00000088   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000008C   0xD005             BEQ.N    ??USART_GetFlagStatus_1
   \   0000008E   0xF240 0x5114      MOVW     R1,#+1300
   \   00000092   0x.... 0x....      ADR.W    R0,?_0
   \   00000096   0x.... 0x....      BL       assert_failed
   1301          
   1302            /* The CTS flag is not available for UART4 and UART5 */
   1303            if (USART_FLAG == USART_FLAG_CTS)
   \                     ??USART_GetFlagStatus_1: (+1)
   \   0000009A   0xF5B8 0x7F00      CMP      R8,#+512
   \   0000009E   0xD110             BNE.N    ??USART_GetFlagStatus_2
   1304            {
   1305              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   000000A0   0x42BC             CMP      R4,R7
   \   000000A2   0xD00E             BEQ.N    ??USART_GetFlagStatus_2
   \   000000A4   0x....             LDR.N    R0,??DataTable27_2  ;; 0x40004400
   \   000000A6   0x4284             CMP      R4,R0
   \   000000A8   0xD00B             BEQ.N    ??USART_GetFlagStatus_2
   \   000000AA   0x....             LDR.N    R0,??DataTable27_3  ;; 0x40004800
   \   000000AC   0x4284             CMP      R4,R0
   \   000000AE   0xD008             BEQ.N    ??USART_GetFlagStatus_2
   \   000000B0   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   000000B2   0x4284             CMP      R4,R0
   \   000000B4   0xD005             BEQ.N    ??USART_GetFlagStatus_2
   \   000000B6   0xF240 0x5119      MOVW     R1,#+1305
   \   000000BA   0x.... 0x....      ADR.W    R0,?_0
   \   000000BE   0x.... 0x....      BL       assert_failed
   1306            } 
   1307              
   1308            if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
   \                     ??USART_GetFlagStatus_2: (+1)
   \   000000C2   0x8820             LDRH     R0,[R4, #+0]
   \   000000C4   0x4228             TST      R0,R5
   \   000000C6   0xD000             BEQ.N    ??USART_GetFlagStatus_3
   1309            {
   1310              bitstatus = SET;
   \   000000C8   0x2601             MOVS     R6,#+1
   1311            }
   1312            else
   1313            {
   1314              bitstatus = RESET;
   1315            }
   1316            return bitstatus;
   \                     ??USART_GetFlagStatus_3: (+1)
   \   000000CA   0x4630             MOV      R0,R6
   \   000000CC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1317          }
   1318          
   1319          /**
   1320            * @brief  Clears the USARTx's pending flags.
   1321            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1322            *         UART peripheral.
   1323            * @param  USART_FLAG: specifies the flag to clear.
   1324            *          This parameter can be any combination of the following values:
   1325            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1326            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1327            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1328            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1329            *   
   1330            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1331            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1332            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1333            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1334            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1335            *          (USART_ReceiveData()).
   1336            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1337            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1338            *          to USART_DR register (USART_SendData()).
   1339            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1340            *          (USART_SendData()).
   1341            *   
   1342            * @retval None
   1343            */

   \                                 In section .text, align 2, keep-with-next
   1344          void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
   1345          {
   \                     USART_ClearFlag: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1346            /* Check the parameters */
   1347            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R6,??DataTable27_1  ;; 0x40011000
   \   00000008   0x42B4             CMP      R4,R6
   \   0000000A   0xD01A             BEQ.N    ??USART_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable27_2  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD017             BEQ.N    ??USART_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable27_3  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??USART_ClearFlag_0
   \   00000018   0x....             LDR.N    R0,??DataTable27_4  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_ClearFlag_0
   \   0000001E   0x....             LDR.N    R0,??DataTable27_5  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00E             BEQ.N    ??USART_ClearFlag_0
   \   00000024   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00B             BEQ.N    ??USART_ClearFlag_0
   \   0000002A   0x....             LDR.N    R0,??DataTable27_7  ;; 0x40007800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??USART_ClearFlag_0
   \   00000030   0x....             LDR.N    R0,??DataTable27  ;; 0x40007c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_ClearFlag_0
   \   00000036   0xF240 0x5143      MOVW     R1,#+1347
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
   1348            assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
   \                     ??USART_ClearFlag_0: (+1)
   \   00000042   0xF64F 0x409F      MOVW     R0,#+64671
   \   00000046   0x4205             TST      R5,R0
   \   00000048   0xD101             BNE.N    ??USART_ClearFlag_1
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD105             BNE.N    ??USART_ClearFlag_2
   \                     ??USART_ClearFlag_1: (+1)
   \   0000004E   0xF240 0x5144      MOVW     R1,#+1348
   \   00000052   0x.... 0x....      ADR.W    R0,?_0
   \   00000056   0x.... 0x....      BL       assert_failed
   1349          
   1350            /* The CTS flag is not available for UART4 and UART5 */
   1351            if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
   \                     ??USART_ClearFlag_2: (+1)
   \   0000005A   0x05A8             LSLS     R0,R5,#+22
   \   0000005C   0xD510             BPL.N    ??USART_ClearFlag_3
   1352            {
   1353              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   0000005E   0x42B4             CMP      R4,R6
   \   00000060   0xD00E             BEQ.N    ??USART_ClearFlag_3
   \   00000062   0x....             LDR.N    R0,??DataTable27_2  ;; 0x40004400
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD00B             BEQ.N    ??USART_ClearFlag_3
   \   00000068   0x....             LDR.N    R0,??DataTable27_3  ;; 0x40004800
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xD008             BEQ.N    ??USART_ClearFlag_3
   \   0000006E   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD005             BEQ.N    ??USART_ClearFlag_3
   \   00000074   0xF240 0x5149      MOVW     R1,#+1353
   \   00000078   0x.... 0x....      ADR.W    R0,?_0
   \   0000007C   0x.... 0x....      BL       assert_failed
   1354            } 
   1355                 
   1356            USARTx->SR = (uint16_t)~USART_FLAG;
   \                     ??USART_ClearFlag_3: (+1)
   \   00000080   0x43E8             MVNS     R0,R5
   \   00000082   0x8020             STRH     R0,[R4, #+0]
   1357          }
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
   1358          
   1359          /**
   1360            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1361            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1362            *         UART peripheral.
   1363            * @param  USART_IT: specifies the USART interrupt source to check.
   1364            *          This parameter can be one of the following values:
   1365            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1366            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1367            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1368            *            @arg USART_IT_TC:   Transmission complete interrupt
   1369            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1370            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1371            *            @arg USART_IT_ORE_RX : OverRun Error interrupt if the RXNEIE bit is set
   1372            *            @arg USART_IT_ORE_ER : OverRun Error interrupt if the EIE bit is set  
   1373            *            @arg USART_IT_NE:   Noise Error interrupt
   1374            *            @arg USART_IT_FE:   Framing Error interrupt
   1375            *            @arg USART_IT_PE:   Parity Error interrupt
   1376            * @retval The new state of USART_IT (SET or RESET).
   1377            */

   \                                 In section .text, align 2, keep-with-next
   1378          ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
   1379          {
   \                     USART_GetITStatus: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1380            uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
   1381            ITStatus bitstatus = RESET;
   \   00000008   0x2600             MOVS     R6,#+0
   1382            /* Check the parameters */
   1383            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   0000000A   0x....             LDR.N    R7,??DataTable27_1  ;; 0x40011000
   \   0000000C   0x42BC             CMP      R4,R7
   \   0000000E   0xD01A             BEQ.N    ??USART_GetITStatus_0
   \   00000010   0x....             LDR.N    R0,??DataTable27_2  ;; 0x40004400
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD017             BEQ.N    ??USART_GetITStatus_0
   \   00000016   0x....             LDR.N    R0,??DataTable27_3  ;; 0x40004800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD014             BEQ.N    ??USART_GetITStatus_0
   \   0000001C   0x....             LDR.N    R0,??DataTable27_4  ;; 0x40004c00
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD011             BEQ.N    ??USART_GetITStatus_0
   \   00000022   0x....             LDR.N    R0,??DataTable27_5  ;; 0x40005000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00E             BEQ.N    ??USART_GetITStatus_0
   \   00000028   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD00B             BEQ.N    ??USART_GetITStatus_0
   \   0000002E   0x....             LDR.N    R0,??DataTable27_7  ;; 0x40007800
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD008             BEQ.N    ??USART_GetITStatus_0
   \   00000034   0x....             LDR.N    R0,??DataTable27  ;; 0x40007c00
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD005             BEQ.N    ??USART_GetITStatus_0
   \   0000003A   0xF240 0x5167      MOVW     R1,#+1383
   \   0000003E   0x.... 0x....      ADR.W    R0,?_0
   \   00000042   0x.... 0x....      BL       assert_failed
   1384            assert_param(IS_USART_GET_IT(USART_IT)); 
   \                     ??USART_GetITStatus_0: (+1)
   \   00000046   0x46A8             MOV      R8,R5
   \   00000048   0xF1B8 0x0F28      CMP      R8,#+40
   \   0000004C   0xD02D             BEQ.N    ??USART_GetITStatus_1
   \   0000004E   0xF240 0x7027      MOVW     R0,#+1831
   \   00000052   0x4580             CMP      R8,R0
   \   00000054   0xD029             BEQ.N    ??USART_GetITStatus_1
   \   00000056   0xF240 0x6026      MOVW     R0,#+1574
   \   0000005A   0x4580             CMP      R8,R0
   \   0000005C   0xD025             BEQ.N    ??USART_GetITStatus_1
   \   0000005E   0xF240 0x5025      MOVW     R0,#+1317
   \   00000062   0x4580             CMP      R8,R0
   \   00000064   0xD021             BEQ.N    ??USART_GetITStatus_1
   \   00000066   0xF240 0x4024      MOVW     R0,#+1060
   \   0000006A   0x4580             CMP      R8,R0
   \   0000006C   0xD01D             BEQ.N    ??USART_GetITStatus_1
   \   0000006E   0xF640 0x0046      MOVW     R0,#+2118
   \   00000072   0x4580             CMP      R8,R0
   \   00000074   0xD019             BEQ.N    ??USART_GetITStatus_1
   \   00000076   0xF640 0x106A      MOVW     R0,#+2410
   \   0000007A   0x4580             CMP      R8,R0
   \   0000007C   0xD015             BEQ.N    ??USART_GetITStatus_1
   \   0000007E   0xF5B8 0x7F58      CMP      R8,#+864
   \   00000082   0xD012             BEQ.N    ??USART_GetITStatus_1
   \   00000084   0xF240 0x3025      MOVW     R0,#+805
   \   00000088   0x4580             CMP      R8,R0
   \   0000008A   0xD00E             BEQ.N    ??USART_GetITStatus_1
   \   0000008C   0xF5B8 0x7F58      CMP      R8,#+864
   \   00000090   0xD00B             BEQ.N    ??USART_GetITStatus_1
   \   00000092   0xF5B8 0x7F18      CMP      R8,#+608
   \   00000096   0xD008             BEQ.N    ??USART_GetITStatus_1
   \   00000098   0xF5B8 0x7FB0      CMP      R8,#+352
   \   0000009C   0xD005             BEQ.N    ??USART_GetITStatus_1
   \   0000009E   0xF44F 0x61AD      MOV      R1,#+1384
   \   000000A2   0x.... 0x....      ADR.W    R0,?_0
   \   000000A6   0x.... 0x....      BL       assert_failed
   1385          
   1386            /* The CTS interrupt is not available for UART4 and UART5 */ 
   1387            if (USART_IT == USART_IT_CTS)
   \                     ??USART_GetITStatus_1: (+1)
   \   000000AA   0xF640 0x106A      MOVW     R0,#+2410
   \   000000AE   0x4580             CMP      R8,R0
   \   000000B0   0xD110             BNE.N    ??USART_GetITStatus_2
   1388            {
   1389              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   000000B2   0x42BC             CMP      R4,R7
   \   000000B4   0xD00E             BEQ.N    ??USART_GetITStatus_2
   \   000000B6   0x....             LDR.N    R0,??DataTable27_2  ;; 0x40004400
   \   000000B8   0x4284             CMP      R4,R0
   \   000000BA   0xD00B             BEQ.N    ??USART_GetITStatus_2
   \   000000BC   0x....             LDR.N    R0,??DataTable27_3  ;; 0x40004800
   \   000000BE   0x4284             CMP      R4,R0
   \   000000C0   0xD008             BEQ.N    ??USART_GetITStatus_2
   \   000000C2   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   000000C4   0x4284             CMP      R4,R0
   \   000000C6   0xD005             BEQ.N    ??USART_GetITStatus_2
   \   000000C8   0xF240 0x516D      MOVW     R1,#+1389
   \   000000CC   0x.... 0x....      ADR.W    R0,?_0
   \   000000D0   0x.... 0x....      BL       assert_failed
   1390            } 
   1391              
   1392            /* Get the USART register index */
   1393            usartreg = (((uint8_t)USART_IT) >> 0x05);
   \                     ??USART_GetITStatus_2: (+1)
   \   000000D4   0x4628             MOV      R0,R5
   \   000000D6   0xB2C0             UXTB     R0,R0
   \   000000D8   0x0940             LSRS     R0,R0,#+5
   1394            /* Get the interrupt position */
   1395            itmask = USART_IT & IT_MASK;
   1396            itmask = (uint32_t)0x01 << itmask;
   \   000000DA   0x2101             MOVS     R1,#+1
   \   000000DC   0xF005 0x021F      AND      R2,R5,#0x1F
   \   000000E0   0xFA01 0xF202      LSL      R2,R1,R2
   1397            
   1398            if (usartreg == 0x01) /* The IT  is in CR1 register */
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xD102             BNE.N    ??USART_GetITStatus_3
   1399            {
   1400              itmask &= USARTx->CR1;
   \   000000E8   0x89A0             LDRH     R0,[R4, #+12]
   \   000000EA   0x4010             ANDS     R0,R0,R2
   \   000000EC   0xE006             B.N      ??USART_GetITStatus_4
   1401            }
   1402            else if (usartreg == 0x02) /* The IT  is in CR2 register */
   \                     ??USART_GetITStatus_3: (+1)
   \   000000EE   0x2802             CMP      R0,#+2
   \   000000F0   0xD102             BNE.N    ??USART_GetITStatus_5
   1403            {
   1404              itmask &= USARTx->CR2;
   \   000000F2   0x8A20             LDRH     R0,[R4, #+16]
   \   000000F4   0x4010             ANDS     R0,R0,R2
   \   000000F6   0xE001             B.N      ??USART_GetITStatus_4
   1405            }
   1406            else /* The IT  is in CR3 register */
   1407            {
   1408              itmask &= USARTx->CR3;
   \                     ??USART_GetITStatus_5: (+1)
   \   000000F8   0x8AA0             LDRH     R0,[R4, #+20]
   \   000000FA   0x4010             ANDS     R0,R0,R2
   1409            }
   1410            
   1411            bitpos = USART_IT >> 0x08;
   1412            bitpos = (uint32_t)0x01 << bitpos;
   1413            bitpos &= USARTx->SR;
   \                     ??USART_GetITStatus_4: (+1)
   \   000000FC   0x0A2A             LSRS     R2,R5,#+8
   \   000000FE   0x4091             LSLS     R1,R1,R2
   \   00000100   0x8822             LDRH     R2,[R4, #+0]
   \   00000102   0x4011             ANDS     R1,R2,R1
   1414            if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD002             BEQ.N    ??USART_GetITStatus_6
   \   00000108   0x2900             CMP      R1,#+0
   \   0000010A   0xD000             BEQ.N    ??USART_GetITStatus_6
   1415            {
   1416              bitstatus = SET;
   \   0000010C   0x2601             MOVS     R6,#+1
   1417            }
   1418            else
   1419            {
   1420              bitstatus = RESET;
   1421            }
   1422            
   1423            return bitstatus;  
   \                     ??USART_GetITStatus_6: (+1)
   \   0000010E   0x4630             MOV      R0,R6
   \   00000110   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1424          }
   1425          
   1426          /**
   1427            * @brief  Clears the USARTx's interrupt pending bits.
   1428            * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
   1429            *         UART peripheral.
   1430            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1431            *          This parameter can be one of the following values:
   1432            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1433            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1434            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1435            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1436            *
   1437            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1438            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1439            *          software sequence: a read operation to USART_SR register 
   1440            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1441            *          (USART_ReceiveData()).
   1442            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1443            *          (USART_ReceiveData()).
   1444            * @note   TC pending bit can be also cleared by software sequence: a read 
   1445            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1446            *          operation to USART_DR register (USART_SendData()).
   1447            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1448            *          (USART_SendData()).
   1449            *  
   1450            * @retval None
   1451            */

   \                                 In section .text, align 2, keep-with-next
   1452          void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
   1453          {
   \                     USART_ClearITPendingBit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1454            uint16_t bitpos = 0x00, itmask = 0x00;
   1455            /* Check the parameters */
   1456            assert_param(IS_USART_ALL_PERIPH(USARTx));
   \   00000006   0x....             LDR.N    R6,??DataTable27_1  ;; 0x40011000
   \   00000008   0x42B4             CMP      R4,R6
   \   0000000A   0xD01A             BEQ.N    ??USART_ClearITPendingBit_0
   \   0000000C   0x....             LDR.N    R0,??DataTable27_2  ;; 0x40004400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD017             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000012   0x....             LDR.N    R0,??DataTable27_3  ;; 0x40004800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000018   0x....             LDR.N    R0,??DataTable27_4  ;; 0x40004c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??USART_ClearITPendingBit_0
   \   0000001E   0x....             LDR.N    R0,??DataTable27_5  ;; 0x40005000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00E             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000024   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00B             BEQ.N    ??USART_ClearITPendingBit_0
   \   0000002A   0x....             LDR.N    R0,??DataTable27_7  ;; 0x40007800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000030   0x....             LDR.N    R0,??DataTable27  ;; 0x40007c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??USART_ClearITPendingBit_0
   \   00000036   0xF44F 0x61B6      MOV      R1,#+1456
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
   1457            assert_param(IS_USART_CLEAR_IT(USART_IT)); 
   \                     ??USART_ClearITPendingBit_0: (+1)
   \   00000042   0x462F             MOV      R7,R5
   \   00000044   0xF240 0x6026      MOVW     R0,#+1574
   \   00000048   0x4287             CMP      R7,R0
   \   0000004A   0xD011             BEQ.N    ??USART_ClearITPendingBit_1
   \   0000004C   0xF240 0x5025      MOVW     R0,#+1317
   \   00000050   0x4287             CMP      R7,R0
   \   00000052   0xD00D             BEQ.N    ??USART_ClearITPendingBit_1
   \   00000054   0xF640 0x0046      MOVW     R0,#+2118
   \   00000058   0x4287             CMP      R7,R0
   \   0000005A   0xD009             BEQ.N    ??USART_ClearITPendingBit_1
   \   0000005C   0xF640 0x106A      MOVW     R0,#+2410
   \   00000060   0x4287             CMP      R7,R0
   \   00000062   0xD005             BEQ.N    ??USART_ClearITPendingBit_1
   \   00000064   0xF240 0x51B1      MOVW     R1,#+1457
   \   00000068   0x.... 0x....      ADR.W    R0,?_0
   \   0000006C   0x.... 0x....      BL       assert_failed
   1458          
   1459            /* The CTS interrupt is not available for UART4 and UART5 */
   1460            if (USART_IT == USART_IT_CTS)
   \                     ??USART_ClearITPendingBit_1: (+1)
   \   00000070   0xF640 0x106A      MOVW     R0,#+2410
   \   00000074   0x4287             CMP      R7,R0
   \   00000076   0xD110             BNE.N    ??USART_ClearITPendingBit_2
   1461            {
   1462              assert_param(IS_USART_1236_PERIPH(USARTx));
   \   00000078   0x42B4             CMP      R4,R6
   \   0000007A   0xD00E             BEQ.N    ??USART_ClearITPendingBit_2
   \   0000007C   0x....             LDR.N    R0,??DataTable27_2  ;; 0x40004400
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD00B             BEQ.N    ??USART_ClearITPendingBit_2
   \   00000082   0x....             LDR.N    R0,??DataTable27_3  ;; 0x40004800
   \   00000084   0x4284             CMP      R4,R0
   \   00000086   0xD008             BEQ.N    ??USART_ClearITPendingBit_2
   \   00000088   0x....             LDR.N    R0,??DataTable27_6  ;; 0x40011400
   \   0000008A   0x4284             CMP      R4,R0
   \   0000008C   0xD005             BEQ.N    ??USART_ClearITPendingBit_2
   \   0000008E   0xF240 0x51B6      MOVW     R1,#+1462
   \   00000092   0x.... 0x....      ADR.W    R0,?_0
   \   00000096   0x.... 0x....      BL       assert_failed
   1463            } 
   1464              
   1465            bitpos = USART_IT >> 0x08;
   1466            itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
   1467            USARTx->SR = (uint16_t)~itmask;
   \                     ??USART_ClearITPendingBit_2: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x0A29             LSRS     R1,R5,#+8
   \   0000009E   0x4088             LSLS     R0,R0,R1
   \   000000A0   0xB280             UXTH     R0,R0
   \   000000A2   0x43C0             MVNS     R0,R0
   \   000000A4   0x8020             STRH     R0,[R4, #+0]
   1468          }
   \   000000A6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x40007800         DC32     0x40007800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40007C00         DC32     0x40007c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x007270E1         DC32     0x7270e1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x40007C00         DC32     0x40007c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x40004800         DC32     0x40004800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x40005000         DC32     0x40005000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   0x40007800         DC32     0x40007800

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x75 0x73          DC8 75H, 73H, 61H, 72H, 74H, 2EH, 63H, 0
   \              0x61 0x72    
   \              0x74 0x2E    
   \              0x63 0x00    
   1469          
   1470          /**
   1471            * @}
   1472            */
   1473          
   1474          /**
   1475            * @}
   1476            */
   1477          
   1478          /**
   1479            * @}
   1480            */
   1481          
   1482          /**
   1483            * @}
   1484            */
   1485          
   1486          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USART_ClearFlag
        16   -> assert_failed
      24   USART_ClearITPendingBit
        24   -> assert_failed
      16   USART_ClockInit
        16   -> assert_failed
       0   USART_ClockStructInit
      16   USART_Cmd
        16   -> assert_failed
      16   USART_DMACmd
        16   -> assert_failed
      16   USART_DeInit
        16   -> RCC_APB1PeriphResetCmd
        16   -> RCC_APB2PeriphResetCmd
        16   -> assert_failed
      24   USART_GetFlagStatus
        24   -> assert_failed
      24   USART_GetITStatus
        24   -> assert_failed
      16   USART_HalfDuplexCmd
        16   -> assert_failed
      24   USART_ITConfig
        24   -> assert_failed
      40   USART_Init
        40   -> RCC_GetClocksFreq
        40   -> assert_failed
      16   USART_IrDACmd
        16   -> assert_failed
      16   USART_IrDAConfig
        16   -> assert_failed
      16   USART_LINBreakDetectLengthConfig
        16   -> assert_failed
      16   USART_LINCmd
        16   -> assert_failed
      16   USART_OneBitMethodCmd
        16   -> assert_failed
      16   USART_OverSampling8Cmd
        16   -> assert_failed
       8   USART_ReceiveData
         8   -> assert_failed
      16   USART_ReceiverWakeUpCmd
        16   -> assert_failed
       8   USART_SendBreak
         8   -> assert_failed
      16   USART_SendData
        16   -> assert_failed
      16   USART_SetAddress
        16   -> assert_failed
      16   USART_SetGuardTime
        16   -> assert_failed
      16   USART_SetPrescaler
        16   -> assert_failed
      16   USART_SmartCardCmd
        16   -> assert_failed
      16   USART_SmartCardNACKCmd
        16   -> assert_failed
       0   USART_StructInit
      16   USART_WakeUpConfig
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
     104  ?_0
     134  USART_ClearFlag
     168  USART_ClearITPendingBit
     174  USART_ClockInit
      12  USART_ClockStructInit
     126  USART_Cmd
     146  USART_DMACmd
     324  USART_DeInit
     208  USART_GetFlagStatus
     276  USART_GetITStatus
     126  USART_HalfDuplexCmd
     288  USART_ITConfig
     454  USART_Init
     126  USART_IrDACmd
     120  USART_IrDAConfig
     106  USART_LINBreakDetectLengthConfig
     112  USART_LINCmd
     126  USART_OneBitMethodCmd
     124  USART_OverSampling8Cmd
      72  USART_ReceiveData
     108  USART_ReceiverWakeUpCmd
      76  USART_SendBreak
     104  USART_SendData
      98  USART_SetAddress
      66  USART_SetGuardTime
      98  USART_SetPrescaler
      94  USART_SmartCardCmd
      94  USART_SmartCardNACKCmd
      24  USART_StructInit
     108  USART_WakeUpConfig

 
 4 268 bytes in section .text
 
 4 268 bytes of CODE memory

Errors: none
Warnings: none
