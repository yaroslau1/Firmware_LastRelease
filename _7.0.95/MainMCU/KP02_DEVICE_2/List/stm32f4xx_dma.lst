###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        17/Oct/2018  09:51:05
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_dma.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_dma.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Direct Memory Access controller (DMA):           
      9            *           + Initialization and Configuration
     10            *           + Data Counter
     11            *           + Double Buffer mode configuration and command  
     12            *           + Interrupts and flags management
     13            *           
     14            @verbatim      
     15           ===============================================================================      
     16                                 ##### How to use this driver #####
     17           ===============================================================================
     18              [..] 
     19                (#) Enable The DMA controller clock using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA1, ENABLE)
     20                    function for DMA1 or using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2, ENABLE)
     21                    function for DMA2.
     22            
     23                (#) Enable and configure the peripheral to be connected to the DMA Stream
     24                    (except for internal SRAM / FLASH memories: no initialization is 
     25                    necessary). 
     26                    
     27                (#) For a given Stream, program the required configuration through following parameters:   
     28                    Source and Destination addresses, Transfer Direction, Transfer size, Source and Destination 
     29                    data formats, Circular or Normal mode, Stream Priority level, Source and Destination 
     30                    Incrementation mode, FIFO mode and its Threshold (if needed), Burst 
     31                    mode for Source and/or Destination (if needed) using the DMA_Init() function.
     32                    To avoid filling unneccessary fields, you can call DMA_StructInit() function
     33                    to initialize a given structure with default values (reset values), the modify
     34                    only necessary fields 
     35                    (ie. Source and Destination addresses, Transfer size and Data Formats).
     36            
     37                (#) Enable the NVIC and the corresponding interrupt(s) using the function 
     38                    DMA_ITConfig() if you need to use DMA interrupts. 
     39            
     40                (#) Optionally, if the Circular mode is enabled, you can use the Double buffer mode by configuring 
     41                    the second Memory address and the first Memory to be used through the function 
     42                    DMA_DoubleBufferModeConfig(). Then enable the Double buffer mode through the function
     43                    DMA_DoubleBufferModeCmd(). These operations must be done before step 6.
     44                
     45                (#) Enable the DMA stream using the DMA_Cmd() function. 
     46                            
     47                (#) Activate the needed Stream Request using PPP_DMACmd() function for
     48                    any PPP peripheral except internal SRAM and FLASH (ie. SPI, USART ...)
     49                    The function allowing this operation is provided in each PPP peripheral
     50                    driver (ie. SPI_DMACmd for SPI peripheral).
     51                    Once the Stream is enabled, it is not possible to modify its configuration
     52                    unless the stream is stopped and disabled.
     53                    After enabling the Stream, it is advised to monitor the EN bit status using
     54                    the function DMA_GetCmdStatus(). In case of configuration errors or bus errors
     55                    this bit will remain reset and all transfers on this Stream will remain on hold.      
     56            
     57                (#) Optionally, you can configure the number of data to be transferred
     58                    when the Stream is disabled (ie. after each Transfer Complete event
     59                    or when a Transfer Error occurs) using the function DMA_SetCurrDataCounter().
     60                    And you can get the number of remaining data to be transferred using 
     61                    the function DMA_GetCurrDataCounter() at run time (when the DMA Stream is
     62                    enabled and running).  
     63                               
     64                (#) To control DMA events you can use one of the following two methods:
     65                  (##) Check on DMA Stream flags using the function DMA_GetFlagStatus().  
     66                  (##) Use DMA interrupts through the function DMA_ITConfig() at initialization
     67                       phase and DMA_GetITStatus() function into interrupt routines in
     68                       communication phase.
     69              [..]     
     70                    After checking on a flag you should clear it using DMA_ClearFlag()
     71                    function. And after checking on an interrupt event you should 
     72                    clear it using DMA_ClearITPendingBit() function.    
     73                          
     74                (#) Optionally, if Circular mode and Double Buffer mode are enabled, you can modify
     75                    the Memory Addresses using the function DMA_MemoryTargetConfig(). Make sure that
     76                    the Memory Address to be modified is not the one currently in use by DMA Stream.
     77                    This condition can be monitored using the function DMA_GetCurrentMemoryTarget().
     78                          
     79                (#) Optionally, Pause-Resume operations may be performed:
     80                    The DMA_Cmd() function may be used to perform Pause-Resume operation. 
     81                    When a transfer is ongoing, calling this function to disable the 
     82                    Stream will cause the transfer to be paused. All configuration registers 
     83                    and the number of remaining data will be preserved. When calling again 
     84                    this function to re-enable the Stream, the transfer will be resumed from 
     85                    the point where it was paused.          
     86                             
     87                -@- Memory-to-Memory transfer is possible by setting the address of the memory into
     88                     the Peripheral registers. In this mode, Circular mode and Double Buffer mode
     89                     are not allowed.
     90              
     91                -@- The FIFO is used mainly to reduce bus usage and to allow data 
     92                     packing/unpacking: it is possible to set different Data Sizes for 
     93                     the Peripheral and the Memory (ie. you can set Half-Word data size 
     94                     for the peripheral to access its data register and set Word data size
     95                     for the Memory to gain in access time. Each two Half-words will be 
     96                     packed and written in a single access to a Word in the Memory).
     97                
     98                -@- When FIFO is disabled, it is not allowed to configure different 
     99                     Data Sizes for Source and Destination. In this case the Peripheral 
    100                     Data Size will be applied to both Source and Destination.               
    101            
    102            @endverbatim                                 
    103            ******************************************************************************
    104            * @attention
    105            *
    106            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
    107            *
    108            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    109            * You may not use this file except in compliance with the License.
    110            * You may obtain a copy of the License at:
    111            *
    112            *        http://www.st.com/software_license_agreement_liberty_v2
    113            *
    114            * Unless required by applicable law or agreed to in writing, software 
    115            * distributed under the License is distributed on an "AS IS" BASIS, 
    116            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    117            * See the License for the specific language governing permissions and
    118            * limitations under the License.
    119            *
    120            ******************************************************************************  
    121            */ 
    122          
    123          /* Includes ------------------------------------------------------------------*/
    124          #include "stm32f4xx_dma.h"
    125          #include "stm32f4xx_rcc.h"
    126          
    127          /** @addtogroup STM32F4xx_StdPeriph_Driver
    128            * @{
    129            */
    130          
    131          /** @defgroup DMA 
    132            * @brief DMA driver modules
    133            * @{
    134            */ 
    135          
    136          /* Private typedef -----------------------------------------------------------*/
    137          /* Private define ------------------------------------------------------------*/
    138          
    139          /* Masks Definition */
    140          #define TRANSFER_IT_ENABLE_MASK (uint32_t)(DMA_SxCR_TCIE | DMA_SxCR_HTIE | \
    141                                                     DMA_SxCR_TEIE | DMA_SxCR_DMEIE)
    142          
    143          #define DMA_Stream0_IT_MASK     (uint32_t)(DMA_LISR_FEIF0 | DMA_LISR_DMEIF0 | \
    144                                                     DMA_LISR_TEIF0 | DMA_LISR_HTIF0 | \
    145                                                     DMA_LISR_TCIF0)
    146          
    147          #define DMA_Stream1_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 6)
    148          #define DMA_Stream2_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 16)
    149          #define DMA_Stream3_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 22)
    150          #define DMA_Stream4_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK | (uint32_t)0x20000000)
    151          #define DMA_Stream5_IT_MASK     (uint32_t)(DMA_Stream1_IT_MASK | (uint32_t)0x20000000)
    152          #define DMA_Stream6_IT_MASK     (uint32_t)(DMA_Stream2_IT_MASK | (uint32_t)0x20000000)
    153          #define DMA_Stream7_IT_MASK     (uint32_t)(DMA_Stream3_IT_MASK | (uint32_t)0x20000000)
    154          #define TRANSFER_IT_MASK        (uint32_t)0x0F3C0F3C
    155          #define HIGH_ISR_MASK           (uint32_t)0x20000000
    156          #define RESERVED_MASK           (uint32_t)0x0F7D0F7D  
    157          
    158          /* Private macro -------------------------------------------------------------*/
    159          /* Private variables ---------------------------------------------------------*/
    160          /* Private function prototypes -----------------------------------------------*/
    161          /* Private functions ---------------------------------------------------------*/
    162          
    163          
    164          /** @defgroup DMA_Private_Functions
    165            * @{
    166            */
    167          
    168          /** @defgroup DMA_Group1 Initialization and Configuration functions
    169           *  @brief   Initialization and Configuration functions
    170           *
    171          @verbatim   
    172           ===============================================================================
    173                          ##### Initialization and Configuration functions #####
    174           ===============================================================================  
    175              [..]
    176              This subsection provides functions allowing to initialize the DMA Stream source
    177              and destination addresses, incrementation and data sizes, transfer direction, 
    178              buffer size, circular/normal mode selection, memory-to-memory mode selection 
    179              and Stream priority value.
    180              [..]
    181              The DMA_Init() function follows the DMA configuration procedures as described in
    182              reference manual (RM0090) except the first point: waiting on EN bit to be reset.
    183              This condition should be checked by user application using the function DMA_GetCmdStatus()
    184              before calling the DMA_Init() function.
    185          
    186          @endverbatim
    187            * @{
    188            */
    189          
    190          /**
    191            * @brief  Deinitialize the DMAy Streamx registers to their default reset values.
    192            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    193            *         to 7 to select the DMA Stream.
    194            * @retval None
    195            */

   \                                 In section .text, align 2, keep-with-next
    196          void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
    197          {
   \                     DMA_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    198            /* Check the parameters */
    199            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable8  ;; 0x40026010
   \   00000008   0x42AC             CMP      R4,R5
   \   0000000A   0xD040             BEQ.N    ??DMA_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x40026028
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD03C             BEQ.N    ??DMA_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x40026040
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD038             BEQ.N    ??DMA_DeInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40026058
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD034             BEQ.N    ??DMA_DeInit_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40026070
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD030             BEQ.N    ??DMA_DeInit_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x40026088
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD02C             BEQ.N    ??DMA_DeInit_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400260a0
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD028             BEQ.N    ??DMA_DeInit_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400260b8
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD024             BEQ.N    ??DMA_DeInit_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x40026410
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD020             BEQ.N    ??DMA_DeInit_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x40026428
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD01C             BEQ.N    ??DMA_DeInit_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable8_10  ;; 0x40026440
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD018             BEQ.N    ??DMA_DeInit_0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable8_11  ;; 0x40026458
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD014             BEQ.N    ??DMA_DeInit_0
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x40026470
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD010             BEQ.N    ??DMA_DeInit_0
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable8_13  ;; 0x40026488
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD00C             BEQ.N    ??DMA_DeInit_0
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable8_14  ;; 0x400264a0
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD008             BEQ.N    ??DMA_DeInit_0
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable8_15  ;; 0x400264b8
   \   00000080   0x4284             CMP      R4,R0
   \   00000082   0xD004             BEQ.N    ??DMA_DeInit_0
   \   00000084   0x21C7             MOVS     R1,#+199
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \   0000008A   0x.... 0x....      BL       assert_failed
    200          
    201            /* Disable the selected DMAy Streamx */
    202            DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
   \                     ??DMA_DeInit_0: (+1)
   \   0000008E   0x6820             LDR      R0,[R4, #+0]
   \   00000090   0x0840             LSRS     R0,R0,#+1
   \   00000092   0x0040             LSLS     R0,R0,#+1
   \   00000094   0x6020             STR      R0,[R4, #+0]
    203          
    204            /* Reset DMAy Streamx control register */
    205            DMAy_Streamx->CR  = 0;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x6020             STR      R0,[R4, #+0]
    206            
    207            /* Reset DMAy Streamx Number of Data to Transfer register */
    208            DMAy_Streamx->NDTR = 0;
   \   0000009A   0x6060             STR      R0,[R4, #+4]
    209            
    210            /* Reset DMAy Streamx peripheral address register */
    211            DMAy_Streamx->PAR  = 0;
   \   0000009C   0x60A0             STR      R0,[R4, #+8]
    212            
    213            /* Reset DMAy Streamx memory 0 address register */
    214            DMAy_Streamx->M0AR = 0;
   \   0000009E   0x60E0             STR      R0,[R4, #+12]
    215          
    216            /* Reset DMAy Streamx memory 1 address register */
    217            DMAy_Streamx->M1AR = 0;
   \   000000A0   0x6120             STR      R0,[R4, #+16]
    218          
    219            /* Reset DMAy Streamx FIFO control register */
    220            DMAy_Streamx->FCR = (uint32_t)0x00000021; 
   \   000000A2   0x2021             MOVS     R0,#+33
   \   000000A4   0x6160             STR      R0,[R4, #+20]
    221          
    222            /* Reset interrupt pending bits for the selected stream */
    223            if (DMAy_Streamx == DMA1_Stream0)
   \   000000A6   0x42AC             CMP      R4,R5
   \   000000A8   0xD104             BNE.N    ??DMA_DeInit_1
    224            {
    225              /* Reset interrupt pending bits for DMA1 Stream0 */
    226              DMA1->LIFCR = DMA_Stream0_IT_MASK;
   \   000000AA   0x203D             MOVS     R0,#+61
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   000000B0   0x6008             STR      R0,[R1, #+0]
   \   000000B2   0xBD31             POP      {R0,R4,R5,PC}
    227            }
    228            else if (DMAy_Streamx == DMA1_Stream1)
   \                     ??DMA_DeInit_1: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x40026028
   \   000000B8   0x4284             CMP      R4,R0
   \   000000BA   0xD105             BNE.N    ??DMA_DeInit_2
    229            {
    230              /* Reset interrupt pending bits for DMA1 Stream1 */
    231              DMA1->LIFCR = DMA_Stream1_IT_MASK;
   \   000000BC   0xF44F 0x6074      MOV      R0,#+3904
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   000000C4   0x6008             STR      R0,[R1, #+0]
   \   000000C6   0xBD31             POP      {R0,R4,R5,PC}
    232            }
    233            else if (DMAy_Streamx == DMA1_Stream2)
   \                     ??DMA_DeInit_2: (+1)
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x40026040
   \   000000CC   0x4284             CMP      R4,R0
   \   000000CE   0xD105             BNE.N    ??DMA_DeInit_3
    234            {
    235              /* Reset interrupt pending bits for DMA1 Stream2 */
    236              DMA1->LIFCR = DMA_Stream2_IT_MASK;
   \   000000D0   0xF44F 0x1074      MOV      R0,#+3997696
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   000000D8   0x6008             STR      R0,[R1, #+0]
   \   000000DA   0xBD31             POP      {R0,R4,R5,PC}
    237            }
    238            else if (DMAy_Streamx == DMA1_Stream3)
   \                     ??DMA_DeInit_3: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40026058
   \   000000E0   0x4284             CMP      R4,R0
   \   000000E2   0xD105             BNE.N    ??DMA_DeInit_4
    239            {
    240              /* Reset interrupt pending bits for DMA1 Stream3 */
    241              DMA1->LIFCR = DMA_Stream3_IT_MASK;
   \   000000E4   0xF04F 0x6074      MOV      R0,#+255852544
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   000000EC   0x6008             STR      R0,[R1, #+0]
   \   000000EE   0xBD31             POP      {R0,R4,R5,PC}
    242            }
    243            else if (DMAy_Streamx == DMA1_Stream4)
   \                     ??DMA_DeInit_4: (+1)
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40026070
   \   000000F4   0x4284             CMP      R4,R0
   \   000000F6   0xD105             BNE.N    ??DMA_DeInit_5
    244            {
    245              /* Reset interrupt pending bits for DMA1 Stream4 */
    246              DMA1->HIFCR = DMA_Stream4_IT_MASK;
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x2000003d
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   00000100   0x6048             STR      R0,[R1, #+4]
   \   00000102   0xBD31             POP      {R0,R4,R5,PC}
    247            }
    248            else if (DMAy_Streamx == DMA1_Stream5)
   \                     ??DMA_DeInit_5: (+1)
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x40026088
   \   00000108   0x4284             CMP      R4,R0
   \   0000010A   0xD105             BNE.N    ??DMA_DeInit_6
    249            {
    250              /* Reset interrupt pending bits for DMA1 Stream5 */
    251              DMA1->HIFCR = DMA_Stream5_IT_MASK;
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x20000f40
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   00000114   0x6048             STR      R0,[R1, #+4]
   \   00000116   0xBD31             POP      {R0,R4,R5,PC}
    252            }
    253            else if (DMAy_Streamx == DMA1_Stream6)
   \                     ??DMA_DeInit_6: (+1)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400260a0
   \   0000011C   0x4284             CMP      R4,R0
   \   0000011E   0xD105             BNE.N    ??DMA_DeInit_7
    254            {
    255              /* Reset interrupt pending bits for DMA1 Stream6 */
    256              DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x203d0000
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   00000128   0x6048             STR      R0,[R1, #+4]
   \   0000012A   0xBD31             POP      {R0,R4,R5,PC}
    257            }
    258            else if (DMAy_Streamx == DMA1_Stream7)
   \                     ??DMA_DeInit_7: (+1)
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400260b8
   \   00000130   0x4284             CMP      R4,R0
   \   00000132   0xD105             BNE.N    ??DMA_DeInit_8
    259            {
    260              /* Reset interrupt pending bits for DMA1 Stream7 */
    261              DMA1->HIFCR = DMA_Stream7_IT_MASK;
   \   00000134   0xF04F 0x503D      MOV      R0,#+792723456
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable8_17  ;; 0x40026008
   \   0000013C   0x6048             STR      R0,[R1, #+4]
   \   0000013E   0xBD31             POP      {R0,R4,R5,PC}
    262            }
    263            else if (DMAy_Streamx == DMA2_Stream0)
   \                     ??DMA_DeInit_8: (+1)
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x40026410
   \   00000144   0x4284             CMP      R4,R0
   \   00000146   0xD104             BNE.N    ??DMA_DeInit_9
    264            {
    265              /* Reset interrupt pending bits for DMA2 Stream0 */
    266              DMA2->LIFCR = DMA_Stream0_IT_MASK;
   \   00000148   0x203D             MOVS     R0,#+61
   \   0000014A   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   0000014E   0x6008             STR      R0,[R1, #+0]
   \   00000150   0xBD31             POP      {R0,R4,R5,PC}
    267            }
    268            else if (DMAy_Streamx == DMA2_Stream1)
   \                     ??DMA_DeInit_9: (+1)
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x40026428
   \   00000156   0x4284             CMP      R4,R0
   \   00000158   0xD105             BNE.N    ??DMA_DeInit_10
    269            {
    270              /* Reset interrupt pending bits for DMA2 Stream1 */
    271              DMA2->LIFCR = DMA_Stream1_IT_MASK;
   \   0000015A   0xF44F 0x6074      MOV      R0,#+3904
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   00000162   0x6008             STR      R0,[R1, #+0]
   \   00000164   0xBD31             POP      {R0,R4,R5,PC}
    272            }
    273            else if (DMAy_Streamx == DMA2_Stream2)
   \                     ??DMA_DeInit_10: (+1)
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable8_10  ;; 0x40026440
   \   0000016A   0x4284             CMP      R4,R0
   \   0000016C   0xD105             BNE.N    ??DMA_DeInit_11
    274            {
    275              /* Reset interrupt pending bits for DMA2 Stream2 */
    276              DMA2->LIFCR = DMA_Stream2_IT_MASK;
   \   0000016E   0xF44F 0x1074      MOV      R0,#+3997696
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   00000176   0x6008             STR      R0,[R1, #+0]
   \   00000178   0xBD31             POP      {R0,R4,R5,PC}
    277            }
    278            else if (DMAy_Streamx == DMA2_Stream3)
   \                     ??DMA_DeInit_11: (+1)
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable8_11  ;; 0x40026458
   \   0000017E   0x4284             CMP      R4,R0
   \   00000180   0xD105             BNE.N    ??DMA_DeInit_12
    279            {
    280              /* Reset interrupt pending bits for DMA2 Stream3 */
    281              DMA2->LIFCR = DMA_Stream3_IT_MASK;
   \   00000182   0xF04F 0x6074      MOV      R0,#+255852544
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   0000018A   0x6008             STR      R0,[R1, #+0]
   \   0000018C   0xBD31             POP      {R0,R4,R5,PC}
    282            }
    283            else if (DMAy_Streamx == DMA2_Stream4)
   \                     ??DMA_DeInit_12: (+1)
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x40026470
   \   00000192   0x4284             CMP      R4,R0
   \   00000194   0xD105             BNE.N    ??DMA_DeInit_13
    284            {
    285              /* Reset interrupt pending bits for DMA2 Stream4 */
    286              DMA2->HIFCR = DMA_Stream4_IT_MASK;
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x2000003d
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   0000019E   0x6048             STR      R0,[R1, #+4]
   \   000001A0   0xBD31             POP      {R0,R4,R5,PC}
    287            }
    288            else if (DMAy_Streamx == DMA2_Stream5)
   \                     ??DMA_DeInit_13: (+1)
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable8_13  ;; 0x40026488
   \   000001A6   0x4284             CMP      R4,R0
   \   000001A8   0xD105             BNE.N    ??DMA_DeInit_14
    289            {
    290              /* Reset interrupt pending bits for DMA2 Stream5 */
    291              DMA2->HIFCR = DMA_Stream5_IT_MASK;
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x20000f40
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   000001B2   0x6048             STR      R0,[R1, #+4]
   \   000001B4   0xBD31             POP      {R0,R4,R5,PC}
    292            }
    293            else if (DMAy_Streamx == DMA2_Stream6)
   \                     ??DMA_DeInit_14: (+1)
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable8_14  ;; 0x400264a0
   \   000001BA   0x4284             CMP      R4,R0
   \   000001BC   0xD105             BNE.N    ??DMA_DeInit_15
    294            {
    295              /* Reset interrupt pending bits for DMA2 Stream6 */
    296              DMA2->HIFCR = DMA_Stream6_IT_MASK;
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x203d0000
   \   000001C2   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   000001C6   0x6048             STR      R0,[R1, #+4]
   \   000001C8   0xBD31             POP      {R0,R4,R5,PC}
    297            }
    298            else 
    299            {
    300              if (DMAy_Streamx == DMA2_Stream7)
   \                     ??DMA_DeInit_15: (+1)
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable8_15  ;; 0x400264b8
   \   000001CE   0x4284             CMP      R4,R0
   \   000001D0   0xD104             BNE.N    ??DMA_DeInit_16
    301              {
    302                /* Reset interrupt pending bits for DMA2 Stream7 */
    303                DMA2->HIFCR = DMA_Stream7_IT_MASK;
   \   000001D2   0xF04F 0x503D      MOV      R0,#+792723456
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x40026408
   \   000001DA   0x6048             STR      R0,[R1, #+4]
    304              }
    305            }
    306          }
   \                     ??DMA_DeInit_16: (+1)
   \   000001DC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    307          
    308          /**
    309            * @brief  Initializes the DMAy Streamx according to the specified parameters in 
    310            *         the DMA_InitStruct structure.
    311            * @note   Before calling this function, it is recommended to check that the Stream 
    312            *         is actually disabled using the function DMA_GetCmdStatus().  
    313            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    314            *         to 7 to select the DMA Stream.
    315            * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
    316            *         the configuration information for the specified DMA Stream.  
    317            * @retval None
    318            */

   \                                 In section .text, align 2, keep-with-next
    319          void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
    320          {
   \                     DMA_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    321            uint32_t tmpreg = 0;
    322          
    323            /* Check the parameters */
    324            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable8_16
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40026010
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD040             BEQ.N    ??DMA_Init_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x40026028
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD03C             BEQ.N    ??DMA_Init_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x40026040
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD038             BEQ.N    ??DMA_Init_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40026058
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD034             BEQ.N    ??DMA_Init_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40026070
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD030             BEQ.N    ??DMA_Init_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x40026088
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD02C             BEQ.N    ??DMA_Init_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400260a0
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD028             BEQ.N    ??DMA_Init_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400260b8
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD024             BEQ.N    ??DMA_Init_0
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x40026410
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD020             BEQ.N    ??DMA_Init_0
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x40026428
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD01C             BEQ.N    ??DMA_Init_0
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable8_10  ;; 0x40026440
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD018             BEQ.N    ??DMA_Init_0
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable8_11  ;; 0x40026458
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD014             BEQ.N    ??DMA_Init_0
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x40026470
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD010             BEQ.N    ??DMA_Init_0
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable8_13  ;; 0x40026488
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD00C             BEQ.N    ??DMA_Init_0
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable8_14  ;; 0x400264a0
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD008             BEQ.N    ??DMA_Init_0
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable8_15  ;; 0x400264b8
   \   00000086   0x4284             CMP      R4,R0
   \   00000088   0xD004             BEQ.N    ??DMA_Init_0
   \   0000008A   0xF44F 0x71A2      MOV      R1,#+324
   \   0000008E   0x4630             MOV      R0,R6
   \   00000090   0x.... 0x....      BL       assert_failed
    325            assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
   \                     ??DMA_Init_0: (+1)
   \   00000094   0x6828             LDR      R0,[R5, #+0]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD019             BEQ.N    ??DMA_Init_1
   \   0000009A   0xF1B0 0x7F00      CMP      R0,#+33554432
   \   0000009E   0xD016             BEQ.N    ??DMA_Init_1
   \   000000A0   0xF1B0 0x6F80      CMP      R0,#+67108864
   \   000000A4   0xD013             BEQ.N    ??DMA_Init_1
   \   000000A6   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \   000000AA   0xD010             BEQ.N    ??DMA_Init_1
   \   000000AC   0xF1B0 0x6F00      CMP      R0,#+134217728
   \   000000B0   0xD00D             BEQ.N    ??DMA_Init_1
   \   000000B2   0xF1B0 0x6F20      CMP      R0,#+167772160
   \   000000B6   0xD00A             BEQ.N    ??DMA_Init_1
   \   000000B8   0xF1B0 0x6F40      CMP      R0,#+201326592
   \   000000BC   0xD007             BEQ.N    ??DMA_Init_1
   \   000000BE   0xF1B0 0x6F60      CMP      R0,#+234881024
   \   000000C2   0xD004             BEQ.N    ??DMA_Init_1
   \   000000C4   0xF240 0x1145      MOVW     R1,#+325
   \   000000C8   0x4630             MOV      R0,R6
   \   000000CA   0x.... 0x....      BL       assert_failed
    326            assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
   \                     ??DMA_Init_1: (+1)
   \   000000CE   0x68E8             LDR      R0,[R5, #+12]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD008             BEQ.N    ??DMA_Init_2
   \   000000D4   0x2840             CMP      R0,#+64
   \   000000D6   0xD006             BEQ.N    ??DMA_Init_2
   \   000000D8   0x2880             CMP      R0,#+128
   \   000000DA   0xD004             BEQ.N    ??DMA_Init_2
   \   000000DC   0xF44F 0x71A3      MOV      R1,#+326
   \   000000E0   0x4630             MOV      R0,R6
   \   000000E2   0x.... 0x....      BL       assert_failed
    327            assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
   \                     ??DMA_Init_2: (+1)
   \   000000E6   0x6928             LDR      R0,[R5, #+16]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD002             BEQ.N    ??DMA_Init_3
   \   000000EC   0xF5B0 0x3F80      CMP      R0,#+65536
   \   000000F0   0xD304             BCC.N    ??DMA_Init_4
   \                     ??DMA_Init_3: (+1)
   \   000000F2   0xF240 0x1147      MOVW     R1,#+327
   \   000000F6   0x4630             MOV      R0,R6
   \   000000F8   0x.... 0x....      BL       assert_failed
    328            assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
   \                     ??DMA_Init_4: (+1)
   \   000000FC   0x6968             LDR      R0,[R5, #+20]
   \   000000FE   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000102   0xD006             BEQ.N    ??DMA_Init_5
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD004             BEQ.N    ??DMA_Init_5
   \   00000108   0xF44F 0x71A4      MOV      R1,#+328
   \   0000010C   0x4630             MOV      R0,R6
   \   0000010E   0x.... 0x....      BL       assert_failed
    329            assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
   \                     ??DMA_Init_5: (+1)
   \   00000112   0x69A8             LDR      R0,[R5, #+24]
   \   00000114   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000118   0xD006             BEQ.N    ??DMA_Init_6
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD004             BEQ.N    ??DMA_Init_6
   \   0000011E   0xF240 0x1149      MOVW     R1,#+329
   \   00000122   0x4630             MOV      R0,R6
   \   00000124   0x.... 0x....      BL       assert_failed
    330            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
   \                     ??DMA_Init_6: (+1)
   \   00000128   0x69E8             LDR      R0,[R5, #+28]
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD00A             BEQ.N    ??DMA_Init_7
   \   0000012E   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000132   0xD007             BEQ.N    ??DMA_Init_7
   \   00000134   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000138   0xD004             BEQ.N    ??DMA_Init_7
   \   0000013A   0xF44F 0x71A5      MOV      R1,#+330
   \   0000013E   0x4630             MOV      R0,R6
   \   00000140   0x.... 0x....      BL       assert_failed
    331            assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
   \                     ??DMA_Init_7: (+1)
   \   00000144   0x6A28             LDR      R0,[R5, #+32]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD00A             BEQ.N    ??DMA_Init_8
   \   0000014A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000014E   0xD007             BEQ.N    ??DMA_Init_8
   \   00000150   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000154   0xD004             BEQ.N    ??DMA_Init_8
   \   00000156   0xF240 0x114B      MOVW     R1,#+331
   \   0000015A   0x4630             MOV      R0,R6
   \   0000015C   0x.... 0x....      BL       assert_failed
    332            assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
   \                     ??DMA_Init_8: (+1)
   \   00000160   0x6A68             LDR      R0,[R5, #+36]
   \   00000162   0x2800             CMP      R0,#+0
   \   00000164   0xD007             BEQ.N    ??DMA_Init_9
   \   00000166   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000016A   0xD004             BEQ.N    ??DMA_Init_9
   \   0000016C   0xF44F 0x71A6      MOV      R1,#+332
   \   00000170   0x4630             MOV      R0,R6
   \   00000172   0x.... 0x....      BL       assert_failed
    333            assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
   \                     ??DMA_Init_9: (+1)
   \   00000176   0x6AA8             LDR      R0,[R5, #+40]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD00D             BEQ.N    ??DMA_Init_10
   \   0000017C   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000180   0xD00A             BEQ.N    ??DMA_Init_10
   \   00000182   0xF5B0 0x3F00      CMP      R0,#+131072
   \   00000186   0xD007             BEQ.N    ??DMA_Init_10
   \   00000188   0xF5B0 0x3F40      CMP      R0,#+196608
   \   0000018C   0xD004             BEQ.N    ??DMA_Init_10
   \   0000018E   0xF240 0x114D      MOVW     R1,#+333
   \   00000192   0x4630             MOV      R0,R6
   \   00000194   0x.... 0x....      BL       assert_failed
    334            assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
   \                     ??DMA_Init_10: (+1)
   \   00000198   0x6AE8             LDR      R0,[R5, #+44]
   \   0000019A   0x2800             CMP      R0,#+0
   \   0000019C   0xD006             BEQ.N    ??DMA_Init_11
   \   0000019E   0x2804             CMP      R0,#+4
   \   000001A0   0xD004             BEQ.N    ??DMA_Init_11
   \   000001A2   0xF44F 0x71A7      MOV      R1,#+334
   \   000001A6   0x4630             MOV      R0,R6
   \   000001A8   0x.... 0x....      BL       assert_failed
    335            assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
   \                     ??DMA_Init_11: (+1)
   \   000001AC   0x6B28             LDR      R0,[R5, #+48]
   \   000001AE   0x2800             CMP      R0,#+0
   \   000001B0   0xD00A             BEQ.N    ??DMA_Init_12
   \   000001B2   0x2801             CMP      R0,#+1
   \   000001B4   0xD008             BEQ.N    ??DMA_Init_12
   \   000001B6   0x2802             CMP      R0,#+2
   \   000001B8   0xD006             BEQ.N    ??DMA_Init_12
   \   000001BA   0x2803             CMP      R0,#+3
   \   000001BC   0xD004             BEQ.N    ??DMA_Init_12
   \   000001BE   0xF240 0x114F      MOVW     R1,#+335
   \   000001C2   0x4630             MOV      R0,R6
   \   000001C4   0x.... 0x....      BL       assert_failed
    336            assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
   \                     ??DMA_Init_12: (+1)
   \   000001C8   0x6B68             LDR      R0,[R5, #+52]
   \   000001CA   0x2800             CMP      R0,#+0
   \   000001CC   0xD00D             BEQ.N    ??DMA_Init_13
   \   000001CE   0xF5B0 0x0F00      CMP      R0,#+8388608
   \   000001D2   0xD00A             BEQ.N    ??DMA_Init_13
   \   000001D4   0xF1B0 0x7F80      CMP      R0,#+16777216
   \   000001D8   0xD007             BEQ.N    ??DMA_Init_13
   \   000001DA   0xF1B0 0x7FC0      CMP      R0,#+25165824
   \   000001DE   0xD004             BEQ.N    ??DMA_Init_13
   \   000001E0   0xF44F 0x71A8      MOV      R1,#+336
   \   000001E4   0x4630             MOV      R0,R6
   \   000001E6   0x.... 0x....      BL       assert_failed
    337            assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
   \                     ??DMA_Init_13: (+1)
   \   000001EA   0x6BA8             LDR      R0,[R5, #+56]
   \   000001EC   0x2800             CMP      R0,#+0
   \   000001EE   0xD00D             BEQ.N    ??DMA_Init_14
   \   000001F0   0xF5B0 0x1F00      CMP      R0,#+2097152
   \   000001F4   0xD00A             BEQ.N    ??DMA_Init_14
   \   000001F6   0xF5B0 0x0F80      CMP      R0,#+4194304
   \   000001FA   0xD007             BEQ.N    ??DMA_Init_14
   \   000001FC   0xF5B0 0x0FC0      CMP      R0,#+6291456
   \   00000200   0xD004             BEQ.N    ??DMA_Init_14
   \   00000202   0xF240 0x1151      MOVW     R1,#+337
   \   00000206   0x4630             MOV      R0,R6
   \   00000208   0x.... 0x....      BL       assert_failed
    338          
    339            /*------------------------- DMAy Streamx CR Configuration ------------------*/
    340            /* Get the DMAy_Streamx CR value */
    341            tmpreg = DMAy_Streamx->CR;
   \                     ??DMA_Init_14: (+1)
   \   0000020C   0x6820             LDR      R0,[R4, #+0]
    342          
    343            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
    344            tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    345                                   DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \
    346                                   DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \
    347                                   DMA_SxCR_DIR));
    348          
    349            /* Configure DMAy Streamx: */
    350            /* Set CHSEL bits according to DMA_CHSEL value */
    351            /* Set DIR bits according to DMA_DIR value */
    352            /* Set PINC bit according to DMA_PeripheralInc value */
    353            /* Set MINC bit according to DMA_MemoryInc value */
    354            /* Set PSIZE bits according to DMA_PeripheralDataSize value */
    355            /* Set MSIZE bits according to DMA_MemoryDataSize value */
    356            /* Set CIRC bit according to DMA_Mode value */
    357            /* Set PL bits according to DMA_Priority value */
    358            /* Set MBURST bits according to DMA_MemoryBurst value */
    359            /* Set PBURST bits according to DMA_PeripheralBurst value */
    360            tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
    361                      DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
    362                      DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
    363                      DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
    364                      DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
    365          
    366            /* Write to DMAy Streamx CR register */
    367            DMAy_Streamx->CR = tmpreg;
   \   0000020E   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0xf01c803f
   \   00000212   0x4008             ANDS     R0,R1,R0
   \   00000214   0x6829             LDR      R1,[R5, #+0]
   \   00000216   0x4308             ORRS     R0,R1,R0
   \   00000218   0x68E9             LDR      R1,[R5, #+12]
   \   0000021A   0x4308             ORRS     R0,R1,R0
   \   0000021C   0x6969             LDR      R1,[R5, #+20]
   \   0000021E   0x4308             ORRS     R0,R1,R0
   \   00000220   0x69A9             LDR      R1,[R5, #+24]
   \   00000222   0x4308             ORRS     R0,R1,R0
   \   00000224   0x69E9             LDR      R1,[R5, #+28]
   \   00000226   0x4308             ORRS     R0,R1,R0
   \   00000228   0x6A29             LDR      R1,[R5, #+32]
   \   0000022A   0x4308             ORRS     R0,R1,R0
   \   0000022C   0x6A69             LDR      R1,[R5, #+36]
   \   0000022E   0x4308             ORRS     R0,R1,R0
   \   00000230   0x6AA9             LDR      R1,[R5, #+40]
   \   00000232   0x4308             ORRS     R0,R1,R0
   \   00000234   0x6B69             LDR      R1,[R5, #+52]
   \   00000236   0x4308             ORRS     R0,R1,R0
   \   00000238   0x6BA9             LDR      R1,[R5, #+56]
   \   0000023A   0x4308             ORRS     R0,R1,R0
   \   0000023C   0x6020             STR      R0,[R4, #+0]
    368          
    369            /*------------------------- DMAy Streamx FCR Configuration -----------------*/
    370            /* Get the DMAy_Streamx FCR value */
    371            tmpreg = DMAy_Streamx->FCR;
   \   0000023E   0x6960             LDR      R0,[R4, #+20]
    372          
    373            /* Clear DMDIS and FTH bits */
    374            tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    375          
    376            /* Configure DMAy Streamx FIFO: 
    377              Set DMDIS bits according to DMA_FIFOMode value 
    378              Set FTH bits according to DMA_FIFOThreshold value */
    379            tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
    380          
    381            /* Write to DMAy Streamx CR */
    382            DMAy_Streamx->FCR = tmpreg;
   \   00000240   0x08C0             LSRS     R0,R0,#+3
   \   00000242   0x6AE9             LDR      R1,[R5, #+44]
   \   00000244   0xEA51 0x00C0      ORRS     R0,R1,R0, LSL #+3
   \   00000248   0x6B29             LDR      R1,[R5, #+48]
   \   0000024A   0x4308             ORRS     R0,R1,R0
   \   0000024C   0x6160             STR      R0,[R4, #+20]
    383          
    384            /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
    385            /* Write to DMAy Streamx NDTR register */
    386            DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
   \   0000024E   0x6928             LDR      R0,[R5, #+16]
   \   00000250   0x6060             STR      R0,[R4, #+4]
    387          
    388            /*------------------------- DMAy Streamx PAR Configuration -----------------*/
    389            /* Write to DMAy Streamx PAR */
    390            DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
   \   00000252   0x6868             LDR      R0,[R5, #+4]
   \   00000254   0x60A0             STR      R0,[R4, #+8]
    391          
    392            /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
    393            /* Write to DMAy Streamx M0AR */
    394            DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
   \   00000256   0x68A8             LDR      R0,[R5, #+8]
   \   00000258   0x60E0             STR      R0,[R4, #+12]
    395          }
   \   0000025A   0xBD70             POP      {R4-R6,PC}       ;; return
    396          
    397          /**
    398            * @brief  Fills each DMA_InitStruct member with its default value.
    399            * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will 
    400            *         be initialized.
    401            * @retval None
    402            */

   \                                 In section .text, align 2, keep-with-next
    403          void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
    404          {
    405            /*-------------- Reset DMA init structure parameters values ----------------*/
    406            /* Initialize the DMA_Channel member */
    407            DMA_InitStruct->DMA_Channel = 0;
   \                     DMA_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    408          
    409            /* Initialize the DMA_PeripheralBaseAddr member */
    410            DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    411          
    412            /* Initialize the DMA_Memory0BaseAddr member */
    413            DMA_InitStruct->DMA_Memory0BaseAddr = 0;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    414          
    415            /* Initialize the DMA_DIR member */
    416            DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    417          
    418            /* Initialize the DMA_BufferSize member */
    419            DMA_InitStruct->DMA_BufferSize = 0;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    420          
    421            /* Initialize the DMA_PeripheralInc member */
    422            DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    423          
    424            /* Initialize the DMA_MemoryInc member */
    425            DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    426          
    427            /* Initialize the DMA_PeripheralDataSize member */
    428            DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    429          
    430            /* Initialize the DMA_MemoryDataSize member */
    431            DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   00000012   0x6201             STR      R1,[R0, #+32]
    432          
    433            /* Initialize the DMA_Mode member */
    434            DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
   \   00000014   0x6241             STR      R1,[R0, #+36]
    435          
    436            /* Initialize the DMA_Priority member */
    437            DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
   \   00000016   0x6281             STR      R1,[R0, #+40]
    438          
    439            /* Initialize the DMA_FIFOMode member */
    440            DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
   \   00000018   0x62C1             STR      R1,[R0, #+44]
    441          
    442            /* Initialize the DMA_FIFOThreshold member */
    443            DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
   \   0000001A   0x6301             STR      R1,[R0, #+48]
    444          
    445            /* Initialize the DMA_MemoryBurst member */
    446            DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
   \   0000001C   0x6341             STR      R1,[R0, #+52]
    447          
    448            /* Initialize the DMA_PeripheralBurst member */
    449            DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   \   0000001E   0x6381             STR      R1,[R0, #+56]
    450          }
   \   00000020   0x4770             BX       LR               ;; return
    451          
    452          /**
    453            * @brief  Enables or disables the specified DMAy Streamx.
    454            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    455            *         to 7 to select the DMA Stream.
    456            * @param  NewState: new state of the DMAy Streamx. 
    457            *          This parameter can be: ENABLE or DISABLE.
    458            *
    459            * @note  This function may be used to perform Pause-Resume operation. When a
    460            *        transfer is ongoing, calling this function to disable the Stream will
    461            *        cause the transfer to be paused. All configuration registers and the
    462            *        number of remaining data will be preserved. When calling again this
    463            *        function to re-enable the Stream, the transfer will be resumed from
    464            *        the point where it was paused.          
    465            *    
    466            * @note  After configuring the DMA Stream (DMA_Init() function) and enabling the
    467            *        stream, it is recommended to check (or wait until) the DMA Stream is
    468            *        effectively enabled. A Stream may remain disabled if a configuration 
    469            *        parameter is wrong.
    470            *        After disabling a DMA Stream, it is also recommended to check (or wait
    471            *        until) the DMA Stream is effectively disabled. If a Stream is disabled 
    472            *        while a data transfer is ongoing, the current data will be transferred
    473            *        and the Stream will be effectively disabled only after the transfer of
    474            *        this single data is finished.            
    475            *    
    476            * @retval None
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
    479          {
   \                     DMA_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    480            /* Check the parameters */
    481            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40026010
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD041             BEQ.N    ??DMA_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x40026028
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD03D             BEQ.N    ??DMA_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x40026040
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD039             BEQ.N    ??DMA_Cmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40026058
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD035             BEQ.N    ??DMA_Cmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40026070
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD031             BEQ.N    ??DMA_Cmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x40026088
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD02D             BEQ.N    ??DMA_Cmd_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400260a0
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD029             BEQ.N    ??DMA_Cmd_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400260b8
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD025             BEQ.N    ??DMA_Cmd_0
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x40026410
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD021             BEQ.N    ??DMA_Cmd_0
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable8_9  ;; 0x40026428
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xD01D             BEQ.N    ??DMA_Cmd_0
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable8_10  ;; 0x40026440
   \   0000005A   0x4284             CMP      R4,R0
   \   0000005C   0xD019             BEQ.N    ??DMA_Cmd_0
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable8_11  ;; 0x40026458
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD015             BEQ.N    ??DMA_Cmd_0
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable8_12  ;; 0x40026470
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xD011             BEQ.N    ??DMA_Cmd_0
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable8_13  ;; 0x40026488
   \   00000072   0x4284             CMP      R4,R0
   \   00000074   0xD00D             BEQ.N    ??DMA_Cmd_0
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable8_14  ;; 0x400264a0
   \   0000007A   0x4284             CMP      R4,R0
   \   0000007C   0xD009             BEQ.N    ??DMA_Cmd_0
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable8_15  ;; 0x400264b8
   \   00000082   0x4284             CMP      R4,R0
   \   00000084   0xD005             BEQ.N    ??DMA_Cmd_0
   \   00000086   0xF240 0x11E1      MOVW     R1,#+481
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \   0000008E   0x.... 0x....      BL       assert_failed
    482            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DMA_Cmd_0: (+1)
   \   00000092   0x2D00             CMP      R5,#+0
   \   00000094   0xD007             BEQ.N    ??DMA_Cmd_1
   \   00000096   0x2D01             CMP      R5,#+1
   \   00000098   0xD005             BEQ.N    ??DMA_Cmd_1
   \   0000009A   0xF44F 0x71F1      MOV      R1,#+482
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable8_16
   \   000000A2   0x.... 0x....      BL       assert_failed
    483          
    484            if (NewState != DISABLE)
   \                     ??DMA_Cmd_1: (+1)
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0xD003             BEQ.N    ??DMA_Cmd_2
    485            {
    486              /* Enable the selected DMAy Streamx by setting EN bit */
    487              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
   \   000000AC   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000B0   0x6020             STR      R0,[R4, #+0]
   \   000000B2   0xBD31             POP      {R0,R4,R5,PC}
    488            }
    489            else
    490            {
    491              /* Disable the selected DMAy Streamx by clearing EN bit */
    492              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
   \                     ??DMA_Cmd_2: (+1)
   \   000000B4   0x0840             LSRS     R0,R0,#+1
   \   000000B6   0x0040             LSLS     R0,R0,#+1
   \   000000B8   0x6020             STR      R0,[R4, #+0]
    493            }
    494          }
   \   000000BA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    495          
    496          /**
    497            * @brief  Configures, when the PINC (Peripheral Increment address mode) bit is
    498            *         set, if the peripheral address should be incremented with the data 
    499            *         size (configured with PSIZE bits) or by a fixed offset equal to 4
    500            *         (32-bit aligned addresses).
    501            *   
    502            * @note   This function has no effect if the Peripheral Increment mode is disabled.
    503            *     
    504            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    505            *          to 7 to select the DMA Stream.
    506            * @param  DMA_Pincos: specifies the Peripheral increment offset size.
    507            *          This parameter can be one of the following values:
    508            *            @arg DMA_PINCOS_Psize: Peripheral address increment is done  
    509            *                                   accordingly to PSIZE parameter.
    510            *            @arg DMA_PINCOS_WordAligned: Peripheral address increment offset is 
    511            *                                         fixed to 4 (32-bit aligned addresses). 
    512            * @retval None
    513            */

   \                                 In section .text, align 2, keep-with-next
    514          void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
    515          {
   \                     DMA_PeriphIncOffsetSizeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    516            /* Check the parameters */
    517            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x40026010
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD039             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8_1  ;; 0x40026028
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD035             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8_2  ;; 0x40026040
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD031             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable8_3  ;; 0x40026058
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD02D             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x40026070
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD029             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable8_5  ;; 0x40026088
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD025             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable8_6  ;; 0x400260a0
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD021             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable8_7  ;; 0x400260b8
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD01D             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable8_8  ;; 0x40026410
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD019             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   0000004E   0x....             LDR.N    R0,??DataTable8_9  ;; 0x40026428
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD016             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000054   0x....             LDR.N    R0,??DataTable8_10  ;; 0x40026440
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD013             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   0000005A   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40026458
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD010             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000060   0x....             LDR.N    R0,??DataTable8_12  ;; 0x40026470
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD00D             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000066   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40026488
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD00A             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   0000006C   0x....             LDR.N    R0,??DataTable8_14  ;; 0x400264a0
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD007             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000072   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400264b8
   \   00000074   0x4284             CMP      R4,R0
   \   00000076   0xD004             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_0
   \   00000078   0xF240 0x2105      MOVW     R1,#+517
   \   0000007C   0x....             LDR.N    R0,??DataTable8_16
   \   0000007E   0x.... 0x....      BL       assert_failed
    518            assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));
   \                     ??DMA_PeriphIncOffsetSizeConfig_0: (+1)
   \   00000082   0x2D00             CMP      R5,#+0
   \   00000084   0xD007             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_1
   \   00000086   0xF5B5 0x4F00      CMP      R5,#+32768
   \   0000008A   0xD004             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_1
   \   0000008C   0xF240 0x2106      MOVW     R1,#+518
   \   00000090   0x....             LDR.N    R0,??DataTable8_16
   \   00000092   0x.... 0x....      BL       assert_failed
    519          
    520            /* Check the needed Peripheral increment offset */
    521            if(DMA_Pincos != DMA_PINCOS_Psize)
   \                     ??DMA_PeriphIncOffsetSizeConfig_1: (+1)
   \   00000096   0x2D00             CMP      R5,#+0
   \   00000098   0x6820             LDR      R0,[R4, #+0]
   \   0000009A   0xD003             BEQ.N    ??DMA_PeriphIncOffsetSizeConfig_2
    522            {
    523              /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    524              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
   \   0000009C   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000000A0   0x6020             STR      R0,[R4, #+0]
   \   000000A2   0xBD31             POP      {R0,R4,R5,PC}
    525            }
    526            else
    527            {
    528              /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    529              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
   \                     ??DMA_PeriphIncOffsetSizeConfig_2: (+1)
   \   000000A4   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   000000A8   0x6020             STR      R0,[R4, #+0]
    530            }
    531          }
   \   000000AA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    532          
    533          /**
    534            * @brief  Configures, when the DMAy Streamx is disabled, the flow controller for
    535            *         the next transactions (Peripheral or Memory).
    536            *       
    537            * @note   Before enabling this feature, check if the used peripheral supports 
    538            *         the Flow Controller mode or not.    
    539            *  
    540            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    541            *          to 7 to select the DMA Stream.
    542            * @param  DMA_FlowCtrl: specifies the DMA flow controller.
    543            *          This parameter can be one of the following values:
    544            *            @arg DMA_FlowCtrl_Memory: DMAy_Streamx transactions flow controller is 
    545            *                                      the DMA controller.
    546            *            @arg DMA_FlowCtrl_Peripheral: DMAy_Streamx transactions flow controller 
    547            *                                          is the peripheral.    
    548            * @retval None
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
    551          {
   \                     DMA_FlowControllerConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    552            /* Check the parameters */
    553            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x....             LDR.N    R0,??DataTable8  ;; 0x40026010
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD031             BEQ.N    ??DMA_FlowControllerConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40026028
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD02E             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000012   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40026040
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD02B             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000018   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40026058
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD028             BEQ.N    ??DMA_FlowControllerConfig_0
   \   0000001E   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40026070
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD025             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000024   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40026088
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD022             BEQ.N    ??DMA_FlowControllerConfig_0
   \   0000002A   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400260a0
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD01F             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000030   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400260b8
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD01C             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000036   0x....             LDR.N    R0,??DataTable8_8  ;; 0x40026410
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD019             BEQ.N    ??DMA_FlowControllerConfig_0
   \   0000003C   0x....             LDR.N    R0,??DataTable8_9  ;; 0x40026428
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD016             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000042   0x....             LDR.N    R0,??DataTable8_10  ;; 0x40026440
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD013             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000048   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40026458
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD010             BEQ.N    ??DMA_FlowControllerConfig_0
   \   0000004E   0x....             LDR.N    R0,??DataTable8_12  ;; 0x40026470
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD00D             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000054   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40026488
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD00A             BEQ.N    ??DMA_FlowControllerConfig_0
   \   0000005A   0x....             LDR.N    R0,??DataTable8_14  ;; 0x400264a0
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD007             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000060   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400264b8
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD004             BEQ.N    ??DMA_FlowControllerConfig_0
   \   00000066   0xF240 0x2129      MOVW     R1,#+553
   \   0000006A   0x....             LDR.N    R0,??DataTable8_16
   \   0000006C   0x.... 0x....      BL       assert_failed
    554            assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));
   \                     ??DMA_FlowControllerConfig_0: (+1)
   \   00000070   0x2D00             CMP      R5,#+0
   \   00000072   0xD006             BEQ.N    ??DMA_FlowControllerConfig_1
   \   00000074   0x2D20             CMP      R5,#+32
   \   00000076   0xD004             BEQ.N    ??DMA_FlowControllerConfig_1
   \   00000078   0xF240 0x212A      MOVW     R1,#+554
   \   0000007C   0x....             LDR.N    R0,??DataTable8_16
   \   0000007E   0x.... 0x....      BL       assert_failed
    555          
    556            /* Check the needed flow controller  */
    557            if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
   \                     ??DMA_FlowControllerConfig_1: (+1)
   \   00000082   0x2D00             CMP      R5,#+0
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0xD003             BEQ.N    ??DMA_FlowControllerConfig_2
    558            {
    559              /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    560              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
   \   00000088   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000008C   0x6020             STR      R0,[R4, #+0]
   \   0000008E   0xBD31             POP      {R0,R4,R5,PC}
    561            }
    562            else
    563            {
    564              /* Clear the PFCTRL bit: Memory is the flow controller */
    565              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
   \                     ??DMA_FlowControllerConfig_2: (+1)
   \   00000090   0xF020 0x0020      BIC      R0,R0,#0x20
   \   00000094   0x6020             STR      R0,[R4, #+0]
    566            }
    567          }
   \   00000096   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    568          /**
    569            * @}
    570            */
    571          
    572          /** @defgroup DMA_Group2 Data Counter functions
    573           *  @brief   Data Counter functions 
    574           *
    575          @verbatim   
    576           ===============================================================================
    577                                ##### Data Counter functions #####
    578           ===============================================================================  
    579              [..]
    580              This subsection provides function allowing to configure and read the buffer size
    581              (number of data to be transferred). 
    582              [..]
    583              The DMA data counter can be written only when the DMA Stream is disabled 
    584              (ie. after transfer complete event).
    585              [..]
    586              The following function can be used to write the Stream data counter value:
    587                (+) void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);
    588                -@- It is advised to use this function rather than DMA_Init() in situations 
    589                    where only the Data buffer needs to be reloaded.
    590                -@- If the Source and Destination Data Sizes are different, then the value 
    591                    written in data counter, expressing the number of transfers, is relative 
    592                    to the number of transfers from the Peripheral point of view.
    593                    ie. If Memory data size is Word, Peripheral data size is Half-Words, 
    594                    then the value to be configured in the data counter is the number 
    595                    of Half-Words to be transferred from/to the peripheral.
    596              [..]
    597              The DMA data counter can be read to indicate the number of remaining transfers for
    598              the relative DMA Stream. This counter is decremented at the end of each data 
    599              transfer and when the transfer is complete: 
    600                (+) If Normal mode is selected: the counter is set to 0.
    601                (+) If Circular mode is selected: the counter is reloaded with the initial value
    602                    (configured before enabling the DMA Stream)
    603               [..]
    604               The following function can be used to read the Stream data counter value:
    605                 (+) uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);
    606          
    607          @endverbatim
    608            * @{
    609            */
    610          
    611          /**
    612            * @brief  Writes the number of data units to be transferred on the DMAy Streamx.
    613            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    614            *          to 7 to select the DMA Stream.
    615            * @param  Counter: Number of data units to be transferred (from 0 to 65535) 
    616            *          Number of data items depends only on the Peripheral data format.
    617            *            
    618            * @note   If Peripheral data format is Bytes: number of data units is equal 
    619            *         to total number of bytes to be transferred.
    620            *           
    621            * @note   If Peripheral data format is Half-Word: number of data units is  
    622            *         equal to total number of bytes to be transferred / 2.
    623            *           
    624            * @note   If Peripheral data format is Word: number of data units is equal 
    625            *         to total  number of bytes to be transferred / 4.
    626            *      
    627            * @note   In Memory-to-Memory transfer mode, the memory buffer pointed by 
    628            *         DMAy_SxPAR register is considered as Peripheral.
    629            *      
    630            * @retval The number of remaining data units in the current DMAy Streamx transfer.
    631            */

   \                                 In section .text, align 2, keep-with-next
    632          void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
    633          {
   \                     DMA_SetCurrDataCounter: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    634            /* Check the parameters */
    635            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x....             LDR.N    R0,??DataTable8  ;; 0x40026010
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD031             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   0000000C   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40026028
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD02E             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000012   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40026040
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD02B             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000018   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40026058
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD028             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   0000001E   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40026070
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD025             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000024   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40026088
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD022             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   0000002A   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400260a0
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD01F             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000030   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400260b8
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD01C             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000036   0x....             LDR.N    R0,??DataTable8_8  ;; 0x40026410
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD019             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   0000003C   0x....             LDR.N    R0,??DataTable8_9  ;; 0x40026428
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD016             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000042   0x....             LDR.N    R0,??DataTable8_10  ;; 0x40026440
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD013             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000048   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40026458
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD010             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   0000004E   0x....             LDR.N    R0,??DataTable8_12  ;; 0x40026470
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD00D             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000054   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40026488
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD00A             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   0000005A   0x....             LDR.N    R0,??DataTable8_14  ;; 0x400264a0
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD007             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000060   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400264b8
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD004             BEQ.N    ??DMA_SetCurrDataCounter_0
   \   00000066   0xF240 0x217B      MOVW     R1,#+635
   \   0000006A   0x....             LDR.N    R0,??DataTable8_16
   \   0000006C   0x.... 0x....      BL       assert_failed
    636          
    637            /* Write the number of data units to be transferred */
    638            DMAy_Streamx->NDTR = (uint16_t)Counter;
   \                     ??DMA_SetCurrDataCounter_0: (+1)
   \   00000070   0x6065             STR      R5,[R4, #+4]
    639          }
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    640          
    641          /**
    642            * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
    643            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    644            *          to 7 to select the DMA Stream.
    645            * @retval The number of remaining data units in the current DMAy Streamx transfer.
    646            */

   \                                 In section .text, align 2, keep-with-next
    647          uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
    648          {
   \                     DMA_GetCurrDataCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    649            /* Check the parameters */
    650            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000004   0x....             LDR.N    R0,??DataTable8  ;; 0x40026010
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD031             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   0000000A   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40026028
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD02E             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000010   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40026040
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD02B             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000016   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40026058
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD028             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   0000001C   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40026070
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD025             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000022   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40026088
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD022             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000028   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400260a0
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD01F             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   0000002E   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400260b8
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD01C             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000034   0x....             LDR.N    R0,??DataTable8_8  ;; 0x40026410
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD019             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   0000003A   0x....             LDR.N    R0,??DataTable8_9  ;; 0x40026428
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD016             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000040   0x....             LDR.N    R0,??DataTable8_10  ;; 0x40026440
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD013             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000046   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40026458
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD010             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   0000004C   0x....             LDR.N    R0,??DataTable8_12  ;; 0x40026470
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD00D             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000052   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40026488
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD00A             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000058   0x....             LDR.N    R0,??DataTable8_14  ;; 0x400264a0
   \   0000005A   0x4284             CMP      R4,R0
   \   0000005C   0xD007             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   0000005E   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400264b8
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD004             BEQ.N    ??DMA_GetCurrDataCounter_0
   \   00000064   0xF240 0x218A      MOVW     R1,#+650
   \   00000068   0x....             LDR.N    R0,??DataTable8_16
   \   0000006A   0x.... 0x....      BL       assert_failed
    651          
    652            /* Return the number of remaining data units for DMAy Streamx */
    653            return ((uint16_t)(DMAy_Streamx->NDTR));
   \                     ??DMA_GetCurrDataCounter_0: (+1)
   \   0000006E   0x6860             LDR      R0,[R4, #+4]
   \   00000070   0xB280             UXTH     R0,R0
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
    654          }
    655          /**
    656            * @}
    657            */
    658          
    659          /** @defgroup DMA_Group3 Double Buffer mode functions
    660           *  @brief   Double Buffer mode functions 
    661           *
    662          @verbatim   
    663           ===============================================================================
    664                              ##### Double Buffer mode functions #####
    665           ===============================================================================  
    666              [..]
    667              This subsection provides function allowing to configure and control the double 
    668              buffer mode parameters.
    669              
    670              [..]
    671              The Double Buffer mode can be used only when Circular mode is enabled.
    672              The Double Buffer mode cannot be used when transferring data from Memory to Memory.
    673              
    674              [..]
    675              The Double Buffer mode allows to set two different Memory addresses from/to which
    676              the DMA controller will access alternatively (after completing transfer to/from 
    677              target memory 0, it will start transfer to/from target memory 1).
    678              This allows to reduce software overhead for double buffering and reduce the CPU
    679              access time.
    680              
    681              [..]
    682              Two functions must be called before calling the DMA_Init() function:
    683                (+) void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, 
    684                    uint32_t Memory1BaseAddr, uint32_t DMA_CurrentMemory);
    685                (+) void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
    686                
    687              [..]
    688              DMA_DoubleBufferModeConfig() is called to configure the Memory 1 base address 
    689              and the first Memory target from/to which the transfer will start after 
    690              enabling the DMA Stream. Then DMA_DoubleBufferModeCmd() must be called 
    691              to enable the Double Buffer mode (or disable it when it should not be used).
    692            
    693              [..]
    694              Two functions can be called dynamically when the transfer is ongoing (or when the DMA Stream is 
    695              stopped) to modify on of the target Memories addresses or to check wich Memory target is currently
    696              used:
    697                (+) void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, 
    698                          uint32_t MemoryBaseAddr, uint32_t DMA_MemoryTarget);
    699                (+) uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);
    700                
    701              [..]
    702              DMA_MemoryTargetConfig() can be called to modify the base address of one of 
    703              the two target Memories.
    704              The Memory of which the base address will be modified must not be currently 
    705              be used by the DMA Stream (ie. if the DMA Stream is currently transferring 
    706              from Memory 1 then you can only modify base address of target Memory 0 and vice versa).
    707              To check this condition, it is recommended to use the function DMA_GetCurrentMemoryTarget() which
    708              returns the index of the Memory target currently in use by the DMA Stream.
    709          
    710          @endverbatim
    711            * @{
    712            */
    713            
    714          /**
    715            * @brief  Configures, when the DMAy Streamx is disabled, the double buffer mode 
    716            *         and the current memory target.
    717            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    718            *          to 7 to select the DMA Stream.
    719            * @param  Memory1BaseAddr: the base address of the second buffer (Memory 1)  
    720            * @param  DMA_CurrentMemory: specifies which memory will be first buffer for
    721            *         the transactions when the Stream will be enabled. 
    722            *          This parameter can be one of the following values:
    723            *            @arg DMA_Memory_0: Memory 0 is the current buffer.
    724            *            @arg DMA_Memory_1: Memory 1 is the current buffer.  
    725            *       
    726            * @note   Memory0BaseAddr is set by the DMA structure configuration in DMA_Init().
    727            *   
    728            * @retval None
    729            */

   \                                 In section .text, align 2, keep-with-next
    730          void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
    731                                          uint32_t DMA_CurrentMemory)
    732          {  
   \                     DMA_DoubleBufferModeConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    733            /* Check the parameters */
    734            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000008   0x....             LDR.N    R0,??DataTable8  ;; 0x40026010
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD031             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40026028
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD02E             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable8_2  ;; 0x40026040
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD02B             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable8_3  ;; 0x40026058
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD028             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000020   0x....             LDR.N    R0,??DataTable8_4  ;; 0x40026070
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD025             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000026   0x....             LDR.N    R0,??DataTable8_5  ;; 0x40026088
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD022             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   0000002C   0x....             LDR.N    R0,??DataTable8_6  ;; 0x400260a0
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD01F             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000032   0x....             LDR.N    R0,??DataTable8_7  ;; 0x400260b8
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD01C             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000038   0x....             LDR.N    R0,??DataTable8_8  ;; 0x40026410
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD019             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   0000003E   0x....             LDR.N    R0,??DataTable8_9  ;; 0x40026428
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD016             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000044   0x....             LDR.N    R0,??DataTable8_10  ;; 0x40026440
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD013             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   0000004A   0x....             LDR.N    R0,??DataTable8_11  ;; 0x40026458
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD010             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000050   0x....             LDR.N    R0,??DataTable8_12  ;; 0x40026470
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xD00D             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000056   0x....             LDR.N    R0,??DataTable8_13  ;; 0x40026488
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD00A             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   0000005C   0x....             LDR.N    R0,??DataTable8_14  ;; 0x400264a0
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD007             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000062   0x....             LDR.N    R0,??DataTable8_15  ;; 0x400264b8
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD004             BEQ.N    ??DMA_DoubleBufferModeConfig_0
   \   00000068   0xF240 0x21DE      MOVW     R1,#+734
   \   0000006C   0x....             LDR.N    R0,??DataTable8_16
   \   0000006E   0x.... 0x....      BL       assert_failed
    735            assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));
   \                     ??DMA_DoubleBufferModeConfig_0: (+1)
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD007             BEQ.N    ??DMA_DoubleBufferModeConfig_1
   \   00000076   0xF5B6 0x2F00      CMP      R6,#+524288
   \   0000007A   0xD004             BEQ.N    ??DMA_DoubleBufferModeConfig_1
   \   0000007C   0xF240 0x21DF      MOVW     R1,#+735
   \   00000080   0x....             LDR.N    R0,??DataTable8_16
   \   00000082   0x.... 0x....      BL       assert_failed
    736          
    737            if (DMA_CurrentMemory != DMA_Memory_0)
   \                     ??DMA_DoubleBufferModeConfig_1: (+1)
   \   00000086   0x2E00             CMP      R6,#+0
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0xD003             BEQ.N    ??DMA_DoubleBufferModeConfig_2
    738            {
    739              /* Set Memory 1 as current memory address */
    740              DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
   \   0000008C   0xF440 0x2000      ORR      R0,R0,#0x80000
   \   00000090   0x6020             STR      R0,[R4, #+0]
   \   00000092   0xE002             B.N      ??DMA_DoubleBufferModeConfig_3
    741            }
    742            else
    743            {
    744              /* Set Memory 0 as current memory address */
    745              DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
   \                     ??DMA_DoubleBufferModeConfig_2: (+1)
   \   00000094   0xF420 0x2000      BIC      R0,R0,#0x80000
   \   00000098   0x6020             STR      R0,[R4, #+0]
    746            }
    747          
    748            /* Write to DMAy Streamx M1AR */
    749            DMAy_Streamx->M1AR = Memory1BaseAddr;
   \                     ??DMA_DoubleBufferModeConfig_3: (+1)
   \   0000009A   0x6125             STR      R5,[R4, #+16]
    750          }
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
    751          
    752          /**
    753            * @brief  Enables or disables the double buffer mode for the selected DMA stream.
    754            * @note   This function can be called only when the DMA Stream is disabled.  
    755            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    756            *          to 7 to select the DMA Stream.
    757            * @param  NewState: new state of the DMAy Streamx double buffer mode. 
    758            *          This parameter can be: ENABLE or DISABLE.
    759            * @retval None
    760            */

   \                                 In section .text, align 2, keep-with-next
    761          void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
    762          {  
   \                     DMA_DoubleBufferModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    763            /* Check the parameters */
    764            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40026010
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD041             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40026028
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD03D             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40026040
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD039             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40026058
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD035             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40026070
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD031             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x40026088
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD02D             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_7  ;; 0x400260a0
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD029             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x400260b8
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD025             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x40026410
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD021             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x40026428
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xD01D             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable16_11  ;; 0x40026440
   \   0000005A   0x4284             CMP      R4,R0
   \   0000005C   0xD019             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable16_12  ;; 0x40026458
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD015             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable16_13  ;; 0x40026470
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xD011             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable16_14  ;; 0x40026488
   \   00000072   0x4284             CMP      R4,R0
   \   00000074   0xD00D             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x400264a0
   \   0000007A   0x4284             CMP      R4,R0
   \   0000007C   0xD009             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable16_16  ;; 0x400264b8
   \   00000082   0x4284             CMP      R4,R0
   \   00000084   0xD005             BEQ.N    ??DMA_DoubleBufferModeCmd_0
   \   00000086   0xF44F 0x713F      MOV      R1,#+764
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000008E   0x.... 0x....      BL       assert_failed
    765            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DMA_DoubleBufferModeCmd_0: (+1)
   \   00000092   0x2D00             CMP      R5,#+0
   \   00000094   0xD007             BEQ.N    ??DMA_DoubleBufferModeCmd_1
   \   00000096   0x2D01             CMP      R5,#+1
   \   00000098   0xD005             BEQ.N    ??DMA_DoubleBufferModeCmd_1
   \   0000009A   0xF240 0x21FD      MOVW     R1,#+765
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000A2   0x.... 0x....      BL       assert_failed
    766          
    767            /* Configure the Double Buffer mode */
    768            if (NewState != DISABLE)
   \                     ??DMA_DoubleBufferModeCmd_1: (+1)
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0xD003             BEQ.N    ??DMA_DoubleBufferModeCmd_2
    769            {
    770              /* Enable the Double buffer mode */
    771              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
   \   000000AC   0xF440 0x2080      ORR      R0,R0,#0x40000
   \   000000B0   0x6020             STR      R0,[R4, #+0]
   \   000000B2   0xBD31             POP      {R0,R4,R5,PC}
    772            }
    773            else
    774            {
    775              /* Disable the Double buffer mode */
    776              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
   \                     ??DMA_DoubleBufferModeCmd_2: (+1)
   \   000000B4   0xF420 0x2080      BIC      R0,R0,#0x40000
   \   000000B8   0x6020             STR      R0,[R4, #+0]
    777            }
    778          }
   \   000000BA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    779          
    780          /**
    781            * @brief  Configures the Memory address for the next buffer transfer in double
    782            *         buffer mode (for dynamic use). This function can be called when the
    783            *         DMA Stream is enabled and when the transfer is ongoing.  
    784            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    785            *          to 7 to select the DMA Stream.
    786            * @param  MemoryBaseAddr: The base address of the target memory buffer
    787            * @param  DMA_MemoryTarget: Next memory target to be used. 
    788            *         This parameter can be one of the following values:
    789            *            @arg DMA_Memory_0: To use the memory address 0
    790            *            @arg DMA_Memory_1: To use the memory address 1
    791            * 
    792            * @note    It is not allowed to modify the Base Address of a target Memory when
    793            *          this target is involved in the current transfer. ie. If the DMA Stream
    794            *          is currently transferring to/from Memory 1, then it not possible to
    795            *          modify Base address of Memory 1, but it is possible to modify Base
    796            *          address of Memory 0.
    797            *          To know which Memory is currently used, you can use the function
    798            *          DMA_GetCurrentMemoryTarget().             
    799            *  
    800            * @retval None
    801            */

   \                                 In section .text, align 2, keep-with-next
    802          void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
    803                                     uint32_t DMA_MemoryTarget)
    804          {
   \                     DMA_MemoryTargetConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    805            /* Check the parameters */
    806            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40026010
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD041             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40026028
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD03D             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40026040
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD039             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40026058
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD035             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40026070
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD031             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x40026088
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD02D             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable16_7  ;; 0x400260a0
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD029             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x400260b8
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD025             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x40026410
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD021             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x40026428
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD01D             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16_11  ;; 0x40026440
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD019             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_12  ;; 0x40026458
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD015             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16_13  ;; 0x40026470
   \   0000006C   0x4284             CMP      R4,R0
   \   0000006E   0xD011             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16_14  ;; 0x40026488
   \   00000074   0x4284             CMP      R4,R0
   \   00000076   0xD00D             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x400264a0
   \   0000007C   0x4284             CMP      R4,R0
   \   0000007E   0xD009             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16_16  ;; 0x400264b8
   \   00000084   0x4284             CMP      R4,R0
   \   00000086   0xD005             BEQ.N    ??DMA_MemoryTargetConfig_0
   \   00000088   0xF240 0x3126      MOVW     R1,#+806
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000090   0x.... 0x....      BL       assert_failed
    807            assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
   \                     ??DMA_MemoryTargetConfig_0: (+1)
   \   00000094   0x2E00             CMP      R6,#+0
   \   00000096   0xD008             BEQ.N    ??DMA_MemoryTargetConfig_1
   \   00000098   0xF5B6 0x2F00      CMP      R6,#+524288
   \   0000009C   0xD005             BEQ.N    ??DMA_MemoryTargetConfig_1
   \   0000009E   0xF240 0x3127      MOVW     R1,#+807
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000A6   0x.... 0x....      BL       assert_failed
    808              
    809            /* Check the Memory target to be configured */
    810            if (DMA_MemoryTarget != DMA_Memory_0)
   \                     ??DMA_MemoryTargetConfig_1: (+1)
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD001             BEQ.N    ??DMA_MemoryTargetConfig_2
    811            {
    812              /* Write to DMAy Streamx M1AR */
    813              DMAy_Streamx->M1AR = MemoryBaseAddr;    
   \   000000AE   0x6125             STR      R5,[R4, #+16]
   \   000000B0   0xBD70             POP      {R4-R6,PC}
    814            }  
    815            else
    816            {
    817              /* Write to DMAy Streamx M0AR */
    818              DMAy_Streamx->M0AR = MemoryBaseAddr;  
   \                     ??DMA_MemoryTargetConfig_2: (+1)
   \   000000B2   0x60E5             STR      R5,[R4, #+12]
    819            }
    820          }
   \   000000B4   0xBD70             POP      {R4-R6,PC}       ;; return
    821          
    822          /**
    823            * @brief  Returns the current memory target used by double buffer transfer.
    824            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    825            *          to 7 to select the DMA Stream.
    826            * @retval The memory target number: 0 for Memory0 or 1 for Memory1. 
    827            */

   \                                 In section .text, align 2, keep-with-next
    828          uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
    829          {
   \                     DMA_GetCurrentMemoryTarget: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    830            uint32_t tmp = 0;
    831            
    832            /* Check the parameters */
    833            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40026010
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD041             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40026028
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD03D             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40026040
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD039             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40026058
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD035             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40026070
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD031             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x40026088
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD02D             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_7  ;; 0x400260a0
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD029             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x400260b8
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD025             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x40026410
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD021             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x40026428
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD01D             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16_11  ;; 0x40026440
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD019             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable16_12  ;; 0x40026458
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD015             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_13  ;; 0x40026470
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD011             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16_14  ;; 0x40026488
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD00D             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x400264a0
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD009             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16_16  ;; 0x400264b8
   \   00000080   0x4284             CMP      R4,R0
   \   00000082   0xD005             BEQ.N    ??DMA_GetCurrentMemoryTarget_0
   \   00000084   0xF240 0x3141      MOVW     R1,#+833
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000008C   0x.... 0x....      BL       assert_failed
    834          
    835            /* Get the current memory target */
    836            if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
   \                     ??DMA_GetCurrentMemoryTarget_0: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
    837            {
    838              /* Current memory buffer used is Memory 1 */
    839              tmp = 1;
    840            }  
    841            else
    842            {
    843              /* Current memory buffer used is Memory 0 */
    844              tmp = 0;    
   \   00000092   0x0CC0             LSRS     R0,R0,#+19
   \   00000094   0xF000 0x0001      AND      R0,R0,#0x1
    845            }
    846            return tmp;
   \   00000098   0xBD10             POP      {R4,PC}          ;; return
    847          }
    848          /**
    849            * @}
    850            */
    851          
    852          /** @defgroup DMA_Group4 Interrupts and flags management functions
    853           *  @brief   Interrupts and flags management functions 
    854           *
    855          @verbatim   
    856           ===============================================================================
    857                        ##### Interrupts and flags management functions #####
    858           ===============================================================================  
    859              [..]
    860              This subsection provides functions allowing to
    861                (+) Check the DMA enable status
    862                (+) Check the FIFO status 
    863                (+) Configure the DMA Interrupts sources and check or clear the flags or 
    864                    pending bits status.  
    865                     
    866              [..]
    867                (#) DMA Enable status:
    868                    After configuring the DMA Stream (DMA_Init() function) and enabling 
    869                    the stream, it is recommended to check (or wait until) the DMA Stream 
    870                    is effectively enabled. A Stream may remain disabled if a configuration 
    871                    parameter is wrong. After disabling a DMA Stream, it is also recommended 
    872                    to check (or wait until) the DMA Stream is effectively disabled. 
    873                    If a Stream is disabled while a data transfer is ongoing, the current 
    874                    data will be transferred and the Stream will be effectively disabled 
    875                    only after this data transfer completion.
    876                    To monitor this state it is possible to use the following function:
    877                  (++) FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
    878           
    879                (#) FIFO Status:
    880                    It is possible to monitor the FIFO status when a transfer is ongoing 
    881                    using the following function:
    882                  (++) uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
    883           
    884                (#) DMA Interrupts and Flags:
    885                    The user should identify which mode will be used in his application 
    886                    to manage the DMA controller events: Polling mode or Interrupt mode. 
    887              
    888              *** Polling Mode ***
    889              ====================
    890              [..]
    891              Each DMA stream can be managed through 4 event Flags:
    892              (x : DMA Stream number )
    893                (#) DMA_FLAG_FEIFx  : to indicate that a FIFO Mode Transfer Error event occurred.
    894                (#) DMA_FLAG_DMEIFx : to indicate that a Direct Mode Transfer Error event occurred.
    895                (#) DMA_FLAG_TEIFx  : to indicate that a Transfer Error event occurred.
    896                (#) DMA_FLAG_HTIFx  : to indicate that a Half-Transfer Complete event occurred.
    897                (#) DMA_FLAG_TCIFx  : to indicate that a Transfer Complete event occurred .       
    898              [..]
    899              In this Mode it is advised to use the following functions:
    900                (+) FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    901                (+) void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    902          
    903              *** Interrupt Mode ***
    904              ======================
    905              [..]
    906              Each DMA Stream can be managed through 4 Interrupts:
    907          
    908              *** Interrupt Source ***
    909              ========================
    910              [..]
    911                (#) DMA_IT_FEIFx  : specifies the interrupt source for the  FIFO Mode Transfer Error event.
    912                (#) DMA_IT_DMEIFx : specifies the interrupt source for the Direct Mode Transfer Error event.
    913                (#) DMA_IT_TEIFx  : specifies the interrupt source for the Transfer Error event.
    914                (#) DMA_IT_HTIFx  : specifies the interrupt source for the Half-Transfer Complete event.
    915                (#) DMA_IT_TCIFx  : specifies the interrupt source for the a Transfer Complete event. 
    916              [..]
    917              In this Mode it is advised to use the following functions:
    918                (+) void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);
    919                (+) ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
    920                (+) void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
    921          
    922          @endverbatim
    923            * @{
    924            */
    925          
    926          /**
    927            * @brief  Returns the status of EN bit for the specified DMAy Streamx.
    928            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    929            *          to 7 to select the DMA Stream.
    930            *   
    931            * @note    After configuring the DMA Stream (DMA_Init() function) and enabling
    932            *          the stream, it is recommended to check (or wait until) the DMA Stream
    933            *          is effectively enabled. A Stream may remain disabled if a configuration
    934            *          parameter is wrong.
    935            *          After disabling a DMA Stream, it is also recommended to check (or wait 
    936            *          until) the DMA Stream is effectively disabled. If a Stream is disabled
    937            *          while a data transfer is ongoing, the current data will be transferred
    938            *          and the Stream will be effectively disabled only after the transfer
    939            *          of this single data is finished.  
    940            *      
    941            * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
    942            */

   \                                 In section .text, align 2, keep-with-next
    943          FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
    944          {
   \                     DMA_GetCmdStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    945            FunctionalState state = DISABLE;
    946          
    947            /* Check the parameters */
    948            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40026010
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD041             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40026028
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD03D             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40026040
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD039             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40026058
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD035             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40026070
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD031             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x40026088
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD02D             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_7  ;; 0x400260a0
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD029             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x400260b8
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD025             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x40026410
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD021             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x40026428
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD01D             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16_11  ;; 0x40026440
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD019             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable16_12  ;; 0x40026458
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD015             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_13  ;; 0x40026470
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD011             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16_14  ;; 0x40026488
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD00D             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x400264a0
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD009             BEQ.N    ??DMA_GetCmdStatus_0
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16_16  ;; 0x400264b8
   \   00000080   0x4284             CMP      R4,R0
   \   00000082   0xD005             BEQ.N    ??DMA_GetCmdStatus_0
   \   00000084   0xF44F 0x716D      MOV      R1,#+948
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000008C   0x.... 0x....      BL       assert_failed
    949          
    950            if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
   \                     ??DMA_GetCmdStatus_0: (+1)
   \   00000090   0x6820             LDR      R0,[R4, #+0]
    951            {
    952              /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
    953              state = ENABLE;
    954            }
    955            else
    956            {
    957              /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
    958                  all transfers are complete) */
    959              state = DISABLE;
   \   00000092   0xF000 0x0001      AND      R0,R0,#0x1
    960            }
    961            return state;
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
    962          }
    963          
    964          /**
    965            * @brief  Returns the current DMAy Streamx FIFO filled level.
    966            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0 
    967            *         to 7 to select the DMA Stream.
    968            * @retval The FIFO filling state.
    969            *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
    970            *                                               and not empty.
    971            *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
    972            *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
    973            *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
    974            *           - DMA_FIFOStatus_Empty: when FIFO is empty
    975            *           - DMA_FIFOStatus_Full: when FIFO is full
    976            */

   \                                 In section .text, align 2, keep-with-next
    977          uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
    978          {
   \                     DMA_GetFIFOStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    979            uint32_t tmpreg = 0;
    980           
    981            /* Check the parameters */
    982            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40026010
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD041             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40026028
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD03D             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40026040
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD039             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40026058
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD035             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40026070
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD031             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x40026088
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD02D             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_7  ;; 0x400260a0
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD029             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x400260b8
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD025             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x40026410
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD021             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x40026428
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD01D             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable16_11  ;; 0x40026440
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD019             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable16_12  ;; 0x40026458
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD015             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_13  ;; 0x40026470
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD011             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable16_14  ;; 0x40026488
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD00D             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x400264a0
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD009             BEQ.N    ??DMA_GetFIFOStatus_0
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x400264b8
   \   00000080   0x4284             CMP      R4,R0
   \   00000082   0xD005             BEQ.N    ??DMA_GetFIFOStatus_0
   \   00000084   0xF240 0x31D6      MOVW     R1,#+982
   \   00000088   0x.... 0x....      ADR.W    R0,?_0
   \   0000008C   0x.... 0x....      BL       assert_failed
    983            
    984            /* Get the FIFO level bits */
    985            tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
   \                     ??DMA_GetFIFOStatus_0: (+1)
   \   00000090   0x6960             LDR      R0,[R4, #+20]
   \   00000092   0xF000 0x0038      AND      R0,R0,#0x38
    986            
    987            return tmpreg;
   \   00000096   0xBD10             POP      {R4,PC}          ;; return
    988          }
    989          
    990          /**
    991            * @brief  Checks whether the specified DMAy Streamx flag is set or not.
    992            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    993            *          to 7 to select the DMA Stream.
    994            * @param  DMA_FLAG: specifies the flag to check.
    995            *          This parameter can be one of the following values:
    996            *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
    997            *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
    998            *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
    999            *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
   1000            *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
   1001            *         Where x can be 0 to 7 to select the DMA Stream.
   1002            * @retval The new state of DMA_FLAG (SET or RESET).
   1003            */

   \                                 In section .text, align 2, keep-with-next
   1004          FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
   1005          {
   \                     DMA_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1006            FlagStatus bitstatus = RESET;
   \   00000006   0x2500             MOVS     R5,#+0
   1007            DMA_TypeDef* DMAy;
   1008            uint32_t tmpreg = 0;
   1009          
   1010            /* Check the parameters */
   1011            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40026010
   \   0000000C   0x4286             CMP      R6,R0
   \   0000000E   0xD041             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x40026028
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xD03D             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_3  ;; 0x40026040
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xD039             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x40026058
   \   00000024   0x4286             CMP      R6,R0
   \   00000026   0xD035             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_5  ;; 0x40026070
   \   0000002C   0x4286             CMP      R6,R0
   \   0000002E   0xD031             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16_6  ;; 0x40026088
   \   00000034   0x4286             CMP      R6,R0
   \   00000036   0xD02D             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable16_7  ;; 0x400260a0
   \   0000003C   0x4286             CMP      R6,R0
   \   0000003E   0xD029             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16_8  ;; 0x400260b8
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xD025             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x40026410
   \   0000004C   0x4286             CMP      R6,R0
   \   0000004E   0xD021             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x40026428
   \   00000054   0x4286             CMP      R6,R0
   \   00000056   0xD01D             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16_11  ;; 0x40026440
   \   0000005C   0x4286             CMP      R6,R0
   \   0000005E   0xD019             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_12  ;; 0x40026458
   \   00000064   0x4286             CMP      R6,R0
   \   00000066   0xD015             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable16_13  ;; 0x40026470
   \   0000006C   0x4286             CMP      R6,R0
   \   0000006E   0xD011             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable16_14  ;; 0x40026488
   \   00000074   0x4286             CMP      R6,R0
   \   00000076   0xD00D             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x400264a0
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xD009             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16_16  ;; 0x400264b8
   \   00000084   0x4286             CMP      R6,R0
   \   00000086   0xD005             BEQ.N    ??DMA_GetFlagStatus_0
   \   00000088   0xF240 0x31F3      MOVW     R1,#+1011
   \   0000008C   0x.... 0x....      ADR.W    R0,?_0
   \   00000090   0x.... 0x....      BL       assert_failed
   1012            assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
   \                     ??DMA_GetFlagStatus_0: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x10000020
   \   00000098   0x4284             CMP      R4,R0
   \   0000009A   0xF000 0x809D      BEQ.W    ??DMA_GetFlagStatus_1
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x10000010
   \   000000A2   0x4284             CMP      R4,R0
   \   000000A4   0xF000 0x8098      BEQ.W    ??DMA_GetFlagStatus_1
   \   000000A8   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x10000008
   \   000000AC   0x4284             CMP      R4,R0
   \   000000AE   0xF000 0x8093      BEQ.W    ??DMA_GetFlagStatus_1
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable18_5  ;; 0x10800004
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xF000 0x808E      BEQ.W    ??DMA_GetFlagStatus_1
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable18_6  ;; 0x10800001
   \   000000C0   0x4284             CMP      R4,R0
   \   000000C2   0xF000 0x8089      BEQ.W    ??DMA_GetFlagStatus_1
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable18_7  ;; 0x10000800
   \   000000CA   0x4284             CMP      R4,R0
   \   000000CC   0xF000 0x8084      BEQ.W    ??DMA_GetFlagStatus_1
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable18_8  ;; 0x10000400
   \   000000D4   0x4284             CMP      R4,R0
   \   000000D6   0xF000 0x807F      BEQ.W    ??DMA_GetFlagStatus_1
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable18_9  ;; 0x10000200
   \   000000DE   0x4284             CMP      R4,R0
   \   000000E0   0xD07A             BEQ.N    ??DMA_GetFlagStatus_1
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable18_10  ;; 0x10000100
   \   000000E6   0x4284             CMP      R4,R0
   \   000000E8   0xD076             BEQ.N    ??DMA_GetFlagStatus_1
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable18_11  ;; 0x10000040
   \   000000EE   0x4284             CMP      R4,R0
   \   000000F0   0xD072             BEQ.N    ??DMA_GetFlagStatus_1
   \   000000F2   0xF1B4 0x5F81      CMP      R4,#+270532608
   \   000000F6   0xD06F             BEQ.N    ??DMA_GetFlagStatus_1
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable18_12  ;; 0x10100000
   \   000000FC   0x4284             CMP      R4,R0
   \   000000FE   0xD06B             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000100   0x.... 0x....      LDR.W    R0,??DataTable18_13  ;; 0x10080000
   \   00000104   0x4284             CMP      R4,R0
   \   00000106   0xD067             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable18_14  ;; 0x10040000
   \   0000010C   0x4284             CMP      R4,R0
   \   0000010E   0xD063             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable18_15  ;; 0x10010000
   \   00000114   0x4284             CMP      R4,R0
   \   00000116   0xD05F             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000118   0xF1B4 0x5FC0      CMP      R4,#+402653184
   \   0000011C   0xD05C             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000011E   0xF1B4 0x5FA0      CMP      R4,#+335544320
   \   00000122   0xD059             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000124   0xF1B4 0x5F90      CMP      R4,#+301989888
   \   00000128   0xD056             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000012A   0xF1B4 0x5F88      CMP      R4,#+285212672
   \   0000012E   0xD053             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000130   0xF1B4 0x5F82      CMP      R4,#+272629760
   \   00000134   0xD050             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable18_16  ;; 0x20000020
   \   0000013A   0x4284             CMP      R4,R0
   \   0000013C   0xD04C             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable18_17  ;; 0x20000010
   \   00000142   0x4284             CMP      R4,R0
   \   00000144   0xD048             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable18_18  ;; 0x20000008
   \   0000014A   0x4284             CMP      R4,R0
   \   0000014C   0xD044             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable18_19  ;; 0x20000004
   \   00000152   0x4284             CMP      R4,R0
   \   00000154   0xD040             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000156   0x.... 0x....      LDR.W    R0,??DataTable18_20  ;; 0x20000001
   \   0000015A   0x4284             CMP      R4,R0
   \   0000015C   0xD03C             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000015E   0x.... 0x....      LDR.W    R0,??DataTable18_21  ;; 0x20000800
   \   00000162   0x4284             CMP      R4,R0
   \   00000164   0xD038             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable18_22  ;; 0x20000400
   \   0000016A   0x4284             CMP      R4,R0
   \   0000016C   0xD034             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable18_23  ;; 0x20000200
   \   00000172   0x4284             CMP      R4,R0
   \   00000174   0xD030             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable18_24  ;; 0x20000100
   \   0000017A   0x4284             CMP      R4,R0
   \   0000017C   0xD02C             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable18_25  ;; 0x20000040
   \   00000182   0x4284             CMP      R4,R0
   \   00000184   0xD028             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000186   0x.... 0x....      LDR.W    R0,??DataTable18_26  ;; 0x20200000
   \   0000018A   0x4284             CMP      R4,R0
   \   0000018C   0xD024             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000018E   0x.... 0x....      LDR.W    R0,??DataTable18_27  ;; 0x20100000
   \   00000192   0x4284             CMP      R4,R0
   \   00000194   0xD020             BEQ.N    ??DMA_GetFlagStatus_1
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable18_28  ;; 0x20080000
   \   0000019A   0x4284             CMP      R4,R0
   \   0000019C   0xD01C             BEQ.N    ??DMA_GetFlagStatus_1
   \   0000019E   0x.... 0x....      LDR.W    R0,??DataTable18_29  ;; 0x20040000
   \   000001A2   0x4284             CMP      R4,R0
   \   000001A4   0xD018             BEQ.N    ??DMA_GetFlagStatus_1
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable18_30  ;; 0x20010000
   \   000001AA   0x4284             CMP      R4,R0
   \   000001AC   0xD014             BEQ.N    ??DMA_GetFlagStatus_1
   \   000001AE   0xF1B4 0x5F20      CMP      R4,#+671088640
   \   000001B2   0xD011             BEQ.N    ??DMA_GetFlagStatus_1
   \   000001B4   0xF1B4 0x5F10      CMP      R4,#+603979776
   \   000001B8   0xD00E             BEQ.N    ??DMA_GetFlagStatus_1
   \   000001BA   0xF1B4 0x5F08      CMP      R4,#+570425344
   \   000001BE   0xD00B             BEQ.N    ??DMA_GetFlagStatus_1
   \   000001C0   0xF1B4 0x5F04      CMP      R4,#+553648128
   \   000001C4   0xD008             BEQ.N    ??DMA_GetFlagStatus_1
   \   000001C6   0xF1B4 0x5F01      CMP      R4,#+541065216
   \   000001CA   0xD005             BEQ.N    ??DMA_GetFlagStatus_1
   \   000001CC   0xF44F 0x717D      MOV      R1,#+1012
   \   000001D0   0x.... 0x....      ADR.W    R0,?_0
   \   000001D4   0x.... 0x....      BL       assert_failed
   1013          
   1014            /* Determine the DMA to which belongs the stream */
   1015            if (DMAy_Streamx < DMA2_Stream0)
   \                     ??DMA_GetFlagStatus_1: (+1)
   \   000001D8   0x....             LDR.N    R0,??DataTable16_9  ;; 0x40026410
   \   000001DA   0x4286             CMP      R6,R0
   \   000001DC   0xD202             BCS.N    ??DMA_GetFlagStatus_2
   1016            {
   1017              /* DMAy_Streamx belongs to DMA1 */
   1018              DMAy = DMA1; 
   \   000001DE   0x.... 0x....      LDR.W    R0,??DataTable18_31  ;; 0x40026000
   \   000001E2   0xE001             B.N      ??DMA_GetFlagStatus_3
   1019            } 
   1020            else 
   1021            {
   1022              /* DMAy_Streamx belongs to DMA2 */
   1023              DMAy = DMA2; 
   \                     ??DMA_GetFlagStatus_2: (+1)
   \   000001E4   0x.... 0x....      LDR.W    R0,??DataTable18_32  ;; 0x40026400
   1024            }
   1025          
   1026            /* Check if the flag is in HISR or LISR */
   1027            if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
   \                     ??DMA_GetFlagStatus_3: (+1)
   \   000001E8   0x00A1             LSLS     R1,R4,#+2
   \   000001EA   0xD501             BPL.N    ??DMA_GetFlagStatus_4
   1028            {
   1029              /* Get DMAy HISR register value */
   1030              tmpreg = DMAy->HISR;
   \   000001EC   0x6840             LDR      R0,[R0, #+4]
   \   000001EE   0xE000             B.N      ??DMA_GetFlagStatus_5
   1031            }
   1032            else
   1033            {
   1034              /* Get DMAy LISR register value */
   1035              tmpreg = DMAy->LISR;
   \                     ??DMA_GetFlagStatus_4: (+1)
   \   000001F0   0x6800             LDR      R0,[R0, #+0]
   1036            }   
   1037           
   1038            /* Mask the reserved bits */
   1039            tmpreg &= (uint32_t)RESERVED_MASK;
   1040          
   1041            /* Check the status of the specified DMA flag */
   1042            if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
   \                     ??DMA_GetFlagStatus_5: (+1)
   \   000001F2   0x4020             ANDS     R0,R4,R0
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable18_33  ;; 0xf7d0f7d
   \   000001F8   0x4208             TST      R0,R1
   \   000001FA   0xD000             BEQ.N    ??DMA_GetFlagStatus_6
   1043            {
   1044              /* DMA_FLAG is set */
   1045              bitstatus = SET;
   \   000001FC   0x2501             MOVS     R5,#+1
   1046            }
   1047            else
   1048            {
   1049              /* DMA_FLAG is reset */
   1050              bitstatus = RESET;
   1051            }
   1052          
   1053            /* Return the DMA_FLAG status */
   1054            return  bitstatus;
   \                     ??DMA_GetFlagStatus_6: (+1)
   \   000001FE   0x4628             MOV      R0,R5
   \   00000200   0xBD70             POP      {R4-R6,PC}       ;; return
   1055          }
   1056          
   1057          /**
   1058            * @brief  Clears the DMAy Streamx's pending flags.
   1059            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1060            *          to 7 to select the DMA Stream.
   1061            * @param  DMA_FLAG: specifies the flag to clear.
   1062            *          This parameter can be any combination of the following values:
   1063            *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
   1064            *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
   1065            *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
   1066            *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
   1067            *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
   1068            *         Where x can be 0 to 7 to select the DMA Stream.   
   1069            * @retval None
   1070            */

   \                                 In section .text, align 2, keep-with-next
   1071          void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
   1072          {
   \                     DMA_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   1073            DMA_TypeDef* DMAy;
   1074          
   1075            /* Check the parameters */
   1076            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40026010
   \   00000008   0x4285             CMP      R5,R0
   \   0000000A   0xD032             BEQ.N    ??DMA_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40026028
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD02F             BEQ.N    ??DMA_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable16_3  ;; 0x40026040
   \   00000014   0x4285             CMP      R5,R0
   \   00000016   0xD02C             BEQ.N    ??DMA_ClearFlag_0
   \   00000018   0x....             LDR.N    R0,??DataTable16_4  ;; 0x40026058
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xD029             BEQ.N    ??DMA_ClearFlag_0
   \   0000001E   0x....             LDR.N    R0,??DataTable16_5  ;; 0x40026070
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD026             BEQ.N    ??DMA_ClearFlag_0
   \   00000024   0x....             LDR.N    R0,??DataTable16_6  ;; 0x40026088
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD023             BEQ.N    ??DMA_ClearFlag_0
   \   0000002A   0x....             LDR.N    R0,??DataTable16_7  ;; 0x400260a0
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD020             BEQ.N    ??DMA_ClearFlag_0
   \   00000030   0x....             LDR.N    R0,??DataTable16_8  ;; 0x400260b8
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD01D             BEQ.N    ??DMA_ClearFlag_0
   \   00000036   0x....             LDR.N    R0,??DataTable16_9  ;; 0x40026410
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD01A             BEQ.N    ??DMA_ClearFlag_0
   \   0000003C   0x....             LDR.N    R0,??DataTable16_10  ;; 0x40026428
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD017             BEQ.N    ??DMA_ClearFlag_0
   \   00000042   0x....             LDR.N    R0,??DataTable16_11  ;; 0x40026440
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xD014             BEQ.N    ??DMA_ClearFlag_0
   \   00000048   0x....             LDR.N    R0,??DataTable16_12  ;; 0x40026458
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0xD011             BEQ.N    ??DMA_ClearFlag_0
   \   0000004E   0x....             LDR.N    R0,??DataTable16_13  ;; 0x40026470
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD00E             BEQ.N    ??DMA_ClearFlag_0
   \   00000054   0x....             LDR.N    R0,??DataTable16_14  ;; 0x40026488
   \   00000056   0x4285             CMP      R5,R0
   \   00000058   0xD00B             BEQ.N    ??DMA_ClearFlag_0
   \   0000005A   0x....             LDR.N    R0,??DataTable16_15  ;; 0x400264a0
   \   0000005C   0x4285             CMP      R5,R0
   \   0000005E   0xD008             BEQ.N    ??DMA_ClearFlag_0
   \   00000060   0x....             LDR.N    R0,??DataTable16_16  ;; 0x400264b8
   \   00000062   0x4285             CMP      R5,R0
   \   00000064   0xD005             BEQ.N    ??DMA_ClearFlag_0
   \   00000066   0xF240 0x4134      MOVW     R1,#+1076
   \   0000006A   0x.... 0x....      ADR.W    R0,?_0
   \   0000006E   0x.... 0x....      BL       assert_failed
   1077            assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
   \                     ??DMA_ClearFlag_0: (+1)
   \   00000072   0xF004 0x5040      AND      R0,R4,#0x30000000
   \   00000076   0xF1B0 0x5F40      CMP      R0,#+805306368
   \   0000007A   0xD008             BEQ.N    ??DMA_ClearFlag_1
   \   0000007C   0xF014 0x5F40      TST      R4,#0x30000000
   \   00000080   0xD005             BEQ.N    ??DMA_ClearFlag_1
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable18_34  ;; 0xc002f082
   \   00000086   0x4204             TST      R4,R0
   \   00000088   0xD101             BNE.N    ??DMA_ClearFlag_1
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD105             BNE.N    ??DMA_ClearFlag_2
   \                     ??DMA_ClearFlag_1: (+1)
   \   0000008E   0xF240 0x4135      MOVW     R1,#+1077
   \   00000092   0x.... 0x....      ADR.W    R0,?_0
   \   00000096   0x.... 0x....      BL       assert_failed
   1078          
   1079            /* Determine the DMA to which belongs the stream */
   1080            if (DMAy_Streamx < DMA2_Stream0)
   \                     ??DMA_ClearFlag_2: (+1)
   \   0000009A   0x....             LDR.N    R0,??DataTable16_9  ;; 0x40026410
   \   0000009C   0x4285             CMP      R5,R0
   \   0000009E   0xD202             BCS.N    ??DMA_ClearFlag_3
   1081            {
   1082              /* DMAy_Streamx belongs to DMA1 */
   1083              DMAy = DMA1; 
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable18_31  ;; 0x40026000
   \   000000A4   0xE001             B.N      ??DMA_ClearFlag_4
   1084            } 
   1085            else 
   1086            {
   1087              /* DMAy_Streamx belongs to DMA2 */
   1088              DMAy = DMA2; 
   \                     ??DMA_ClearFlag_3: (+1)
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable18_32  ;; 0x40026400
   \                     ??DMA_ClearFlag_4: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable18_33  ;; 0xf7d0f7d
   \   000000AE   0x4021             ANDS     R1,R1,R4
   \   000000B0   0x00A2             LSLS     R2,R4,#+2
   \   000000B2   0xD501             BPL.N    ??DMA_ClearFlag_5
   1089            }
   1090          
   1091            /* Check if LIFCR or HIFCR register is targeted */
   1092            if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
   1093            {
   1094              /* Set DMAy HIFCR register clear flag bits */
   1095              DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
   \   000000B4   0x60C1             STR      R1,[R0, #+12]
   \   000000B6   0xBD31             POP      {R0,R4,R5,PC}
   1096            }
   1097            else 
   1098            {
   1099              /* Set DMAy LIFCR register clear flag bits */
   1100              DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
   \                     ??DMA_ClearFlag_5: (+1)
   \   000000B8   0x6081             STR      R1,[R0, #+8]
   1101            }    
   1102          }
   \   000000BA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1103          
   1104          /**
   1105            * @brief  Enables or disables the specified DMAy Streamx interrupts.
   1106            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1107            *          to 7 to select the DMA Stream.
   1108            * @param DMA_IT: specifies the DMA interrupt sources to be enabled or disabled. 
   1109            *          This parameter can be any combination of the following values:
   1110            *            @arg DMA_IT_TC:  Transfer complete interrupt mask
   1111            *            @arg DMA_IT_HT:  Half transfer complete interrupt mask
   1112            *            @arg DMA_IT_TE:  Transfer error interrupt mask
   1113            *            @arg DMA_IT_FE:  FIFO error interrupt mask
   1114            * @param  NewState: new state of the specified DMA interrupts.
   1115            *          This parameter can be: ENABLE or DISABLE.
   1116            * @retval None
   1117            */

   \                                 In section .text, align 2, keep-with-next
   1118          void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
   1119          {
   \                     DMA_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   1120            /* Check the parameters */
   1121            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000008   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40026010
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD033             BEQ.N    ??DMA_ITConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable16_2  ;; 0x40026028
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD030             BEQ.N    ??DMA_ITConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable16_3  ;; 0x40026040
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD02D             BEQ.N    ??DMA_ITConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable16_4  ;; 0x40026058
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD02A             BEQ.N    ??DMA_ITConfig_0
   \   00000020   0x....             LDR.N    R0,??DataTable16_5  ;; 0x40026070
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD027             BEQ.N    ??DMA_ITConfig_0
   \   00000026   0x....             LDR.N    R0,??DataTable16_6  ;; 0x40026088
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD024             BEQ.N    ??DMA_ITConfig_0
   \   0000002C   0x....             LDR.N    R0,??DataTable16_7  ;; 0x400260a0
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD021             BEQ.N    ??DMA_ITConfig_0
   \   00000032   0x....             LDR.N    R0,??DataTable16_8  ;; 0x400260b8
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD01E             BEQ.N    ??DMA_ITConfig_0
   \   00000038   0x....             LDR.N    R0,??DataTable16_9  ;; 0x40026410
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD01B             BEQ.N    ??DMA_ITConfig_0
   \   0000003E   0x....             LDR.N    R0,??DataTable16_10  ;; 0x40026428
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD018             BEQ.N    ??DMA_ITConfig_0
   \   00000044   0x....             LDR.N    R0,??DataTable16_11  ;; 0x40026440
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD015             BEQ.N    ??DMA_ITConfig_0
   \   0000004A   0x....             LDR.N    R0,??DataTable16_12  ;; 0x40026458
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD012             BEQ.N    ??DMA_ITConfig_0
   \   00000050   0x....             LDR.N    R0,??DataTable16_13  ;; 0x40026470
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xD00F             BEQ.N    ??DMA_ITConfig_0
   \   00000056   0x....             LDR.N    R0,??DataTable16_14  ;; 0x40026488
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD00C             BEQ.N    ??DMA_ITConfig_0
   \   0000005C   0x....             LDR.N    R0,??DataTable16_15  ;; 0x400264a0
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD009             BEQ.N    ??DMA_ITConfig_0
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable18_1  ;; 0x400264b8
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD005             BEQ.N    ??DMA_ITConfig_0
   \   0000006A   0xF240 0x4161      MOVW     R1,#+1121
   \   0000006E   0x.... 0x....      ADR.W    R0,?_0
   \   00000072   0x.... 0x....      BL       assert_failed
   1122            assert_param(IS_DMA_CONFIG_IT(DMA_IT));
   \                     ??DMA_ITConfig_0: (+1)
   \   00000076   0xF036 0x009E      BICS     R0,R6,#0x9E
   \   0000007A   0xD101             BNE.N    ??DMA_ITConfig_1
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD105             BNE.N    ??DMA_ITConfig_2
   \                     ??DMA_ITConfig_1: (+1)
   \   00000080   0xF240 0x4162      MOVW     R1,#+1122
   \   00000084   0x.... 0x....      ADR.W    R0,?_0
   \   00000088   0x.... 0x....      BL       assert_failed
   1123            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??DMA_ITConfig_2: (+1)
   \   0000008C   0x2D00             CMP      R5,#+0
   \   0000008E   0xD007             BEQ.N    ??DMA_ITConfig_3
   \   00000090   0x2D01             CMP      R5,#+1
   \   00000092   0xD005             BEQ.N    ??DMA_ITConfig_3
   \   00000094   0xF240 0x4163      MOVW     R1,#+1123
   \   00000098   0x.... 0x....      ADR.W    R0,?_0
   \   0000009C   0x.... 0x....      BL       assert_failed
   1124          
   1125            /* Check if the DMA_IT parameter contains a FIFO interrupt */
   1126            if ((DMA_IT & DMA_IT_FE) != 0)
   \                     ??DMA_ITConfig_3: (+1)
   \   000000A0   0x0630             LSLS     R0,R6,#+24
   \   000000A2   0xD509             BPL.N    ??DMA_ITConfig_4
   1127            {
   1128              if (NewState != DISABLE)
   \   000000A4   0x2D00             CMP      R5,#+0
   \   000000A6   0x6960             LDR      R0,[R4, #+20]
   \   000000A8   0xD003             BEQ.N    ??DMA_ITConfig_5
   1129              {
   1130                /* Enable the selected DMA FIFO interrupts */
   1131                DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
   \   000000AA   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000AE   0x6160             STR      R0,[R4, #+20]
   \   000000B0   0xE002             B.N      ??DMA_ITConfig_4
   1132              }    
   1133              else 
   1134              {
   1135                /* Disable the selected DMA FIFO interrupts */
   1136                DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
   \                     ??DMA_ITConfig_5: (+1)
   \   000000B2   0xF020 0x0080      BIC      R0,R0,#0x80
   \   000000B6   0x6160             STR      R0,[R4, #+20]
   1137              }
   1138            }
   1139          
   1140            /* Check if the DMA_IT parameter contains a Transfer interrupt */
   1141            if (DMA_IT != DMA_IT_FE)
   \                     ??DMA_ITConfig_4: (+1)
   \   000000B8   0x2E80             CMP      R6,#+128
   \   000000BA   0xD00A             BEQ.N    ??DMA_ITConfig_6
   1142            {
   1143              if (NewState != DISABLE)
   \   000000BC   0xF006 0x001E      AND      R0,R6,#0x1E
   \   000000C0   0x2D00             CMP      R5,#+0
   \   000000C2   0x6821             LDR      R1,[R4, #+0]
   \   000000C4   0xD002             BEQ.N    ??DMA_ITConfig_7
   1144              {
   1145                /* Enable the selected DMA transfer interrupts */
   1146                DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
   \   000000C6   0x4308             ORRS     R0,R0,R1
   \   000000C8   0x6020             STR      R0,[R4, #+0]
   \   000000CA   0xBD70             POP      {R4-R6,PC}
   1147              }
   1148              else
   1149              {
   1150                /* Disable the selected DMA transfer interrupts */
   1151                DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
   \                     ??DMA_ITConfig_7: (+1)
   \   000000CC   0xEA21 0x0000      BIC      R0,R1,R0
   \   000000D0   0x6020             STR      R0,[R4, #+0]
   1152              }    
   1153            }
   1154          }
   \                     ??DMA_ITConfig_6: (+1)
   \   000000D2   0xBD70             POP      {R4-R6,PC}       ;; return
   1155          
   1156          /**
   1157            * @brief  Checks whether the specified DMAy Streamx interrupt has occurred or not.
   1158            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1159            *          to 7 to select the DMA Stream.
   1160            * @param  DMA_IT: specifies the DMA interrupt source to check.
   1161            *          This parameter can be one of the following values:
   1162            *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
   1163            *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
   1164            *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
   1165            *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
   1166            *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
   1167            *         Where x can be 0 to 7 to select the DMA Stream.
   1168            * @retval The new state of DMA_IT (SET or RESET).
   1169            */

   \                                 In section .text, align 2, keep-with-next
   1170          ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
   1171          {
   \                     DMA_GetITStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1172            ITStatus bitstatus = RESET;
   \   00000006   0x2500             MOVS     R5,#+0
   1173            DMA_TypeDef* DMAy;
   1174            uint32_t tmpreg = 0, enablestatus = 0;
   1175          
   1176            /* Check the parameters */
   1177            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18_35  ;; 0x40026010
   \   0000000C   0x4286             CMP      R6,R0
   \   0000000E   0xD03F             BEQ.N    ??DMA_GetITStatus_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_36  ;; 0x40026028
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xD03B             BEQ.N    ??DMA_GetITStatus_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_37  ;; 0x40026040
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xD037             BEQ.N    ??DMA_GetITStatus_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable18_38  ;; 0x40026058
   \   00000024   0x4286             CMP      R6,R0
   \   00000026   0xD033             BEQ.N    ??DMA_GetITStatus_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_39  ;; 0x40026070
   \   0000002C   0x4286             CMP      R6,R0
   \   0000002E   0xD02F             BEQ.N    ??DMA_GetITStatus_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable18_40  ;; 0x40026088
   \   00000034   0x4286             CMP      R6,R0
   \   00000036   0xD02B             BEQ.N    ??DMA_GetITStatus_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable18_41  ;; 0x400260a0
   \   0000003C   0x4286             CMP      R6,R0
   \   0000003E   0xD027             BEQ.N    ??DMA_GetITStatus_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_42  ;; 0x400260b8
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xD023             BEQ.N    ??DMA_GetITStatus_0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable18_43  ;; 0x40026410
   \   0000004C   0x4286             CMP      R6,R0
   \   0000004E   0xD01F             BEQ.N    ??DMA_GetITStatus_0
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable18_44  ;; 0x40026428
   \   00000054   0x4286             CMP      R6,R0
   \   00000056   0xD01B             BEQ.N    ??DMA_GetITStatus_0
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable18_45  ;; 0x40026440
   \   0000005C   0x4286             CMP      R6,R0
   \   0000005E   0xD017             BEQ.N    ??DMA_GetITStatus_0
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable18_46  ;; 0x40026458
   \   00000064   0x4286             CMP      R6,R0
   \   00000066   0xD013             BEQ.N    ??DMA_GetITStatus_0
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable18_47  ;; 0x40026470
   \   0000006C   0x4286             CMP      R6,R0
   \   0000006E   0xD00F             BEQ.N    ??DMA_GetITStatus_0
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable18_48  ;; 0x40026488
   \   00000074   0x4286             CMP      R6,R0
   \   00000076   0xD00B             BEQ.N    ??DMA_GetITStatus_0
   \   00000078   0x....             LDR.N    R0,??DataTable18_49  ;; 0x400264a0
   \   0000007A   0x4286             CMP      R6,R0
   \   0000007C   0xD008             BEQ.N    ??DMA_GetITStatus_0
   \   0000007E   0x....             LDR.N    R0,??DataTable18_1  ;; 0x400264b8
   \   00000080   0x4286             CMP      R6,R0
   \   00000082   0xD005             BEQ.N    ??DMA_GetITStatus_0
   \   00000084   0xF240 0x4199      MOVW     R1,#+1177
   \   00000088   0x.... 0x....      ADR.W    R0,?_0
   \   0000008C   0x.... 0x....      BL       assert_failed
   1178            assert_param(IS_DMA_GET_IT(DMA_IT));
   \                     ??DMA_GetITStatus_0: (+1)
   \   00000090   0x....             LDR.N    R0,??DataTable18_50  ;; 0x10008020
   \   00000092   0x4284             CMP      R4,R0
   \   00000094   0xD07A             BEQ.N    ??DMA_GetITStatus_1
   \   00000096   0x....             LDR.N    R0,??DataTable18_51  ;; 0x10004010
   \   00000098   0x4284             CMP      R4,R0
   \   0000009A   0xD077             BEQ.N    ??DMA_GetITStatus_1
   \   0000009C   0x....             LDR.N    R0,??DataTable18_52  ;; 0x10002008
   \   0000009E   0x4284             CMP      R4,R0
   \   000000A0   0xD074             BEQ.N    ??DMA_GetITStatus_1
   \   000000A2   0x....             LDR.N    R0,??DataTable18_53  ;; 0x10001004
   \   000000A4   0x4284             CMP      R4,R0
   \   000000A6   0xD071             BEQ.N    ??DMA_GetITStatus_1
   \   000000A8   0x....             LDR.N    R0,??DataTable18_54  ;; 0x90000001
   \   000000AA   0x4284             CMP      R4,R0
   \   000000AC   0xD06E             BEQ.N    ??DMA_GetITStatus_1
   \   000000AE   0x....             LDR.N    R0,??DataTable18_55  ;; 0x10008800
   \   000000B0   0x4284             CMP      R4,R0
   \   000000B2   0xD06B             BEQ.N    ??DMA_GetITStatus_1
   \   000000B4   0x....             LDR.N    R0,??DataTable18_56  ;; 0x10004400
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xD068             BEQ.N    ??DMA_GetITStatus_1
   \   000000BA   0x....             LDR.N    R0,??DataTable18_57  ;; 0x10002200
   \   000000BC   0x4284             CMP      R4,R0
   \   000000BE   0xD065             BEQ.N    ??DMA_GetITStatus_1
   \   000000C0   0x....             LDR.N    R0,??DataTable18_58  ;; 0x10001100
   \   000000C2   0x4284             CMP      R4,R0
   \   000000C4   0xD062             BEQ.N    ??DMA_GetITStatus_1
   \   000000C6   0x....             LDR.N    R0,??DataTable18_59  ;; 0x90000040
   \   000000C8   0x4284             CMP      R4,R0
   \   000000CA   0xD05F             BEQ.N    ??DMA_GetITStatus_1
   \   000000CC   0x....             LDR.N    R0,??DataTable18_60  ;; 0x10208000
   \   000000CE   0x4284             CMP      R4,R0
   \   000000D0   0xD05C             BEQ.N    ??DMA_GetITStatus_1
   \   000000D2   0x....             LDR.N    R0,??DataTable18_61  ;; 0x10104000
   \   000000D4   0x4284             CMP      R4,R0
   \   000000D6   0xD059             BEQ.N    ??DMA_GetITStatus_1
   \   000000D8   0x....             LDR.N    R0,??DataTable18_62  ;; 0x10082000
   \   000000DA   0x4284             CMP      R4,R0
   \   000000DC   0xD056             BEQ.N    ??DMA_GetITStatus_1
   \   000000DE   0x....             LDR.N    R0,??DataTable18_63  ;; 0x10041000
   \   000000E0   0x4284             CMP      R4,R0
   \   000000E2   0xD053             BEQ.N    ??DMA_GetITStatus_1
   \   000000E4   0x....             LDR.N    R0,??DataTable18_64  ;; 0x90010000
   \   000000E6   0x4284             CMP      R4,R0
   \   000000E8   0xD050             BEQ.N    ??DMA_GetITStatus_1
   \   000000EA   0x....             LDR.N    R0,??DataTable18_65  ;; 0x18008000
   \   000000EC   0x4284             CMP      R4,R0
   \   000000EE   0xD04D             BEQ.N    ??DMA_GetITStatus_1
   \   000000F0   0x....             LDR.N    R0,??DataTable18_66  ;; 0x14004000
   \   000000F2   0x4284             CMP      R4,R0
   \   000000F4   0xD04A             BEQ.N    ??DMA_GetITStatus_1
   \   000000F6   0x....             LDR.N    R0,??DataTable18_67  ;; 0x12002000
   \   000000F8   0x4284             CMP      R4,R0
   \   000000FA   0xD047             BEQ.N    ??DMA_GetITStatus_1
   \   000000FC   0x....             LDR.N    R0,??DataTable18_68  ;; 0x11001000
   \   000000FE   0x4284             CMP      R4,R0
   \   00000100   0xD044             BEQ.N    ??DMA_GetITStatus_1
   \   00000102   0x....             LDR.N    R0,??DataTable18_69  ;; 0x90400000
   \   00000104   0x4284             CMP      R4,R0
   \   00000106   0xD041             BEQ.N    ??DMA_GetITStatus_1
   \   00000108   0x....             LDR.N    R0,??DataTable18_70  ;; 0x20008020
   \   0000010A   0x4284             CMP      R4,R0
   \   0000010C   0xD03E             BEQ.N    ??DMA_GetITStatus_1
   \   0000010E   0x....             LDR.N    R0,??DataTable18_71  ;; 0x20004010
   \   00000110   0x4284             CMP      R4,R0
   \   00000112   0xD03B             BEQ.N    ??DMA_GetITStatus_1
   \   00000114   0x....             LDR.N    R0,??DataTable18_72  ;; 0x20002008
   \   00000116   0x4284             CMP      R4,R0
   \   00000118   0xD038             BEQ.N    ??DMA_GetITStatus_1
   \   0000011A   0x....             LDR.N    R0,??DataTable18_73  ;; 0x20001004
   \   0000011C   0x4284             CMP      R4,R0
   \   0000011E   0xD035             BEQ.N    ??DMA_GetITStatus_1
   \   00000120   0x....             LDR.N    R0,??DataTable18_74  ;; 0xa0000001
   \   00000122   0x4284             CMP      R4,R0
   \   00000124   0xD032             BEQ.N    ??DMA_GetITStatus_1
   \   00000126   0x....             LDR.N    R0,??DataTable18_75  ;; 0x20008800
   \   00000128   0x4284             CMP      R4,R0
   \   0000012A   0xD02F             BEQ.N    ??DMA_GetITStatus_1
   \   0000012C   0x....             LDR.N    R0,??DataTable18_76  ;; 0x20004400
   \   0000012E   0x4284             CMP      R4,R0
   \   00000130   0xD02C             BEQ.N    ??DMA_GetITStatus_1
   \   00000132   0x....             LDR.N    R0,??DataTable18_77  ;; 0x20002200
   \   00000134   0x4284             CMP      R4,R0
   \   00000136   0xD029             BEQ.N    ??DMA_GetITStatus_1
   \   00000138   0x....             LDR.N    R0,??DataTable18_78  ;; 0x20001100
   \   0000013A   0x4284             CMP      R4,R0
   \   0000013C   0xD026             BEQ.N    ??DMA_GetITStatus_1
   \   0000013E   0x....             LDR.N    R0,??DataTable18_79  ;; 0xa0000040
   \   00000140   0x4284             CMP      R4,R0
   \   00000142   0xD023             BEQ.N    ??DMA_GetITStatus_1
   \   00000144   0x....             LDR.N    R0,??DataTable18_80  ;; 0x20208000
   \   00000146   0x4284             CMP      R4,R0
   \   00000148   0xD020             BEQ.N    ??DMA_GetITStatus_1
   \   0000014A   0x....             LDR.N    R0,??DataTable18_81  ;; 0x20104000
   \   0000014C   0x4284             CMP      R4,R0
   \   0000014E   0xD01D             BEQ.N    ??DMA_GetITStatus_1
   \   00000150   0x....             LDR.N    R0,??DataTable18_82  ;; 0x20082000
   \   00000152   0x4284             CMP      R4,R0
   \   00000154   0xD01A             BEQ.N    ??DMA_GetITStatus_1
   \   00000156   0x....             LDR.N    R0,??DataTable18_83  ;; 0x20041000
   \   00000158   0x4284             CMP      R4,R0
   \   0000015A   0xD017             BEQ.N    ??DMA_GetITStatus_1
   \   0000015C   0x....             LDR.N    R0,??DataTable18_84  ;; 0xa0010000
   \   0000015E   0x4284             CMP      R4,R0
   \   00000160   0xD014             BEQ.N    ??DMA_GetITStatus_1
   \   00000162   0x....             LDR.N    R0,??DataTable18_85  ;; 0x28008000
   \   00000164   0x4284             CMP      R4,R0
   \   00000166   0xD011             BEQ.N    ??DMA_GetITStatus_1
   \   00000168   0x....             LDR.N    R0,??DataTable18_86  ;; 0x24004000
   \   0000016A   0x4284             CMP      R4,R0
   \   0000016C   0xD00E             BEQ.N    ??DMA_GetITStatus_1
   \   0000016E   0x....             LDR.N    R0,??DataTable18_87  ;; 0x22002000
   \   00000170   0x4284             CMP      R4,R0
   \   00000172   0xD00B             BEQ.N    ??DMA_GetITStatus_1
   \   00000174   0x....             LDR.N    R0,??DataTable18_88  ;; 0x21001000
   \   00000176   0x4284             CMP      R4,R0
   \   00000178   0xD008             BEQ.N    ??DMA_GetITStatus_1
   \   0000017A   0x....             LDR.N    R0,??DataTable18_89  ;; 0xa0400000
   \   0000017C   0x4284             CMP      R4,R0
   \   0000017E   0xD005             BEQ.N    ??DMA_GetITStatus_1
   \   00000180   0xF240 0x419A      MOVW     R1,#+1178
   \   00000184   0x.... 0x....      ADR.W    R0,?_0
   \   00000188   0x.... 0x....      BL       assert_failed
   1179           
   1180            /* Determine the DMA to which belongs the stream */
   1181            if (DMAy_Streamx < DMA2_Stream0)
   \                     ??DMA_GetITStatus_1: (+1)
   \   0000018C   0x....             LDR.N    R0,??DataTable18_43  ;; 0x40026410
   \   0000018E   0x4286             CMP      R6,R0
   \   00000190   0xD201             BCS.N    ??DMA_GetITStatus_2
   1182            {
   1183              /* DMAy_Streamx belongs to DMA1 */
   1184              DMAy = DMA1; 
   \   00000192   0x....             LDR.N    R0,??DataTable18_31  ;; 0x40026000
   \   00000194   0xE000             B.N      ??DMA_GetITStatus_3
   1185            } 
   1186            else 
   1187            {
   1188              /* DMAy_Streamx belongs to DMA2 */
   1189              DMAy = DMA2; 
   \                     ??DMA_GetITStatus_2: (+1)
   \   00000196   0x....             LDR.N    R0,??DataTable18_32  ;; 0x40026400
   1190            }
   1191          
   1192            /* Check if the interrupt enable bit is in the CR or FCR register */
   1193            if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
   \                     ??DMA_GetITStatus_3: (+1)
   \   00000198   0x....             LDR.N    R1,??DataTable18_90  ;; 0xf3c0f3c
   \   0000019A   0x420C             TST      R4,R1
   \   0000019C   0xD005             BEQ.N    ??DMA_GetITStatus_4
   1194            {
   1195              /* Get the interrupt enable position mask in CR register */
   1196              tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
   1197              
   1198              /* Check the enable bit in CR register */
   1199              enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
   \   0000019E   0x6831             LDR      R1,[R6, #+0]
   \   000001A0   0xEA01 0x21D4      AND      R1,R1,R4, LSR #+11
   \   000001A4   0xF001 0x011E      AND      R1,R1,#0x1E
   \   000001A8   0xE002             B.N      ??DMA_GetITStatus_5
   1200            }
   1201            else 
   1202            {
   1203              /* Check the enable bit in FCR register */
   1204              enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
   \                     ??DMA_GetITStatus_4: (+1)
   \   000001AA   0x6971             LDR      R1,[R6, #+20]
   \   000001AC   0xF001 0x0180      AND      R1,R1,#0x80
   1205            }
   1206           
   1207            /* Check if the interrupt pending flag is in LISR or HISR */
   1208            if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
   \                     ??DMA_GetITStatus_5: (+1)
   \   000001B0   0x00A2             LSLS     R2,R4,#+2
   \   000001B2   0xD501             BPL.N    ??DMA_GetITStatus_6
   1209            {
   1210              /* Get DMAy HISR register value */
   1211              tmpreg = DMAy->HISR ;
   \   000001B4   0x6840             LDR      R0,[R0, #+4]
   \   000001B6   0xE000             B.N      ??DMA_GetITStatus_7
   1212            }
   1213            else
   1214            {
   1215              /* Get DMAy LISR register value */
   1216              tmpreg = DMAy->LISR ;
   \                     ??DMA_GetITStatus_6: (+1)
   \   000001B8   0x6800             LDR      R0,[R0, #+0]
   1217            } 
   1218          
   1219            /* mask all reserved bits */
   1220            tmpreg &= (uint32_t)RESERVED_MASK;
   1221          
   1222            /* Check the status of the specified DMA interrupt */
   1223            if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
   \                     ??DMA_GetITStatus_7: (+1)
   \   000001BA   0x4020             ANDS     R0,R4,R0
   \   000001BC   0x....             LDR.N    R2,??DataTable18_33  ;; 0xf7d0f7d
   \   000001BE   0x4210             TST      R0,R2
   \   000001C0   0xD002             BEQ.N    ??DMA_GetITStatus_8
   \   000001C2   0x2900             CMP      R1,#+0
   \   000001C4   0xD000             BEQ.N    ??DMA_GetITStatus_8
   1224            {
   1225              /* DMA_IT is set */
   1226              bitstatus = SET;
   \   000001C6   0x2501             MOVS     R5,#+1
   1227            }
   1228            else
   1229            {
   1230              /* DMA_IT is reset */
   1231              bitstatus = RESET;
   1232            }
   1233          
   1234            /* Return the DMA_IT status */
   1235            return  bitstatus;
   \                     ??DMA_GetITStatus_8: (+1)
   \   000001C8   0x4628             MOV      R0,R5
   \   000001CA   0xBD70             POP      {R4-R6,PC}       ;; return
   1236          }
   1237          
   1238          /**
   1239            * @brief  Clears the DMAy Streamx's interrupt pending bits.
   1240            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1241            *          to 7 to select the DMA Stream.
   1242            * @param  DMA_IT: specifies the DMA interrupt pending bit to clear.
   1243            *          This parameter can be any combination of the following values:
   1244            *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
   1245            *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
   1246            *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
   1247            *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
   1248            *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
   1249            *         Where x can be 0 to 7 to select the DMA Stream.
   1250            * @retval None
   1251            */

   \                                 In section .text, align 2, keep-with-next
   1252          void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
   1253          {
   \                     DMA_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   1254            DMA_TypeDef* DMAy;
   1255          
   1256            /* Check the parameters */
   1257            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   \   00000006   0x....             LDR.N    R0,??DataTable18_35  ;; 0x40026010
   \   00000008   0x4285             CMP      R5,R0
   \   0000000A   0xD032             BEQ.N    ??DMA_ClearITPendingBit_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_36  ;; 0x40026028
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD02F             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000012   0x....             LDR.N    R0,??DataTable18_37  ;; 0x40026040
   \   00000014   0x4285             CMP      R5,R0
   \   00000016   0xD02C             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000018   0x....             LDR.N    R0,??DataTable18_38  ;; 0x40026058
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xD029             BEQ.N    ??DMA_ClearITPendingBit_0
   \   0000001E   0x....             LDR.N    R0,??DataTable18_39  ;; 0x40026070
   \   00000020   0x4285             CMP      R5,R0
   \   00000022   0xD026             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000024   0x....             LDR.N    R0,??DataTable18_40  ;; 0x40026088
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD023             BEQ.N    ??DMA_ClearITPendingBit_0
   \   0000002A   0x....             LDR.N    R0,??DataTable18_41  ;; 0x400260a0
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0xD020             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000030   0x....             LDR.N    R0,??DataTable18_42  ;; 0x400260b8
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD01D             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000036   0x....             LDR.N    R0,??DataTable18_43  ;; 0x40026410
   \   00000038   0x4285             CMP      R5,R0
   \   0000003A   0xD01A             BEQ.N    ??DMA_ClearITPendingBit_0
   \   0000003C   0x....             LDR.N    R0,??DataTable18_44  ;; 0x40026428
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xD017             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000042   0x....             LDR.N    R0,??DataTable18_45  ;; 0x40026440
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xD014             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000048   0x....             LDR.N    R0,??DataTable18_46  ;; 0x40026458
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0xD011             BEQ.N    ??DMA_ClearITPendingBit_0
   \   0000004E   0x....             LDR.N    R0,??DataTable18_47  ;; 0x40026470
   \   00000050   0x4285             CMP      R5,R0
   \   00000052   0xD00E             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000054   0x....             LDR.N    R0,??DataTable18_48  ;; 0x40026488
   \   00000056   0x4285             CMP      R5,R0
   \   00000058   0xD00B             BEQ.N    ??DMA_ClearITPendingBit_0
   \   0000005A   0x....             LDR.N    R0,??DataTable18_49  ;; 0x400264a0
   \   0000005C   0x4285             CMP      R5,R0
   \   0000005E   0xD008             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000060   0x....             LDR.N    R0,??DataTable18_1  ;; 0x400264b8
   \   00000062   0x4285             CMP      R5,R0
   \   00000064   0xD005             BEQ.N    ??DMA_ClearITPendingBit_0
   \   00000066   0xF240 0x41E9      MOVW     R1,#+1257
   \   0000006A   0x.... 0x....      ADR.W    R0,?_0
   \   0000006E   0x.... 0x....      BL       assert_failed
   1258            assert_param(IS_DMA_CLEAR_IT(DMA_IT));
   \                     ??DMA_ClearITPendingBit_0: (+1)
   \   00000072   0xF004 0x5040      AND      R0,R4,#0x30000000
   \   00000076   0xF1B0 0x5F40      CMP      R0,#+805306368
   \   0000007A   0xD007             BEQ.N    ??DMA_ClearITPendingBit_1
   \   0000007C   0xF014 0x5F40      TST      R4,#0x30000000
   \   00000080   0xD004             BEQ.N    ??DMA_ClearITPendingBit_1
   \   00000082   0x2C00             CMP      R4,#+0
   \   00000084   0xD002             BEQ.N    ??DMA_ClearITPendingBit_1
   \   00000086   0x....             LDR.N    R0,??DataTable18_91  ;; 0x40820082
   \   00000088   0x4204             TST      R4,R0
   \   0000008A   0xD005             BEQ.N    ??DMA_ClearITPendingBit_2
   \                     ??DMA_ClearITPendingBit_1: (+1)
   \   0000008C   0xF240 0x41EA      MOVW     R1,#+1258
   \   00000090   0x.... 0x....      ADR.W    R0,?_0
   \   00000094   0x.... 0x....      BL       assert_failed
   1259          
   1260            /* Determine the DMA to which belongs the stream */
   1261            if (DMAy_Streamx < DMA2_Stream0)
   \                     ??DMA_ClearITPendingBit_2: (+1)
   \   00000098   0x....             LDR.N    R0,??DataTable18_43  ;; 0x40026410
   \   0000009A   0x4285             CMP      R5,R0
   \   0000009C   0xD201             BCS.N    ??DMA_ClearITPendingBit_3
   1262            {
   1263              /* DMAy_Streamx belongs to DMA1 */
   1264              DMAy = DMA1; 
   \   0000009E   0x....             LDR.N    R0,??DataTable18_31  ;; 0x40026000
   \   000000A0   0xE000             B.N      ??DMA_ClearITPendingBit_4
   1265            } 
   1266            else 
   1267            {
   1268              /* DMAy_Streamx belongs to DMA2 */
   1269              DMAy = DMA2; 
   \                     ??DMA_ClearITPendingBit_3: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable18_32  ;; 0x40026400
   \                     ??DMA_ClearITPendingBit_4: (+1)
   \   000000A4   0x....             LDR.N    R1,??DataTable18_33  ;; 0xf7d0f7d
   \   000000A6   0x4021             ANDS     R1,R1,R4
   \   000000A8   0x00A2             LSLS     R2,R4,#+2
   \   000000AA   0xD501             BPL.N    ??DMA_ClearITPendingBit_5
   1270            }
   1271          
   1272            /* Check if LIFCR or HIFCR register is targeted */
   1273            if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
   1274            {
   1275              /* Set DMAy HIFCR register clear interrupt bits */
   1276              DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
   \   000000AC   0x60C1             STR      R1,[R0, #+12]
   \   000000AE   0xBD31             POP      {R0,R4,R5,PC}
   1277            }
   1278            else 
   1279            {
   1280              /* Set DMAy LIFCR register clear interrupt bits */
   1281              DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
   \                     ??DMA_ClearITPendingBit_5: (+1)
   \   000000B0   0x6081             STR      R1,[R0, #+8]
   1282            }   
   1283          }
   \   000000B2   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40026010         DC32     0x40026010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x40026028         DC32     0x40026028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40026040         DC32     0x40026040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40026058         DC32     0x40026058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x40026070         DC32     0x40026070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x40026088         DC32     0x40026088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x400260A0         DC32     0x400260a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x40026428         DC32     0x40026428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x40026440         DC32     0x40026440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x40026458         DC32     0x40026458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x40026470         DC32     0x40026470

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x40026488         DC32     0x40026488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x400264A0         DC32     0x400264a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x400264B8         DC32     0x400264b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x40026008         DC32     0x40026008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x2000003D         DC32     0x2000003d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x20000F40         DC32     0x20000f40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x203D0000         DC32     0x203d0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40026408         DC32     0x40026408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xF01C803F         DC32     0xf01c803f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40026010         DC32     0x40026010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x40026028         DC32     0x40026028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x40026040         DC32     0x40026040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x40026058         DC32     0x40026058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x40026070         DC32     0x40026070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x40026088         DC32     0x40026088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x400260A0         DC32     0x400260a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x40026428         DC32     0x40026428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x40026440         DC32     0x40026440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x40026458         DC32     0x40026458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x40026470         DC32     0x40026470

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x40026488         DC32     0x40026488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x400264A0         DC32     0x400264a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x400264B8         DC32     0x400264b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x400264B8         DC32     0x400264b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x10000020         DC32     0x10000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x10000010         DC32     0x10000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x10000008         DC32     0x10000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x10800004         DC32     0x10800004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x10800001         DC32     0x10800001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x10000800         DC32     0x10000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x10000400         DC32     0x10000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x10000200         DC32     0x10000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x10000100         DC32     0x10000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x10000040         DC32     0x10000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x10100000         DC32     0x10100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x10080000         DC32     0x10080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \   00000000   0x10040000         DC32     0x10040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \   00000000   0x10010000         DC32     0x10010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_16:
   \   00000000   0x20000020         DC32     0x20000020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_17:
   \   00000000   0x20000010         DC32     0x20000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_18:
   \   00000000   0x20000008         DC32     0x20000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_19:
   \   00000000   0x20000004         DC32     0x20000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_20:
   \   00000000   0x20000001         DC32     0x20000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_21:
   \   00000000   0x20000800         DC32     0x20000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_22:
   \   00000000   0x20000400         DC32     0x20000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_23:
   \   00000000   0x20000200         DC32     0x20000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_24:
   \   00000000   0x20000100         DC32     0x20000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_25:
   \   00000000   0x20000040         DC32     0x20000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_26:
   \   00000000   0x20200000         DC32     0x20200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_27:
   \   00000000   0x20100000         DC32     0x20100000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_28:
   \   00000000   0x20080000         DC32     0x20080000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_29:
   \   00000000   0x20040000         DC32     0x20040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_30:
   \   00000000   0x20010000         DC32     0x20010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_31:
   \   00000000   0x40026000         DC32     0x40026000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_32:
   \   00000000   0x40026400         DC32     0x40026400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_33:
   \   00000000   0x0F7D0F7D         DC32     0xf7d0f7d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_34:
   \   00000000   0xC002F082         DC32     0xc002f082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_35:
   \   00000000   0x40026010         DC32     0x40026010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_36:
   \   00000000   0x40026028         DC32     0x40026028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_37:
   \   00000000   0x40026040         DC32     0x40026040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_38:
   \   00000000   0x40026058         DC32     0x40026058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_39:
   \   00000000   0x40026070         DC32     0x40026070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_40:
   \   00000000   0x40026088         DC32     0x40026088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_41:
   \   00000000   0x400260A0         DC32     0x400260a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_42:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_43:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_44:
   \   00000000   0x40026428         DC32     0x40026428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_45:
   \   00000000   0x40026440         DC32     0x40026440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_46:
   \   00000000   0x40026458         DC32     0x40026458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_47:
   \   00000000   0x40026470         DC32     0x40026470

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_48:
   \   00000000   0x40026488         DC32     0x40026488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_49:
   \   00000000   0x400264A0         DC32     0x400264a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_50:
   \   00000000   0x10008020         DC32     0x10008020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_51:
   \   00000000   0x10004010         DC32     0x10004010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_52:
   \   00000000   0x10002008         DC32     0x10002008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_53:
   \   00000000   0x10001004         DC32     0x10001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_54:
   \   00000000   0x90000001         DC32     0x90000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_55:
   \   00000000   0x10008800         DC32     0x10008800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_56:
   \   00000000   0x10004400         DC32     0x10004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_57:
   \   00000000   0x10002200         DC32     0x10002200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_58:
   \   00000000   0x10001100         DC32     0x10001100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_59:
   \   00000000   0x90000040         DC32     0x90000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_60:
   \   00000000   0x10208000         DC32     0x10208000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_61:
   \   00000000   0x10104000         DC32     0x10104000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_62:
   \   00000000   0x10082000         DC32     0x10082000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_63:
   \   00000000   0x10041000         DC32     0x10041000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_64:
   \   00000000   0x90010000         DC32     0x90010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_65:
   \   00000000   0x18008000         DC32     0x18008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_66:
   \   00000000   0x14004000         DC32     0x14004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_67:
   \   00000000   0x12002000         DC32     0x12002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_68:
   \   00000000   0x11001000         DC32     0x11001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_69:
   \   00000000   0x90400000         DC32     0x90400000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_70:
   \   00000000   0x20008020         DC32     0x20008020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_71:
   \   00000000   0x20004010         DC32     0x20004010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_72:
   \   00000000   0x20002008         DC32     0x20002008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_73:
   \   00000000   0x20001004         DC32     0x20001004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_74:
   \   00000000   0xA0000001         DC32     0xa0000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_75:
   \   00000000   0x20008800         DC32     0x20008800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_76:
   \   00000000   0x20004400         DC32     0x20004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_77:
   \   00000000   0x20002200         DC32     0x20002200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_78:
   \   00000000   0x20001100         DC32     0x20001100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_79:
   \   00000000   0xA0000040         DC32     0xa0000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_80:
   \   00000000   0x20208000         DC32     0x20208000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_81:
   \   00000000   0x20104000         DC32     0x20104000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_82:
   \   00000000   0x20082000         DC32     0x20082000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_83:
   \   00000000   0x20041000         DC32     0x20041000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_84:
   \   00000000   0xA0010000         DC32     0xa0010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_85:
   \   00000000   0x28008000         DC32     0x28008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_86:
   \   00000000   0x24004000         DC32     0x24004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_87:
   \   00000000   0x22002000         DC32     0x22002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_88:
   \   00000000   0x21001000         DC32     0x21001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_89:
   \   00000000   0xA0400000         DC32     0xa0400000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_90:
   \   00000000   0x0F3C0F3C         DC32     0xf3c0f3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_91:
   \   00000000   0x40820082         DC32     0x40820082

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x64 0x6D          DC8 64H, 6DH, 61H, 2EH, 63H, 0
   \              0x61 0x2E    
   \              0x63 0x00    
   \   00000066   0x00 0x00          DC8 0, 0
   1284          
   1285          /**
   1286            * @}
   1287            */
   1288          
   1289          /**
   1290            * @}
   1291            */
   1292          
   1293          /**
   1294            * @}
   1295            */
   1296          
   1297          /**
   1298            * @}
   1299            */
   1300          
   1301          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DMA_ClearFlag
        16   -> assert_failed
      16   DMA_ClearITPendingBit
        16   -> assert_failed
      16   DMA_Cmd
        16   -> assert_failed
      16   DMA_DeInit
        16   -> assert_failed
      16   DMA_DoubleBufferModeCmd
        16   -> assert_failed
      16   DMA_DoubleBufferModeConfig
        16   -> assert_failed
      16   DMA_FlowControllerConfig
        16   -> assert_failed
       8   DMA_GetCmdStatus
         8   -> assert_failed
       8   DMA_GetCurrDataCounter
         8   -> assert_failed
       8   DMA_GetCurrentMemoryTarget
         8   -> assert_failed
       8   DMA_GetFIFOStatus
         8   -> assert_failed
      16   DMA_GetFlagStatus
        16   -> assert_failed
      16   DMA_GetITStatus
        16   -> assert_failed
      16   DMA_ITConfig
        16   -> assert_failed
      16   DMA_Init
        16   -> assert_failed
      16   DMA_MemoryTargetConfig
        16   -> assert_failed
      16   DMA_PeriphIncOffsetSizeConfig
        16   -> assert_failed
      16   DMA_SetCurrDataCounter
        16   -> assert_failed
       0   DMA_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_16
       4  ??DataTable18_17
       4  ??DataTable18_18
       4  ??DataTable18_19
       4  ??DataTable18_2
       4  ??DataTable18_20
       4  ??DataTable18_21
       4  ??DataTable18_22
       4  ??DataTable18_23
       4  ??DataTable18_24
       4  ??DataTable18_25
       4  ??DataTable18_26
       4  ??DataTable18_27
       4  ??DataTable18_28
       4  ??DataTable18_29
       4  ??DataTable18_3
       4  ??DataTable18_30
       4  ??DataTable18_31
       4  ??DataTable18_32
       4  ??DataTable18_33
       4  ??DataTable18_34
       4  ??DataTable18_35
       4  ??DataTable18_36
       4  ??DataTable18_37
       4  ??DataTable18_38
       4  ??DataTable18_39
       4  ??DataTable18_4
       4  ??DataTable18_40
       4  ??DataTable18_41
       4  ??DataTable18_42
       4  ??DataTable18_43
       4  ??DataTable18_44
       4  ??DataTable18_45
       4  ??DataTable18_46
       4  ??DataTable18_47
       4  ??DataTable18_48
       4  ??DataTable18_49
       4  ??DataTable18_5
       4  ??DataTable18_50
       4  ??DataTable18_51
       4  ??DataTable18_52
       4  ??DataTable18_53
       4  ??DataTable18_54
       4  ??DataTable18_55
       4  ??DataTable18_56
       4  ??DataTable18_57
       4  ??DataTable18_58
       4  ??DataTable18_59
       4  ??DataTable18_6
       4  ??DataTable18_60
       4  ??DataTable18_61
       4  ??DataTable18_62
       4  ??DataTable18_63
       4  ??DataTable18_64
       4  ??DataTable18_65
       4  ??DataTable18_66
       4  ??DataTable18_67
       4  ??DataTable18_68
       4  ??DataTable18_69
       4  ??DataTable18_7
       4  ??DataTable18_70
       4  ??DataTable18_71
       4  ??DataTable18_72
       4  ??DataTable18_73
       4  ??DataTable18_74
       4  ??DataTable18_75
       4  ??DataTable18_76
       4  ??DataTable18_77
       4  ??DataTable18_78
       4  ??DataTable18_79
       4  ??DataTable18_8
       4  ??DataTable18_80
       4  ??DataTable18_81
       4  ??DataTable18_82
       4  ??DataTable18_83
       4  ??DataTable18_84
       4  ??DataTable18_85
       4  ??DataTable18_86
       4  ??DataTable18_87
       4  ??DataTable18_88
       4  ??DataTable18_89
       4  ??DataTable18_9
       4  ??DataTable18_90
       4  ??DataTable18_91
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
     104  ?_0
     188  DMA_ClearFlag
     180  DMA_ClearITPendingBit
     188  DMA_Cmd
     478  DMA_DeInit
     188  DMA_DoubleBufferModeCmd
     158  DMA_DoubleBufferModeConfig
     152  DMA_FlowControllerConfig
     152  DMA_GetCmdStatus
     116  DMA_GetCurrDataCounter
     154  DMA_GetCurrentMemoryTarget
     152  DMA_GetFIFOStatus
     514  DMA_GetFlagStatus
     460  DMA_GetITStatus
     212  DMA_ITConfig
     604  DMA_Init
     182  DMA_MemoryTargetConfig
     172  DMA_PeriphIncOffsetSizeConfig
     116  DMA_SetCurrDataCounter
      34  DMA_StructInit

 
 5 028 bytes in section .text
 
 5 028 bytes of CODE memory

Errors: none
Warnings: none
