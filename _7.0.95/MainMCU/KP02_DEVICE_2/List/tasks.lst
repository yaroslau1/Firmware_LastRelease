###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        08/Oct/2018  17:04:52
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\tasks.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\tasks.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\tasks.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\tasks.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\tasks.c
      1          /*
      2              FreeRTOS V7.1.1 - Copyright (C) 2012 Real Time Engineers Ltd.
      3          	
      4          
      5              ***************************************************************************
      6               *                                                                       *
      7               *    FreeRTOS tutorial books are available in pdf and paperback.        *
      8               *    Complete, revised, and edited pdf reference manuals are also       *
      9               *    available.                                                         *
     10               *                                                                       *
     11               *    Purchasing FreeRTOS documentation will not only help you, by       *
     12               *    ensuring you get running as quickly as possible and with an        *
     13               *    in-depth knowledge of how to use FreeRTOS, it will also help       *
     14               *    the FreeRTOS project to continue with its mission of providing     *
     15               *    professional grade, cross platform, de facto standard solutions    *
     16               *    for microcontrollers - completely free of charge!                  *
     17               *                                                                       *
     18               *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
     19               *                                                                       *
     20               *    Thank you for using FreeRTOS, and thank you for your support!      *
     21               *                                                                       *
     22              ***************************************************************************
     23          
     24          
     25              This file is part of the FreeRTOS distribution.
     26          
     27              FreeRTOS is free software; you can redistribute it and/or modify it under
     28              the terms of the GNU General Public License (version 2) as published by the
     29              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     30              >>>NOTE<<< The modification to the GPL is included to allow you to
     31              distribute a combined work that includes FreeRTOS without being obliged to
     32              provide the source code for proprietary components outside of the FreeRTOS
     33              kernel.  FreeRTOS is distributed in the hope that it will be useful, but
     34              WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
     35              or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     36              more details. You should have received a copy of the GNU General Public
     37              License and the FreeRTOS license exception along with FreeRTOS; if not it
     38              can be viewed here: http://www.freertos.org/a00114.html and also obtained
     39              by writing to Richard Barry, contact details for whom are available on the
     40              FreeRTOS WEB site.
     41          
     42              1 tab == 4 spaces!
     43              
     44              ***************************************************************************
     45               *                                                                       *
     46               *    Having a problem?  Start by reading the FAQ "My application does   *
     47               *    not run, what could be wrong?                                      *
     48               *                                                                       *
     49               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     50               *                                                                       *
     51              ***************************************************************************
     52          
     53              
     54              http://www.FreeRTOS.org - Documentation, training, latest information, 
     55              license and contact details.
     56              
     57              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     58              including FreeRTOS+Trace - an indispensable productivity tool.
     59          
     60              Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell 
     61              the code with commercial support, indemnification, and middleware, under 
     62              the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
     63              provide a safety engineered and independently SIL3 certified version under 
     64              the SafeRTOS brand: http://www.SafeRTOS.com.
     65          */
     66          
     67          
     68          #include <stdio.h>
     69          #include <stdlib.h>
     70          #include <string.h>
     71          
     72          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     73          all the API functions to use the MPU wrappers.  That should only be done when
     74          task.h is included from an application file. */
     75          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     76          
     77          #include "FreeRTOS.h"
     78          #include "task.h"
     79          #include "timers.h"
     80          #include "StackMacros.h"
     81          
     82          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     83          
     84          /*
     85           * Macro to define the amount of stack available to the idle task.
     86           */
     87          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
     88          
     89          /*
     90           * Task control block.  A task control block (TCB) is allocated to each task,
     91           * and stores the context of the task.
     92           */
     93          typedef struct tskTaskControlBlock
     94          {
     95          	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE STRUCT. */
     96          
     97          	#if ( portUSING_MPU_WRAPPERS == 1 )
     98          		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE STRUCT. */
     99          	#endif	
    100          	
    101          	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
    102          	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
    103          	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. */
    104          	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
    105          	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */
    106          
    107          	#if ( portSTACK_GROWTH > 0 )
    108          		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the stack grows up from low memory. */
    109          	#endif
    110          
    111          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    112          		unsigned portBASE_TYPE uxCriticalNesting;
    113          	#endif
    114          
    115          	#if ( configUSE_TRACE_FACILITY == 1 )
    116          		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    117          		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third party trace code. */
    118          	#endif
    119          
    120          	#if ( configUSE_MUTEXES == 1 )
    121          		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    122          	#endif
    123          
    124          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    125          		pdTASK_HOOK_CODE pxTaskTag;
    126          	#endif
    127          
    128          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    129          		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilising. */
    130          	#endif
    131          
    132          } tskTCB;
    133          
    134          
    135          /*
    136           * Some kernel aware debuggers require data to be viewed to be global, rather
    137           * than file scope.
    138           */
    139          #ifdef portREMOVE_STATIC_QUALIFIER
    140          	#define static
    141          #endif
    142          
    143          /*lint -e956 */

   \                                 In section .bss, align 4
    144          PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
   \                     pxCurrentTCB:
   \   00000000                      DS8 4
   \   00000004                      DS8 100
   \   00000068                      DS8 4
   \   0000006C                      DS8 4
   \   00000070                      DS8 4
   \   00000074                      DS8 4
   \   00000078                      DS8 4
   \   0000007C                      DS8 4
    145          
    146          /* Lists for ready and blocked tasks. --------------------*/
    147          
    148          PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks. */

   \                                 In section .data, align 4
    149          PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
    150          PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    151          PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list currently being used. */
    152          PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    153          PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready queue when the scheduler is resumed. */
   \                     xPendingReadyList:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000030   0x00000000         DC32 0
   \   00000034   0x00000000         DC32 0
   \   00000038   0x00000000         DC32 0
   \   0000003C   0x00000000         DC32 0
   \   00000040   0xFFFFFFFF         DC32 4294967295
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    154          
    155          #if ( INCLUDE_vTaskDelete == 1 )
    156          
    157          	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but the their memory not yet freed. */
    158          	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE ) 0U;
    159          
    160          #endif
    161          
    162          #if ( INCLUDE_vTaskSuspend == 1 )
    163          
    164          	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    165          
    166          #endif
    167          
    168          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
    169          	
    170          	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
    171          	
    172          #endif
    173          
    174          /* File private variables. --------------------------------*/
    175          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBASE_TYPE ) 0U;
    176          PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
    177          PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
    178          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
    179          PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
    180          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE_TYPE ) pdFALSE;
    181          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE ) 0U;
    182          PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
    183          PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
    184          PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
    185          PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
    186          
    187          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    188          
    189          	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
    190          	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    191          	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime ) PRIVILEGED_FUNCTION;
    192          
    193          #endif
    194          
    195          /* Debugging and trace facilities private variables and macros. ------------*/
    196          
    197          /*
    198           * The value used to fill the stack of a task when the task is created.  This
    199           * is used purely for checking the high water mark for tasks.
    200           */
    201          #define tskSTACK_FILL_BYTE	( 0xa5U )
    202          
    203          /*
    204           * Macros used by vListTask to indicate which state a task is in.
    205           */
    206          #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
    207          #define tskREADY_CHAR		( ( signed char ) 'R' )
    208          #define tskDELETED_CHAR		( ( signed char ) 'D' )
    209          #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
    210          
    211          /*-----------------------------------------------------------*/
    212          
    213          /*
    214           * Place the task represented by pxTCB into the appropriate ready queue for
    215           * the task.  It is inserted at the end of the list.  One quirk of this is
    216           * that if the task being inserted is at the same priority as the currently
    217           * executing task, then it will only be rescheduled after the currently
    218           * executing task has been rescheduled.
    219           */
    220          #define prvAddTaskToReadyQueue( pxTCB )																					\
    221          	traceMOVED_TASK_TO_READY_STATE( pxTCB )																				\
    222          	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
    223          	{																													\
    224          		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
    225          	}																													\
    226          	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
    227          /*-----------------------------------------------------------*/
    228          
    229          /*
    230           * Macro that looks at the list of tasks that are currently delayed to see if
    231           * any require waking.
    232           *
    233           * Tasks are stored in the queue in the order of their wake time - meaning
    234           * once one tasks has been found whose timer has not expired we need not look
    235           * any further down the list.
    236           */
    237          #define prvCheckDelayedTasks()															\
    238          {																						\
    239          portTickType xItemValue;																\
    240          																						\
    241          	/* Is the tick count greater than or equal to the wake time of the first			\
    242          	task referenced from the delayed tasks list? */										\
    243          	if( xTickCount >= xNextTaskUnblockTime )											\
    244          	{																					\
    245          		for( ;; )																		\
    246          		{																				\
    247          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
    248          			{																			\
    249          				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
    250          				maximum possible value so it is extremely unlikely that the				\
    251          				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
    252          				time through. */														\
    253          				xNextTaskUnblockTime = portMAX_DELAY;									\
    254          				break;																	\
    255          			}																			\
    256          			else																		\
    257          			{																			\
    258          				/* The delayed list is not empty, get the value of the item at			\
    259          				the head of the delayed list.  This is the time at which the			\
    260          				task at the head of the delayed list should be removed from				\
    261          				the Blocked state. */													\
    262          				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
    263          				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
    264          																						\
    265          				if( xTickCount < xItemValue )											\
    266          				{																		\
    267          					/* It is not time to unblock this item yet, but the item			\
    268          					value is the time at which the task at the head of the				\
    269          					blocked list should be removed from the Blocked state -				\
    270          					so record the item value in xNextTaskUnblockTime. */				\
    271          					xNextTaskUnblockTime = xItemValue;									\
    272          					break;																\
    273          				}																		\
    274          																						\
    275          				/* It is time to remove the item from the Blocked state. */				\
    276          				vListRemove( &( pxTCB->xGenericListItem ) );							\
    277          																						\
    278          				/* Is the task waiting on an event also? */								\
    279          				if( pxTCB->xEventListItem.pvContainer != NULL )							\
    280          				{																		\
    281          					vListRemove( &( pxTCB->xEventListItem ) );							\
    282          				}																		\
    283          				prvAddTaskToReadyQueue( pxTCB );										\
    284          			}																			\
    285          		}																				\
    286          	}																					\
    287          }
    288          /*-----------------------------------------------------------*/
    289          
    290          /*
    291           * Several functions take an xTaskHandle parameter that can optionally be NULL,
    292           * where NULL is used to indicate that the handle of the currently executing
    293           * task should be used in place of the parameter.  This macro simply checks to
    294           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    295           */
    296          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskTCB * ) ( pxHandle ) )
    297          
    298          /* Callback function prototypes. --------------------------*/
    299          extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
    300          extern void vApplicationTickHook( void );
    301          		
    302          /* File private functions. --------------------------------*/
    303          
    304          /*
    305           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    306           * into the TCB structure.
    307           */
    308          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
    309          
    310          /*
    311           * Utility to ready all the lists used by the scheduler.  This is called
    312           * automatically upon the creation of the first task.
    313           */
    314          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    315          
    316          /*
    317           * The idle task, which as all tasks is implemented as a never ending loop.
    318           * The idle task is automatically created and added to the ready lists upon
    319           * creation of the first user task.
    320           *
    321           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    322           * language extensions.  The equivalent prototype for this function is:
    323           *
    324           * void prvIdleTask( void *pvParameters );
    325           *
    326           */
    327          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    328          
    329          /*
    330           * Utility to free all memory allocated by the scheduler to hold a TCB,
    331           * including the stack pointed to by the TCB.
    332           *
    333           * This does not free memory allocated by the task itself (i.e. memory
    334           * allocated by calls to pvPortMalloc from within the tasks application code).
    335           */
    336          #if ( INCLUDE_vTaskDelete == 1 )
    337          
    338          	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
    339          
    340          #endif
    341          
    342          /*
    343           * Used only by the idle task.  This checks to see if anything has been placed
    344           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    345           * and its TCB deleted.
    346           */
    347          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    348          
    349          /*
    350           * The currently executing task is entering the Blocked state.  Add the task to
    351           * either the current or the overflow delayed task list.
    352           */
    353          static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
    354          
    355          /*
    356           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    357           * allocation was successful.
    358           */
    359          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer ) PRIVILEGED_FUNCTION;
    360          
    361          /*
    362           * Called from vTaskList.  vListTasks details all the tasks currently under
    363           * control of the scheduler.  The tasks may be in one of a number of lists.
    364           * prvListTaskWithinSingleList accepts a list and details the tasks from
    365           * within just that list.
    366           *
    367           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    368           * NORMAL APPLICATION CODE.
    369           */
    370          #if ( configUSE_TRACE_FACILITY == 1 )
    371          
    372          	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus ) PRIVILEGED_FUNCTION;
    373          
    374          #endif
    375          
    376          /*
    377           * When a task is created, the stack of the task is filled with a known value.
    378           * This function determines the 'high water mark' of the task stack by
    379           * determining how much of the stack remains at the original preset value.
    380           */
    381          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    382          
    383          	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_FUNCTION;
    384          
    385          #endif
    386          
    387          
    388          /*lint +e956 */
    389          
    390          
    391          
    392          /*-----------------------------------------------------------
    393           * TASK CREATION API documented in task.h
    394           *----------------------------------------------------------*/
    395          

   \                                 In section .text, align 2, keep-with-next
    396          signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
    397          {
   \                     xTaskGenericCreate: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
    398          signed portBASE_TYPE xReturn;
    399          tskTCB * pxNewTCB;
    400          
    401          	configASSERT( pxTaskCode );
    402          	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
    403          
    404          	/* Allocate the memory required by the TCB and stack for the new task,
    405          	checking that the allocation was successful. */
    406          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   \   0000000E   0x990C             LDR      R1,[SP, #+48]
   \   00000010   0x4640             MOV      R0,R8
   \   00000012   0x.... 0x....      BL       _Z22prvAllocateTCBAndStacktPm
   \   00000016   0x0004             MOVS     R4,R0
   \   00000018   0x9D0A             LDR      R5,[SP, #+40]
    407          
    408          	if( pxNewTCB != NULL )
   \   0000001A   0xD04E             BEQ.N    ??xTaskGenericCreate_0
    409          	{
    410          		portSTACK_TYPE *pxTopOfStack;
    411          
    412          		#if( portUSING_MPU_WRAPPERS == 1 )
    413          			/* Should the task be created in privileged mode? */
    414          			portBASE_TYPE xRunPrivileged;
    415          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    416          			{
    417          				xRunPrivileged = pdTRUE;
    418          			}
    419          			else
    420          			{
    421          				xRunPrivileged = pdFALSE;
    422          			}
    423          			uxPriority &= ~portPRIVILEGE_BIT;
    424          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    425          
    426          		/* Calculate the top of stack address.  This depends on whether the
    427          		stack grows from high memory to low (as per the 80x86) or visa versa.
    428          		portSTACK_GROWTH is used to make the result positive or negative as
    429          		required by the port. */
    430          		#if( portSTACK_GROWTH < 0 )
    431          		{
    432          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
   \   0000001C   0x6B20             LDR      R0,[R4, #+48]
   \   0000001E   0xEB00 0x0088      ADD      R0,R0,R8, LSL #+2
   \   00000022   0xF1A0 0x0A04      SUB      R10,R0,#+4
    433          			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
    434          
    435          			/* Check the alignment of the calculated top of stack is correct. */
    436          			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    437          		}
    438          		#else
    439          		{
    440          			pxTopOfStack = pxNewTCB->pxStack;
    441          			
    442          			/* Check the alignment of the stack buffer is correct. */
    443          			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    444          
    445          			/* If we want to use stack checking on architectures that use
    446          			a positive stack growth direction then we also need to store the
    447          			other extreme of the stack space. */
    448          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    449          		}
    450          		#endif
    451          
    452          		/* Setup the newly allocated TCB with the initial state of the task. */
    453          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   \   00000026   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000002A   0x9B0D             LDR      R3,[SP, #+52]
   \   0000002C   0x462A             MOV      R2,R5
   \   0000002E   0x4639             MOV      R1,R7
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       _Z25prvInitialiseTCBVariablesP19tskTaskControlBlockPKamPK14xMEMORY_REGIONt
    454          
    455          		/* Initialize the TCB stack to look as if the task was already running,
    456          		but had been interrupted by the scheduler.  The return address is set
    457          		to the start of the task function. Once the stack has been initialised
    458          		the	top of stack variable is updated. */
    459          		#if( portUSING_MPU_WRAPPERS == 1 )
    460          		{
    461          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    462          		}
    463          		#else
    464          		{
    465          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   \   00000036   0x464A             MOV      R2,R9
   \   00000038   0x4631             MOV      R1,R6
   \   0000003A   0xEA4F 0x00DA      LSR      R0,R10,#+3
   \   0000003E   0x00C0             LSLS     R0,R0,#+3
   \   00000040   0x.... 0x....      BL       pxPortInitialiseStack
   \   00000044   0x6020             STR      R0,[R4, #+0]
   \   00000046   0x980B             LDR      R0,[SP, #+44]
    466          		}
    467          		#endif
    468          
    469          		/* Check the alignment of the initialised stack. */
    470          		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    471          
    472          		if( ( void * ) pxCreatedTask != NULL )
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD000             BEQ.N    ??xTaskGenericCreate_1
    473          		{
    474          			/* Pass the TCB out - in an anonymous way.  The calling function/
    475          			task can use this as a handle to delete the task later if
    476          			required.*/
    477          			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
   \   0000004C   0x6004             STR      R4,[R0, #+0]
    478          		}
    479          		
    480          		/* We are going to manipulate the task queues to add this task to a
    481          		ready list, so must make sure no interrupts occur. */
    482          		taskENTER_CRITICAL();
   \                     ??xTaskGenericCreate_1: (+1)
   \   0000004E   0x.... 0x....      BL       vPortEnterCritical
    483          		{
    484          			uxCurrentNumberOfTasks++;
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable24
   \   00000056   0x6EB0             LDR      R0,[R6, #+104]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x66B0             STR      R0,[R6, #+104]
    485          			if( pxCurrentTCB == NULL )
   \   0000005C   0x6830             LDR      R0,[R6, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD106             BNE.N    ??xTaskGenericCreate_2
    486          			{
    487          				/* There are no other tasks, or all the other tasks are in
    488          				the suspended state - make this the current task. */
    489          				pxCurrentTCB =  pxNewTCB;
   \   00000062   0x6034             STR      R4,[R6, #+0]
    490          
    491          				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
   \   00000064   0x6EB0             LDR      R0,[R6, #+104]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD10C             BNE.N    ??xTaskGenericCreate_3
    492          				{
    493          					/* This is the first task to be created so do the preliminary
    494          					initialisation required.  We will not recover if this call
    495          					fails, but we will report the failure. */
    496          					prvInitialiseTaskLists();
   \   0000006A   0x.... 0x....      BL       _Z22prvInitialiseTaskListsv
   \   0000006E   0xE009             B.N      ??xTaskGenericCreate_3
    497          				}
    498          			}
    499          			else
    500          			{
    501          				/* If the scheduler is not already running, make this task the
    502          				current task if it is the highest priority task to be created
    503          				so far. */
    504          				if( xSchedulerRunning == pdFALSE )
   \                     ??xTaskGenericCreate_2: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000074   0x6B40             LDR      R0,[R0, #+52]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD104             BNE.N    ??xTaskGenericCreate_3
    505          				{
    506          					if( pxCurrentTCB->uxPriority <= uxPriority )
   \   0000007A   0x6830             LDR      R0,[R6, #+0]
   \   0000007C   0x6AC0             LDR      R0,[R0, #+44]
   \   0000007E   0x4285             CMP      R5,R0
   \   00000080   0xD300             BCC.N    ??xTaskGenericCreate_3
    507          					{
    508          						pxCurrentTCB = pxNewTCB;
   \   00000082   0x6034             STR      R4,[R6, #+0]
    509          					}
    510          				}
    511          			}
    512          
    513          			/* Remember the top priority to make context switching faster.  Use
    514          			the priority in pxNewTCB as this has been capped to a valid value. */
    515          			if( pxNewTCB->uxPriority > uxTopUsedPriority )
   \                     ??xTaskGenericCreate_3: (+1)
   \   00000084   0x6AE0             LDR      R0,[R4, #+44]
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   0000008A   0x6B0A             LDR      R2,[R1, #+48]
   \   0000008C   0x4282             CMP      R2,R0
   \   0000008E   0xD200             BCS.N    ??xTaskGenericCreate_4
   \   00000090   0x4602             MOV      R2,R0
   \                     ??xTaskGenericCreate_4: (+1)
   \   00000092   0x630A             STR      R2,[R1, #+48]
    516          			{
    517          				uxTopUsedPriority = pxNewTCB->uxPriority;
    518          			}
    519          
    520          			#if ( configUSE_TRACE_FACILITY == 1 )
    521          			{
    522          				/* Add a counter into the TCB for tracing only. */
    523          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    524          			}
    525          			#endif
    526          			uxTaskNumber++;
   \   00000094   0x6BCA             LDR      R2,[R1, #+60]
   \   00000096   0x1C52             ADDS     R2,R2,#+1
   \   00000098   0x63CA             STR      R2,[R1, #+60]
    527          
    528          			prvAddTaskToReadyQueue( pxNewTCB );
   \   0000009A   0x6F31             LDR      R1,[R6, #+112]
   \   0000009C   0x4281             CMP      R1,R0
   \   0000009E   0xD200             BCS.N    ??xTaskGenericCreate_5
   \   000000A0   0x6730             STR      R0,[R6, #+112]
   \                     ??xTaskGenericCreate_5: (+1)
   \   000000A2   0x1D21             ADDS     R1,R4,#+4
   \   000000A4   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   000000A8   0xEB06 0x0082      ADD      R0,R6,R2, LSL #+2
   \   000000AC   0x1D00             ADDS     R0,R0,#+4
   \   000000AE   0x.... 0x....      BL       vListInsertEnd
    529          
    530          			xReturn = pdPASS;
   \   000000B2   0x2401             MOVS     R4,#+1
    531          			portSETUP_TCB( pxNewTCB );
    532          			traceTASK_CREATE( pxNewTCB );
    533          		}
    534          		taskEXIT_CRITICAL();
   \   000000B4   0x.... 0x....      BL       vPortExitCritical
   \   000000B8   0xE001             B.N      ??xTaskGenericCreate_6
    535          	}
    536          	else
    537          	{
    538          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   \                     ??xTaskGenericCreate_0: (+1)
   \   000000BA   0xF04F 0x34FF      MOV      R4,#-1
    539          		traceTASK_CREATE_FAILED();
    540          	}
    541          
    542          	if( xReturn == pdPASS )
   \                     ??xTaskGenericCreate_6: (+1)
   \   000000BE   0x2C01             CMP      R4,#+1
   \   000000C0   0xD10C             BNE.N    ??xTaskGenericCreate_7
    543          	{
    544          		if( xSchedulerRunning != pdFALSE )
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   000000C6   0x6B40             LDR      R0,[R0, #+52]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD007             BEQ.N    ??xTaskGenericCreate_7
    545          		{
    546          			/* If the created task is of a higher priority than the current task
    547          			then it should run now. */
    548          			if( pxCurrentTCB->uxPriority < uxPriority )
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable24
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x6AC0             LDR      R0,[R0, #+44]
   \   000000D4   0x42A8             CMP      R0,R5
   \   000000D6   0xD201             BCS.N    ??xTaskGenericCreate_7
    549          			{
    550          				portYIELD_WITHIN_API();
   \   000000D8   0x.... 0x....      BL       vPortYieldFromISR
    551          			}
    552          		}
    553          	}
    554          
    555          	return xReturn;
   \                     ??xTaskGenericCreate_7: (+1)
   \   000000DC   0x4620             MOV      R0,R4
   \   000000DE   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    556          }
    557          /*-----------------------------------------------------------*/
    558          
    559          #if ( INCLUDE_vTaskDelete == 1 )
    560          
    561          	void vTaskDelete( xTaskHandle pxTaskToDelete )
    562          	{
    563          	tskTCB *pxTCB;
    564          
    565          		taskENTER_CRITICAL();
    566          		{
    567          			/* Ensure a yield is performed if the current task is being
    568          			deleted. */
    569          			if( pxTaskToDelete == pxCurrentTCB )
    570          			{
    571          				pxTaskToDelete = NULL;
    572          			}
    573          
    574          			/* If null is passed in here then we are deleting ourselves. */
    575          			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    576          
    577          			/* Remove task from the ready list and place in the	termination list.
    578          			This will stop the task from be scheduled.  The idle task will check
    579          			the termination list and free up any memory allocated by the
    580          			scheduler for the TCB and stack. */
    581          			vListRemove( &( pxTCB->xGenericListItem ) );
    582          
    583          			/* Is the task waiting on an event also? */
    584          			if( pxTCB->xEventListItem.pvContainer != NULL )
    585          			{
    586          				vListRemove( &( pxTCB->xEventListItem ) );
    587          			}
    588          
    589          			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    590          
    591          			/* Increment the ucTasksDeleted variable so the idle task knows
    592          			there is a task that has been deleted and that it should therefore
    593          			check the xTasksWaitingTermination list. */
    594          			++uxTasksDeleted;
    595          
    596          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    597          			can detect that the task lists need re-generating. */
    598          			uxTaskNumber++;
    599          
    600          			traceTASK_DELETE( pxTCB );
    601          		}
    602          		taskEXIT_CRITICAL();
    603          
    604          		/* Force a reschedule if we have just deleted the current task. */
    605          		if( xSchedulerRunning != pdFALSE )
    606          		{
    607          			if( ( void * ) pxTaskToDelete == NULL )
    608          			{
    609          				portYIELD_WITHIN_API();
    610          			}
    611          		}
    612          	}
    613          
    614          #endif
    615          
    616          
    617          
    618          
    619          
    620          
    621          /*-----------------------------------------------------------
    622           * TASK CONTROL API documented in task.h
    623           *----------------------------------------------------------*/
    624          
    625          #if ( INCLUDE_vTaskDelayUntil == 1 )
    626          

   \                                 In section .text, align 2, keep-with-next
    627          	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
    628          	{
   \                     vTaskDelayUntil: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
    629          	portTickType xTimeToWake;
    630          	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
   \   00000006   0x2500             MOVS     R5,#+0
    631          
    632          		configASSERT( pxPreviousWakeTime );
    633          		configASSERT( ( xTimeIncrement > 0U ) );
    634          
    635          		vTaskSuspendAll();
   \   00000008   0x.... 0x....      BL       vTaskSuspendAll
    636          		{
    637          			/* Generate the tick time at which the task wants to wake. */
    638          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x1836             ADDS     R6,R6,R0
    639          
    640          			if( xTickCount < *pxPreviousWakeTime )
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000014   0x6ECA             LDR      R2,[R1, #+108]
   \   00000016   0x4282             CMP      R2,R0
   \   00000018   0xD206             BCS.N    ??vTaskDelayUntil_0
    641          			{
    642          				/* The tick count has overflowed since this function was
    643          				lasted called.  In this case the only time we should ever
    644          				actually delay is if the wake time has also	overflowed,
    645          				and the wake time is greater than the tick time.  When this
    646          				is the case it is as if neither time had overflowed. */
    647          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
   \   0000001A   0x4286             CMP      R6,R0
   \   0000001C   0xD20A             BCS.N    ??vTaskDelayUntil_1
   \   0000001E   0x6EC8             LDR      R0,[R1, #+108]
   \   00000020   0x42B0             CMP      R0,R6
   \   00000022   0xD207             BCS.N    ??vTaskDelayUntil_1
    648          				{
    649          					xShouldDelay = pdTRUE;
   \   00000024   0x2501             MOVS     R5,#+1
   \   00000026   0xE005             B.N      ??vTaskDelayUntil_1
    650          				}
    651          			}
    652          			else
    653          			{
    654          				/* The tick time has not overflowed.  In this case we will
    655          				delay if either the wake time has overflowed, and/or the
    656          				tick time is less than the wake time. */
    657          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
   \                     ??vTaskDelayUntil_0: (+1)
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD302             BCC.N    ??vTaskDelayUntil_2
   \   0000002C   0x6EC8             LDR      R0,[R1, #+108]
   \   0000002E   0x42B0             CMP      R0,R6
   \   00000030   0xD200             BCS.N    ??vTaskDelayUntil_1
    658          				{
    659          					xShouldDelay = pdTRUE;
   \                     ??vTaskDelayUntil_2: (+1)
   \   00000032   0x2501             MOVS     R5,#+1
    660          				}
    661          			}
    662          
    663          			/* Update the wake time ready for the next call. */
    664          			*pxPreviousWakeTime = xTimeToWake;
   \                     ??vTaskDelayUntil_1: (+1)
   \   00000034   0x6026             STR      R6,[R4, #+0]
    665          
    666          			if( xShouldDelay != pdFALSE )
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD006             BEQ.N    ??vTaskDelayUntil_3
    667          			{
    668          				traceTASK_DELAY_UNTIL();
    669          
    670          				/* We must remove ourselves from the ready list before adding
    671          				ourselves to the blocked list as the same list item is used for
    672          				both lists. */
    673          				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   0000003A   0x6808             LDR      R0,[R1, #+0]
   \   0000003C   0x1D00             ADDS     R0,R0,#+4
   \   0000003E   0x.... 0x....      BL       vListRemove
    674          				prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   00000042   0x4630             MOV      R0,R6
   \   00000044   0x.... 0x....      BL       _Z30prvAddCurrentTaskToDelayedListm
    675          			}
    676          		}
    677          		xAlreadyYielded = xTaskResumeAll();
    678          
    679          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    680          		have put ourselves to sleep. */
    681          		if( xAlreadyYielded == pdFALSE )
   \                     ??vTaskDelayUntil_3: (+1)
   \   00000048   0x.... 0x....      BL       xTaskResumeAll
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD103             BNE.N    ??vTaskDelayUntil_4
    682          		{
    683          			portYIELD_WITHIN_API();
   \   00000050   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000054   0x.... 0x....      B.W      vPortYieldFromISR
    684          		}
    685          	}
   \                     ??vTaskDelayUntil_4: (+1)
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    686          
    687          #endif
    688          /*-----------------------------------------------------------*/
    689          
    690          #if ( INCLUDE_vTaskDelay == 1 )
    691          

   \                                 In section .text, align 2, keep-with-next
    692          	void vTaskDelay( portTickType xTicksToDelay )
    693          	{
   \                     vTaskDelay: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    694          	portTickType xTimeToWake;
    695          	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   \   00000004   0x2000             MOVS     R0,#+0
    696          
    697          		/* A delay time of zero just forces a reschedule. */
    698          		if( xTicksToDelay > ( portTickType ) 0U )
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??vTaskDelay_0
    699          		{
    700          			vTaskSuspendAll();
   \   0000000A   0x.... 0x....      BL       vTaskSuspendAll
    701          			{
    702          				traceTASK_DELAY();
    703          
    704          				/* A task that is removed from the event list while the
    705          				scheduler is suspended will not get placed in the ready
    706          				list or removed from the blocked list until the scheduler
    707          				is resumed.
    708          
    709          				This task cannot be in an event list as it is the currently
    710          				executing task. */
    711          
    712          				/* Calculate the time to wake - this may overflow but this is
    713          				not a problem. */
    714          				xTimeToWake = xTickCount + xTicksToDelay;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000012   0x6EC1             LDR      R1,[R0, #+108]
   \   00000014   0x1864             ADDS     R4,R4,R1
    715          
    716          				/* We must remove ourselves from the ready list before adding
    717          				ourselves to the blocked list as the same list item is used for
    718          				both lists. */
    719          				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1D00             ADDS     R0,R0,#+4
   \   0000001A   0x.... 0x....      BL       vListRemove
    720          				prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _Z30prvAddCurrentTaskToDelayedListm
    721          			}
    722          			xAlreadyYielded = xTaskResumeAll();
   \   00000024   0x.... 0x....      BL       xTaskResumeAll
    723          		}
    724          
    725          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    726          		have put ourselves to sleep. */
    727          		if( xAlreadyYielded == pdFALSE )
   \                     ??vTaskDelay_0: (+1)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD103             BNE.N    ??vTaskDelay_1
    728          		{
    729          			portYIELD_WITHIN_API();
   \   0000002C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000030   0x.... 0x....      B.W      vPortYieldFromISR
    730          		}
    731          	}
   \                     ??vTaskDelay_1: (+1)
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    732          
    733          #endif
    734          /*-----------------------------------------------------------*/
    735          
    736          #if ( INCLUDE_uxTaskPriorityGet == 1 )
    737          
    738          	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
    739          	{
    740          	tskTCB *pxTCB;
    741          	unsigned portBASE_TYPE uxReturn;
    742          
    743          		taskENTER_CRITICAL();
    744          		{
    745          			/* If null is passed in here then we are changing the
    746          			priority of the calling function. */
    747          			pxTCB = prvGetTCBFromHandle( pxTask );
    748          			uxReturn = pxTCB->uxPriority;
    749          		}
    750          		taskEXIT_CRITICAL();
    751          
    752          		return uxReturn;
    753          	}
    754          
    755          #endif
    756          /*-----------------------------------------------------------*/
    757          
    758          #if ( INCLUDE_vTaskPrioritySet == 1 )
    759          
    760          	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
    761          	{
    762          	tskTCB *pxTCB;
    763          	unsigned portBASE_TYPE uxCurrentPriority;
    764          	portBASE_TYPE xYieldRequired = pdFALSE;
    765          
    766          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
    767          
    768          		/* Ensure the new priority is valid. */
    769          		if( uxNewPriority >= configMAX_PRIORITIES )
    770          		{
    771          			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    772          		}
    773          
    774          		taskENTER_CRITICAL();
    775          		{
    776          			if( pxTask == pxCurrentTCB )
    777          			{
    778          				pxTask = NULL;
    779          			}
    780          
    781          			/* If null is passed in here then we are changing the
    782          			priority of the calling function. */
    783          			pxTCB = prvGetTCBFromHandle( pxTask );
    784          
    785          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
    786          
    787          			#if ( configUSE_MUTEXES == 1 )
    788          			{
    789          				uxCurrentPriority = pxTCB->uxBasePriority;
    790          			}
    791          			#else
    792          			{
    793          				uxCurrentPriority = pxTCB->uxPriority;
    794          			}
    795          			#endif
    796          
    797          			if( uxCurrentPriority != uxNewPriority )
    798          			{
    799          				/* The priority change may have readied a task of higher
    800          				priority than the calling task. */
    801          				if( uxNewPriority > uxCurrentPriority )
    802          				{
    803          					if( pxTask != NULL )
    804          					{
    805          						/* The priority of another task is being raised.  If we
    806          						were raising the priority of the currently running task
    807          						there would be no need to switch as it must have already
    808          						been the highest priority task. */
    809          						xYieldRequired = pdTRUE;
    810          					}
    811          				}
    812          				else if( pxTask == NULL )
    813          				{
    814          					/* Setting our own priority down means there may now be another
    815          					task of higher priority that is ready to execute. */
    816          					xYieldRequired = pdTRUE;
    817          				}
    818          
    819          
    820          
    821          				#if ( configUSE_MUTEXES == 1 )
    822          				{
    823          					/* Only change the priority being used if the task is not
    824          					currently using an inherited priority. */
    825          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    826          					{
    827          						pxTCB->uxPriority = uxNewPriority;
    828          					}
    829          
    830          					/* The base priority gets set whatever. */
    831          					pxTCB->uxBasePriority = uxNewPriority;
    832          				}
    833          				#else
    834          				{
    835          					pxTCB->uxPriority = uxNewPriority;
    836          				}
    837          				#endif
    838          
    839          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    840          
    841          				/* If the task is in the blocked or suspended list we need do
    842          				nothing more than change it's priority variable. However, if
    843          				the task is in a ready list it needs to be removed and placed
    844          				in the queue appropriate to its new priority. */
    845          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    846          				{
    847          					/* The task is currently in its ready list - remove before adding
    848          					it to it's new ready list.  As we are in a critical section we
    849          					can do this even if the scheduler is suspended. */
    850          					vListRemove( &( pxTCB->xGenericListItem ) );
    851          					prvAddTaskToReadyQueue( pxTCB );
    852          				}
    853          
    854          				if( xYieldRequired == pdTRUE )
    855          				{
    856          					portYIELD_WITHIN_API();
    857          				}
    858          			}
    859          		}
    860          		taskEXIT_CRITICAL();
    861          	}
    862          
    863          #endif
    864          /*-----------------------------------------------------------*/
    865          
    866          #if ( INCLUDE_vTaskSuspend == 1 )
    867          
    868          #pragma diag_suppress=Pa082

   \                                 In section .text, align 2, keep-with-next
    869          	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
    870          	{
   \                     vTaskSuspend: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
    871          	tskTCB *pxTCB;
    872          
    873          		taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    874          		{
    875          			/* Ensure a yield is performed if the current task is being
    876          			suspended. */
    877          			if( pxTaskToSuspend == pxCurrentTCB )
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable24
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x4285             CMP      R5,R0
   \   00000010   0xD100             BNE.N    ??vTaskSuspend_0
    878          			{
    879          				pxTaskToSuspend = NULL;
   \   00000012   0x2500             MOVS     R5,#+0
    880          			}
    881          
    882          			/* If null is passed in here then we are suspending ourselves. */
    883          			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
   \                     ??vTaskSuspend_0: (+1)
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD101             BNE.N    ??vTaskSuspend_1
   \   00000018   0x6826             LDR      R6,[R4, #+0]
   \   0000001A   0xE000             B.N      ??vTaskSuspend_2
   \                     ??vTaskSuspend_1: (+1)
   \   0000001C   0x462E             MOV      R6,R5
    884          
    885          			traceTASK_SUSPEND( pxTCB );
    886          
    887          			/* Remove task from the ready/delayed list and place in the	suspended list. */
    888          			vListRemove( &( pxTCB->xGenericListItem ) );
   \                     ??vTaskSuspend_2: (+1)
   \   0000001E   0x1D30             ADDS     R0,R6,#+4
   \   00000020   0x.... 0x....      BL       vListRemove
    889          
    890          			/* Is the task waiting on an event also? */
    891          			if( pxTCB->xEventListItem.pvContainer != NULL )
   \   00000024   0x6AB0             LDR      R0,[R6, #+40]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD003             BEQ.N    ??vTaskSuspend_3
    892          			{
    893          				vListRemove( &( pxTCB->xEventListItem ) );
   \   0000002A   0xF106 0x0018      ADD      R0,R6,#+24
   \   0000002E   0x.... 0x....      BL       vListRemove
    894          			}
    895          
    896          			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   \                     ??vTaskSuspend_3: (+1)
   \   00000032   0x.... 0x....      LDR.W    R7,??DataTable24_1
   \   00000036   0x1D31             ADDS     R1,R6,#+4
   \   00000038   0xF107 0x001C      ADD      R0,R7,#+28
   \   0000003C   0x.... 0x....      BL       vListInsertEnd
    897          		}
    898          		taskEXIT_CRITICAL();
   \   00000040   0x.... 0x....      BL       vPortExitCritical
    899          
    900          		if( ( void * ) pxTaskToSuspend == NULL )
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD110             BNE.N    ??vTaskSuspend_4
    901          		{
    902          			if( xSchedulerRunning != pdFALSE )
   \   00000048   0x6B78             LDR      R0,[R7, #+52]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD003             BEQ.N    ??vTaskSuspend_5
    903          			{
    904          				/* We have just suspended the current task. */
    905          				portYIELD_WITHIN_API();
   \   0000004E   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000052   0x.... 0x....      B.W      vPortYieldFromISR
    906          			}
    907          			else
    908          			{
    909          				/* The scheduler is not running, but the task that was pointed
    910          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
    911          				must be adjusted to point to a different task. */
    912          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   \                     ??vTaskSuspend_5: (+1)
   \   00000056   0x69F8             LDR      R0,[R7, #+28]
   \   00000058   0x6EA1             LDR      R1,[R4, #+104]
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD102             BNE.N    ??vTaskSuspend_6
    913          				{
    914          					/* No other tasks are ready, so set pxCurrentTCB back to
    915          					NULL so when the next task is created pxCurrentTCB will
    916          					be set to point to it no matter what its relative priority
    917          					is. */
    918          					pxCurrentTCB = NULL;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x6020             STR      R0,[R4, #+0]
   \   00000062   0xBDF1             POP      {R0,R4-R7,PC}
    919          				}
    920          				else
    921          				{
    922          					vTaskSwitchContext();
   \                     ??vTaskSuspend_6: (+1)
   \   00000064   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000068   0x....             B.N      vTaskSwitchContext
    923          				}
    924          			}
    925          		}
    926          	}
   \                     ??vTaskSuspend_4: (+1)
   \   0000006A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    927          
    928          #endif
    929          /*-----------------------------------------------------------*/
    930          
    931          #if ( INCLUDE_vTaskSuspend == 1 )
    932          

   \                                 In section .text, align 2, keep-with-next
    933          	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
    934          	{
   \                     xTaskIsTaskSuspended: (+1)
   \   00000000   0xB410             PUSH     {R4}
    935          	portBASE_TYPE xReturn = pdFALSE;
   \   00000002   0x2100             MOVS     R1,#+0
    936          	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    937          
    938          		/* It does not make sense to check if the calling task is suspended. */
    939          		configASSERT( xTask );
    940          
    941          		/* Is the task we are attempting to resume actually in the
    942          		suspended list? */
    943          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   \   00000004   0x.... 0x....      LDR.W    R2,??DataTable24_1
   \   00000008   0x6943             LDR      R3,[R0, #+20]
   \   0000000A   0xF102 0x041C      ADD      R4,R2,#+28
   \   0000000E   0x42A3             CMP      R3,R4
   \   00000010   0xD105             BNE.N    ??xTaskIsTaskSuspended_0
    944          		{
    945          			/* Has the task already been resumed from within an ISR? */
    946          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
   \   00000012   0x6A80             LDR      R0,[R0, #+40]
   \   00000014   0x4290             CMP      R0,R2
   \   00000016   0xD002             BEQ.N    ??xTaskIsTaskSuspended_0
    947          			{
    948          				/* Is it in the suspended list because it is in the
    949          				Suspended state?  It is possible to be in the suspended
    950          				list because it is blocked on a task with no timeout
    951          				specified. */
    952          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD100             BNE.N    ??xTaskIsTaskSuspended_0
    953          				{
    954          					xReturn = pdTRUE;
   \   0000001C   0x2101             MOVS     R1,#+1
    955          				}
    956          			}
    957          		}
    958          
    959          		return xReturn;
   \                     ??xTaskIsTaskSuspended_0: (+1)
   \   0000001E   0x4608             MOV      R0,R1
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    960          	}
    961          
    962          #endif
    963          /*-----------------------------------------------------------*/
    964          
    965          #if ( INCLUDE_vTaskSuspend == 1 )
    966          

   \                                 In section .text, align 2, keep-with-next
    967          	void vTaskResume( xTaskHandle pxTaskToResume )
    968          	{
   \                     vTaskResume: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    969          	tskTCB *pxTCB;
    970          
    971          		/* It does not make sense to resume the calling task. */
    972          		configASSERT( pxTaskToResume );
    973          
    974          		/* Remove the task from whichever list it is currently in, and place
    975          		it in the ready list. */
    976          		pxTCB = ( tskTCB * ) pxTaskToResume;
    977          
    978          		/* The parameter cannot be NULL as it is impossible to resume the
    979          		currently executing task. */
    980          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   \   00000004   0xD026             BEQ.N    ??vTaskResume_0
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable24
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD021             BEQ.N    ??vTaskResume_0
    981          		{
    982          			taskENTER_CRITICAL();
   \   00000010   0x.... 0x....      BL       vPortEnterCritical
    983          			{
    984          				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       xTaskIsTaskSuspended
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD116             BNE.N    ??vTaskResume_1
    985          				{
    986          					traceTASK_RESUME( pxTCB );
    987          
    988          					/* As we are in a critical section we can access the ready
    989          					lists even if the scheduler is suspended. */
    990          					vListRemove(  &( pxTCB->xGenericListItem ) );
   \   0000001E   0x1D20             ADDS     R0,R4,#+4
   \   00000020   0x.... 0x....      BL       vListRemove
    991          					prvAddTaskToReadyQueue( pxTCB );
   \   00000024   0x6AE0             LDR      R0,[R4, #+44]
   \   00000026   0x6F29             LDR      R1,[R5, #+112]
   \   00000028   0x4281             CMP      R1,R0
   \   0000002A   0xD200             BCS.N    ??vTaskResume_2
   \   0000002C   0x6728             STR      R0,[R5, #+112]
   \                     ??vTaskResume_2: (+1)
   \   0000002E   0x1D21             ADDS     R1,R4,#+4
   \   00000030   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000034   0xEB05 0x0082      ADD      R0,R5,R2, LSL #+2
   \   00000038   0x1D00             ADDS     R0,R0,#+4
   \   0000003A   0x.... 0x....      BL       vListInsertEnd
    992          
    993          					/* We may have just resumed a higher priority task. */
    994          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   0000003E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000040   0x6829             LDR      R1,[R5, #+0]
   \   00000042   0x6AC9             LDR      R1,[R1, #+44]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD301             BCC.N    ??vTaskResume_1
    995          					{
    996          						/* This yield may not cause the task just resumed to run, but
    997          						will leave the lists in the correct state for the next yield. */
    998          						portYIELD_WITHIN_API();
   \   00000048   0x.... 0x....      BL       vPortYieldFromISR
    999          					}
   1000          				}
   1001          			}
   1002          			taskEXIT_CRITICAL();
   \                     ??vTaskResume_1: (+1)
   \   0000004C   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000050   0x.... 0x....      B.W      vPortExitCritical
   1003          		}
   1004          	}
   \                     ??vTaskResume_0: (+1)
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1005          
   1006          #endif
   1007          
   1008          /*-----------------------------------------------------------*/
   1009          
   1010          #pragma diag_suppress=Pe550
   1011          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1012          

   \                                 In section .text, align 2, keep-with-next
   1013          	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
   1014          	{
   \                     xTaskResumeFromISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1015          	portBASE_TYPE xYieldRequired = pdFALSE;
   \   00000004   0x2600             MOVS     R6,#+0
   1016          	tskTCB *pxTCB;
   1017          	unsigned portBASE_TYPE uxSavedInterruptStatus;
   1018          
   1019          		configASSERT( pxTaskToResume );
   1020          
   1021          		pxTCB = ( tskTCB * ) pxTaskToResume;
   1022          
   1023          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000006   0x.... 0x....      BL       vPortSetInterruptMask
   1024          		{
   1025          			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       xTaskIsTaskSuspended
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD121             BNE.N    ??xTaskResumeFromISR_0
   1026          			{
   1027          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1028          
   1029          				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable24
   \   00000018   0x6F68             LDR      R0,[R5, #+116]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD116             BNE.N    ??xTaskResumeFromISR_1
   1030          				{
   1031          					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
   \   0000001E   0x6AE0             LDR      R0,[R4, #+44]
   \   00000020   0x6829             LDR      R1,[R5, #+0]
   \   00000022   0x6AC9             LDR      R1,[R1, #+44]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD300             BCC.N    ??xTaskResumeFromISR_2
   \   00000028   0x2601             MOVS     R6,#+1
   1032          					vListRemove(  &( pxTCB->xGenericListItem ) );
   \                     ??xTaskResumeFromISR_2: (+1)
   \   0000002A   0x1D20             ADDS     R0,R4,#+4
   \   0000002C   0x.... 0x....      BL       vListRemove
   1033          					prvAddTaskToReadyQueue( pxTCB );
   \   00000030   0x6AE0             LDR      R0,[R4, #+44]
   \   00000032   0x6F29             LDR      R1,[R5, #+112]
   \   00000034   0x4281             CMP      R1,R0
   \   00000036   0xD200             BCS.N    ??xTaskResumeFromISR_3
   \   00000038   0x6728             STR      R0,[R5, #+112]
   \                     ??xTaskResumeFromISR_3: (+1)
   \   0000003A   0x1D21             ADDS     R1,R4,#+4
   \   0000003C   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000040   0xEB05 0x0082      ADD      R0,R5,R2, LSL #+2
   \   00000044   0x1D00             ADDS     R0,R0,#+4
   \   00000046   0x.... 0x....      BL       vListInsertEnd
   \   0000004A   0xE005             B.N      ??xTaskResumeFromISR_0
   1034          				}
   1035          				else
   1036          				{
   1037          					/* We cannot access the delayed or ready lists, so will hold this
   1038          					task pending until the scheduler is resumed, at which point a
   1039          					yield will be performed if necessary. */
   1040          					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskResumeFromISR_1: (+1)
   \   0000004C   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \   00000054   0x.... 0x....      BL       vListInsertEnd
   1041          				}
   1042          			}
   1043          		}
   1044          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskResumeFromISR_0: (+1)
   \   00000058   0x.... 0x....      BL       vPortClearInterruptMask
   1045          
   1046          		return xYieldRequired;
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
   1047          	}
   1048          
   1049          #endif
   1050          
   1051          
   1052          
   1053          
   1054          /*-----------------------------------------------------------
   1055           * PUBLIC SCHEDULER CONTROL documented in task.h
   1056           *----------------------------------------------------------*/
   1057          
   1058          

   \                                 In section .text, align 2, keep-with-next
   1059          void vTaskStartScheduler( void )
   1060          {
   \                     vTaskStartScheduler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1061          portBASE_TYPE xReturn;
   1062          
   1063          	/* Add the idle task at the lowest priority. */
   1064          	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1065          	{
   1066          		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
   1067          		be returned by the xTaskGetIdleTaskHandle() function. */
   1068          		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
   1069          	}
   1070          	#else
   1071          	{
   1072          		/* Create the idle task without storing its handle. */
   1073          		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
   1074          	}
   1075          	#endif
   1076          
   1077          	#if ( configUSE_TIMERS == 1 )
   1078          	{
   1079          		if( xReturn == pdPASS )
   1080          		{
   1081          			xReturn = xTimerCreateTimerTask();
   1082          		}
   1083          	}
   1084          	#endif
   1085          
   1086          	if( xReturn == pdPASS )
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9003             STR      R0,[SP, #+12]
   \   00000008   0x9002             STR      R0,[SP, #+8]
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x4603             MOV      R3,R0
   \   00000010   0x2280             MOVS     R2,#+128
   \   00000012   0x.... 0x....      ADR.W    R1,?_0
   \   00000016   0x.... 0x....      ADR.W    R0,_Z11prvIdleTaskPv
   \   0000001A   0x.... 0x....      BL       xTaskGenericCreate
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD10E             BNE.N    ??vTaskStartScheduler_0
   1087          	{
   1088          		/* Interrupts are turned off here, to ensure a tick does not occur
   1089          		before or during the call to xPortStartScheduler().  The stacks of
   1090          		the created tasks contain a status word with interrupts switched on
   1091          		so interrupts will automatically get re-enabled when the first task
   1092          		starts to run.
   1093          
   1094          		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
   1095          		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
   1096          		portDISABLE_INTERRUPTS();
   \   00000022   0x.... 0x....      BL       vPortSetInterruptMask
   1097          
   1098          		xSchedulerRunning = pdTRUE;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   0000002C   0x6348             STR      R0,[R1, #+52]
   1099          		xTickCount = ( portTickType ) 0U;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000034   0x66C8             STR      R0,[R1, #+108]
   1100          
   1101          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1102          		macro must be defined to configure the timer/counter used to generate
   1103          		the run time counter time base. */
   1104          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1105          		
   1106          		/* Setting up the timer tick is hardware specific and thus in the
   1107          		portable interface. */
   1108          		if( xPortStartScheduler() != pdFALSE )
   \   00000036   0xB005             ADD      SP,SP,#+20
   \   00000038   0xF85D 0xEB04      POP      {LR}
   \   0000003C   0x.... 0x....      B.W      xPortStartScheduler
   1109          		{
   1110          			/* Should not reach here as if the scheduler is running the
   1111          			function will not return. */
   1112          		}
   1113          		else
   1114          		{
   1115          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1116          		}
   1117          	}
   1118          
   1119          	/* This line will only be reached if the kernel could not be started. */
   1120          	configASSERT( xReturn );
   1121          }
   \                     ??vTaskStartScheduler_0: (+1)
   \   00000040   0xB005             ADD      SP,SP,#+20
   \   00000042   0xBD00             POP      {PC}             ;; return
   1122          /*-----------------------------------------------------------*/
   1123          

   \                                 In section .text, align 2, keep-with-next
   1124          void vTaskEndScheduler( void )
   1125          {
   \                     vTaskEndScheduler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1126          	/* Stop the scheduler interrupts and call the portable scheduler end
   1127          	routine so the original ISRs can be restored if necessary.  The port
   1128          	layer must ensure interrupts enable	bit is left in the correct state. */
   1129          	portDISABLE_INTERRUPTS();
   \   00000002   0x.... 0x....      BL       vPortSetInterruptMask
   1130          	xSchedulerRunning = pdFALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable24_1
   \   0000000C   0x6348             STR      R0,[R1, #+52]
   1131          	vPortEndScheduler();
   \   0000000E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000012   0x.... 0x....      B.W      vPortEndScheduler
   1132          }
   1133          /*----------------------------------------------------------*/
   1134          

   \                                 In section .text, align 2, keep-with-next
   1135          void vTaskSuspendAll( void )
   1136          {
   1137          	/* A critical section is not required as the variable is of type
   1138          	portBASE_TYPE. */
   1139          	++uxSchedulerSuspended;
   \                     vTaskSuspendAll: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable24
   \   00000004   0x6F41             LDR      R1,[R0, #+116]
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0x6741             STR      R1,[R0, #+116]
   1140          }
   \   0000000A   0x4770             BX       LR               ;; return
   1141          /*----------------------------------------------------------*/
   1142          

   \                                 In section .text, align 2, keep-with-next
   1143          signed portBASE_TYPE xTaskResumeAll( void )
   1144          {
   \                     xTaskResumeAll: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1145          register tskTCB *pxTCB;
   1146          signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   \   00000002   0x2400             MOVS     R4,#+0
   1147          
   1148          	/* If uxSchedulerSuspended is zero then this function does not match a
   1149          	previous call to vTaskSuspendAll(). */
   1150          	configASSERT( uxSchedulerSuspended );
   1151          
   1152          	/* It is possible that an ISR caused a task to be removed from an event
   1153          	list while the scheduler was suspended.  If this was the case then the
   1154          	removed task will have been added to the xPendingReadyList.  Once the
   1155          	scheduler has been resumed it is safe to move all the pending ready
   1156          	tasks from this list into their appropriate ready list. */
   1157          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1158          	{
   1159          		--uxSchedulerSuspended;
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable24
   \   0000000C   0x6F68             LDR      R0,[R5, #+116]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x6768             STR      R0,[R5, #+116]
   1160          
   1161          		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000012   0x6F68             LDR      R0,[R5, #+116]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD13B             BNE.N    ??xTaskResumeAll_0
   1162          		{
   1163          			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
   \   00000018   0x6EA8             LDR      R0,[R5, #+104]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD038             BEQ.N    ??xTaskResumeAll_0
   1164          			{
   1165          				portBASE_TYPE xYieldRequired = pdFALSE;
   \   0000001E   0x4626             MOV      R6,R4
   \   00000020   0xE01B             B.N      ??xTaskResumeAll_1
   1166          
   1167          				/* Move any readied tasks from the pending list into the
   1168          				appropriate ready list. */
   1169          				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   1170          				{
   1171          					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
   \                     ??xTaskResumeAll_2: (+1)
   \   00000022   0x68C0             LDR      R0,[R0, #+12]
   \   00000024   0x68C7             LDR      R7,[R0, #+12]
   1172          					vListRemove( &( pxTCB->xEventListItem ) );
   \   00000026   0xF107 0x0018      ADD      R0,R7,#+24
   \   0000002A   0x.... 0x....      BL       vListRemove
   1173          					vListRemove( &( pxTCB->xGenericListItem ) );
   \   0000002E   0x1D38             ADDS     R0,R7,#+4
   \   00000030   0x.... 0x....      BL       vListRemove
   1174          					prvAddTaskToReadyQueue( pxTCB );
   \   00000034   0x6AF8             LDR      R0,[R7, #+44]
   \   00000036   0x6F29             LDR      R1,[R5, #+112]
   \   00000038   0x4281             CMP      R1,R0
   \   0000003A   0xD200             BCS.N    ??xTaskResumeAll_3
   \   0000003C   0x6728             STR      R0,[R5, #+112]
   \                     ??xTaskResumeAll_3: (+1)
   \   0000003E   0x1D39             ADDS     R1,R7,#+4
   \   00000040   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   00000044   0xEB05 0x0082      ADD      R0,R5,R2, LSL #+2
   \   00000048   0x1D00             ADDS     R0,R0,#+4
   \   0000004A   0x.... 0x....      BL       vListInsertEnd
   1175          
   1176          					/* If we have moved a task that has a priority higher than
   1177          					the current task then we should yield. */
   1178          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   0000004E   0x6AF8             LDR      R0,[R7, #+44]
   \   00000050   0x6829             LDR      R1,[R5, #+0]
   \   00000052   0x6AC9             LDR      R1,[R1, #+44]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD300             BCC.N    ??xTaskResumeAll_1
   1179          					{
   1180          						xYieldRequired = pdTRUE;
   \   00000058   0x2601             MOVS     R6,#+1
   1181          					}
   1182          				}
   \                     ??xTaskResumeAll_1: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable24_1
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD1DF             BNE.N    ??xTaskResumeAll_2
   1183          
   1184          				/* If any ticks occurred while the scheduler was suspended then
   1185          				they should be processed now.  This ensures the tick count does not
   1186          				slip, and that any delayed tasks are resumed at the correct time. */
   1187          				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   \   00000062   0x6FA8             LDR      R0,[R5, #+120]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD105             BNE.N    ??xTaskResumeAll_4
   \   00000068   0xE008             B.N      ??xTaskResumeAll_5
   1188          				{
   1189          					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   1190          					{
   1191          						vTaskIncrementTick();
   \                     ??xTaskResumeAll_6: (+1)
   \   0000006A   0x.... 0x....      BL       vTaskIncrementTick
   1192          						--uxMissedTicks;
   \   0000006E   0x6FA8             LDR      R0,[R5, #+120]
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x67A8             STR      R0,[R5, #+120]
   1193          					}
   \                     ??xTaskResumeAll_4: (+1)
   \   00000074   0x6FA8             LDR      R0,[R5, #+120]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD1F7             BNE.N    ??xTaskResumeAll_6
   1194          
   1195          					/* As we have processed some ticks it is appropriate to yield
   1196          					to ensure the highest priority task that is ready to run is
   1197          					the task actually running. */
   1198          					#if configUSE_PREEMPTION == 1
   1199          					{
   1200          						xYieldRequired = pdTRUE;
   \   0000007A   0x2601             MOVS     R6,#+1
   1201          					}
   1202          					#endif
   1203          				}
   1204          
   1205          				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   \                     ??xTaskResumeAll_5: (+1)
   \   0000007C   0x2E01             CMP      R6,#+1
   \   0000007E   0xD002             BEQ.N    ??xTaskResumeAll_7
   \   00000080   0x6FE8             LDR      R0,[R5, #+124]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD104             BNE.N    ??xTaskResumeAll_0
   1206          				{
   1207          					xAlreadyYielded = pdTRUE;
   \                     ??xTaskResumeAll_7: (+1)
   \   00000086   0x2401             MOVS     R4,#+1
   1208          					xMissedYield = pdFALSE;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x67E8             STR      R0,[R5, #+124]
   1209          					portYIELD_WITHIN_API();
   \   0000008C   0x.... 0x....      BL       vPortYieldFromISR
   1210          				}
   1211          			}
   1212          		}
   1213          	}
   1214          	taskEXIT_CRITICAL();
   \                     ??xTaskResumeAll_0: (+1)
   \   00000090   0x.... 0x....      BL       vPortExitCritical
   1215          
   1216          	return xAlreadyYielded;
   \   00000094   0x4620             MOV      R0,R4
   \   00000096   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1217          }
   1218          
   1219          
   1220          
   1221          
   1222          
   1223          
   1224          /*-----------------------------------------------------------
   1225           * PUBLIC TASK UTILITIES documented in task.h
   1226           *----------------------------------------------------------*/
   1227          
   1228          
   1229          

   \                                 In section .text, align 2, keep-with-next
   1230          portTickType xTaskGetTickCount( void )
   1231          {
   \                     xTaskGetTickCount: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1232          portTickType xTicks;
   1233          
   1234          	/* Critical section required if running on a 16 bit processor. */
   1235          	taskENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       vPortEnterCritical
   1236          	{
   1237          		xTicks = xTickCount;
   \   00000006   0x....             LDR.N    R0,??DataTable24
   \   00000008   0x6EC4             LDR      R4,[R0, #+108]
   1238          	}
   1239          	taskEXIT_CRITICAL();
   \   0000000A   0x.... 0x....      BL       vPortExitCritical
   1240          
   1241          	return xTicks;
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1242          }
   1243          /*-----------------------------------------------------------*/
   1244          

   \                                 In section .text, align 2, keep-with-next
   1245          portTickType xTaskGetTickCountFromISR( void )
   1246          {
   \                     xTaskGetTickCountFromISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1247          portTickType xReturn;
   1248          unsigned portBASE_TYPE uxSavedInterruptStatus;
   1249          
   1250          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000002   0x.... 0x....      BL       vPortSetInterruptMask
   1251          	xReturn = xTickCount;
   \   00000006   0x....             LDR.N    R0,??DataTable24
   \   00000008   0x6EC4             LDR      R4,[R0, #+108]
   1252          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \   0000000A   0x.... 0x....      BL       vPortClearInterruptMask
   1253          
   1254          	return xReturn;
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
   1255          }
   1256          /*-----------------------------------------------------------*/
   1257          

   \                                 In section .text, align 2, keep-with-next
   1258          unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
   1259          {
   1260          	/* A critical section is not required because the variables are of type
   1261          	portBASE_TYPE. */
   1262          	return uxCurrentNumberOfTasks;
   \                     uxTaskGetNumberOfTasks: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable24
   \   00000002   0x6E80             LDR      R0,[R0, #+104]
   \   00000004   0x4770             BX       LR               ;; return
   1263          }
   1264          /*-----------------------------------------------------------*/
   1265          
   1266          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1267          
   1268          	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
   1269          	{
   1270          	tskTCB *pxTCB;
   1271          
   1272          		/* If null is passed in here then the name of the calling task is being queried. */
   1273          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1274          		configASSERT( pxTCB );
   1275          		return &( pxTCB->pcTaskName[ 0 ] );
   1276          	}
   1277          
   1278          #endif
   1279          /*-----------------------------------------------------------*/
   1280          
   1281          #if ( configUSE_TRACE_FACILITY == 1 )
   1282          
   1283          	void vTaskList( signed char *pcWriteBuffer )
   1284          	{
   1285          	unsigned portBASE_TYPE uxQueue;
   1286          
   1287          		/* This is a VERY costly function that should be used for debug only.
   1288          		It leaves interrupts disabled for a LONG time. */
   1289          
   1290          		vTaskSuspendAll();
   1291          		{
   1292          			/* Run through all the lists that could potentially contain a TCB and
   1293          			report the task name, state and stack high water mark. */
   1294          
   1295          			*pcWriteBuffer = ( signed char ) 0x00;
   1296          			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   1297          
   1298          			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
   1299          
   1300          			do
   1301          			{
   1302          				uxQueue--;
   1303          
   1304          				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   1305          				{
   1306          					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
   1307          				}
   1308          			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   1309          
   1310          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
   1311          			{
   1312          				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
   1313          			}
   1314          
   1315          			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
   1316          			{
   1317          				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
   1318          			}
   1319          
   1320          			#if( INCLUDE_vTaskDelete == 1 )
   1321          			{
   1322          				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
   1323          				{
   1324          					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
   1325          				}
   1326          			}
   1327          			#endif
   1328          
   1329          			#if ( INCLUDE_vTaskSuspend == 1 )
   1330          			{
   1331          				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
   1332          				{
   1333          					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
   1334          				}
   1335          			}
   1336          			#endif
   1337          		}
   1338          		xTaskResumeAll();
   1339          	}
   1340          
   1341          #endif
   1342          /*----------------------------------------------------------*/
   1343          
   1344          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   1345          
   1346          	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
   1347          	{
   1348          	unsigned portBASE_TYPE uxQueue;
   1349          	unsigned long ulTotalRunTime;
   1350          
   1351          		/* This is a VERY costly function that should be used for debug only.
   1352          		It leaves interrupts disabled for a LONG time. */
   1353          
   1354          		vTaskSuspendAll();
   1355          		{
   1356          			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1357          				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   1358          			#else
   1359          				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1360          			#endif
   1361          
   1362          			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
   1363          			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
   1364          			ulTotalRunTime /= 100UL;
   1365          			
   1366          			/* Run through all the lists that could potentially contain a TCB,
   1367          			generating a table of run timer percentages in the provided
   1368          			buffer. */
   1369          
   1370          			*pcWriteBuffer = ( signed char ) 0x00;
   1371          			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   1372          
   1373          			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
   1374          
   1375          			do
   1376          			{
   1377          				uxQueue--;
   1378          
   1379          				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   1380          				{
   1381          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
   1382          				}
   1383          			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   1384          
   1385          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
   1386          			{
   1387          				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime );
   1388          			}
   1389          
   1390          			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
   1391          			{
   1392          				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime );
   1393          			}
   1394          
   1395          			#if ( INCLUDE_vTaskDelete == 1 )
   1396          			{
   1397          				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
   1398          				{
   1399          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTime );
   1400          				}
   1401          			}
   1402          			#endif
   1403          
   1404          			#if ( INCLUDE_vTaskSuspend == 1 )
   1405          			{
   1406          				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
   1407          				{
   1408          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
   1409          				}
   1410          			}
   1411          			#endif
   1412          		}
   1413          		xTaskResumeAll();
   1414          	}
   1415          
   1416          #endif
   1417          /*----------------------------------------------------------*/
   1418          
   1419          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1420          
   1421          	xTaskHandle xTaskGetIdleTaskHandle( void )
   1422          	{
   1423          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1424          		started, then xIdleTaskHandle will be NULL. */
   1425          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1426          		return xIdleTaskHandle;
   1427          	}
   1428          	
   1429          #endif
   1430          
   1431          /*-----------------------------------------------------------
   1432           * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
   1433           * documented in task.h
   1434           *----------------------------------------------------------*/
   1435          

   \                                 In section .text, align 2, keep-with-next
   1436          void vTaskIncrementTick( void )
   1437          {
   \                     vTaskIncrementTick: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1438          tskTCB * pxTCB;
   1439          
   1440          	/* Called by the portable layer each time a tick interrupt occurs.
   1441          	Increments the tick then checks to see if the new tick value will cause any
   1442          	tasks to be unblocked. */
   1443          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   00000002   0x....             LDR.N    R4,??DataTable24
   \   00000004   0x6F60             LDR      R0,[R4, #+116]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD147             BNE.N    ??vTaskIncrementTick_0
   1444          	{
   1445          		++xTickCount;
   \   0000000A   0x6EE0             LDR      R0,[R4, #+108]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x66E0             STR      R0,[R4, #+108]
   1446          		if( xTickCount == ( portTickType ) 0U )
   \   00000010   0x....             LDR.N    R5,??DataTable24_1
   \   00000012   0x6EE0             LDR      R0,[R4, #+108]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD113             BNE.N    ??vTaskIncrementTick_1
   1447          		{
   1448          			xList *pxTemp;
   1449          
   1450          			/* Tick count has overflowed so we need to swap the delay lists.
   1451          			If there are any items in pxDelayedTaskList here then there is
   1452          			an error! */
   1453          			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
   1454          			
   1455          			pxTemp = pxDelayedTaskList;
   \   00000018   0x6968             LDR      R0,[R5, #+20]
   1456          			pxDelayedTaskList = pxOverflowDelayedTaskList;
   \   0000001A   0x69A9             LDR      R1,[R5, #+24]
   \   0000001C   0x6169             STR      R1,[R5, #+20]
   1457          			pxOverflowDelayedTaskList = pxTemp;
   \   0000001E   0x61A8             STR      R0,[R5, #+24]
   1458          			xNumOfOverflows++;
   \   00000020   0x6BA8             LDR      R0,[R5, #+56]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x63A8             STR      R0,[R5, #+56]
   1459          	
   1460          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   \   00000026   0x6968             LDR      R0,[R5, #+20]
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD103             BNE.N    ??vTaskIncrementTick_2
   1461          			{
   1462          				/* The new current delayed list is empty.  Set
   1463          				xNextTaskUnblockTime to the maximum possible value so it is
   1464          				extremely unlikely that the	
   1465          				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   1466          				there is an item in the delayed list. */
   1467          				xNextTaskUnblockTime = portMAX_DELAY;
   \   0000002E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000032   0x6428             STR      R0,[R5, #+64]
   \   00000034   0xE004             B.N      ??vTaskIncrementTick_1
   1468          			}
   1469          			else
   1470          			{
   1471          				/* The new current delayed list is not empty, get the value of
   1472          				the item at the head of the delayed list.  This is the time at
   1473          				which the task at the head of the delayed list should be removed
   1474          				from the Blocked state. */
   1475          				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   \                     ??vTaskIncrementTick_2: (+1)
   \   00000036   0x6968             LDR      R0,[R5, #+20]
   \   00000038   0x68C0             LDR      R0,[R0, #+12]
   \   0000003A   0x68C6             LDR      R6,[R0, #+12]
   1476          				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   \   0000003C   0x6870             LDR      R0,[R6, #+4]
   \   0000003E   0x6428             STR      R0,[R5, #+64]
   1477          			}
   1478          		}
   1479          
   1480          		/* See if this tick has made a timeout expire. */
   1481          		prvCheckDelayedTasks();
   \                     ??vTaskIncrementTick_1: (+1)
   \   00000040   0x6EE0             LDR      R0,[R4, #+108]
   \   00000042   0x6C29             LDR      R1,[R5, #+64]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD32B             BCC.N    ??vTaskIncrementTick_3
   \   00000048   0xE016             B.N      ??vTaskIncrementTick_4
   \                     ??vTaskIncrementTick_5: (+1)
   \   0000004A   0x1D30             ADDS     R0,R6,#+4
   \   0000004C   0x.... 0x....      BL       vListRemove
   \   00000050   0x6AB0             LDR      R0,[R6, #+40]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD003             BEQ.N    ??vTaskIncrementTick_6
   \   00000056   0xF106 0x0018      ADD      R0,R6,#+24
   \   0000005A   0x.... 0x....      BL       vListRemove
   \                     ??vTaskIncrementTick_6: (+1)
   \   0000005E   0x6AF0             LDR      R0,[R6, #+44]
   \   00000060   0x6F21             LDR      R1,[R4, #+112]
   \   00000062   0x4281             CMP      R1,R0
   \   00000064   0xD200             BCS.N    ??vTaskIncrementTick_7
   \   00000066   0x6720             STR      R0,[R4, #+112]
   \                     ??vTaskIncrementTick_7: (+1)
   \   00000068   0x1D31             ADDS     R1,R6,#+4
   \   0000006A   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   0000006E   0xEB04 0x0082      ADD      R0,R4,R2, LSL #+2
   \   00000072   0x1D00             ADDS     R0,R0,#+4
   \   00000074   0x.... 0x....      BL       vListInsertEnd
   \                     ??vTaskIncrementTick_4: (+1)
   \   00000078   0x6968             LDR      R0,[R5, #+20]
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD103             BNE.N    ??vTaskIncrementTick_8
   \   00000080   0xF04F 0x30FF      MOV      R0,#-1
   \   00000084   0x6428             STR      R0,[R5, #+64]
   \   00000086   0xBD70             POP      {R4-R6,PC}
   \                     ??vTaskIncrementTick_8: (+1)
   \   00000088   0x6968             LDR      R0,[R5, #+20]
   \   0000008A   0x68C0             LDR      R0,[R0, #+12]
   \   0000008C   0x68C6             LDR      R6,[R0, #+12]
   \   0000008E   0x6870             LDR      R0,[R6, #+4]
   \   00000090   0x6EE1             LDR      R1,[R4, #+108]
   \   00000092   0x4281             CMP      R1,R0
   \   00000094   0xD2D9             BCS.N    ??vTaskIncrementTick_5
   \   00000096   0x6428             STR      R0,[R5, #+64]
   \   00000098   0xBD70             POP      {R4-R6,PC}
   1482          	}
   1483          	else
   1484          	{
   1485          		++uxMissedTicks;
   \                     ??vTaskIncrementTick_0: (+1)
   \   0000009A   0x6FA0             LDR      R0,[R4, #+120]
   \   0000009C   0x1C40             ADDS     R0,R0,#+1
   \   0000009E   0x67A0             STR      R0,[R4, #+120]
   1486          
   1487          		/* The tick hook gets called at regular intervals, even if the
   1488          		scheduler is locked. */
   1489          		#if ( configUSE_TICK_HOOK == 1 )
   1490          		{
   1491          			vApplicationTickHook();
   1492          		}
   1493          		#endif
   1494          	}
   1495          
   1496          	#if ( configUSE_TICK_HOOK == 1 )
   1497          	{
   1498          		/* Guard against the tick hook being called when the missed tick
   1499          		count is being unwound (when the scheduler is being unlocked. */
   1500          		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
   1501          		{
   1502          			vApplicationTickHook();
   1503          		}
   1504          	}
   1505          	#endif
   1506          
   1507          	traceTASK_INCREMENT_TICK( xTickCount );
   1508          }
   \                     ??vTaskIncrementTick_3: (+1)
   \   000000A0   0xBD70             POP      {R4-R6,PC}       ;; return
   1509          /*-----------------------------------------------------------*/
   1510          
   1511          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1512          
   1513          	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
   1514          	{
   1515          	tskTCB *xTCB;
   1516          
   1517          		/* If xTask is NULL then we are setting our own task hook. */
   1518          		if( xTask == NULL )
   1519          		{
   1520          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1521          		}
   1522          		else
   1523          		{
   1524          			xTCB = ( tskTCB * ) xTask;
   1525          		}
   1526          
   1527          		/* Save the hook function in the TCB.  A critical section is required as
   1528          		the value can be accessed from an interrupt. */
   1529          		taskENTER_CRITICAL();
   1530          			xTCB->pxTaskTag = pxHookFunction;
   1531          		taskEXIT_CRITICAL();
   1532          	}
   1533          
   1534          #endif
   1535          /*-----------------------------------------------------------*/
   1536          
   1537          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1538          
   1539          	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
   1540          	{
   1541          	tskTCB *xTCB;
   1542          	pdTASK_HOOK_CODE xReturn;
   1543          
   1544          		/* If xTask is NULL then we are setting our own task hook. */
   1545          		if( xTask == NULL )
   1546          		{
   1547          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1548          		}
   1549          		else
   1550          		{
   1551          			xTCB = ( tskTCB * ) xTask;
   1552          		}
   1553          
   1554          		/* Save the hook function in the TCB.  A critical section is required as
   1555          		the value can be accessed from an interrupt. */
   1556          		taskENTER_CRITICAL();
   1557          			xReturn = xTCB->pxTaskTag;
   1558          		taskEXIT_CRITICAL();
   1559          
   1560          		return xReturn;
   1561          	}
   1562          
   1563          #endif
   1564          /*-----------------------------------------------------------*/
   1565          
   1566          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1567          
   1568          	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
   1569          	{
   1570          	tskTCB *xTCB;
   1571          	portBASE_TYPE xReturn;
   1572          
   1573          		/* If xTask is NULL then we are calling our own task hook. */
   1574          		if( xTask == NULL )
   1575          		{
   1576          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1577          		}
   1578          		else
   1579          		{
   1580          			xTCB = ( tskTCB * ) xTask;
   1581          		}
   1582          
   1583          		if( xTCB->pxTaskTag != NULL )
   1584          		{
   1585          			xReturn = xTCB->pxTaskTag( pvParameter );
   1586          		}
   1587          		else
   1588          		{
   1589          			xReturn = pdFAIL;
   1590          		}
   1591          
   1592          		return xReturn;
   1593          	}
   1594          
   1595          #endif
   1596          /*-----------------------------------------------------------*/
   1597          

   \                                 In section .text, align 2, keep-with-next
   1598          void vTaskSwitchContext( void )
   1599          {
   1600          	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   \                     vTaskSwitchContext: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable24
   \   00000002   0x6F41             LDR      R1,[R0, #+116]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD004             BEQ.N    ??vTaskSwitchContext_0
   1601          	{
   1602          		/* The scheduler is currently suspended - do not allow a context
   1603          		switch. */
   1604          		xMissedYield = pdTRUE;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x67C1             STR      R1,[R0, #+124]
   \   0000000C   0x4770             BX       LR
   1605          	}
   1606          	else
   1607          	{
   1608          		traceTASK_SWITCHED_OUT();
   1609          	
   1610          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   1611          		{
   1612          			unsigned long ulTempCounter;
   1613          			
   1614          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1615          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
   1616          				#else
   1617          					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
   1618          				#endif
   1619          	
   1620          				/* Add the amount of time the task has been running to the accumulated
   1621          				time so far.  The time the task started running was stored in
   1622          				ulTaskSwitchedInTime.  Note that there is no overflow protection here
   1623          				so count values are only valid until the timer overflows.  Generally
   1624          				this will be about 1 hour assuming a 1uS timer increment. */
   1625          				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
   1626          				ulTaskSwitchedInTime = ulTempCounter;
   1627          		}
   1628          		#endif
   1629          	
   1630          		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   1631          		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   1632          	
   1633          		/* Find the highest priority queue that contains ready tasks. */
   1634          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
   1635          		{
   1636          			configASSERT( uxTopReadyPriority );
   1637          			--uxTopReadyPriority;
   \                     ??vTaskSwitchContext_1: (+1)
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0x6701             STR      R1,[R0, #+112]
   1638          		}
   \                     ??vTaskSwitchContext_0: (+1)
   \   00000012   0x6F01             LDR      R1,[R0, #+112]
   \   00000014   0x2214             MOVS     R2,#+20
   \   00000016   0xFB02 0x0101      MLA      R1,R2,R1,R0
   \   0000001A   0x6849             LDR      R1,[R1, #+4]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0x6F01             LDR      R1,[R0, #+112]
   \   00000020   0xD0F5             BEQ.N    ??vTaskSwitchContext_1
   1639          	
   1640          		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
   1641          		same priority get an equal share of the processor time. */
   1642          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
   \   00000022   0xFB02 0x0101      MLA      R1,R2,R1,R0
   \   00000026   0x1D09             ADDS     R1,R1,#+4
   \   00000028   0x684A             LDR      R2,[R1, #+4]
   \   0000002A   0x6852             LDR      R2,[R2, #+4]
   \   0000002C   0x604A             STR      R2,[R1, #+4]
   \   0000002E   0xF101 0x0308      ADD      R3,R1,#+8
   \   00000032   0x429A             CMP      R2,R3
   \   00000034   0xD101             BNE.N    ??vTaskSwitchContext_2
   \   00000036   0x6852             LDR      R2,[R2, #+4]
   \   00000038   0x604A             STR      R2,[R1, #+4]
   \                     ??vTaskSwitchContext_2: (+1)
   \   0000003A   0x6849             LDR      R1,[R1, #+4]
   \   0000003C   0x68C9             LDR      R1,[R1, #+12]
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   1643          
   1644          		traceTASK_SWITCHED_IN();
   1645          	}
   1646          }
   \   00000040   0x4770             BX       LR               ;; return
   1647          /*-----------------------------------------------------------*/
   1648          

   \                                 In section .text, align 2, keep-with-next
   1649          void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
   1650          {
   \                     vTaskPlaceOnEventList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
   1651          portTickType xTimeToWake;
   1652          
   1653          	configASSERT( pxEventList );
   1654          
   1655          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1656          	SCHEDULER SUSPENDED. */
   1657          
   1658          	/* Place the event list item of the TCB in the appropriate event list.
   1659          	This is placed in the list in priority order so the highest priority task
   1660          	is the first to be woken by the event. */
   1661          	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   \   00000004   0x....             LDR.N    R5,??DataTable24
   \   00000006   0x6829             LDR      R1,[R5, #+0]
   \   00000008   0x3118             ADDS     R1,R1,#+24
   \   0000000A   0x.... 0x....      BL       vListInsert
   1662          
   1663          	/* We must remove ourselves from the ready list before adding ourselves
   1664          	to the blocked list as the same list item is used for both lists.  We have
   1665          	exclusive access to the ready lists as the scheduler is locked. */
   1666          	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   0000000E   0x6828             LDR      R0,[R5, #+0]
   \   00000010   0x1D00             ADDS     R0,R0,#+4
   \   00000012   0x.... 0x....      BL       vListRemove
   1667          
   1668          
   1669          	#if ( INCLUDE_vTaskSuspend == 1 )
   1670          	{
   1671          		if( xTicksToWait == portMAX_DELAY )
   \   00000016   0xF114 0x0F01      CMN      R4,#+1
   \   0000001A   0xD106             BNE.N    ??vTaskPlaceOnEventList_0
   1672          		{
   1673          			/* Add ourselves to the suspended task list instead of a delayed task
   1674          			list to ensure we are not woken by a timing event.  We will block
   1675          			indefinitely. */
   1676          			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x1D01             ADDS     R1,R0,#+4
   \   00000020   0x....             LDR.N    R0,??DataTable24_2
   \   00000022   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      vListInsertEnd
   1677          		}
   1678          		else
   1679          		{
   1680          			/* Calculate the time at which the task should be woken if the event does
   1681          			not occur.  This may overflow but this doesn't matter. */
   1682          			xTimeToWake = xTickCount + xTicksToWait;
   \                     ??vTaskPlaceOnEventList_0: (+1)
   \   0000002A   0x6EE8             LDR      R0,[R5, #+108]
   \   0000002C   0x1820             ADDS     R0,R4,R0
   1683          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   0000002E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000032   0x....             B.N      _Z30prvAddCurrentTaskToDelayedListm
   1684          		}
   1685          	}
   1686          	#else
   1687          	{
   1688          			/* Calculate the time at which the task should be woken if the event does
   1689          			not occur.  This may overflow but this doesn't matter. */
   1690          			xTimeToWake = xTickCount + xTicksToWait;
   1691          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   1692          	}
   1693          	#endif
   1694          }
   1695          /*-----------------------------------------------------------*/
   1696          
   1697          #if configUSE_TIMERS == 1
   1698          
   1699          	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
   1700          	{
   1701          	portTickType xTimeToWake;
   1702          
   1703          		configASSERT( pxEventList );
   1704          
   1705          		/* This function should not be called by application code hence the
   1706          		'Restricted' in its name.  It is not part of the public API.  It is
   1707          		designed for use by kernel code, and has special calling requirements -
   1708          		it should be called from a critical section. */
   1709          
   1710          	
   1711          		/* Place the event list item of the TCB in the appropriate event list.
   1712          		In this case it is assume that this is the only task that is going to
   1713          		be waiting on this event list, so the faster vListInsertEnd() function
   1714          		can be used in place of vListInsert. */
   1715          		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   1716          
   1717          		/* We must remove this task from the ready list before adding it to the
   1718          		blocked list as the same list item is used for both lists.  This
   1719          		function is called form a critical section. */
   1720          		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   1721          
   1722          		/* Calculate the time at which the task should be woken if the event does
   1723          		not occur.  This may overflow but this doesn't matter. */
   1724          		xTimeToWake = xTickCount + xTicksToWait;
   1725          		prvAddCurrentTaskToDelayedList( xTimeToWake );
   1726          	}
   1727          	
   1728          #endif /* configUSE_TIMERS */
   1729          /*-----------------------------------------------------------*/
   1730          

   \                                 In section .text, align 2, keep-with-next
   1731          signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
   1732          {
   \                     xTaskRemoveFromEventList: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1733          tskTCB *pxUnblockedTCB;
   1734          portBASE_TYPE xReturn;
   1735          
   1736          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1737          	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
   1738          
   1739          	/* The event list is sorted in priority order, so we can remove the
   1740          	first in the list, remove the TCB from the delayed list, and add
   1741          	it to the ready list.
   1742          
   1743          	If an event is for a queue that is locked then this function will never
   1744          	get called - the lock count on the queue will get modified instead.  This
   1745          	means we can always expect exclusive access to the event list here.
   1746          	
   1747          	This function assumes that a check has already been made to ensure that
   1748          	pxEventList is not empty. */
   1749          	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0x68C4             LDR      R4,[R0, #+12]
   1750          	configASSERT( pxUnblockedTCB );
   1751          	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
   \   00000006   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000000A   0x.... 0x....      BL       vListRemove
   1752          
   1753          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   \   0000000E   0x....             LDR.N    R5,??DataTable24
   \   00000010   0x6F68             LDR      R0,[R5, #+116]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD110             BNE.N    ??xTaskRemoveFromEventList_0
   1754          	{
   1755          		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   \   00000016   0x1D20             ADDS     R0,R4,#+4
   \   00000018   0x.... 0x....      BL       vListRemove
   1756          		prvAddTaskToReadyQueue( pxUnblockedTCB );
   \   0000001C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000001E   0x6F29             LDR      R1,[R5, #+112]
   \   00000020   0x4281             CMP      R1,R0
   \   00000022   0xD200             BCS.N    ??xTaskRemoveFromEventList_1
   \   00000024   0x6728             STR      R0,[R5, #+112]
   \                     ??xTaskRemoveFromEventList_1: (+1)
   \   00000026   0x1D21             ADDS     R1,R4,#+4
   \   00000028   0xEB00 0x0280      ADD      R2,R0,R0, LSL #+2
   \   0000002C   0xEB05 0x0082      ADD      R0,R5,R2, LSL #+2
   \   00000030   0x1D00             ADDS     R0,R0,#+4
   \   00000032   0x.... 0x....      BL       vListInsertEnd
   \   00000036   0xE004             B.N      ??xTaskRemoveFromEventList_2
   1757          	}
   1758          	else
   1759          	{
   1760          		/* We cannot access the delayed or ready lists, so will hold this
   1761          		task pending until the scheduler is resumed. */
   1762          		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_0: (+1)
   \   00000038   0xF104 0x0118      ADD      R1,R4,#+24
   \   0000003C   0x....             LDR.N    R0,??DataTable24_1
   \   0000003E   0x.... 0x....      BL       vListInsertEnd
   1763          	}
   1764          
   1765          	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \                     ??xTaskRemoveFromEventList_2: (+1)
   \   00000042   0x6AE0             LDR      R0,[R4, #+44]
   \   00000044   0x6829             LDR      R1,[R5, #+0]
   \   00000046   0x6AC9             LDR      R1,[R1, #+44]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0x4180             SBCS     R0,R0,R0
   \   0000004C   0x43C0             MVNS     R0,R0
   \   0000004E   0x0FC0             LSRS     R0,R0,#+31
   1766          	{
   1767          		/* Return true if the task removed from the event list has
   1768          		a higher priority than the calling task.  This allows
   1769          		the calling task to know if it should force a context
   1770          		switch now. */
   1771          		xReturn = pdTRUE;
   1772          	}
   1773          	else
   1774          	{
   1775          		xReturn = pdFALSE;
   1776          	}
   1777          
   1778          	return xReturn;
   \   00000050   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1779          }
   1780          /*-----------------------------------------------------------*/
   1781          

   \                                 In section .text, align 2, keep-with-next
   1782          void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
   1783          {
   1784          	configASSERT( pxTimeOut );
   1785          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   \                     vTaskSetTimeOutState: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable24_1
   \   00000002   0x6B89             LDR      R1,[R1, #+56]
   \   00000004   0x6001             STR      R1,[R0, #+0]
   1786          	pxTimeOut->xTimeOnEntering = xTickCount;
   \   00000006   0x....             LDR.N    R1,??DataTable24
   \   00000008   0x6EC9             LDR      R1,[R1, #+108]
   \   0000000A   0x6041             STR      R1,[R0, #+4]
   1787          }
   \   0000000C   0x4770             BX       LR               ;; return
   1788          /*-----------------------------------------------------------*/
   1789          

   \                                 In section .text, align 2, keep-with-next
   1790          portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
   1791          {
   \                     xTaskCheckForTimeOut: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1792          portBASE_TYPE xReturn;
   1793          
   1794          	configASSERT( pxTimeOut );
   1795          	configASSERT( pxTicksToWait );
   1796          
   1797          	taskENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
   1798          	{
   1799          		#if ( INCLUDE_vTaskSuspend == 1 )
   1800          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   1801          			the maximum block time then the task should block indefinitely, and
   1802          			therefore never time out. */
   1803          			if( *pxTicksToWait == portMAX_DELAY )
   \   0000000A   0x6828             LDR      R0,[R5, #+0]
   \   0000000C   0xF110 0x0F01      CMN      R0,#+1
   \   00000010   0xD101             BNE.N    ??xTaskCheckForTimeOut_0
   1804          			{
   1805          				xReturn = pdFALSE;
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0xE019             B.N      ??xTaskCheckForTimeOut_1
   1806          			}
   1807          			else /* We are not blocking indefinitely, perform the checks below. */
   1808          		#endif
   1809          
   1810          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
   \                     ??xTaskCheckForTimeOut_0: (+1)
   \   00000016   0x6861             LDR      R1,[R4, #+4]
   \   00000018   0x....             LDR.N    R2,??DataTable24
   \   0000001A   0x....             LDR.N    R3,??DataTable24_1
   \   0000001C   0x6B9B             LDR      R3,[R3, #+56]
   \   0000001E   0x6826             LDR      R6,[R4, #+0]
   \   00000020   0x42B3             CMP      R3,R6
   \   00000022   0xD004             BEQ.N    ??xTaskCheckForTimeOut_2
   \   00000024   0x6ED3             LDR      R3,[R2, #+108]
   \   00000026   0x428B             CMP      R3,R1
   \   00000028   0xD301             BCC.N    ??xTaskCheckForTimeOut_2
   1811          		{
   1812          			/* The tick count is greater than the time at which vTaskSetTimeout()
   1813          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   1814          			It must have wrapped all the way around and gone past us again. This
   1815          			passed since vTaskSetTimeout() was called. */
   1816          			xReturn = pdTRUE;
   \   0000002A   0x2401             MOVS     R4,#+1
   \   0000002C   0xE00D             B.N      ??xTaskCheckForTimeOut_1
   1817          		}
   1818          		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
   \                     ??xTaskCheckForTimeOut_2: (+1)
   \   0000002E   0x6ED3             LDR      R3,[R2, #+108]
   \   00000030   0x1A5B             SUBS     R3,R3,R1
   \   00000032   0x4283             CMP      R3,R0
   \   00000034   0xD208             BCS.N    ??xTaskCheckForTimeOut_3
   1819          		{
   1820          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   1821          			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
   \   00000036   0x6ED2             LDR      R2,[R2, #+108]
   \   00000038   0x1A80             SUBS     R0,R0,R2
   \   0000003A   0x1808             ADDS     R0,R1,R0
   \   0000003C   0x6028             STR      R0,[R5, #+0]
   1822          			vTaskSetTimeOutState( pxTimeOut );
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       vTaskSetTimeOutState
   1823          			xReturn = pdFALSE;
   \   00000044   0x2400             MOVS     R4,#+0
   \   00000046   0xE000             B.N      ??xTaskCheckForTimeOut_1
   1824          		}
   1825          		else
   1826          		{
   1827          			xReturn = pdTRUE;
   \                     ??xTaskCheckForTimeOut_3: (+1)
   \   00000048   0x2401             MOVS     R4,#+1
   1828          		}
   1829          	}
   1830          	taskEXIT_CRITICAL();
   \                     ??xTaskCheckForTimeOut_1: (+1)
   \   0000004A   0x.... 0x....      BL       vPortExitCritical
   1831          
   1832          	return xReturn;
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
   1833          }
   1834          /*-----------------------------------------------------------*/
   1835          

   \                                 In section .text, align 2, keep-with-next
   1836          void vTaskMissedYield( void )
   1837          {
   1838          	xMissedYield = pdTRUE;
   \                     vTaskMissedYield: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR.N    R1,??DataTable24
   \   00000004   0x67C8             STR      R0,[R1, #+124]
   1839          }
   \   00000006   0x4770             BX       LR               ;; return
   1840          /*-----------------------------------------------------------*/
   1841          
   1842          #if ( configUSE_TRACE_FACILITY == 1 )
   1843          	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
   1844          	{
   1845          	unsigned portBASE_TYPE uxReturn;
   1846          	tskTCB *pxTCB;
   1847          	
   1848          		if( xTask != NULL )
   1849          		{
   1850          			pxTCB = ( tskTCB * ) xTask;
   1851          			uxReturn = pxTCB->uxTaskNumber;
   1852          		}
   1853          		else
   1854          		{
   1855          			uxReturn = 0U;
   1856          		}
   1857          		
   1858          		return uxReturn;
   1859          	}
   1860          #endif
   1861          /*-----------------------------------------------------------*/
   1862          
   1863          #if ( configUSE_TRACE_FACILITY == 1 )
   1864          	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
   1865          	{
   1866          	tskTCB *pxTCB;
   1867          	
   1868          		if( xTask != NULL )
   1869          		{
   1870          			pxTCB = ( tskTCB * ) xTask;
   1871          			pxTCB->uxTaskNumber = uxHandle;
   1872          		}
   1873          	}
   1874          #endif
   1875          
   1876          
   1877          /*
   1878           * -----------------------------------------------------------
   1879           * The Idle task.
   1880           * ----------------------------------------------------------
   1881           *
   1882           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   1883           * language extensions.  The equivalent prototype for this function is:
   1884           *
   1885           * void prvIdleTask( void *pvParameters );
   1886           *
   1887           */

   \                                 In section .text, align 4, keep-with-next
   1888          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   1889          {
   \                     _Z11prvIdleTaskPv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1890          	/* Stop warnings. */
   1891          	( void ) pvParameters;
   1892          
   1893          	for( ;; )
   1894          	{
   1895          		/* See if any tasks have been deleted. */
   1896          		prvCheckTasksWaitingTermination();
   \                     ??prvIdleTask_0: (+1)
   \   00000002   0x.... 0x....      BL       _Z31prvCheckTasksWaitingTerminationv
   1897          
   1898          		#if ( configUSE_PREEMPTION == 0 )
   1899          		{
   1900          			/* If we are not using preemption we keep forcing a task switch to
   1901          			see if any other task has become available.  If we are using
   1902          			preemption we don't need to do this as any task becoming available
   1903          			will automatically get the processor anyway. */
   1904          			taskYIELD();
   1905          		}
   1906          		#endif
   1907          
   1908          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   1909          		{
   1910          			/* When using preemption tasks of equal priority will be
   1911          			timesliced.  If a task that is sharing the idle priority is ready
   1912          			to run then the idle task should yield before the end of the
   1913          			timeslice.
   1914          
   1915          			A critical region is not required here as we are just reading from
   1916          			the list, and an occasional incorrect value will not matter.  If
   1917          			the ready list at the idle priority contains more than one task
   1918          			then a task other than the idle task is ready to execute. */
   1919          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   \   00000006   0x....             LDR.N    R0,??DataTable24
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD301             BCC.N    ??prvIdleTask_1
   1920          			{
   1921          				taskYIELD();
   \   0000000E   0x.... 0x....      BL       vPortYieldFromISR
   1922          			}
   1923          		}
   1924          		#endif
   1925          
   1926          		#if ( configUSE_IDLE_HOOK == 1 )
   1927          		{
   1928          			extern void vApplicationIdleHook( void );
   1929          
   1930          			/* Call the user defined function from within the idle task.  This
   1931          			allows the application designer to add background functionality
   1932          			without the overhead of a separate task.
   1933          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   1934          			CALL A FUNCTION THAT MIGHT BLOCK. */
   1935          			vApplicationIdleHook();
   \                     ??prvIdleTask_1: (+1)
   \   00000012   0x.... 0x....      BL       _Z20vApplicationIdleHookv
   \   00000016   0xE7F4             B.N      ??prvIdleTask_0
   1936          		}
   1937          		#endif
   1938          	}
   1939          } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
   1940          
   1941          
   1942          
   1943          
   1944          
   1945          
   1946          
   1947          /*-----------------------------------------------------------
   1948           * File private functions documented at the top of the file.
   1949           *----------------------------------------------------------*/
   1950          
   1951          
   1952          

   \                                 In section .text, align 2, keep-with-next
   1953          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
   1954          {
   \                     _Z25prvInitialiseTCBVariablesP19tskTaskControlBlockPKamPK14xMEMORY_REGIONt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
   1955          	/* Store the function name in the TCB. */
   1956          	#if configMAX_TASK_NAME_LEN > 1
   1957          	{
   1958          		/* Don't bring strncpy into the build unnecessarily. */
   1959          		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   \   00000006   0x2210             MOVS     R2,#+16
   \   00000008   0xF104 0x0034      ADD      R0,R4,#+52
   \   0000000C   0x.... 0x....      BL       strncpy
   1960          	}
   1961          	#endif
   1962          	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF884 0x0043      STRB     R0,[R4, #+67]
   1963          
   1964          	/* This is used as an array index so must ensure it's not too large.  First
   1965          	remove the privilege bit if one is present. */
   1966          	if( uxPriority >= configMAX_PRIORITIES )
   \   00000016   0x2D05             CMP      R5,#+5
   \   00000018   0xD300             BCC.N    ??prvInitialiseTCBVariables_0
   1967          	{
   1968          		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   \   0000001A   0x2504             MOVS     R5,#+4
   1969          	}
   1970          
   1971          	pxTCB->uxPriority = uxPriority;
   \                     ??prvInitialiseTCBVariables_0: (+1)
   \   0000001C   0xF104 0x0610      ADD      R6,R4,#+16
   \   00000020   0x61F5             STR      R5,[R6, #+28]
   1972          	#if ( configUSE_MUTEXES == 1 )
   1973          	{
   1974          		pxTCB->uxBasePriority = uxPriority;
   1975          	}
   1976          	#endif
   1977          
   1978          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   \   00000022   0x1D20             ADDS     R0,R4,#+4
   \   00000024   0x.... 0x....      BL       vListInitialiseItem
   1979          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   \   00000028   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000002C   0x.... 0x....      BL       vListInitialiseItem
   1980          
   1981          	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
   1982          	back to	the containing TCB from a generic item in a list. */
   1983          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   \   00000030   0x6034             STR      R4,[R6, #+0]
   1984          
   1985          	/* Event lists are always in priority order. */
   1986          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   \   00000032   0xF1C5 0x0005      RSB      R0,R5,#+5
   \   00000036   0x60B0             STR      R0,[R6, #+8]
   1987          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   \   00000038   0x6174             STR      R4,[R6, #+20]
   1988          
   1989          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   1990          	{
   1991          		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
   1992          	}
   1993          	#endif
   1994          
   1995          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1996          	{
   1997          		pxTCB->pxTaskTag = NULL;
   1998          	}
   1999          	#endif
   2000          
   2001          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2002          	{
   2003          		pxTCB->ulRunTimeCounter = 0UL;
   2004          	}
   2005          	#endif
   2006          
   2007          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2008          	{
   2009          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2010          	}
   2011          	#else
   2012          	{
   2013          		( void ) xRegions;
   2014          		( void ) usStackDepth;
   2015          	}
   2016          	#endif
   2017          }
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
   2018          /*-----------------------------------------------------------*/
   2019          
   2020          #if ( portUSING_MPU_WRAPPERS == 1 )
   2021          
   2022          	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
   2023          	{
   2024          	tskTCB *pxTCB;
   2025          	
   2026          		if( xTaskToModify == pxCurrentTCB )
   2027          		{
   2028          			xTaskToModify = NULL;
   2029          		}
   2030          
   2031          		/* If null is passed in here then we are deleting ourselves. */
   2032          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   2033          
   2034                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   2035          	}
   2036          	/*-----------------------------------------------------------*/
   2037          #endif
   2038          

   \                                 In section .text, align 2, keep-with-next
   2039          static void prvInitialiseTaskLists( void )
   2040          {
   \                     _Z22prvInitialiseTaskListsv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2041          unsigned portBASE_TYPE uxPriority;
   2042          
   2043          	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE008             B.N      ??prvInitialiseTaskLists_0
   2044          	{
   2045          		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   \                     ??prvInitialiseTaskLists_1: (+1)
   \   00000006   0x....             LDR.N    R0,??DataTable24
   \   00000008   0xEB04 0x0184      ADD      R1,R4,R4, LSL #+2
   \   0000000C   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000010   0x1D00             ADDS     R0,R0,#+4
   \   00000012   0x.... 0x....      BL       vListInitialise
   2046          	}
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??prvInitialiseTaskLists_0: (+1)
   \   00000018   0x2C05             CMP      R4,#+5
   \   0000001A   0xD3F4             BCC.N    ??prvInitialiseTaskLists_1
   2047          
   2048          	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   \   0000001C   0x....             LDR.N    R4,??DataTable24_1
   \   0000001E   0xF104 0x0044      ADD      R0,R4,#+68
   \   00000022   0x.... 0x....      BL       vListInitialise
   2049          	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   \   00000026   0xF104 0x0058      ADD      R0,R4,#+88
   \   0000002A   0x.... 0x....      BL       vListInitialise
   2050          	vListInitialise( ( xList * ) &xPendingReadyList );
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       vListInitialise
   2051          
   2052          	#if ( INCLUDE_vTaskDelete == 1 )
   2053          	{
   2054          		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   2055          	}
   2056          	#endif
   2057          
   2058          	#if ( INCLUDE_vTaskSuspend == 1 )
   2059          	{
   2060          		vListInitialise( ( xList * ) &xSuspendedTaskList );
   \   00000034   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000038   0x.... 0x....      BL       vListInitialise
   2061          	}
   2062          	#endif
   2063          
   2064          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   2065          	using list2. */
   2066          	pxDelayedTaskList = &xDelayedTaskList1;
   \   0000003C   0xF104 0x0044      ADD      R0,R4,#+68
   \   00000040   0x6160             STR      R0,[R4, #+20]
   2067          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   \   00000042   0xF104 0x0058      ADD      R0,R4,#+88
   \   00000046   0x61A0             STR      R0,[R4, #+24]
   2068          }
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
   2069          /*-----------------------------------------------------------*/
   2070          

   \                                 In section .text, align 2, keep-with-next
   2071          static void prvCheckTasksWaitingTermination( void )
   2072          {
   2073          	#if ( INCLUDE_vTaskDelete == 1 )
   2074          	{
   2075          		portBASE_TYPE xListIsEmpty;
   2076          
   2077          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   2078          		too often in the idle task. */
   2079          		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   2080          		{
   2081          			vTaskSuspendAll();
   2082          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   2083          			xTaskResumeAll();
   2084          
   2085          			if( xListIsEmpty == pdFALSE )
   2086          			{
   2087          				tskTCB *pxTCB;
   2088          
   2089          				taskENTER_CRITICAL();
   2090          				{
   2091          					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
   2092          					vListRemove( &( pxTCB->xGenericListItem ) );
   2093          					--uxCurrentNumberOfTasks;
   2094          					--uxTasksDeleted;
   2095          				}
   2096          				taskEXIT_CRITICAL();
   2097          
   2098          				prvDeleteTCB( pxTCB );
   2099          			}
   2100          		}
   2101          	}
   2102          	#endif
   2103          }
   \                     _Z31prvCheckTasksWaitingTerminationv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   2104          /*-----------------------------------------------------------*/
   2105          

   \                                 In section .text, align 2, keep-with-next
   2106          static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
   2107          {
   \                     _Z30prvAddCurrentTaskToDelayedListm: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2108          	/* The list item will be inserted in wake time order. */
   2109          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   \   00000004   0x....             LDR.N    R0,??DataTable24
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x604C             STR      R4,[R1, #+4]
   2110          
   2111          	if( xTimeToWake < xTickCount )
   \   0000000A   0x....             LDR.N    R5,??DataTable24_1
   \   0000000C   0x6EC1             LDR      R1,[R0, #+108]
   \   0000000E   0x428C             CMP      R4,R1
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xD205             BCS.N    ??prvAddCurrentTaskToDelayedList_0
   2112          	{
   2113          		/* Wake time has overflowed.  Place this item in the overflow list. */
   2114          		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \   00000014   0x1D01             ADDS     R1,R0,#+4
   \   00000016   0x69A8             LDR      R0,[R5, #+24]
   \   00000018   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000001C   0x.... 0x....      B.W      vListInsert
   2115          	}
   2116          	else
   2117          	{
   2118          		/* The wake time has not overflowed, so we can use the current block list. */
   2119          		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   \                     ??prvAddCurrentTaskToDelayedList_0: (+1)
   \   00000020   0x1D01             ADDS     R1,R0,#+4
   \   00000022   0x6968             LDR      R0,[R5, #+20]
   \   00000024   0x.... 0x....      BL       vListInsert
   2120          
   2121          		/* If the task entering the blocked state was placed at the head of the
   2122          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   2123          		too. */
   2124          		if( xTimeToWake < xNextTaskUnblockTime )
   \   00000028   0x6C28             LDR      R0,[R5, #+64]
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD900             BLS.N    ??prvAddCurrentTaskToDelayedList_1
   \   0000002E   0x4604             MOV      R4,R0
   \                     ??prvAddCurrentTaskToDelayedList_1: (+1)
   \   00000030   0x642C             STR      R4,[R5, #+64]
   2125          		{
   2126          			xNextTaskUnblockTime = xTimeToWake;
   2127          		}
   2128          	}
   2129          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2130          /*-----------------------------------------------------------*/
   2131          

   \                                 In section .text, align 2, keep-with-next
   2132          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
   2133          {
   \                     _Z22prvAllocateTCBAndStacktPm: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2134          tskTCB *pxNewTCB;
   2135          
   2136          	/* Allocate space for the TCB.  Where the memory comes from depends on
   2137          	the implementation of the port malloc function. */
   2138          	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   \   00000006   0x2044             MOVS     R0,#+68
   \   00000008   0x.... 0x....      BL       pvPortMalloc
   \   0000000C   0x0006             MOVS     R6,R0
   2139          
   2140          	if( pxNewTCB != NULL )
   \   0000000E   0xD012             BEQ.N    ??prvAllocateTCBAndStack_0
   2141          	{
   2142          		/* Allocate space for the stack used by the task being created.
   2143          		The base of the stack memory stored in the TCB so the task can
   2144          		be deleted later if required. */
   2145          		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD103             BNE.N    ??prvAllocateTCBAndStack_1
   \   00000014   0x00A0             LSLS     R0,R4,#+2
   \   00000016   0x.... 0x....      BL       pvPortMalloc
   \   0000001A   0x4605             MOV      R5,R0
   \                     ??prvAllocateTCBAndStack_1: (+1)
   \   0000001C   0x6335             STR      R5,[R6, #+48]
   2146          
   2147          		if( pxNewTCB->pxStack == NULL )
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD104             BNE.N    ??prvAllocateTCBAndStack_2
   2148          		{
   2149          			/* Could not allocate the stack.  Delete the allocated TCB. */
   2150          			vPortFree( pxNewTCB );
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       vPortFree
   2151          			pxNewTCB = NULL;
   \   0000002A   0x2600             MOVS     R6,#+0
   \   0000002C   0xE003             B.N      ??prvAllocateTCBAndStack_0
   2152          		}
   2153          		else
   2154          		{
   2155          			/* Just to help debugging. */
   2156          			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   \                     ??prvAllocateTCBAndStack_2: (+1)
   \   0000002E   0x22A5             MOVS     R2,#+165
   \   00000030   0x00A1             LSLS     R1,R4,#+2
   \   00000032   0x.... 0x....      BL       __aeabi_memset4
   2157          		}
   2158          	}
   2159          
   2160          	return pxNewTCB;
   \                     ??prvAllocateTCBAndStack_0: (+1)
   \   00000036   0x4630             MOV      R0,R6
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
   2161          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x........         DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x........         DC32     xPendingReadyList+0x1C

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x49 0x44          DC8 "IDLE"
   \              0x4C 0x45    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2162          /*-----------------------------------------------------------*/
   2163          
   2164          #if ( configUSE_TRACE_FACILITY == 1 )
   2165          
   2166          	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
   2167          	{
   2168          	volatile tskTCB *pxNextTCB, *pxFirstTCB;
   2169          	unsigned short usStackRemaining;
   2170          	PRIVILEGED_DATA static char pcStatusString[ 50 ];
   2171          
   2172          		/* Write the details of all the TCB's in pxList into the buffer. */
   2173          		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2174          		do
   2175          		{
   2176          			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2177          			#if ( portSTACK_GROWTH > 0 )
   2178          			{
   2179          				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
   2180          			}
   2181          			#else
   2182          			{
   2183          				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
   2184          			}
   2185          			#endif			
   2186          			
   2187          			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
   2188          			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
   2189          
   2190          		} while( pxNextTCB != pxFirstTCB );
   2191          	}
   2192          
   2193          #endif
   2194          /*-----------------------------------------------------------*/
   2195          
   2196          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   2197          
   2198          	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime )
   2199          	{
   2200          	volatile tskTCB *pxNextTCB, *pxFirstTCB;
   2201          	unsigned long ulStatsAsPercentage;
   2202          
   2203          		/* Write the run time stats of all the TCB's in pxList into the buffer. */
   2204          		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2205          		do
   2206          		{
   2207          			/* Get next TCB in from the list. */
   2208          			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2209          
   2210          			/* Divide by zero check. */
   2211          			if( ulTotalRunTime > 0UL )
   2212          			{
   2213          				/* Has the task run at all? */
   2214          				if( pxNextTCB->ulRunTimeCounter == 0UL )
   2215          				{
   2216          					/* The task has used no CPU time at all. */
   2217          					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
   2218          				}
   2219          				else
   2220          				{
   2221          					/* What percentage of the total run time has the task used?
   2222          					This will always be rounded down to the nearest integer.
   2223          					ulTotalRunTime has already been divided by 100. */
   2224          					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
   2225          
   2226          					if( ulStatsAsPercentage > 0UL )
   2227          					{
   2228          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   2229          						{
   2230          							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTCB->ulRunTimeCounter, ulStatsAsPercentage );							
   2231          						}
   2232          						#else
   2233          						{
   2234          							/* sizeof( int ) == sizeof( long ) so a smaller
   2235          							printf() library can be used. */
   2236          							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   2237          						}
   2238          						#endif
   2239          					}
   2240          					else
   2241          					{
   2242          						/* If the percentage is zero here then the task has
   2243          						consumed less than 1% of the total run time. */
   2244          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   2245          						{
   2246          							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB->ulRunTimeCounter );							
   2247          						}
   2248          						#else
   2249          						{
   2250          							/* sizeof( int ) == sizeof( long ) so a smaller
   2251          							printf() library can be used. */
   2252          							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter );
   2253          						}
   2254          						#endif
   2255          					}
   2256          				}
   2257          
   2258          				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
   2259          			}
   2260          
   2261          		} while( pxNextTCB != pxFirstTCB );
   2262          	}
   2263          
   2264          #endif
   2265          /*-----------------------------------------------------------*/
   2266          
   2267          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   2268          
   2269          	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
   2270          	{
   2271          	register unsigned short usCount = 0U;
   2272          
   2273          		while( *pucStackByte == tskSTACK_FILL_BYTE )
   2274          		{
   2275          			pucStackByte -= portSTACK_GROWTH;
   2276          			usCount++;
   2277          		}
   2278          
   2279          		usCount /= sizeof( portSTACK_TYPE );
   2280          
   2281          		return usCount;
   2282          	}
   2283          
   2284          #endif
   2285          /*-----------------------------------------------------------*/
   2286          
   2287          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   2288          
   2289          	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
   2290          	{
   2291          	tskTCB *pxTCB;
   2292          	unsigned char *pcEndOfStack;
   2293          	unsigned portBASE_TYPE uxReturn;
   2294          
   2295          		pxTCB = prvGetTCBFromHandle( xTask );
   2296          
   2297          		#if portSTACK_GROWTH < 0
   2298          		{
   2299          			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
   2300          		}
   2301          		#else
   2302          		{
   2303          			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
   2304          		}
   2305          		#endif
   2306          
   2307          		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
   2308          
   2309          		return uxReturn;
   2310          	}
   2311          
   2312          #endif
   2313          /*-----------------------------------------------------------*/
   2314          
   2315          #if ( INCLUDE_vTaskDelete == 1 )
   2316          
   2317          	static void prvDeleteTCB( tskTCB *pxTCB )
   2318          	{
   2319          		/* This call is required specifically for the TriCore port.  It must be
   2320          		above the vPortFree() calls.  The call is also used by ports/demos that
   2321          		want to allocate and clean RAM statically. */
   2322          		portCLEAN_UP_TCB( pxTCB );
   2323          
   2324          		/* Free up the memory allocated by the scheduler for the task.  It is up to
   2325          		the task to free any memory allocated at the application level. */
   2326          		vPortFreeAligned( pxTCB->pxStack );
   2327          		vPortFree( pxTCB );
   2328          	}
   2329          
   2330          #endif
   2331          
   2332          
   2333          /*-----------------------------------------------------------*/
   2334          
   2335          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   2336          
   2337          	xTaskHandle xTaskGetCurrentTaskHandle( void )
   2338          	{
   2339          	xTaskHandle xReturn;
   2340          
   2341          		/* A critical section is not required as this is not called from
   2342          		an interrupt and the current TCB will always be the same for any
   2343          		individual execution thread. */
   2344          		xReturn = pxCurrentTCB;
   2345          
   2346          		return xReturn;
   2347          	}
   2348          
   2349          #endif
   2350          
   2351          /*-----------------------------------------------------------*/
   2352          
   2353          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   2354          
   2355          	portBASE_TYPE xTaskGetSchedulerState( void )
   2356          	{
   2357          	portBASE_TYPE xReturn;
   2358          
   2359          		if( xSchedulerRunning == pdFALSE )
   2360          		{
   2361          			xReturn = taskSCHEDULER_NOT_STARTED;
   2362          		}
   2363          		else
   2364          		{
   2365          			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   2366          			{
   2367          				xReturn = taskSCHEDULER_RUNNING;
   2368          			}
   2369          			else
   2370          			{
   2371          				xReturn = taskSCHEDULER_SUSPENDED;
   2372          			}
   2373          		}
   2374          
   2375          		return xReturn;
   2376          	}
   2377          
   2378          #endif
   2379          /*-----------------------------------------------------------*/
   2380          
   2381          #if ( configUSE_MUTEXES == 1 )
   2382          
   2383          	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
   2384          	{
   2385          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   2386          
   2387          		configASSERT( pxMutexHolder );
   2388          
   2389          		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   2390          		{
   2391          			/* Adjust the mutex holder state to account for its new priority. */
   2392          			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
   2393          
   2394          			/* If the task being modified is in the ready state it will need to
   2395          			be moved in to a new list. */
   2396          			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   2397          			{
   2398          				vListRemove( &( pxTCB->xGenericListItem ) );
   2399          
   2400          				/* Inherit the priority before being moved into the new list. */
   2401          				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   2402          				prvAddTaskToReadyQueue( pxTCB );
   2403          			}
   2404          			else
   2405          			{
   2406          				/* Just inherit the priority. */
   2407          				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   2408          			}
   2409          
   2410          			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   2411          		}
   2412          	}
   2413          
   2414          #endif
   2415          /*-----------------------------------------------------------*/
   2416          
   2417          #if ( configUSE_MUTEXES == 1 )
   2418          
   2419          	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
   2420          	{
   2421          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   2422          
   2423          		if( pxMutexHolder != NULL )
   2424          		{
   2425          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   2426          			{
   2427          				/* We must be the running task to be able to give the mutex back.
   2428          				Remove ourselves from the ready list we currently appear in. */
   2429          				vListRemove( &( pxTCB->xGenericListItem ) );
   2430          
   2431          				/* Disinherit the priority before adding the task into the new
   2432          				ready list. */
   2433          				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   2434          				pxTCB->uxPriority = pxTCB->uxBasePriority;
   2435          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
   2436          				prvAddTaskToReadyQueue( pxTCB );
   2437          			}
   2438          		}
   2439          	}
   2440          
   2441          #endif
   2442          /*-----------------------------------------------------------*/
   2443          
   2444          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2445          
   2446          	void vTaskEnterCritical( void )
   2447          	{
   2448          		portDISABLE_INTERRUPTS();
   2449          
   2450          		if( xSchedulerRunning != pdFALSE )
   2451          		{
   2452          			( pxCurrentTCB->uxCriticalNesting )++;
   2453          		}
   2454          	}
   2455          
   2456          #endif
   2457          /*-----------------------------------------------------------*/
   2458          
   2459          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2460          
   2461          void vTaskExitCritical( void )
   2462          {
   2463          	if( xSchedulerRunning != pdFALSE )
   2464          	{
   2465          		if( pxCurrentTCB->uxCriticalNesting > 0U )
   2466          		{
   2467          			( pxCurrentTCB->uxCriticalNesting )--;
   2468          
   2469          			if( pxCurrentTCB->uxCriticalNesting == 0U )
   2470          			{
   2471          				portENABLE_INTERRUPTS();
   2472          			}
   2473          		}
   2474          	}
   2475          }
   2476          
   2477          #endif
   2478          /*-----------------------------------------------------------*/
   2479          
   2480          
   2481          
   2482          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   prvAddCurrentTaskToDelayedList(portTickType)
        16   -> vListInsert
      16   prvAllocateTCBAndStack(unsigned short, unsigned long *)
        16   -> __aeabi_memset4
        16   -> pvPortMalloc
        16   -> vPortFree
       0   prvCheckTasksWaitingTermination()
       8   prvIdleTask(void *)
         8   -> prvCheckTasksWaitingTermination()
         8   -> vApplicationIdleHook()
         8   -> vPortYieldFromISR
      16   prvInitialiseTCBVariables(tskTaskControlBlock *, signed char const *, unsigned long, xMemoryRegion const *, unsigned short)
        16   -> strncpy
        16   -> vListInitialiseItem
       8   prvInitialiseTaskLists()
         8   -> vListInitialise
       0   uxTaskGetNumberOfTasks
       8   vTaskDelay
         8   -> prvAddCurrentTaskToDelayedList(portTickType)
         8   -> vListRemove
         8   -> vTaskSuspendAll
         8   -> xTaskResumeAll
      16   vTaskDelayUntil
        16   -> prvAddCurrentTaskToDelayedList(portTickType)
        16   -> vListRemove
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
       8   vTaskEndScheduler
         0   -> vPortEndScheduler
         8   -> vPortSetInterruptMask
      16   vTaskIncrementTick
        16   -> vListInsertEnd
        16   -> vListRemove
       0   vTaskMissedYield
      16   vTaskPlaceOnEventList
         0   -> prvAddCurrentTaskToDelayedList(portTickType)
        16   -> vListInsert
        16   -> vListRemove
      16   vTaskResume
        16   -> vListInsertEnd
        16   -> vListRemove
        16   -> vPortEnterCritical
        16   -> vPortYieldFromISR
        16   -> xTaskIsTaskSuspended
       0   vTaskSetTimeOutState
      24   vTaskStartScheduler
        24   -> vPortSetInterruptMask
        24   -> xTaskGenericCreate
      24   vTaskSuspend
        24   -> vListInsertEnd
        24   -> vListRemove
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
       0   vTaskSuspendAll
       0   vTaskSwitchContext
      16   xTaskCheckForTimeOut
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSetTimeOutState
      40   xTaskGenericCreate
        40   -> prvAllocateTCBAndStack(unsigned short, unsigned long *)
        40   -> prvInitialiseTCBVariables(tskTaskControlBlock *, signed char const *, unsigned long, xMemoryRegion const *, unsigned short)
        40   -> prvInitialiseTaskLists()
        40   -> pxPortInitialiseStack
        40   -> vListInsertEnd
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYieldFromISR
       8   xTaskGetTickCount
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   xTaskGetTickCountFromISR
         8   -> vPortClearInterruptMask
         8   -> vPortSetInterruptMask
       4   xTaskIsTaskSuspended
      16   xTaskRemoveFromEventList
        16   -> vListInsertEnd
        16   -> vListRemove
      24   xTaskResumeAll
        24   -> vListInsertEnd
        24   -> vListRemove
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYieldFromISR
        24   -> vTaskIncrementTick
      16   xTaskResumeFromISR
        16   -> vListInsertEnd
        16   -> vListRemove
        16   -> vPortClearInterruptMask
        16   -> vPortSetInterruptMask
        16   -> xTaskIsTaskSuspended


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       8  ?_0
      52  prvAddCurrentTaskToDelayedList(portTickType)
      58  prvAllocateTCBAndStack(unsigned short, unsigned long *)
       2  prvCheckTasksWaitingTermination()
      24  prvIdleTask(void *)
      60  prvInitialiseTCBVariables(tskTaskControlBlock *, signed char const *, unsigned long, xMemoryRegion const *, unsigned short)
      74  prvInitialiseTaskLists()
     128  pxCurrentTCB
          pxReadyTasksLists
          uxCurrentNumberOfTasks
          xTickCount
          uxTopReadyPriority
          uxSchedulerSuspended
          uxMissedTicks
          xMissedYield
       6  uxTaskGetNumberOfTasks
      54  vTaskDelay
      90  vTaskDelayUntil
      22  vTaskEndScheduler
     162  vTaskIncrementTick
       8  vTaskMissedYield
      52  vTaskPlaceOnEventList
      86  vTaskResume
      14  vTaskSetTimeOutState
      68  vTaskStartScheduler
     108  vTaskSuspend
      12  vTaskSuspendAll
      66  vTaskSwitchContext
     108  xPendingReadyList
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          xSuspendedTaskList
          uxTopUsedPriority
          xSchedulerRunning
          xNumOfOverflows
          uxTaskNumber
          xNextTaskUnblockTime
          xDelayedTaskList1
          xDelayedTaskList2
      82  xTaskCheckForTimeOut
     226  xTaskGenericCreate
      18  xTaskGetTickCount
      18  xTaskGetTickCountFromISR
      36  xTaskIsTaskSuspended
      82  xTaskRemoveFromEventList
     152  xTaskResumeAll
      96  xTaskResumeFromISR

 
   128 bytes in section .bss
   108 bytes in section .data
 1 748 bytes in section .text
 
 1 748 bytes of CODE memory
   236 bytes of DATA memory

Errors: none
Warnings: none
