###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        08/Oct/2018  17:05:04
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TSDProcessor.cpp
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TSDProcessor.cpp -D
#        IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D HAVE_CONFIG_H
#        -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\TSDProcessor.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\TSDProcessor.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TSDProcessor.cpp
      1          /************************************************************************************/
      2          /* @title		SD card processor													*/
      3          /* @author		Cyber Genius														*/
      4          /* @version																			*/
      5          /* @date																			*/
      6          /************************************************************************************/
      7          /* @brief																			*/
      8          /************************************************************************************/
      9          #include "TSDProcessor.h"
     10          #include "TAppProcessor.h"
     11          #include "TRespProcessor.h"
     12          #include "TADS1298.h"
     13          #include "THardware.h"
     14          #include "TDevice.h"
     15          #include "TPoolingNand.h"
     16          /*----------------------------------------------------------------------------------*/

   \                                 In section .bss, align 4
     17          FIL TSDProcessor::MainFile;
   \                     _ZN12TSDProcessor8MainFileE:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
     18          FIL TSDProcessor::TrvFile;
   \                     _ZN12TSDProcessor7TrvFileE:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
     19          FATFS TSDProcessor::FATFS_Obj;
   \                     _ZN12TSDProcessor9FATFS_ObjE:
   \   00000000                      DS8 560

   \                                 In section .bss, align 1
     20          bool TSDProcessor::SDStartWrPool = false;	
   \                     _ZN12TSDProcessor13SDStartWrPoolE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     21          bool TSDProcessor::SDPresent = false;				/* флаг присутствия карты */
   \                     _ZN12TSDProcessor9SDPresentE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     22          bool TSDProcessor::SDWriteEnable = false;
   \                     _ZN12TSDProcessor13SDWriteEnableE:
   \   00000000                      DS8 1
     23          //static unsigned int BwW;							/* Bytes was written */

   \                                 In section .bss, align 1
     24          bool TSDProcessor::Def;						/* reset function */
   \                     _ZN12TSDProcessor3DefE:
   \   00000000                      DS8 1
     25          /*----------------------------------------------------------------------------------*/

   \                                 In section .data, align 1
     26          uint8_t TSDProcessor::TrMode = trverrNofile;
   \                     _ZN12TSDProcessor6TrModeE:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
     27          bool TSDProcessor::ReplaceECGFile = false;
   \                     _ZN12TSDProcessor14ReplaceECGFileE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     28          bool TSDProcessor::NoAskReplaceECGFileQuestion = false;		/* чтобы не зацикливался в программе КР01 вопрос о переписываниии файла */
   \                     _ZN12TSDProcessor27NoAskReplaceECGFileQuestionE:
   \   00000000                      DS8 1
     29          /*----------------------------------------------------------------------------------*/

   \                                 In section .bss, align 4
     30          int8_t TSDProcessor::EcgBuffer_1[ 2048 ];
   \                     _ZN12TSDProcessor11EcgBuffer_1E:
   \   00000000                      DS8 2048

   \                                 In section .bss, align 4
     31          int8_t TSDProcessor::EcgBuffer_2[ 2048 ];
   \                     _ZN12TSDProcessor11EcgBuffer_2E:
   \   00000000                      DS8 2048

   \                                 In section .bss, align 1
     32          bool TSDProcessor::EcgBuffer_1_Full = false;
   \                     _ZN12TSDProcessor16EcgBuffer_1_FullE:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     33          bool TSDProcessor::EcgBuffer_2_Full = false;		/* флаг отмечающий полон ли буффер */
   \                     _ZN12TSDProcessor16EcgBuffer_2_FullE:
   \   00000000                      DS8 1
     34          /*----------------------------------------------------------------------------------*/

   \                                 In section .bss, align 4
     35          xTaskHandle TSDProcessor::xSDPresentCheck;
   \                     _ZN12TSDProcessor15xSDPresentCheckE:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     36          xTaskHandle TSDProcessor::xSDDataWrite;
   \                     _ZN12TSDProcessor12xSDDataWriteE:
   \   00000000                      DS8 4
     37          
     38          
     39          /*----------------------------------------------------------------------------------*/
     40          /* @brief	Заполняет буффер данными ЭКГ для записи на SD карту						*/
     41          /* @param	*Data - указатель на структуру ЭКГ										*/
     42          /* @return	None																	*/
     43          /*----------------------------------------------------------------------------------*/
     44          //-----------------------------------------------------------------------------------
     45          // data block format: byte
     46          // | - 0 - | - 1 - | - 2 - | - 3 - |      - 4 -     | - 5 - | - 6 - |    - 7 -     |
     47          // |       12-bit 3ch ECG data         |4 bit flags | 16bit PD data |ADXL axis data|
     48          // flags - |3:res|2:PD data ready|1-0:ADXL axis|
     49          // PD data ready: 0 - not ready, 1 - valid data
     50          // ADXL axis: 01 - X axis, 10 - Y axis, 11 - Z axis
     51          //-----------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     52          void TSDProcessor::FillBuffer_ECG(EcgData_t *Data)
     53          {
   \                     _ZN12TSDProcessor14FillBuffer_ECGEP9EcgData_t: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
     54            static int16_t Ecg[9];
     55            static uint8_t adxl_axis = 0;
     56            static uint8_t VoltageSource = 0;
     57            uint8_t VoltageValue = 0;
     58            uint8_t TmpDataBuff[16];
     59            uint8_t dt_flags;
     60          //  uint16_t *_pdd_buff_8 = (uint16_t*)&TmpDataBuff[5];
     61          //  uint16_t *_pdd_buff_16 = (uint16_t*)&TmpDataBuff[13];
     62          
     63          	if (TAppProcessor::ecg_format == 2) 
   \   00000002   0xF8DF 0x13F4      LDR.W    R1,??FillBuffer_ECG_0
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x2A02             CMP      R2,#+2
   \   0000000C   0xF040 0x80BF      BNE.W    ??FillBuffer_ECG_1
     64          	{
     65          		for(int i = 0; i < 8; i++)
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0xE007             B.N      ??FillBuffer_ECG_2
     66          		{
     67                Ecg[i] = (int16_t)(Data->Channel[i].ChannelData >> 4);		/* превращаем в 12 битные данные */
   \                     ??FillBuffer_ECG_3: (+1)
   \   00000014   0xEB00 0x0382      ADD      R3,R0,R2, LSL #+2
   \   00000018   0x685B             LDR      R3,[R3, #+4]
   \   0000001A   0x111B             ASRS     R3,R3,#+4
   \   0000001C   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   00000020   0x808B             STRH     R3,[R1, #+4]
     68              }
   \   00000022   0x1C52             ADDS     R2,R2,#+1
   \                     ??FillBuffer_ECG_2: (+1)
   \   00000024   0xF8DF 0x13D4      LDR.W    R1,??FillBuffer_ECG_0+0x4
   \   00000028   0x2A08             CMP      R2,#+8
   \   0000002A   0xDBF3             BLT.N    ??FillBuffer_ECG_3
     69          		Ecg[8] = (int16_t)(Data->Channel[8].ChannelData >> 4);
   \   0000002C   0x6A42             LDR      R2,[R0, #+36]
   \   0000002E   0x1112             ASRS     R2,R2,#+4
   \   00000030   0x828A             STRH     R2,[R1, #+20]
     70          //		Ecg[8] = (int16_t)(Data->Channel_10.ChannelData >> 4);
     71          
     72          		for(int i = 0;i < 9;i++) // 12bit rejection
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0xE006             B.N      ??FillBuffer_ECG_4
     73          		{
     74          //			Ecg[i] = (Ecg[i] * 1653L)/(1223L);
     75          			Ecg[i] = (Ecg[i] * 1653L)/(1206L);
     76          			if(Ecg[i] > 2047L) Ecg[i] = 2047L;
     77          			else	
     78          				if(Ecg[i] < -2048L) Ecg[i] = -2048L;
   \                     ??FillBuffer_ECG_5: (+1)
   \   00000036   0xF513 0x6F00      CMN      R3,#+2048
   \   0000003A   0xDA02             BGE.N    ??FillBuffer_ECG_6
   \   0000003C   0xF8DF 0x33C0      LDR.W    R3,??FillBuffer_ECG_0+0x8  ;; 0xfffff800
   \   00000040   0x80A3             STRH     R3,[R4, #+4]
   \                     ??FillBuffer_ECG_6: (+1)
   \   00000042   0x1C52             ADDS     R2,R2,#+1
   \                     ??FillBuffer_ECG_4: (+1)
   \   00000044   0x2A09             CMP      R2,#+9
   \   00000046   0xDA15             BGE.N    ??FillBuffer_ECG_7
   \   00000048   0xEB01 0x0442      ADD      R4,R1,R2, LSL #+1
   \   0000004C   0xF9B4 0x3004      LDRSH    R3,[R4, #+4]
   \   00000050   0xF240 0x6575      MOVW     R5,#+1653
   \   00000054   0xFB13 0xF305      SMULBB   R3,R3,R5
   \   00000058   0xF240 0x45B6      MOVW     R5,#+1206
   \   0000005C   0xFB93 0xF3F5      SDIV     R3,R3,R5
   \   00000060   0x80A3             STRH     R3,[R4, #+4]
   \   00000062   0xF9B4 0x3004      LDRSH    R3,[R4, #+4]
   \   00000066   0xF5B3 0x6F00      CMP      R3,#+2048
   \   0000006A   0xDBE4             BLT.N    ??FillBuffer_ECG_5
   \   0000006C   0xF240 0x73FF      MOVW     R3,#+2047
   \   00000070   0x80A3             STRH     R3,[R4, #+4]
   \   00000072   0xE7E6             B.N      ??FillBuffer_ECG_6
     79          		}
     80          
     81          		TmpDataBuff[0]   = (uint8_t)((Ecg[0]&0x0FF0)>>4);
   \                     ??FillBuffer_ECG_7: (+1)
   \   00000074   0xF9B1 0x3004      LDRSH    R3,[R1, #+4]
   \   00000078   0x111A             ASRS     R2,R3,#+4
   \   0000007A   0xF88D 0x2000      STRB     R2,[SP, #+0]
     82          		TmpDataBuff[1]   = (uint8_t)((Ecg[0]&0x000F)<<4);
     83          		TmpDataBuff[1]  |= (uint8_t)((Ecg[1]&0x0F00)>>8);
   \   0000007E   0xF9B1 0x4006      LDRSH    R4,[R1, #+6]
   \   00000082   0xAA00             ADD      R2,SP,#+0
   \   00000084   0x1225             ASRS     R5,R4,#+8
   \   00000086   0xF005 0x050F      AND      R5,R5,#0xF
   \   0000008A   0xEA45 0x1303      ORR      R3,R5,R3, LSL #+4
   \   0000008E   0x7053             STRB     R3,[R2, #+1]
     84          		TmpDataBuff[2]   = (uint8_t)( Ecg[1]&0x00FF);
   \   00000090   0x7094             STRB     R4,[R2, #+2]
     85          		TmpDataBuff[3]   = (uint8_t)((Ecg[2]&0x0FF0)>>4);
   \   00000092   0xF9B1 0x3008      LDRSH    R3,[R1, #+8]
   \   00000096   0x111C             ASRS     R4,R3,#+4
   \   00000098   0x70D4             STRB     R4,[R2, #+3]
     86          		TmpDataBuff[4]   = (uint8_t)((Ecg[2]&0x000F)<<4);
     87          		TmpDataBuff[4]  |= (uint8_t)((Ecg[3]&0x0F00)>>8);
   \   0000009A   0xF9B1 0x400A      LDRSH    R4,[R1, #+10]
   \   0000009E   0x1225             ASRS     R5,R4,#+8
   \   000000A0   0xF005 0x050F      AND      R5,R5,#0xF
   \   000000A4   0xEA45 0x1303      ORR      R3,R5,R3, LSL #+4
   \   000000A8   0x7113             STRB     R3,[R2, #+4]
     88          		TmpDataBuff[5]   = (uint8_t)( Ecg[3]&0x00FF);
   \   000000AA   0x7154             STRB     R4,[R2, #+5]
     89          	  TmpDataBuff[6]   = (uint8_t)((Ecg[4]&0x0FF0)>>4);
   \   000000AC   0xF9B1 0x300C      LDRSH    R3,[R1, #+12]
   \   000000B0   0x111C             ASRS     R4,R3,#+4
   \   000000B2   0x7194             STRB     R4,[R2, #+6]
     90          		TmpDataBuff[7]   = (uint8_t)((Ecg[4]&0x000F)<<4);
     91          		TmpDataBuff[7]  |= (uint8_t)((Ecg[5]&0x0F00)>>8);
   \   000000B4   0xF9B1 0x400E      LDRSH    R4,[R1, #+14]
   \   000000B8   0x1225             ASRS     R5,R4,#+8
   \   000000BA   0xF005 0x050F      AND      R5,R5,#0xF
   \   000000BE   0xEA45 0x1303      ORR      R3,R5,R3, LSL #+4
   \   000000C2   0x71D3             STRB     R3,[R2, #+7]
     92          		TmpDataBuff[8]   = (uint8_t)( Ecg[5]&0x00FF);
   \   000000C4   0x7214             STRB     R4,[R2, #+8]
     93          		TmpDataBuff[9]   = (uint8_t)((Ecg[6]&0x0FF0)>>4);
   \   000000C6   0xF9B1 0x3010      LDRSH    R3,[R1, #+16]
   \   000000CA   0x111C             ASRS     R4,R3,#+4
   \   000000CC   0x7254             STRB     R4,[R2, #+9]
     94          		TmpDataBuff[10]  = (uint8_t)((Ecg[6]&0x000F)<<4);
     95          		TmpDataBuff[10] |= (uint8_t)((Ecg[7]&0x0F00)>>8);
   \   000000CE   0xF9B1 0x4012      LDRSH    R4,[R1, #+18]
   \   000000D2   0x1225             ASRS     R5,R4,#+8
   \   000000D4   0xF005 0x050F      AND      R5,R5,#0xF
   \   000000D8   0xEA45 0x1303      ORR      R3,R5,R3, LSL #+4
   \   000000DC   0x7293             STRB     R3,[R2, #+10]
     96          		TmpDataBuff[11]  = (uint8_t)( Ecg[7]&0x00FF);
   \   000000DE   0xF88D 0x400B      STRB     R4,[SP, #+11]
     97          		TmpDataBuff[12]  = (uint8_t)((Ecg[8]&0x0FF0)>>4);
   \   000000E2   0xF9B1 0x3014      LDRSH    R3,[R1, #+20]
   \   000000E6   0x111C             ASRS     R4,R3,#+4
   \   000000E8   0x7314             STRB     R4,[R2, #+12]
     98          		TmpDataBuff[13]  = (uint8_t)((Ecg[8]&0x000F)<<4);
   \   000000EA   0x011B             LSLS     R3,R3,#+4
   \   000000EC   0xF88D 0x300D      STRB     R3,[SP, #+13]
     99          
    100          		if (adxl_axis == 3)
   \   000000F0   0x780B             LDRB     R3,[R1, #+0]
   \   000000F2   0x2B03             CMP      R3,#+3
   \   000000F4   0xD133             BNE.N    ??FillBuffer_ECG_8
    101              {
    102                if (VoltageSource == 0) 
   \   000000F6   0x784B             LDRB     R3,[R1, #+1]
   \   000000F8   0x2B00             CMP      R3,#+0
   \   000000FA   0xD10A             BNE.N    ??FillBuffer_ECG_9
    103                {
    104                  VoltageValue  = (uint8_t) (TAppProcessor::BatVoltageValue / 20);
   \   000000FC   0x4BC1             LDR.N    R3,??FillBuffer_ECG_0+0xC
   \   000000FE   0x881B             LDRH     R3,[R3, #+0]
   \   00000100   0x2414             MOVS     R4,#+20
   \   00000102   0xFB93 0xF3F4      SDIV     R3,R3,R4
   \   00000106   0x7393             STRB     R3,[R2, #+14]
    105                  adxl_axis = 3;
   \   00000108   0x2303             MOVS     R3,#+3
   \   0000010A   0x700B             STRB     R3,[R1, #+0]
    106                  VoltageSource++;
   \   0000010C   0x2301             MOVS     R3,#+1
   \   0000010E   0x704B             STRB     R3,[R1, #+1]
   \   00000110   0xE028             B.N      ??FillBuffer_ECG_10
    107                }
    108                else if (VoltageSource == 1)
   \                     ??FillBuffer_ECG_9: (+1)
   \   00000112   0x461D             MOV      R5,R3
   \   00000114   0x2D01             CMP      R5,#+1
   \   00000116   0xD10A             BNE.N    ??FillBuffer_ECG_11
    109                {
    110                  VoltageValue  = (uint8_t) (TAppProcessor::LiVoltageValue / 20);
   \   00000118   0x4CBB             LDR.N    R4,??FillBuffer_ECG_0+0x10
   \   0000011A   0x8824             LDRH     R4,[R4, #+0]
   \   0000011C   0x2514             MOVS     R5,#+20
   \   0000011E   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   00000122   0x7394             STRB     R4,[R2, #+14]
    111                  adxl_axis = 4;
   \   00000124   0x2404             MOVS     R4,#+4
   \   00000126   0x700C             STRB     R4,[R1, #+0]
    112                  VoltageSource++;
   \   00000128   0x1C5B             ADDS     R3,R3,#+1
   \   0000012A   0x704B             STRB     R3,[R1, #+1]
   \   0000012C   0xE01A             B.N      ??FillBuffer_ECG_10
    113                }
    114                else if (VoltageSource == 2)
   \                     ??FillBuffer_ECG_11: (+1)
   \   0000012E   0x2D02             CMP      R5,#+2
   \   00000130   0xD10A             BNE.N    ??FillBuffer_ECG_12
    115                {
    116                  VoltageValue  = (uint8_t) (TAppProcessor::AnalogVoltageValue / 20);
   \   00000132   0x4CB6             LDR.N    R4,??FillBuffer_ECG_0+0x14
   \   00000134   0x8824             LDRH     R4,[R4, #+0]
   \   00000136   0x2514             MOVS     R5,#+20
   \   00000138   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   0000013C   0x7394             STRB     R4,[R2, #+14]
    117                  adxl_axis = 5;
   \   0000013E   0x2405             MOVS     R4,#+5
   \   00000140   0x700C             STRB     R4,[R1, #+0]
    118                  VoltageSource++;
   \   00000142   0x1C5B             ADDS     R3,R3,#+1
   \   00000144   0x704B             STRB     R3,[R1, #+1]
   \   00000146   0xE00D             B.N      ??FillBuffer_ECG_10
    119                }
    120                else
    121                {
    122                  VoltageValue  = (uint8_t) (TAppProcessor::SysVoltageValue / 20);
   \                     ??FillBuffer_ECG_12: (+1)
   \   00000148   0x4BB1             LDR.N    R3,??FillBuffer_ECG_0+0x18
   \   0000014A   0x881B             LDRH     R3,[R3, #+0]
   \   0000014C   0x2414             MOVS     R4,#+20
   \   0000014E   0xFB93 0xF3F4      SDIV     R3,R3,R4
   \   00000152   0x7393             STRB     R3,[R2, #+14]
    123                  adxl_axis = 6;
   \   00000154   0x2306             MOVS     R3,#+6
   \   00000156   0x700B             STRB     R3,[R1, #+0]
    124                  VoltageSource = 0;
   \   00000158   0x2300             MOVS     R3,#+0
   \   0000015A   0x704B             STRB     R3,[R1, #+1]
   \   0000015C   0xE002             B.N      ??FillBuffer_ECG_10
    125                }
    126                TmpDataBuff[14]  = VoltageValue;
    127              }
    128          		else TmpDataBuff[14]  = TAppProcessor::AX_CoordWr[adxl_axis];
   \                     ??FillBuffer_ECG_8: (+1)
   \   0000015E   0x4CAD             LDR.N    R4,??FillBuffer_ECG_0+0x1C
   \   00000160   0x5D1B             LDRB     R3,[R3, R4]
   \   00000162   0x7393             STRB     R3,[R2, #+14]
    129          
    130          		dt_flags = adxl_axis << 1;
    131          		dt_flags |= (uint8_t)((Data->Status.ChannelBytes[0] & 0x08) >> 3);
    132                          TmpDataBuff[15]  = dt_flags;
   \                     ??FillBuffer_ECG_10: (+1)
   \   00000164   0x780B             LDRB     R3,[R1, #+0]
   \   00000166   0x7800             LDRB     R0,[R0, #+0]
   \   00000168   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000016C   0xEA40 0x0043      ORR      R0,R0,R3, LSL #+1
   \   00000170   0x73D0             STRB     R0,[R2, #+15]
    133            
    134          		adxl_axis++;
   \   00000172   0x1C58             ADDS     R0,R3,#+1
   \   00000174   0x7008             STRB     R0,[R1, #+0]
    135          		if(adxl_axis > 3) adxl_axis = 0;
   \   00000176   0xB2C0             UXTB     R0,R0
   \   00000178   0x2804             CMP      R0,#+4
   \   0000017A   0xDB01             BLT.N    ??FillBuffer_ECG_13
   \   0000017C   0x2000             MOVS     R0,#+0
   \   0000017E   0x7008             STRB     R0,[R1, #+0]
    136            
    137          //		TPoolingNand::AddDataToPool(1,TmpDataBuff,16,1);
    138          		TPoolingNand::AddDataToPool(1,TmpDataBuff,16,0);
   \                     ??FillBuffer_ECG_13: (+1)
   \   00000180   0x2300             MOVS     R3,#+0
   \   00000182   0x2210             MOVS     R2,#+16
   \   00000184   0xA900             ADD      R1,SP,#+0
   \   00000186   0x2001             MOVS     R0,#+1
   \   00000188   0x.... 0x....      BL       _ZN12TPoolingNand13AddDataToPoolEiPhib
   \   0000018C   0xBD7F             POP      {R0-R6,PC}
    139          	} 
    140          	else if (TAppProcessor::ecg_format == 1)
   \                     ??FillBuffer_ECG_1: (+1)
   \   0000018E   0x2A01             CMP      R2,#+1
   \   00000190   0xF040 0x809B      BNE.W    ??FillBuffer_ECG_14
    141                  {
    142          		for(int i = 0; i < 3; i++)
   \   00000194   0x2200             MOVS     R2,#+0
   \   00000196   0xE007             B.N      ??FillBuffer_ECG_15
    143          		{
    144                Ecg[i] = (int16_t)(Data->Channel[i].ChannelData >> 4);		/* превращаем в 12 битные данные */
   \                     ??FillBuffer_ECG_16: (+1)
   \   00000198   0xEB00 0x0382      ADD      R3,R0,R2, LSL #+2
   \   0000019C   0x685B             LDR      R3,[R3, #+4]
   \   0000019E   0x111B             ASRS     R3,R3,#+4
   \   000001A0   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   000001A4   0x808B             STRH     R3,[R1, #+4]
    145              }
   \   000001A6   0x1C52             ADDS     R2,R2,#+1
   \                     ??FillBuffer_ECG_15: (+1)
   \   000001A8   0x4994             LDR.N    R1,??FillBuffer_ECG_0+0x4
   \   000001AA   0x2A03             CMP      R2,#+3
   \   000001AC   0xDBF4             BLT.N    ??FillBuffer_ECG_16
    146          		Ecg[3] = (int16_t)(Data->Channel[8].ChannelData >> 4);
   \   000001AE   0x6A42             LDR      R2,[R0, #+36]
   \   000001B0   0x1112             ASRS     R2,R2,#+4
   \   000001B2   0x814A             STRH     R2,[R1, #+10]
    147          
    148          		for(int i = 0;i < 4;i++) // 12bit rejection
   \   000001B4   0x2200             MOVS     R2,#+0
   \   000001B6   0xE005             B.N      ??FillBuffer_ECG_17
    149          		{
    150          //			Ecg[i] = (Ecg[i] * 1653L)/(1223L);
    151          			Ecg[i] = (Ecg[i] * 1653L)/(1206L);
    152          			if(Ecg[i] > 2047L) Ecg[i] = 2047L;
    153          			else	
    154          				if(Ecg[i] < -2048L) Ecg[i] = -2048L;
   \                     ??FillBuffer_ECG_18: (+1)
   \   000001B8   0xF513 0x6F00      CMN      R3,#+2048
   \   000001BC   0xDA01             BGE.N    ??FillBuffer_ECG_19
   \   000001BE   0x4B90             LDR.N    R3,??FillBuffer_ECG_0+0x8  ;; 0xfffff800
   \   000001C0   0x80A3             STRH     R3,[R4, #+4]
   \                     ??FillBuffer_ECG_19: (+1)
   \   000001C2   0x1C52             ADDS     R2,R2,#+1
   \                     ??FillBuffer_ECG_17: (+1)
   \   000001C4   0x2A04             CMP      R2,#+4
   \   000001C6   0xDA15             BGE.N    ??FillBuffer_ECG_20
   \   000001C8   0xEB01 0x0442      ADD      R4,R1,R2, LSL #+1
   \   000001CC   0xF9B4 0x3004      LDRSH    R3,[R4, #+4]
   \   000001D0   0xF240 0x6575      MOVW     R5,#+1653
   \   000001D4   0xFB13 0xF305      SMULBB   R3,R3,R5
   \   000001D8   0xF240 0x45B6      MOVW     R5,#+1206
   \   000001DC   0xFB93 0xF3F5      SDIV     R3,R3,R5
   \   000001E0   0x80A3             STRH     R3,[R4, #+4]
   \   000001E2   0xF9B4 0x3004      LDRSH    R3,[R4, #+4]
   \   000001E6   0xF5B3 0x6F00      CMP      R3,#+2048
   \   000001EA   0xDBE5             BLT.N    ??FillBuffer_ECG_18
   \   000001EC   0xF240 0x73FF      MOVW     R3,#+2047
   \   000001F0   0x80A3             STRH     R3,[R4, #+4]
   \   000001F2   0xE7E6             B.N      ??FillBuffer_ECG_19
    155          		}
    156          
    157          		TmpDataBuff[0] =  (uint8_t)((Ecg[0]&0x00000FF0)>>4);
   \                     ??FillBuffer_ECG_20: (+1)
   \   000001F4   0xF9B1 0x3004      LDRSH    R3,[R1, #+4]
   \   000001F8   0x111A             ASRS     R2,R3,#+4
   \   000001FA   0xF88D 0x2000      STRB     R2,[SP, #+0]
    158          		TmpDataBuff[1] =  (uint8_t)((Ecg[0]&0x0000000F)<<4);
    159          		TmpDataBuff[1] |= (uint8_t)((Ecg[1]&0x00000F00)>>8);
   \   000001FE   0xF9B1 0x4006      LDRSH    R4,[R1, #+6]
   \   00000202   0xAA00             ADD      R2,SP,#+0
   \   00000204   0x1225             ASRS     R5,R4,#+8
   \   00000206   0xF005 0x050F      AND      R5,R5,#0xF
   \   0000020A   0xEA45 0x1303      ORR      R3,R5,R3, LSL #+4
   \   0000020E   0x7053             STRB     R3,[R2, #+1]
    160              TmpDataBuff[2]  = (uint8_t)( Ecg[1]&0x000000FF);
   \   00000210   0x7094             STRB     R4,[R2, #+2]
    161          		TmpDataBuff[3] =  (uint8_t)((Ecg[2]&0x00000FF0)>>4);
   \   00000212   0xF9B1 0x3008      LDRSH    R3,[R1, #+8]
   \   00000216   0x111C             ASRS     R4,R3,#+4
   \   00000218   0x70D4             STRB     R4,[R2, #+3]
    162          		TmpDataBuff[4] =  (uint8_t)((Ecg[2]&0x0000000F)<<4);
    163              TmpDataBuff[4] |= (uint8_t)((Ecg[3]&0x00000F00)>>8);
   \   0000021A   0xF9B1 0x400A      LDRSH    R4,[R1, #+10]
   \   0000021E   0x1225             ASRS     R5,R4,#+8
   \   00000220   0xF005 0x050F      AND      R5,R5,#0xF
   \   00000224   0xEA45 0x1303      ORR      R3,R5,R3, LSL #+4
   \   00000228   0x7113             STRB     R3,[R2, #+4]
    164              TmpDataBuff[5]  = (uint8_t)( Ecg[3]&0x000000FF);
   \   0000022A   0x7154             STRB     R4,[R2, #+5]
    165            
    166          		if (adxl_axis == 3)
   \   0000022C   0x780B             LDRB     R3,[R1, #+0]
   \   0000022E   0x2B03             CMP      R3,#+3
   \   00000230   0xD133             BNE.N    ??FillBuffer_ECG_21
    167              {
    168                if (VoltageSource == 0) 
   \   00000232   0x784B             LDRB     R3,[R1, #+1]
   \   00000234   0x2B00             CMP      R3,#+0
   \   00000236   0xD10A             BNE.N    ??FillBuffer_ECG_22
    169                {
    170                  VoltageValue  = (uint8_t) (TAppProcessor::BatVoltageValue / 20);
   \   00000238   0x4B72             LDR.N    R3,??FillBuffer_ECG_0+0xC
   \   0000023A   0x881B             LDRH     R3,[R3, #+0]
   \   0000023C   0x2414             MOVS     R4,#+20
   \   0000023E   0xFB93 0xF3F4      SDIV     R3,R3,R4
   \   00000242   0x7193             STRB     R3,[R2, #+6]
    171                  adxl_axis = 3;
   \   00000244   0x2303             MOVS     R3,#+3
   \   00000246   0x700B             STRB     R3,[R1, #+0]
    172                  VoltageSource++;
   \   00000248   0x2301             MOVS     R3,#+1
   \   0000024A   0x704B             STRB     R3,[R1, #+1]
   \   0000024C   0xE028             B.N      ??FillBuffer_ECG_23
    173                }
    174                else if (VoltageSource == 1)
   \                     ??FillBuffer_ECG_22: (+1)
   \   0000024E   0x461D             MOV      R5,R3
   \   00000250   0x2D01             CMP      R5,#+1
   \   00000252   0xD10A             BNE.N    ??FillBuffer_ECG_24
    175                {
    176                  VoltageValue  = (uint8_t) (TAppProcessor::LiVoltageValue / 20);
   \   00000254   0x4C6C             LDR.N    R4,??FillBuffer_ECG_0+0x10
   \   00000256   0x8824             LDRH     R4,[R4, #+0]
   \   00000258   0x2514             MOVS     R5,#+20
   \   0000025A   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   0000025E   0x7194             STRB     R4,[R2, #+6]
    177                  adxl_axis = 4;
   \   00000260   0x2404             MOVS     R4,#+4
   \   00000262   0x700C             STRB     R4,[R1, #+0]
    178                  VoltageSource++;
   \   00000264   0x1C5B             ADDS     R3,R3,#+1
   \   00000266   0x704B             STRB     R3,[R1, #+1]
   \   00000268   0xE01A             B.N      ??FillBuffer_ECG_23
    179                }
    180                else if (VoltageSource == 2)
   \                     ??FillBuffer_ECG_24: (+1)
   \   0000026A   0x2D02             CMP      R5,#+2
   \   0000026C   0xD10A             BNE.N    ??FillBuffer_ECG_25
    181                {
    182                  VoltageValue  = (uint8_t) (TAppProcessor::AnalogVoltageValue / 20);
   \   0000026E   0x4C67             LDR.N    R4,??FillBuffer_ECG_0+0x14
   \   00000270   0x8824             LDRH     R4,[R4, #+0]
   \   00000272   0x2514             MOVS     R5,#+20
   \   00000274   0xFB94 0xF4F5      SDIV     R4,R4,R5
   \   00000278   0x7194             STRB     R4,[R2, #+6]
    183                  adxl_axis = 5;
   \   0000027A   0x2405             MOVS     R4,#+5
   \   0000027C   0x700C             STRB     R4,[R1, #+0]
    184                  VoltageSource++;
   \   0000027E   0x1C5B             ADDS     R3,R3,#+1
   \   00000280   0x704B             STRB     R3,[R1, #+1]
   \   00000282   0xE00D             B.N      ??FillBuffer_ECG_23
    185                }
    186                else
    187                {
    188                  VoltageValue  = (uint8_t) (TAppProcessor::SysVoltageValue / 20);
   \                     ??FillBuffer_ECG_25: (+1)
   \   00000284   0x4B62             LDR.N    R3,??FillBuffer_ECG_0+0x18
   \   00000286   0x881B             LDRH     R3,[R3, #+0]
   \   00000288   0x2414             MOVS     R4,#+20
   \   0000028A   0xFB93 0xF3F4      SDIV     R3,R3,R4
   \   0000028E   0x7193             STRB     R3,[R2, #+6]
    189                  adxl_axis = 6;
   \   00000290   0x2306             MOVS     R3,#+6
   \   00000292   0x700B             STRB     R3,[R1, #+0]
    190                  VoltageSource = 0;
   \   00000294   0x2300             MOVS     R3,#+0
   \   00000296   0x704B             STRB     R3,[R1, #+1]
   \   00000298   0xE002             B.N      ??FillBuffer_ECG_23
    191                }
    192                TmpDataBuff[6]  = VoltageValue;
    193              }
    194          		else TmpDataBuff[6]  = TAppProcessor::AX_CoordWr[adxl_axis];
   \                     ??FillBuffer_ECG_21: (+1)
   \   0000029A   0x4C5E             LDR.N    R4,??FillBuffer_ECG_0+0x1C
   \   0000029C   0x5D1B             LDRB     R3,[R3, R4]
   \   0000029E   0x7193             STRB     R3,[R2, #+6]
    195          
    196          		dt_flags = adxl_axis << 1;
    197          		dt_flags |= (uint8_t)((Data->Status.ChannelBytes[0] & 0x08) >> 3);
    198              TmpDataBuff[7]  = dt_flags;
   \                     ??FillBuffer_ECG_23: (+1)
   \   000002A0   0x780B             LDRB     R3,[R1, #+0]
   \   000002A2   0x7800             LDRB     R0,[R0, #+0]
   \   000002A4   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   000002A8   0xEA40 0x0043      ORR      R0,R0,R3, LSL #+1
   \   000002AC   0x71D0             STRB     R0,[R2, #+7]
    199          
    200          		adxl_axis++;
   \   000002AE   0x1C58             ADDS     R0,R3,#+1
   \   000002B0   0x7008             STRB     R0,[R1, #+0]
    201          		if(adxl_axis > 3) adxl_axis = 0;
   \   000002B2   0xB2C0             UXTB     R0,R0
   \   000002B4   0x2804             CMP      R0,#+4
   \   000002B6   0xDB01             BLT.N    ??FillBuffer_ECG_26
   \   000002B8   0x2000             MOVS     R0,#+0
   \   000002BA   0x7008             STRB     R0,[R1, #+0]
    202            
    203          //		TPoolingNand::AddDataToPool(1,TmpDataBuff,8,1);
    204          		TPoolingNand::AddDataToPool(1,TmpDataBuff,8,0);
   \                     ??FillBuffer_ECG_26: (+1)
   \   000002BC   0x2300             MOVS     R3,#+0
   \   000002BE   0x2208             MOVS     R2,#+8
   \   000002C0   0xA900             ADD      R1,SP,#+0
   \   000002C2   0x2001             MOVS     R0,#+1
   \   000002C4   0x.... 0x....      BL       _ZN12TPoolingNand13AddDataToPoolEiPhib
   \   000002C8   0xBD7F             POP      {R0-R6,PC}
    205          	}
    206          	else if (TAppProcessor::ecg_format == 0)
   \                     ??FillBuffer_ECG_14: (+1)
   \   000002CA   0x2900             CMP      R1,#+0
   \   000002CC   0xF040 0x8093      BNE.W    ??FillBuffer_ECG_27
    207                  {
    208          		for(int i = 0; i < 3; i++)
   \   000002D0   0x2200             MOVS     R2,#+0
   \   000002D2   0xE007             B.N      ??FillBuffer_ECG_28
    209          		{
    210                Ecg[i] = (int16_t)(Data->Channel[i].ChannelData >> 4);		/* превращаем в 12 битные данные */
   \                     ??FillBuffer_ECG_29: (+1)
   \   000002D4   0xEB00 0x0382      ADD      R3,R0,R2, LSL #+2
   \   000002D8   0x685B             LDR      R3,[R3, #+4]
   \   000002DA   0x111B             ASRS     R3,R3,#+4
   \   000002DC   0xEB01 0x0142      ADD      R1,R1,R2, LSL #+1
   \   000002E0   0x808B             STRH     R3,[R1, #+4]
    211              }
   \   000002E2   0x1C52             ADDS     R2,R2,#+1
   \                     ??FillBuffer_ECG_28: (+1)
   \   000002E4   0x4945             LDR.N    R1,??FillBuffer_ECG_0+0x4
   \   000002E6   0x2A03             CMP      R2,#+3
   \   000002E8   0xDBF4             BLT.N    ??FillBuffer_ECG_29
    212          
    213          		for(int i = 0;i < 3;i++) // 12bit rejection
   \   000002EA   0x2200             MOVS     R2,#+0
   \   000002EC   0xE005             B.N      ??FillBuffer_ECG_30
    214          		{
    215          //			Ecg[i] = (Ecg[i] * 1653L)/(1223L);
    216          			Ecg[i] = (Ecg[i] * 1653L)/(1206L);
    217          			if(Ecg[i] > 2047L) Ecg[i] = 2047L;
    218          			else	
    219          				if(Ecg[i] < -2048L) Ecg[i] = -2048L;
   \                     ??FillBuffer_ECG_31: (+1)
   \   000002EE   0xF513 0x6F00      CMN      R3,#+2048
   \   000002F2   0xDA01             BGE.N    ??FillBuffer_ECG_32
   \   000002F4   0x4B42             LDR.N    R3,??FillBuffer_ECG_0+0x8  ;; 0xfffff800
   \   000002F6   0x80A3             STRH     R3,[R4, #+4]
   \                     ??FillBuffer_ECG_32: (+1)
   \   000002F8   0x1C52             ADDS     R2,R2,#+1
   \                     ??FillBuffer_ECG_30: (+1)
   \   000002FA   0x2A03             CMP      R2,#+3
   \   000002FC   0xDA15             BGE.N    ??FillBuffer_ECG_33
   \   000002FE   0xEB01 0x0442      ADD      R4,R1,R2, LSL #+1
   \   00000302   0xF9B4 0x3004      LDRSH    R3,[R4, #+4]
   \   00000306   0xF240 0x6575      MOVW     R5,#+1653
   \   0000030A   0xFB13 0xF305      SMULBB   R3,R3,R5
   \   0000030E   0xF240 0x45B6      MOVW     R5,#+1206
   \   00000312   0xFB93 0xF3F5      SDIV     R3,R3,R5
   \   00000316   0x80A3             STRH     R3,[R4, #+4]
   \   00000318   0xF9B4 0x3004      LDRSH    R3,[R4, #+4]
   \   0000031C   0xF5B3 0x6F00      CMP      R3,#+2048
   \   00000320   0xDBE5             BLT.N    ??FillBuffer_ECG_31
   \   00000322   0xF240 0x73FF      MOVW     R3,#+2047
   \   00000326   0x80A3             STRH     R3,[R4, #+4]
   \   00000328   0xE7E6             B.N      ??FillBuffer_ECG_32
    220          		}
    221          
    222          		TmpDataBuff[0] =  (uint8_t)((Ecg[0]&0x00000FF0)>>4);
   \                     ??FillBuffer_ECG_33: (+1)
   \   0000032A   0xF9B1 0x3004      LDRSH    R3,[R1, #+4]
   \   0000032E   0x111A             ASRS     R2,R3,#+4
   \   00000330   0xF88D 0x2000      STRB     R2,[SP, #+0]
    223          		TmpDataBuff[1] =  (uint8_t)((Ecg[0]&0x0000000F)<<4);
    224          		TmpDataBuff[1] |= (uint8_t)((Ecg[1]&0x00000F00)>>8);
   \   00000334   0xF9B1 0x4006      LDRSH    R4,[R1, #+6]
   \   00000338   0xAA00             ADD      R2,SP,#+0
   \   0000033A   0x1225             ASRS     R5,R4,#+8
   \   0000033C   0xF005 0x050F      AND      R5,R5,#0xF
   \   00000340   0xEA45 0x1303      ORR      R3,R5,R3, LSL #+4
   \   00000344   0x7053             STRB     R3,[R2, #+1]
    225          		TmpDataBuff[2] =  (uint8_t)(Ecg[1]&0x000000FF);
   \   00000346   0x7094             STRB     R4,[R2, #+2]
    226          		TmpDataBuff[3] =  (uint8_t)((Ecg[2]&0x00000FF0)>>4);
   \   00000348   0xF9B1 0x3008      LDRSH    R3,[R1, #+8]
   \   0000034C   0x111C             ASRS     R4,R3,#+4
   \   0000034E   0x70D4             STRB     R4,[R2, #+3]
    227          		TmpDataBuff[4] =  (uint8_t)((Ecg[2]&0x0000000F)<<4);
   \   00000350   0x011C             LSLS     R4,R3,#+4
   \   00000352   0x7114             STRB     R4,[R2, #+4]
    228            
    229          		if (adxl_axis == 3)
   \   00000354   0x780B             LDRB     R3,[R1, #+0]
   \   00000356   0x2B03             CMP      R3,#+3
   \   00000358   0xD133             BNE.N    ??FillBuffer_ECG_34
    230              {
    231                if (VoltageSource == 0) 
   \   0000035A   0x784B             LDRB     R3,[R1, #+1]
   \   0000035C   0x2B00             CMP      R3,#+0
   \   0000035E   0xD10A             BNE.N    ??FillBuffer_ECG_35
    232                {
    233                  VoltageValue  = (uint8_t) (TAppProcessor::BatVoltageValue / 20);
   \   00000360   0x4B28             LDR.N    R3,??FillBuffer_ECG_0+0xC
   \   00000362   0x881B             LDRH     R3,[R3, #+0]
   \   00000364   0x2514             MOVS     R5,#+20
   \   00000366   0xFB93 0xF3F5      SDIV     R3,R3,R5
   \   0000036A   0x7153             STRB     R3,[R2, #+5]
    234                  adxl_axis = 3;
   \   0000036C   0x2303             MOVS     R3,#+3
   \   0000036E   0x700B             STRB     R3,[R1, #+0]
    235                  VoltageSource++;
   \   00000370   0x2301             MOVS     R3,#+1
   \   00000372   0x704B             STRB     R3,[R1, #+1]
   \   00000374   0xE028             B.N      ??FillBuffer_ECG_36
    236                }
    237                else if (VoltageSource == 1)
   \                     ??FillBuffer_ECG_35: (+1)
   \   00000376   0x461D             MOV      R5,R3
   \   00000378   0x2D01             CMP      R5,#+1
   \   0000037A   0xD10A             BNE.N    ??FillBuffer_ECG_37
    238                {
    239                  VoltageValue  = (uint8_t) (TAppProcessor::LiVoltageValue / 20);
   \   0000037C   0x4D22             LDR.N    R5,??FillBuffer_ECG_0+0x10
   \   0000037E   0x882D             LDRH     R5,[R5, #+0]
   \   00000380   0x2614             MOVS     R6,#+20
   \   00000382   0xFB95 0xF5F6      SDIV     R5,R5,R6
   \   00000386   0x7155             STRB     R5,[R2, #+5]
    240                  adxl_axis = 4;
   \   00000388   0x2504             MOVS     R5,#+4
   \   0000038A   0x700D             STRB     R5,[R1, #+0]
    241                  VoltageSource++;
   \   0000038C   0x1C5B             ADDS     R3,R3,#+1
   \   0000038E   0x704B             STRB     R3,[R1, #+1]
   \   00000390   0xE01A             B.N      ??FillBuffer_ECG_36
    242                }
    243                else if (VoltageSource == 2)
   \                     ??FillBuffer_ECG_37: (+1)
   \   00000392   0x2D02             CMP      R5,#+2
   \   00000394   0xD10A             BNE.N    ??FillBuffer_ECG_38
    244                {
    245                  VoltageValue  = (uint8_t) (TAppProcessor::AnalogVoltageValue / 20);
   \   00000396   0x4D1D             LDR.N    R5,??FillBuffer_ECG_0+0x14
   \   00000398   0x882D             LDRH     R5,[R5, #+0]
   \   0000039A   0x2614             MOVS     R6,#+20
   \   0000039C   0xFB95 0xF5F6      SDIV     R5,R5,R6
   \   000003A0   0x7155             STRB     R5,[R2, #+5]
    246                  adxl_axis = 5;
   \   000003A2   0x2505             MOVS     R5,#+5
   \   000003A4   0x700D             STRB     R5,[R1, #+0]
    247                  VoltageSource++;
   \   000003A6   0x1C5B             ADDS     R3,R3,#+1
   \   000003A8   0x704B             STRB     R3,[R1, #+1]
   \   000003AA   0xE00D             B.N      ??FillBuffer_ECG_36
    248                }
    249                else
    250                {
    251                  VoltageValue  = (uint8_t) (TAppProcessor::SysVoltageValue / 20);
   \                     ??FillBuffer_ECG_38: (+1)
   \   000003AC   0x4B18             LDR.N    R3,??FillBuffer_ECG_0+0x18
   \   000003AE   0x881B             LDRH     R3,[R3, #+0]
   \   000003B0   0x2514             MOVS     R5,#+20
   \   000003B2   0xFB93 0xF3F5      SDIV     R3,R3,R5
   \   000003B6   0x7153             STRB     R3,[R2, #+5]
    252                  adxl_axis = 6;
   \   000003B8   0x2306             MOVS     R3,#+6
   \   000003BA   0x700B             STRB     R3,[R1, #+0]
    253                  VoltageSource = 0;
   \   000003BC   0x2300             MOVS     R3,#+0
   \   000003BE   0x704B             STRB     R3,[R1, #+1]
   \   000003C0   0xE002             B.N      ??FillBuffer_ECG_36
    254                }
    255                TmpDataBuff[5]  = VoltageValue;
    256              }
    257          		else TmpDataBuff[5]  = TAppProcessor::AX_CoordWr[adxl_axis];
   \                     ??FillBuffer_ECG_34: (+1)
   \   000003C2   0x4D14             LDR.N    R5,??FillBuffer_ECG_0+0x1C
   \   000003C4   0x5D5B             LDRB     R3,[R3, R5]
   \   000003C6   0x7153             STRB     R3,[R2, #+5]
    258          
    259          		dt_flags = adxl_axis << 1;
    260          		dt_flags |= (uint8_t)((Data->Status.ChannelBytes[0] & 0x08) >> 3);
    261              TmpDataBuff[4]  |= (dt_flags & 0x0F);
   \                     ??FillBuffer_ECG_36: (+1)
   \   000003C8   0x780B             LDRB     R3,[R1, #+0]
   \   000003CA   0x7800             LDRB     R0,[R0, #+0]
   \   000003CC   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   000003D0   0xEA40 0x0043      ORR      R0,R0,R3, LSL #+1
   \   000003D4   0xF000 0x000F      AND      R0,R0,#0xF
   \   000003D8   0x4320             ORRS     R0,R0,R4
   \   000003DA   0x7110             STRB     R0,[R2, #+4]
    262          
    263          		adxl_axis++;
   \   000003DC   0x1C58             ADDS     R0,R3,#+1
   \   000003DE   0x7008             STRB     R0,[R1, #+0]
    264          		if(adxl_axis > 3) adxl_axis = 0;
   \   000003E0   0xB2C0             UXTB     R0,R0
   \   000003E2   0x2804             CMP      R0,#+4
   \   000003E4   0xDB01             BLT.N    ??FillBuffer_ECG_39
   \   000003E6   0x2000             MOVS     R0,#+0
   \   000003E8   0x7008             STRB     R0,[R1, #+0]
    265            
    266          //		TPoolingNand::AddDataToPool(1,TmpDataBuff,6,1);
    267          		TPoolingNand::AddDataToPool(1,TmpDataBuff,6,0);
   \                     ??FillBuffer_ECG_39: (+1)
   \   000003EA   0x2300             MOVS     R3,#+0
   \   000003EC   0x2206             MOVS     R2,#+6
   \   000003EE   0xA900             ADD      R1,SP,#+0
   \   000003F0   0x2001             MOVS     R0,#+1
   \   000003F2   0x.... 0x....      BL       _ZN12TPoolingNand13AddDataToPoolEiPhib
    268          	}
    269          
    270          }
   \                     ??FillBuffer_ECG_27: (+1)
   \   000003F6   0xBD7F             POP      {R0-R6,PC}       ;; return
   \                     ??FillBuffer_ECG_0:
   \   000003F8   0x........         DC32     _ZN13TAppProcessor10ecg_formatE
   \   000003FC   0x........         DC32     ??adxl_axis
   \   00000400   0xFFFFF800         DC32     0xfffff800
   \   00000404   0x........         DC32     _ZN13TAppProcessor15BatVoltageValueE
   \   00000408   0x........         DC32     _ZN13TAppProcessor14LiVoltageValueE
   \   0000040C   0x........         DC32     _ZN13TAppProcessor18AnalogVoltageValueE
   \   00000410   0x........         DC32     _ZN13TAppProcessor15SysVoltageValueE
   \   00000414   0x........         DC32     _ZN13TAppProcessor10AX_CoordWrE

   \                                 In section .bss, align 4
   \                     ??adxl_axis:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   00000002                      DS8 2
   \   00000004                      DS8 20
    271          /*----------------------------------------------------------------------------------*/
    272          /* @brief	Заполняет буффер данными ЭКГ для записи на SD карту						*/
    273          /* @param	*Data - указатель на структуру ЭКГ										*/
    274          /* @return	None																	*/
    275          /*----------------------------------------------------------------------------------*/
    276          //void TSDProcessor::FillBuffer_ECG_0( EcgData_t *Data )
    277          //{
    278          //	static int State, BufferFillValue;
    279          //	static int Ecg1, Ecg2, Ecg3;
    280          //	static int8_t *pBuffer = NULL;
    281          //	enum sd_buffer_fill_state{
    282          //		start_fill = 0,				/* подготовка буффера к записи */
    283          //		fill,						/* заполнение 1 */
    284          //		continue_fill				/* заполнение 2 */
    285          //	};
    286          //
    287          //#ifdef EV_BOARD
    288          //	Ecg1 = Data->Channel_4.ChannelData >> 4;		/* превращаем в 12 битные данные */
    289          //	Ecg2 = Data->Channel_5.ChannelData >> 4;
    290          //	Ecg3 = Data->Channel_6.ChannelData >> 4;
    291          //#else
    292          //	Ecg1 = Data->Channel_1.ChannelData >> 4;		/* превращаем в 12 битные данные */
    293          //	Ecg2 = Data->Channel_2.ChannelData >> 4;
    294          //	Ecg3 = Data->Channel_3.ChannelData >> 4;
    295          //#endif	
    296          //	
    297          //	if( Ecg1 > 2047 ) Ecg1 = 2047;					/* ограничитель для 12 битного кода */
    298          //	if( Ecg1 < -2047 ) Ecg1 = -2047;
    299          //	if( Ecg2 > 2047 ) Ecg1 = 2047;					/* ограничитель для 12 битного кода */
    300          //	if( Ecg2 < -2047 ) Ecg1 = -2047;
    301          //	if( Ecg3 > 2047 ) Ecg1 = 2047;					/* ограничитель для 12 битного кода */
    302          //	if( Ecg3 < -2047 ) Ecg1 = -2047;
    303          //
    304          //	switch( State ){
    305          //		case start_fill:
    306          //		{
    307          //			if( EcgBuffer_1_Full == false )			/* в зависимости от того какой буффер полный выбирается для заполнения пустой */
    308          //				pBuffer = EcgBuffer_1;
    309          //			else if( EcgBuffer_2_Full == false )
    310          //				pBuffer = EcgBuffer_2;
    311          //			else if(( EcgBuffer_2_Full == true ) && ( EcgBuffer_1_Full == true ))
    312          //			{
    313          //				TDevice::DEVICE->DebugTools->Led3.On();
    314          //				__no_operation(); 					/* error, all buffers are full */
    315          //			}
    316          //			*(pBuffer++) = 0x55;					/* ID */
    317          //			*(pBuffer++) = 0xAA;					/* ID */
    318          //			*pBuffer = 0x01;						/* type of data in buffer */
    319          //			pBuffer += 12;							/* 8 service bytes in package */
    320          //			State = fill;
    321          //		}
    322          //
    323          //		/* алгоритм записи */
    324          //		case fill:
    325          //		{
    326          //			*(pBuffer++) = (int8_t)Ecg1;
    327          //			*pBuffer = (int8_t)( Ecg1 >> 8 );
    328          //			*pBuffer &= 0xF;
    329          //
    330          //			*(pBuffer++) |= (int8_t)( Ecg2 << 4 );
    331          //			*(pBuffer++) = (int8_t)( Ecg2 >> 4 );
    332          //
    333          //			*(pBuffer++) = (int8_t)Ecg3;
    334          //			*pBuffer = (int8_t)( Ecg3 >> 8 );
    335          //			*pBuffer &= 0xF;
    336          //
    337          //			State = continue_fill;
    338          //			break;
    339          //		}
    340          //		case continue_fill:
    341          //		{
    342          //			*(pBuffer++) |= (int8_t)( Ecg1 << 4 );
    343          //			*(pBuffer++) = (int8_t)( Ecg1 >> 4 );
    344          //
    345          //			*(pBuffer++) = (int8_t)Ecg2;
    346          //			*pBuffer = (int8_t)( Ecg2 >> 8 );
    347          //			*pBuffer &= 0xF;
    348          //
    349          //			*(pBuffer++) |=(int8_t)( Ecg3 << 4 );
    350          //			*(pBuffer++) = (int8_t)( Ecg3 >> 4 );
    351          //
    352          //			State = fill;
    353          //			BufferFillValue++;
    354          //			break;
    355          //		}
    356          //	}
    357          //
    358          //	if( BufferFillValue == 226 )				/* буффер полон 2034/9*/
    359          //	{		
    360          //		if( EcgBuffer_1[0] == 0x55 )
    361          //			EcgBuffer_1_Full = true;
    362          //		else if( EcgBuffer_2[0] == 0x55 )
    363          //			EcgBuffer_2_Full = true;
    364          //		else
    365          //			__no_operation();
    366          //
    367          //		vTaskResume( xSDDataWrite );
    368          //		State = start_fill;
    369          //		pBuffer = NULL;
    370          //		BufferFillValue = 0;
    371          //	}
    372          //}
    373          
    374          
    375          
    376          ///*----------------------------------------------------------------------------------*/
    377          ///* @brief	Задача смотрит фалги буфферов, и если есть заполненные буфферы,			*/
    378          ///*			то отправляет их на запись												*/
    379          ///* @param	None																	*/
    380          ///* @return	None																	*/
    381          ///*----------------------------------------------------------------------------------*/
    382          //void TSDProcessor::TASK_SDDataWrite( void *pvParameters )
    383          //{
    384          //	vTaskSuspend( NULL );
    385          //	
    386          //	while( 1 )
    387          //	{
    388          //		static int8_t *pBuffer;
    389          //
    390          //		if( SDPresent == false ){
    391          //			vTaskDelay( 100 / portTICK_RATE_MS );
    392          //			continue;
    393          //		}
    394          //
    395          //		if( EcgBuffer_1_Full == true )
    396          //		{
    397          //			#ifdef EV_BOARD
    398          //				TDevice::DEVICE->DebugTools->Led2.On();
    399          //				TDevice::DEVICE->DebugTools->Led3.Off();
    400          //			#endif
    401          //			
    402          //			pBuffer = EcgBuffer_1;
    403          //			if( f_write( &MainFile, pBuffer, sizeof(EcgBuffer_1), &BwW ) != FR_OK ){
    404          //				NVIC_SystemReset();		/* Software reset program */
    405          //			}
    406          //			f_sync( &MainFile );
    407          //			memset( pBuffer, 0x00, sizeof(EcgBuffer_1) );
    408          //			EcgBuffer_1_Full = false;
    409          //		}
    410          //		else if( EcgBuffer_2_Full == true )
    411          //		{
    412          //			#ifdef EV_BOARD
    413          //				TDevice::DEVICE->DebugTools->Led2.Off();
    414          //				TDevice::DEVICE->DebugTools->Led3.On();
    415          //			#endif
    416          //			
    417          //			pBuffer = EcgBuffer_2;
    418          //			if( f_write( &MainFile, pBuffer, sizeof(EcgBuffer_2), &BwW ) != FR_OK ){
    419          //				NVIC_SystemReset();		/* Software reset program */
    420          //			}
    421          //			f_sync( &MainFile );
    422          //			memset( pBuffer, 0x00, sizeof(EcgBuffer_2) );
    423          //			EcgBuffer_2_Full = false;
    424          //		}
    425          //
    426          //		else {
    427          //			vTaskSuspend( NULL );
    428          //		}
    429          //	}
    430          //}
    431          //
    432          
    433          
    434          ///*----------------------------------------------------------------------------------*/
    435          ///* @brief	Задача проверки наличия и подготовки SD карты							*/
    436          ///* @param	None																	*/
    437          ///* @return	None																	*/
    438          ///*----------------------------------------------------------------------------------*/
    439          //void TSDProcessor::TASK_SDPresentCheck( void *pvParameters )
    440          //{
    441          //	while( 1 )
    442          //	{
    443          //		if( disk_initialize(0) == RES_OK )
    444          //		{
    445          //			SDPresent = true;
    446          //			
    447          //			if( f_mount( 0, &FATFS_Obj ) == FR_OK )
    448          //			{
    449          //				if( f_open( &TrvFile, "ECG.TRV", FA_OPEN_EXISTING | FA_WRITE | FA_READ ) != FR_OK )		/* File NOT exists */
    450          //				{
    451          //					f_open( &TrvFile, "ECG.TRV", FA_CREATE_NEW | FA_WRITE | FA_READ );		/* Create file */
    452          //					
    453          //					memset( EcgBuffer_1, 0x00, 5 );
    454          //					EcgBuffer_1[0] = 1;
    455          //					f_write( &TrvFile, EcgBuffer_1, 5, &BwW );		/* Write 1 in first byte, mean ECG file was read */
    456          //					TrMode = trverrGood;
    457          //				}
    458          //				else		/* File TRV exists */
    459          //				{
    460          //					f_read( &TrvFile, EcgBuffer_1, 1, &BwW );
    461          //					if( EcgBuffer_1[0] == 0x00 )		/* File ECG.ECG was NOT read */
    462          //					{
    463          //						SDWriteEnable = false;
    464          //						TrMode = trverrNotRead;
    465          //					}
    466          //					else{
    467          //						TrMode = trverrGood;
    468          //					}
    469          //				}
    470          //				
    471          //				f_close( &TrvFile );
    472          //				
    473          //				/* Creating and overwriting ECG file */
    474          //				if( f_open( &MainFile, "KR01.RAW", FA_CREATE_ALWAYS | FA_WRITE ) == FR_OK )
    475          //				{
    476          //					write_patient_card();
    477          //					vTaskSuspend( NULL );
    478          //				}
    479          //			}
    480          //		}
    481          //		SDPresent = false;
    482          //		SDWriteEnable = false;
    483          //		vTaskDelay( 100 / portTICK_RATE_MS );	/* запустить заного если карты нет или файл не создан */
    484          //	}
    485          //}
    486          
    487          
    488          
    489          ///*----------------------------------------------------------------------------------*/
    490          ///* @brief	None																	*/
    491          ///* @param	None																	*/
    492          ///* @return	Status																	*/
    493          ///*----------------------------------------------------------------------------------*/
    494          //uint8_t TSDProcessor::StartWriting( void )
    495          //{
    496          //	enum result{ writing_ERROR, writing_OK };
    497          //	
    498          //	if(( TrMode == trverrNotRead ) && ( ReplaceECGFile == false ))
    499          //		return writing_OK;		/* ECG file was NOT read, return with monitoring */
    500          //	
    501          //	if( Def == true ) return writing_OK;		/* Если запись карты уже была */
    502          //	
    503          //	if( disk_initialize(0) != RES_OK )
    504          //	{
    505          //		SDPresent = false;
    506          //		SDWriteEnable = false;
    507          //		TAppProcessor::Setup.u._bits.UseWriteToCard = 0;
    508          //		return writing_ERROR;
    509          //	}
    510          //	
    511          //	f_close( &MainFile );
    512          //
    513          //	memset( EcgBuffer_1, 0x00, 5 );
    514          //	f_open( &TrvFile, "ECG.TRV", FA_OPEN_EXISTING | FA_WRITE );
    515          //	f_write( &TrvFile, EcgBuffer_1, 1, &BwW );
    516          //	f_close( &TrvFile );
    517          ////	TrMode = trverrNotRead;			/* mark, that file ecg was NOT read */
    518          //
    519          //	/* Setting record start date/time */
    520          //	TAppProcessor::PatientCard.DateTimeOfStart.Time = TAppProcessor::DeviceDateTime.Time;
    521          //	TAppProcessor::PatientCard.DateTimeOfStart.Date = TAppProcessor::DeviceDateTime.Date;
    522          //	TAppProcessor::PatientCard.StartPosition = sizeof( EcgBuffer_1 );
    523          //	
    524          //	f_open( &MainFile, "KR01.RAW", FA_CREATE_ALWAYS | FA_WRITE );
    525          //	f_lseek( &MainFile, 0 );		/* pointer to start of the file */
    526          //	write_patient_card();
    527          //	
    528          //	ReplaceECGFile = false;
    529          //	Def = true;
    530          //	SDWriteEnable = true;
    531          //	SDPresent = true;
    532          //	
    533          //	return writing_OK;
    534          //}
    535          //
    536          //
    537          //
    538          ///*----------------------------------------------------------------------------------*/
    539          ///* @brief	None																	*/
    540          ///* @param	None																	*/
    541          ///* @return	None																	*/
    542          ///*----------------------------------------------------------------------------------*/
    543          //void TSDProcessor::StopWriting( void )
    544          //{
    545          //	TAppProcessor::Setup.u._bits.UseDisableAutoTurnOff = 0;
    546          //	TAppProcessor::Setup.u._bits.UseWriteToCard = 0;
    547          //	TAppProcessor::Setup.u._bits.UseRWaveIndicator = 0;
    548          //	SDPresent = true;
    549          //	SDWriteEnable = false;
    550          //	Def = false;
    551          //	ReplaceECGFile = false;
    552          //	TrMode = trverrNotRead;
    553          //	
    554          //	vTaskSuspend( xSDDataWrite );
    555          //	vTaskResume( xSDPresentCheck );
    556          //}
    557          //
    558          //
    559          //
    560          ///*----------------------------------------------------------------------------------*/
    561          ///* @brief	Write patient card to SD												*/
    562          ///* @param	None																	*/
    563          ///* @return	None																	*/
    564          ///*----------------------------------------------------------------------------------*/
    565          //void TSDProcessor::write_patient_card( void )
    566          //{
    567          //	memcpy( EcgBuffer_1, &TAppProcessor::PatientCard, sizeof(TAppProcessor::PatientCard) );
    568          //	
    569          //	f_write( &MainFile, EcgBuffer_1, sizeof(EcgBuffer_1), &BwW );
    570          //	
    571          //	f_sync( &MainFile );
    572          //	
    573          //	memset( EcgBuffer_1, 0x00, sizeof(EcgBuffer_1) );
    574          //}
    575          //
    576          
    577          
    578          ///*----------------------------------------------------------------------------------*/
    579          ///* @brief	None																	*/
    580          ///* @param	None																	*/
    581          ///* @return	None																	*/
    582          ///*----------------------------------------------------------------------------------*/
    583          //bool TSDProcessor::check_ecg_for_travel( void )
    584          //{
    585          //	enum ecg_file_status{ ecg_file_was_read, ecg_file_was_not_read };
    586          //	uint8_t data;
    587          //	
    588          //	
    589          //}

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   TSDProcessor::FillBuffer_ECG(EcgData_t *)
        32   -> TPoolingNand::AddDataToPool(int, BYTE *, int, bool)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       1  TSDProcessor::Def
    2048  TSDProcessor::EcgBuffer_1
       1  TSDProcessor::EcgBuffer_1_Full
    2048  TSDProcessor::EcgBuffer_2
       1  TSDProcessor::EcgBuffer_2_Full
     560  TSDProcessor::FATFS_Obj
    1048  TSDProcessor::FillBuffer_ECG(EcgData_t *)
      40  TSDProcessor::MainFile
       1  TSDProcessor::NoAskReplaceECGFileQuestion
       1  TSDProcessor::ReplaceECGFile
       1  TSDProcessor::SDPresent
       1  TSDProcessor::SDStartWrPool
       1  TSDProcessor::SDWriteEnable
       1  TSDProcessor::TrMode
      40  TSDProcessor::TrvFile
       4  TSDProcessor::xSDDataWrite
       4  TSDProcessor::xSDPresentCheck
      24  adxl_axis
          VoltageSource
          Ecg

 
 4 776 bytes in section .bss
     1 byte  in section .data
 1 048 bytes in section .text
 
 1 048 bytes of CODE memory
 4 777 bytes of DATA memory

Errors: none
Warnings: none
