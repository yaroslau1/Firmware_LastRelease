###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        08/Oct/2018  17:04:49
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_rtc.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_rtc.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rtc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_rtc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Real-Time Clock (RTC) peripheral:
      9            *           + Initialization
     10            *           + Calendar (Time and Date) configuration
     11            *           + Alarms (Alarm A and Alarm B) configuration
     12            *           + WakeUp Timer configuration
     13            *           + Daylight Saving configuration
     14            *           + Output pin Configuration
     15            *           + Coarse digital Calibration configuration
     16            *           + Smooth digital Calibration configuration
     17            *           + TimeStamp configuration
     18            *           + Tampers configuration
     19            *           + Backup Data Registers configuration
     20            *           + Shift control synchronisation    
     21            *           + RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
     22            *           + Interrupts and flags management
     23            *
     24          @verbatim
     25          
     26           ===================================================================
     27                        ##### Backup Domain Operating Condition #####
     28           ===================================================================
     29           [..] The real-time clock (RTC), the RTC backup registers, and the backup 
     30                SRAM (BKP SRAM) can be powered from the VBAT voltage when the main 
     31                VDD supply is powered off.
     32                To retain the content of the RTC backup registers, backup SRAM, and supply 
     33                the RTC when VDD is turned off, VBAT pin can be connected to an optional 
     34                standby voltage supplied by a battery or by another source.
     35          
     36           [..] To allow the RTC to operate even when the main digital supply (VDD) is turned
     37                off, the VBAT pin powers the following blocks:
     38             (#) The RTC
     39             (#) The LSE oscillator
     40             (#) The backup SRAM when the low power backup regulator is enabled
     41             (#) PC13 to PC15 I/Os, plus PI8 I/O (when available)
     42            
     43           [..] When the backup domain is supplied by VDD (analog switch connected to VDD),
     44                the following functions are available:
     45             (#) PC14 and PC15 can be used as either GPIO or LSE pins
     46             (#) PC13 can be used as a GPIO or as the RTC_AF1 pin
     47             (#) PI8 can be used as a GPIO or as the RTC_AF2 pin
     48            
     49           [..] When the backup domain is supplied by VBAT (analog switch connected to VBAT 
     50                because VDD is not present), the following functions are available:
     51             (#) PC14 and PC15 can be used as LSE pins only
     52             (#) PC13 can be used as the RTC_AF1 pin 
     53             (#) PI8 can be used as the RTC_AF2 pin
     54            
     55                      
     56                             ##### Backup Domain Reset #####
     57           ===================================================================
     58           [..] The backup domain reset sets all RTC registers and the RCC_BDCR register 
     59                to their reset values. The BKPSRAM is not affected by this reset. The only
     60                way of resetting the BKPSRAM is through the Flash interface by requesting 
     61                a protection level change from 1 to 0.
     62           [..] A backup domain reset is generated when one of the following events occurs:
     63             (#) Software reset, triggered by setting the BDRST bit in the 
     64                 RCC Backup domain control register (RCC_BDCR). You can use the
     65                 RCC_BackupResetCmd().
     66             (#) VDD or VBAT power on, if both supplies have previously been powered off.
     67            
     68          
     69                             ##### Backup Domain Access #####
     70           ===================================================================
     71           [..] After reset, the backup domain (RTC registers, RTC backup data 
     72                registers and backup SRAM) is protected against possible unwanted write 
     73                accesses. 
     74           [..] To enable access to the RTC Domain and RTC registers, proceed as follows:
     75             (+) Enable the Power Controller (PWR) APB1 interface clock using the
     76                 RCC_APB1PeriphClockCmd() function.
     77             (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
     78             (+) Select the RTC clock source using the RCC_RTCCLKConfig() function.
     79             (+) Enable RTC Clock using the RCC_RTCCLKCmd() function.
     80            
     81            
     82                            ##### How to use RTC Driver #####
     83           ===================================================================
     84           [..] 
     85             (+) Enable the RTC domain access (see description in the section above)
     86             (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour 
     87                 format using the RTC_Init() function.
     88            
     89           *** Time and Date configuration ***
     90           ===================================
     91           [..] 
     92             (+) To configure the RTC Calendar (Time and Date) use the RTC_SetTime()
     93                 and RTC_SetDate() functions.
     94             (+) To read the RTC Calendar, use the RTC_GetTime() and RTC_GetDate() functions.
     95             (+) Use the RTC_DayLightSavingConfig() function to add or sub one
     96                 hour to the RTC Calendar.    
     97            
     98           *** Alarm configuration ***
     99           ===========================
    100           [..]
    101             (+) To configure the RTC Alarm use the RTC_SetAlarm() function.
    102             (+) Enable the selected RTC Alarm using the RTC_AlarmCmd() function
    103             (+) To read the RTC Alarm, use the RTC_GetAlarm() function.
    104             (+) To read the RTC alarm SubSecond, use the RTC_GetAlarmSubSecond() function.
    105            
    106           *** RTC Wakeup configuration ***
    107           ================================
    108           [..] 
    109             (+) Configure the RTC Wakeup Clock source use the RTC_WakeUpClockConfig()
    110                 function.
    111             (+) Configure the RTC WakeUp Counter using the RTC_SetWakeUpCounter() function  
    112             (+) Enable the RTC WakeUp using the RTC_WakeUpCmd() function  
    113             (+) To read the RTC WakeUp Counter register, use the RTC_GetWakeUpCounter() 
    114                 function.
    115            
    116           *** Outputs configuration ***
    117           =============================
    118           [..] The RTC has 2 different outputs:
    119             (+) AFO_ALARM: this output is used to manage the RTC Alarm A, Alarm B
    120                 and WaKeUp signals. To output the selected RTC signal on RTC_AF1 pin, use the 
    121                 RTC_OutputConfig() function.                
    122             (+) AFO_CALIB: this output is 512Hz signal or 1Hz. To output the RTC Clock on 
    123                 RTC_AF1 pin, use the RTC_CalibOutputCmd() function.
    124            
    125           *** Smooth digital Calibration configuration ***
    126           ================================================    
    127           [..]
    128             (+) Configure the RTC Original Digital Calibration Value and the corresponding
    129                 calibration cycle period (32s,16s and 8s) using the RTC_SmoothCalibConfig() 
    130                 function.
    131            
    132           *** Coarse digital Calibration configuration ***
    133           ================================================
    134           [..]
    135             (+) Configure the RTC Coarse Calibration Value and the corresponding
    136                 sign using the RTC_CoarseCalibConfig() function.
    137             (+) Enable the RTC Coarse Calibration using the RTC_CoarseCalibCmd() function  
    138            
    139           *** TimeStamp configuration ***
    140           ===============================
    141           [..]
    142             (+) Configure the RTC_AF1 trigger and enables the RTC TimeStamp using the RTC
    143                _TimeStampCmd() function.
    144             (+) To read the RTC TimeStamp Time and Date register, use the RTC_GetTimeStamp()
    145                 function.
    146             (+) To read the RTC TimeStamp SubSecond register, use the 
    147                 RTC_GetTimeStampSubSecond() function.
    148             (+) The TAMPER1 alternate function can be mapped either to RTC_AF1(PC13)
    149                 or RTC_AF2 (PI8) depending on the value of TAMP1INSEL bit in 
    150                 RTC_TAFCR register. You can use the  RTC_TamperPinSelection() function to
    151                 select the corresponding pin.     
    152            
    153           *** Tamper configuration ***
    154           ============================
    155           [..]
    156             (+) Enable the RTC Tamper using the RTC_TamperCmd() function.
    157             (+) Configure the Tamper filter count using RTC_TamperFilterConfig()
    158                 function. 
    159             (+) Configure the RTC Tamper trigger Edge or Level according to the Tamper 
    160                 filter (if equal to 0 Edge else Level) value using the RTC_TamperConfig() 
    161                 function.
    162             (+) Configure the Tamper sampling frequency using RTC_TamperSamplingFreqConfig()
    163                 function.
    164             (+) Configure the Tamper precharge or discharge duration using 
    165                 RTC_TamperPinsPrechargeDuration() function.
    166             (+) Enable the Tamper Pull-UP using RTC_TamperPullUpDisableCmd() function.
    167             (+) Enable the Time stamp on Tamper detection event using  
    168                 TC_TSOnTamperDetecCmd() function.
    169             (+) The TIMESTAMP alternate function can be mapped to either RTC_AF1 
    170                 or RTC_AF2 depending on the value of the TSINSEL bit in the RTC_TAFCR 
    171                 register. You can use the  RTC_TimeStampPinSelection() function to select 
    172                 the corresponding pin. 
    173            
    174           *** Backup Data Registers configuration ***
    175           ===========================================
    176           [..]
    177             (+) To write to the RTC Backup Data registers, use the RTC_WriteBackupRegister()
    178                 function.  
    179             (+) To read the RTC Backup Data registers, use the RTC_ReadBackupRegister()
    180                 function.
    181             
    182          
    183                            ##### RTC and low power modes #####
    184           ===================================================================
    185           [..] The MCU can be woken up from a low power mode by an RTC alternate 
    186                function.
    187           [..] The RTC alternate functions are the RTC alarms (Alarm A and Alarm B), 
    188                RTC wakeup, RTC tamper event detection and RTC time stamp event detection.
    189                These RTC alternate functions can wake up the system from the Stop and 
    190                Standby lowpower modes.
    191           [..] The system can also wake up from low power modes without depending 
    192                on an external interrupt (Auto-wakeup mode), by using the RTC alarm 
    193                or the RTC wakeup events.
    194           [..] The RTC provides a programmable time base for waking up from the 
    195                Stop or Standby mode at regular intervals.
    196                Wakeup from STOP and Standby modes is possible only when the RTC clock source
    197                is LSE or LSI.
    198            
    199          
    200                    ##### Selection of RTC_AF1 alternate functions #####
    201           ===================================================================
    202           [..] The RTC_AF1 pin (PC13) can be used for the following purposes:
    203             (+) AFO_ALARM output
    204             (+) AFO_CALIB output
    205             (+) AFI_TAMPER
    206             (+) AFI_TIMESTAMP
    207           
    208           [..]   
    209             +-------------------------------------------------------------------------------------------------------------+
    210             |     Pin         |AFO_ALARM |AFO_CALIB |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    211             |  configuration  | ENABLED  | ENABLED  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    212             |  and function   |          |          |           |              | selection  |  selection   |Configuration |
    213             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    214             |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    215             |   output OD     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      0       |
    216             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    217             |   Alarm out     |          |          |           |              |    Don't   |     Don't    |              |
    218             |   output PP     |     1    |Don't care|Don't care | Don't care   |    care    |     care     |      1       |
    219             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    220             | Calibration out |          |          |           |              |    Don't   |     Don't    |              |
    221             |   output PP     |     0    |    1     |Don't care | Don't care   |    care    |     care     |  Don't care  |
    222             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    223             |  TAMPER input   |          |          |           |              |            |     Don't    |              |
    224             |   floating      |     0    |    0     |     1     |      0       |      0     |     care     |  Don't care  |
    225             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    226             |  TIMESTAMP and  |          |          |           |              |            |              |              |
    227             |  TAMPER input   |     0    |    0     |     1     |      1       |      0     |      0       |  Don't care  |
    228             |   floating      |          |          |           |              |            |              |              |
    229             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    230             | TIMESTAMP input |          |          |           |              |    Don't   |              |              |
    231             |    floating     |     0    |    0     |     0     |      1       |    care    |      0       |  Don't care  |
    232             |-----------------|----------|----------|-----------|--------------|------------|--------------|--------------|
    233             |  Standard GPIO  |     0    |    0     |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    234             +-------------------------------------------------------------------------------------------------------------+
    235          
    236                      
    237                  #####  Selection of RTC_AF2 alternate functions #####
    238           ===================================================================
    239           [..] The RTC_AF2 pin (PI8) can be used for the following purposes:
    240             (+) AFI_TAMPER
    241             (+) AFI_TIMESTAMP
    242           [..]
    243             +---------------------------------------------------------------------------------------+
    244             |     Pin         |AFI_TAMPER |AFI_TIMESTAMP | TAMP1INSEL |   TSINSEL    |ALARMOUTTYPE  |
    245             |  configuration  |  ENABLED  |   ENABLED    |TAMPER1 pin |TIMESTAMP pin |  AFO_ALARM   |
    246             |  and function   |           |              | selection  |  selection   |Configuration |
    247             |-----------------|-----------|--------------|------------|--------------|--------------|
    248             |  TAMPER input   |           |              |            |     Don't    |              |
    249             |   floating      |     1     |      0       |      1     |     care     |  Don't care  |
    250             |-----------------|-----------|--------------|------------|--------------|--------------|
    251             |  TIMESTAMP and  |           |              |            |              |              |
    252             |  TAMPER input   |     1     |      1       |      1     |      1       |  Don't care  |
    253             |   floating      |           |              |            |              |              |
    254             |-----------------|-----------|--------------|------------|--------------|--------------|
    255             | TIMESTAMP input |           |              |    Don't   |              |              |
    256             |    floating     |     0     |      1       |    care    |      1       |  Don't care  |
    257             |-----------------|-----------|--------------|------------|--------------|--------------|
    258             |  Standard GPIO  |     0     |      0       | Don't care |  Don't care  |  Don't care  |
    259             +---------------------------------------------------------------------------------------+   
    260           
    261               
    262          @endverbatim
    263            
    264            ******************************************************************************
    265            * @attention
    266            *
    267            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
    268            *
    269            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    270            * You may not use this file except in compliance with the License.
    271            * You may obtain a copy of the License at:
    272            *
    273            *        http://www.st.com/software_license_agreement_liberty_v2
    274            *
    275            * Unless required by applicable law or agreed to in writing, software 
    276            * distributed under the License is distributed on an "AS IS" BASIS, 
    277            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    278            * See the License for the specific language governing permissions and
    279            * limitations under the License.
    280            *
    281            ******************************************************************************
    282            */ 
    283          
    284          /* Includes ------------------------------------------------------------------*/
    285          #include "stm32f4xx_rtc.h"
    286          
    287          /** @addtogroup STM32F4xx_StdPeriph_Driver
    288            * @{
    289            */
    290          
    291          /** @defgroup RTC 
    292            * @brief RTC driver modules
    293            * @{
    294            */
    295          
    296          /* Private typedef -----------------------------------------------------------*/
    297          /* Private define ------------------------------------------------------------*/
    298          
    299          /* Masks Definition */
    300          #define RTC_TR_RESERVED_MASK    ((uint32_t)0x007F7F7F)
    301          #define RTC_DR_RESERVED_MASK    ((uint32_t)0x00FFFF3F) 
    302          #define RTC_INIT_MASK           ((uint32_t)0xFFFFFFFF)  
    303          #define RTC_RSF_MASK            ((uint32_t)0xFFFFFF5F)
    304          #define RTC_FLAGS_MASK          ((uint32_t)(RTC_FLAG_TSOVF | RTC_FLAG_TSF | RTC_FLAG_WUTF | \
    305                                                      RTC_FLAG_ALRBF | RTC_FLAG_ALRAF | RTC_FLAG_INITF | \
    306                                                      RTC_FLAG_RSF | RTC_FLAG_INITS | RTC_FLAG_WUTWF | \
    307                                                      RTC_FLAG_ALRBWF | RTC_FLAG_ALRAWF | RTC_FLAG_TAMP1F | \
    308                                                      RTC_FLAG_RECALPF | RTC_FLAG_SHPF))
    309          
    310          #define INITMODE_TIMEOUT         ((uint32_t) 0x00010000)
    311          #define SYNCHRO_TIMEOUT          ((uint32_t) 0x00020000)
    312          #define RECALPF_TIMEOUT          ((uint32_t) 0x00020000)
    313          #define SHPF_TIMEOUT             ((uint32_t) 0x00001000)
    314          
    315          /* Private macro -------------------------------------------------------------*/
    316          /* Private variables ---------------------------------------------------------*/
    317          /* Private function prototypes -----------------------------------------------*/
    318          static uint8_t RTC_ByteToBcd2(uint8_t Value);
    319          static uint8_t RTC_Bcd2ToByte(uint8_t Value);
    320          
    321          /* Private functions ---------------------------------------------------------*/
    322          
    323          /** @defgroup RTC_Private_Functions
    324            * @{
    325            */ 
    326          
    327          /** @defgroup RTC_Group1 Initialization and Configuration functions
    328           *  @brief   Initialization and Configuration functions 
    329           *
    330          @verbatim   
    331           ===============================================================================
    332                       ##### Initialization and Configuration functions #####
    333           ===============================================================================
    334           
    335           [..] This section provide functions allowing to initialize and configure the RTC
    336                Prescaler (Synchronous and Asynchronous), RTC Hour format, disable RTC registers
    337                Write protection, enter and exit the RTC initialization mode, RTC registers
    338                synchronization check and reference clock detection enable.
    339            
    340             (#) The RTC Prescaler is programmed to generate the RTC 1Hz time base. It is
    341                 split into 2 programmable prescalers to minimize power consumption.
    342                 (++) A 7-bit asynchronous prescaler and A 13-bit synchronous prescaler.
    343                 (++) When both prescalers are used, it is recommended to configure the 
    344                      asynchronous prescaler to a high value to minimize consumption.
    345          
    346             (#) All RTC registers are Write protected. Writing to the RTC registers
    347                 is enabled by writing a key into the Write Protection register, RTC_WPR.
    348          
    349             (#) To Configure the RTC Calendar, user application should enter initialization
    350                 mode. In this mode, the calendar counter is stopped and its value can be 
    351                 updated. When the initialization sequence is complete, the calendar restarts 
    352                 counting after 4 RTCCLK cycles.
    353          
    354             (#) To read the calendar through the shadow registers after Calendar initialization,
    355                 calendar update or after wakeup from low power modes the software must first 
    356                 clear the RSF flag. The software must then wait until it is set again before 
    357                 reading the calendar, which means that the calendar registers have been 
    358                 correctly copied into the RTC_TR and RTC_DR shadow registers.
    359                 The RTC_WaitForSynchro() function implements the above software sequence 
    360                 (RSF clear and RSF check).
    361          
    362          @endverbatim
    363            * @{
    364            */
    365          
    366          /**
    367            * @brief  Deinitializes the RTC registers to their default reset values.
    368            * @note   This function doesn't reset the RTC Clock source and RTC Backup Data
    369            *         registers.       
    370            * @param  None
    371            * @retval An ErrorStatus enumeration value:
    372            *          - SUCCESS: RTC registers are deinitialized
    373            *          - ERROR: RTC registers are not deinitialized
    374            */

   \                                 In section .text, align 2, keep-with-next
    375          ErrorStatus RTC_DeInit(void)
    376          {
   \                     RTC_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    377            __IO uint32_t wutcounter = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    378            uint32_t wutwfstatus = 0x00;
    379            ErrorStatus status = ERROR;
   \   00000006   0x4604             MOV      R4,R0
    380            
    381            /* Disable the write protection for RTC registers */
    382            RTC->WPR = 0xCA;
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable27  ;; 0x40002800
   \   0000000C   0x20CA             MOVS     R0,#+202
   \   0000000E   0x6268             STR      R0,[R5, #+36]
    383            RTC->WPR = 0x53;
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x6268             STR      R0,[R5, #+36]
    384          
    385            /* Set Initialization mode */
    386            if (RTC_EnterInitMode() == ERROR)
   \   00000014   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD02F             BEQ.N    ??RTC_DeInit_0
    387            {
    388              status = ERROR;
    389            }  
    390            else
    391            {
    392              /* Reset TR, DR and CR registers */
    393              RTC->TR = (uint32_t)0x00000000;
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x6028             STR      R0,[R5, #+0]
    394              RTC->DR = (uint32_t)0x00002101;
   \   00000020   0xF242 0x1001      MOVW     R0,#+8449
   \   00000024   0x6068             STR      R0,[R5, #+4]
    395              /* Reset All CR bits except CR[2:0] */
    396              RTC->CR &= (uint32_t)0x00000007;
   \   00000026   0x68A8             LDR      R0,[R5, #+8]
   \   00000028   0xF000 0x0007      AND      R0,R0,#0x7
   \   0000002C   0x60A8             STR      R0,[R5, #+8]
    397            
    398              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    399              do
    400              {
    401                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_DeInit_1: (+1)
   \   0000002E   0x68E8             LDR      R0,[R5, #+12]
   \   00000030   0xF000 0x0004      AND      R0,R0,#0x4
    402                wutcounter++;  
   \   00000034   0x9900             LDR      R1,[SP, #+0]
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \   00000038   0x9100             STR      R1,[SP, #+0]
    403              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   0000003A   0x9900             LDR      R1,[SP, #+0]
   \   0000003C   0xF5B1 0x3F80      CMP      R1,#+65536
   \   00000040   0xD001             BEQ.N    ??RTC_DeInit_2
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD0F3             BEQ.N    ??RTC_DeInit_1
    404              
    405              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_DeInit_2: (+1)
   \   00000046   0x68E8             LDR      R0,[R5, #+12]
   \   00000048   0x0740             LSLS     R0,R0,#+29
   \   0000004A   0xD517             BPL.N    ??RTC_DeInit_0
    406              {
    407                status = ERROR;
    408              }
    409              else
    410              {
    411                /* Reset all RTC CR register bits */
    412                RTC->CR &= (uint32_t)0x00000000;
   \   0000004C   0x68A8             LDR      R0,[R5, #+8]
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x60A8             STR      R0,[R5, #+8]
    413                RTC->WUTR = (uint32_t)0x0000FFFF;
   \   00000052   0xF64F 0x70FF      MOVW     R0,#+65535
   \   00000056   0x6168             STR      R0,[R5, #+20]
    414                RTC->PRER = (uint32_t)0x007F00FF;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable29  ;; 0x7f00ff
   \   0000005C   0x6128             STR      R0,[R5, #+16]
    415                RTC->CALIBR = (uint32_t)0x00000000;
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x61A8             STR      R0,[R5, #+24]
    416                RTC->ALRMAR = (uint32_t)0x00000000;        
   \   00000062   0x61E8             STR      R0,[R5, #+28]
    417                RTC->ALRMBR = (uint32_t)0x00000000;
   \   00000064   0x6228             STR      R0,[R5, #+32]
    418                RTC->SHIFTR = (uint32_t)0x00000000;
   \   00000066   0x62E8             STR      R0,[R5, #+44]
    419                RTC->CALR = (uint32_t)0x00000000;
   \   00000068   0x63E8             STR      R0,[R5, #+60]
    420                RTC->ALRMASSR = (uint32_t)0x00000000;
   \   0000006A   0x6468             STR      R0,[R5, #+68]
    421                RTC->ALRMBSSR = (uint32_t)0x00000000;
   \   0000006C   0x64A8             STR      R0,[R5, #+72]
    422                
    423                /* Reset ISR register and exit initialization mode */
    424                RTC->ISR = (uint32_t)0x00000000;
   \   0000006E   0x60E8             STR      R0,[R5, #+12]
    425                
    426                /* Reset Tamper and alternate functions configuration register */
    427                RTC->TAFCR = 0x00000000;
   \   00000070   0x6428             STR      R0,[R5, #+64]
    428            
    429                if(RTC_WaitForSynchro() == ERROR)
   \   00000072   0x.... 0x....      BL       RTC_WaitForSynchro
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD000             BEQ.N    ??RTC_DeInit_0
    430                {
    431                  status = ERROR;
    432                }
    433                else
    434                {
    435                  status = SUCCESS;      
   \   0000007A   0x2401             MOVS     R4,#+1
    436                }
    437              }
    438            }
    439            
    440            /* Enable the write protection for RTC registers */
    441            RTC->WPR = 0xFF;  
   \                     ??RTC_DeInit_0: (+1)
   \   0000007C   0x20FF             MOVS     R0,#+255
   \   0000007E   0x6268             STR      R0,[R5, #+36]
    442            
    443            return status;
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    444          }
    445          
    446          /**
    447            * @brief  Initializes the RTC registers according to the specified parameters 
    448            *         in RTC_InitStruct.
    449            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure that contains 
    450            *         the configuration information for the RTC peripheral.
    451            * @note   The RTC Prescaler register is write protected and can be written in 
    452            *         initialization mode only.  
    453            * @retval An ErrorStatus enumeration value:
    454            *          - SUCCESS: RTC registers are initialized
    455            *          - ERROR: RTC registers are not initialized  
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
    458          {
   \                     RTC_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    459            ErrorStatus status = ERROR;
   \   00000004   0x2600             MOVS     R6,#+0
    460            
    461            /* Check the parameters */
    462            assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x2840             CMP      R0,#+64
   \   0000000A   0xD007             BEQ.N    ??RTC_Init_0
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD005             BEQ.N    ??RTC_Init_0
   \   00000010   0xF44F 0x71E7      MOV      R1,#+462
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000018   0x.... 0x....      BL       assert_failed
    463            assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
   \                     ??RTC_Init_0: (+1)
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0x2880             CMP      R0,#+128
   \   00000020   0xD305             BCC.N    ??RTC_Init_1
   \   00000022   0xF240 0x11CF      MOVW     R1,#+463
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000002A   0x.... 0x....      BL       assert_failed
    464            assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
   \                     ??RTC_Init_1: (+1)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000034   0xD305             BCC.N    ??RTC_Init_2
   \   00000036   0xF44F 0x71E8      MOV      R1,#+464
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000003E   0x.... 0x....      BL       assert_failed
    465          
    466            /* Disable the write protection for RTC registers */
    467            RTC->WPR = 0xCA;
   \                     ??RTC_Init_2: (+1)
   \   00000042   0x.... 0x....      LDR.W    R5,??DataTable30  ;; 0x40002808
   \   00000046   0x20CA             MOVS     R0,#+202
   \   00000048   0x61E8             STR      R0,[R5, #+28]
    468            RTC->WPR = 0x53;
   \   0000004A   0x2053             MOVS     R0,#+83
   \   0000004C   0x61E8             STR      R0,[R5, #+28]
    469          
    470            /* Set Initialization mode */
    471            if (RTC_EnterInitMode() == ERROR)
   \   0000004E   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD011             BEQ.N    ??RTC_Init_3
    472            {
    473              status = ERROR;
    474            } 
    475            else
    476            {
    477              /* Clear RTC CR FMT Bit */
    478              RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0xF020 0x0040      BIC      R0,R0,#0x40
   \   0000005C   0x6028             STR      R0,[R5, #+0]
    479              /* Set RTC_CR register */
    480              RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
   \   0000005E   0x6828             LDR      R0,[R5, #+0]
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x4308             ORRS     R0,R1,R0
   \   00000064   0x6028             STR      R0,[R5, #+0]
    481            
    482              /* Configure the RTC PRER */
    483              RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
   \   00000066   0x68A0             LDR      R0,[R4, #+8]
   \   00000068   0x60A8             STR      R0,[R5, #+8]
    484              RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
   \   0000006A   0x68A8             LDR      R0,[R5, #+8]
   \   0000006C   0x6861             LDR      R1,[R4, #+4]
   \   0000006E   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000072   0x60A8             STR      R0,[R5, #+8]
    485          
    486              /* Exit Initialization mode */
    487              RTC_ExitInitMode();
   \   00000074   0x.... 0x....      BL       RTC_ExitInitMode
    488          
    489              status = SUCCESS;    
   \   00000078   0x2601             MOVS     R6,#+1
    490            }
    491            /* Enable the write protection for RTC registers */
    492            RTC->WPR = 0xFF; 
   \                     ??RTC_Init_3: (+1)
   \   0000007A   0x20FF             MOVS     R0,#+255
   \   0000007C   0x61E8             STR      R0,[R5, #+28]
    493            
    494            return status;
   \   0000007E   0x4630             MOV      R0,R6
   \   00000080   0xBD70             POP      {R4-R6,PC}       ;; return
    495          }
    496          
    497          /**
    498            * @brief  Fills each RTC_InitStruct member with its default value.
    499            * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
    500            *         initialized.
    501            * @retval None
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
    504          {
    505            /* Initialize the RTC_HourFormat member */
    506            RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   \                     RTC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    507              
    508            /* Initialize the RTC_AsynchPrediv member */
    509            RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
   \   00000004   0x217F             MOVS     R1,#+127
   \   00000006   0x6041             STR      R1,[R0, #+4]
    510          
    511            /* Initialize the RTC_SynchPrediv member */
    512            RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
   \   00000008   0x21FF             MOVS     R1,#+255
   \   0000000A   0x6081             STR      R1,[R0, #+8]
    513          }
   \   0000000C   0x4770             BX       LR               ;; return
    514          
    515          /**
    516            * @brief  Enables or disables the RTC registers write protection.
    517            * @note   All the RTC registers are write protected except for RTC_ISR[13:8], 
    518            *         RTC_TAFCR and RTC_BKPxR.
    519            * @note   Writing a wrong key reactivates the write protection.
    520            * @note   The protection mechanism is not affected by system reset.  
    521            * @param  NewState: new state of the write protection.
    522            *          This parameter can be: ENABLE or DISABLE.
    523            * @retval None
    524            */

   \                                 In section .text, align 2, keep-with-next
    525          void RTC_WriteProtectionCmd(FunctionalState NewState)
    526          {
   \                     RTC_WriteProtectionCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    527            /* Check the parameters */
    528            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RTC_WriteProtectionCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_WriteProtectionCmd_0
   \   0000000A   0xF44F 0x7104      MOV      R1,#+528
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000012   0x.... 0x....      BL       assert_failed
    529              
    530            if (NewState != DISABLE)
   \                     ??RTC_WriteProtectionCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x40002824
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD002             BEQ.N    ??RTC_WriteProtectionCmd_1
    531            {
    532              /* Enable the write protection for RTC registers */
    533              RTC->WPR = 0xFF;   
   \   0000001E   0x21FF             MOVS     R1,#+255
   \   00000020   0x6001             STR      R1,[R0, #+0]
   \   00000022   0xBD10             POP      {R4,PC}
    534            }
    535            else
    536            {
    537              /* Disable the write protection for RTC registers */
    538              RTC->WPR = 0xCA;
   \                     ??RTC_WriteProtectionCmd_1: (+1)
   \   00000024   0x21CA             MOVS     R1,#+202
   \   00000026   0x6001             STR      R1,[R0, #+0]
    539              RTC->WPR = 0x53;    
   \   00000028   0x2153             MOVS     R1,#+83
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    540            }
    541          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    542          
    543          /**
    544            * @brief  Enters the RTC Initialization mode.
    545            * @note   The RTC Initialization mode is write protected, use the 
    546            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.    
    547            * @param  None
    548            * @retval An ErrorStatus enumeration value:
    549            *          - SUCCESS: RTC is in Init mode
    550            *          - ERROR: RTC is not in Init mode  
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          ErrorStatus RTC_EnterInitMode(void)
    553          {
   \                     RTC_EnterInitMode: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    554            __IO uint32_t initcounter = 0x00;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    555            ErrorStatus status = ERROR;
    556            uint32_t initstatus = 0x00;
    557               
    558            /* Check if the Initialization mode is set */
    559            if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x4000280c
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0649             LSLS     R1,R1,#+25
   \   0000000E   0xD413             BMI.N    ??RTC_EnterInitMode_0
    560            {
    561              /* Set the Initialization mode */
    562              RTC->ISR = (uint32_t)RTC_INIT_MASK;
   \   00000010   0xF04F 0x31FF      MOV      R1,#-1
   \   00000014   0x6001             STR      R1,[R0, #+0]
    563              
    564              /* Wait till RTC is in INIT state and if Time out is reached exit */
    565              do
    566              {
    567                initstatus = RTC->ISR & RTC_ISR_INITF;
   \                     ??RTC_EnterInitMode_1: (+1)
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xF001 0x0140      AND      R1,R1,#0x40
    568                initcounter++;  
   \   0000001C   0x9A00             LDR      R2,[SP, #+0]
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0x9200             STR      R2,[SP, #+0]
    569              } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
   \   00000022   0x9A00             LDR      R2,[SP, #+0]
   \   00000024   0xF5B2 0x3F80      CMP      R2,#+65536
   \   00000028   0xD001             BEQ.N    ??RTC_EnterInitMode_2
   \   0000002A   0x2900             CMP      R1,#+0
   \   0000002C   0xD0F3             BEQ.N    ??RTC_EnterInitMode_1
    570              
    571              if ((RTC->ISR & RTC_ISR_INITF) != RESET)
   \                     ??RTC_EnterInitMode_2: (+1)
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
    572              {
    573                status = SUCCESS;
    574              }
    575              else
    576              {
    577                status = ERROR;
   \   00000030   0x0980             LSRS     R0,R0,#+6
   \   00000032   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000036   0xE000             B.N      ??RTC_EnterInitMode_3
    578              }        
    579            }
    580            else
    581            {
    582              status = SUCCESS;  
   \                     ??RTC_EnterInitMode_0: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
    583            } 
    584              
    585            return (status);  
   \                     ??RTC_EnterInitMode_3: (+1)
   \   0000003A   0xB001             ADD      SP,SP,#+4
   \   0000003C   0x4770             BX       LR               ;; return
    586          }
    587          
    588          /**
    589            * @brief  Exits the RTC Initialization mode.
    590            * @note   When the initialization sequence is complete, the calendar restarts 
    591            *         counting after 4 RTCCLK cycles.  
    592            * @note   The RTC Initialization mode is write protected, use the 
    593            *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
    594            * @param  None
    595            * @retval None
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          void RTC_ExitInitMode(void)
    598          { 
    599            /* Exit Initialization mode */
    600            RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
   \                     RTC_ExitInitMode: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable31_1  ;; 0x4000280c
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    601          }
   \   0000000C   0x4770             BX       LR               ;; return
    602          
    603          /**
    604            * @brief  Waits until the RTC Time and Date registers (RTC_TR and RTC_DR) are 
    605            *         synchronized with RTC APB clock.
    606            * @note   The RTC Resynchronization mode is write protected, use the 
    607            *         RTC_WriteProtectionCmd(DISABLE) before calling this function. 
    608            * @note   To read the calendar through the shadow registers after Calendar 
    609            *         initialization, calendar update or after wakeup from low power modes 
    610            *         the software must first clear the RSF flag. 
    611            *         The software must then wait until it is set again before reading 
    612            *         the calendar, which means that the calendar registers have been 
    613            *         correctly copied into the RTC_TR and RTC_DR shadow registers.   
    614            * @param  None
    615            * @retval An ErrorStatus enumeration value:
    616            *          - SUCCESS: RTC registers are synchronised
    617            *          - ERROR: RTC registers are not synchronised
    618            */

   \                                 In section .text, align 2, keep-with-next
    619          ErrorStatus RTC_WaitForSynchro(void)
    620          {
   \                     RTC_WaitForSynchro: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
    621            __IO uint32_t synchrocounter = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    622            ErrorStatus status = ERROR;
    623            uint32_t synchrostatus = 0x00;
    624          
    625            /* Disable the write protection for RTC registers */
    626            RTC->WPR = 0xCA;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable31_1  ;; 0x4000280c
   \   0000000A   0x20CA             MOVS     R0,#+202
   \   0000000C   0x6188             STR      R0,[R1, #+24]
    627            RTC->WPR = 0x53;
   \   0000000E   0x2053             MOVS     R0,#+83
   \   00000010   0x6188             STR      R0,[R1, #+24]
    628              
    629            /* Clear RSF flag */
    630            RTC->ISR &= (uint32_t)RTC_RSF_MASK;
   \   00000012   0x6808             LDR      R0,[R1, #+0]
   \   00000014   0xF020 0x00A0      BIC      R0,R0,#0xA0
   \   00000018   0x6008             STR      R0,[R1, #+0]
    631              
    632            /* Wait the registers to be synchronised */
    633            do
    634            {
    635              synchrostatus = RTC->ISR & RTC_ISR_RSF;
   \                     ??RTC_WaitForSynchro_0: (+1)
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0xF000 0x0020      AND      R0,R0,#0x20
    636              synchrocounter++;  
   \   00000020   0x9A00             LDR      R2,[SP, #+0]
   \   00000022   0x1C52             ADDS     R2,R2,#+1
   \   00000024   0x9200             STR      R2,[SP, #+0]
    637            } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
   \   00000026   0x9A00             LDR      R2,[SP, #+0]
   \   00000028   0xF5B2 0x3F00      CMP      R2,#+131072
   \   0000002C   0xD001             BEQ.N    ??RTC_WaitForSynchro_1
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD0F3             BEQ.N    ??RTC_WaitForSynchro_0
    638              
    639            if ((RTC->ISR & RTC_ISR_RSF) != RESET)
   \                     ??RTC_WaitForSynchro_1: (+1)
   \   00000032   0x6808             LDR      R0,[R1, #+0]
    640            {
    641              status = SUCCESS;
    642            }
    643            else
    644            {
    645              status = ERROR;
   \   00000034   0x0940             LSRS     R0,R0,#+5
   \   00000036   0xF000 0x0001      AND      R0,R0,#0x1
    646            }        
    647          
    648            /* Enable the write protection for RTC registers */
    649            RTC->WPR = 0xFF; 
   \   0000003A   0x22FF             MOVS     R2,#+255
   \   0000003C   0x618A             STR      R2,[R1, #+24]
    650              
    651            return (status); 
   \   0000003E   0xB001             ADD      SP,SP,#+4
   \   00000040   0x4770             BX       LR               ;; return
    652          }
    653          
    654          /**
    655            * @brief  Enables or disables the RTC reference clock detection.
    656            * @param  NewState: new state of the RTC reference clock.
    657            *          This parameter can be: ENABLE or DISABLE.
    658            * @retval An ErrorStatus enumeration value:
    659            *          - SUCCESS: RTC reference clock detection is enabled
    660            *          - ERROR: RTC reference clock detection is disabled  
    661            */

   \                                 In section .text, align 2, keep-with-next
    662          ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
    663          { 
   \                     RTC_RefClockCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
    664            ErrorStatus status = ERROR;
   \   00000004   0x2600             MOVS     R6,#+0
    665            
    666            /* Check the parameters */
    667            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD007             BEQ.N    ??RTC_RefClockCmd_0
   \   0000000A   0x2D01             CMP      R5,#+1
   \   0000000C   0xD005             BEQ.N    ??RTC_RefClockCmd_0
   \   0000000E   0xF240 0x219B      MOVW     R1,#+667
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000016   0x.... 0x....      BL       assert_failed
    668            
    669            /* Disable the write protection for RTC registers */
    670            RTC->WPR = 0xCA;
   \                     ??RTC_RefClockCmd_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R4,??DataTable30  ;; 0x40002808
   \   0000001E   0x20CA             MOVS     R0,#+202
   \   00000020   0x61E0             STR      R0,[R4, #+28]
    671            RTC->WPR = 0x53;
   \   00000022   0x2053             MOVS     R0,#+83
   \   00000024   0x61E0             STR      R0,[R4, #+28]
    672              
    673            /* Set Initialization mode */
    674            if (RTC_EnterInitMode() == ERROR)
   \   00000026   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00C             BEQ.N    ??RTC_RefClockCmd_1
    675            {
    676              status = ERROR;
    677            } 
    678            else
    679            {  
    680              if (NewState != DISABLE)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0xD003             BEQ.N    ??RTC_RefClockCmd_2
    681              {
    682                /* Enable the RTC reference clock detection */
    683                RTC->CR |= RTC_CR_REFCKON;   
   \   00000034   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000038   0x6020             STR      R0,[R4, #+0]
   \   0000003A   0xE002             B.N      ??RTC_RefClockCmd_3
    684              }
    685              else
    686              {
    687                /* Disable the RTC reference clock detection */
    688                RTC->CR &= ~RTC_CR_REFCKON;    
   \                     ??RTC_RefClockCmd_2: (+1)
   \   0000003C   0xF020 0x0010      BIC      R0,R0,#0x10
   \   00000040   0x6020             STR      R0,[R4, #+0]
    689              }
    690              /* Exit Initialization mode */
    691              RTC_ExitInitMode();
   \                     ??RTC_RefClockCmd_3: (+1)
   \   00000042   0x.... 0x....      BL       RTC_ExitInitMode
    692              
    693              status = SUCCESS;
   \   00000046   0x2601             MOVS     R6,#+1
    694            }
    695            
    696            /* Enable the write protection for RTC registers */
    697            RTC->WPR = 0xFF;  
   \                     ??RTC_RefClockCmd_1: (+1)
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0x61E0             STR      R0,[R4, #+28]
    698            
    699            return status; 
   \   0000004C   0x4630             MOV      R0,R6
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    700          }
    701          
    702          /**
    703            * @brief  Enables or Disables the Bypass Shadow feature.
    704            * @note   When the Bypass Shadow is enabled the calendar value are taken 
    705            *         directly from the Calendar counter.
    706            * @param  NewState: new state of the Bypass Shadow feature.
    707            *         This parameter can be: ENABLE or DISABLE.
    708            * @retval None
    709          */

   \                                 In section .text, align 2, keep-with-next
    710          void RTC_BypassShadowCmd(FunctionalState NewState)
    711          {
   \                     RTC_BypassShadowCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    712            /* Check the parameters */
    713            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RTC_BypassShadowCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_BypassShadowCmd_0
   \   0000000A   0xF240 0x21C9      MOVW     R1,#+713
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000012   0x.... 0x....      BL       assert_failed
    714          
    715            /* Disable the write protection for RTC registers */
    716            RTC->WPR = 0xCA;
   \                     ??RTC_BypassShadowCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0x40002808
   \   0000001A   0x21CA             MOVS     R1,#+202
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
    717            RTC->WPR = 0x53;
   \   0000001E   0x2153             MOVS     R1,#+83
   \   00000020   0x61C1             STR      R1,[R0, #+28]
    718            
    719            if (NewState != DISABLE)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xD003             BEQ.N    ??RTC_BypassShadowCmd_1
    720            {
    721              /* Set the BYPSHAD bit */
    722              RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
   \   00000028   0xF041 0x0120      ORR      R1,R1,#0x20
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   \   0000002E   0xE002             B.N      ??RTC_BypassShadowCmd_2
    723            }
    724            else
    725            {
    726              /* Reset the BYPSHAD bit */
    727              RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
   \                     ??RTC_BypassShadowCmd_1: (+1)
   \   00000030   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   00000034   0x6001             STR      R1,[R0, #+0]
    728            }
    729          
    730            /* Enable the write protection for RTC registers */
    731            RTC->WPR = 0xFF;
   \                     ??RTC_BypassShadowCmd_2: (+1)
   \   00000036   0x21FF             MOVS     R1,#+255
   \   00000038   0x61C1             STR      R1,[R0, #+28]
    732          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    733          
    734          /**
    735            * @}
    736            */
    737          
    738          /** @defgroup RTC_Group2 Time and Date configuration functions
    739           *  @brief   Time and Date configuration functions 
    740           *
    741          @verbatim   
    742           ===============================================================================
    743                           ##### Time and Date configuration functions #####
    744           ===============================================================================  
    745           
    746           [..] This section provide functions allowing to program and read the RTC Calendar
    747                (Time and Date).
    748          
    749          @endverbatim
    750            * @{
    751            */
    752          
    753          /**
    754            * @brief  Set the RTC current time.
    755            * @param  RTC_Format: specifies the format of the entered parameters.
    756            *          This parameter can be  one of the following values:
    757            *            @arg RTC_Format_BIN:  Binary data format 
    758            *            @arg RTC_Format_BCD:  BCD data format
    759            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that contains 
    760            *                        the time configuration information for the RTC.     
    761            * @retval An ErrorStatus enumeration value:
    762            *          - SUCCESS: RTC Time register is configured
    763            *          - ERROR: RTC Time register is not configured
    764            */

   \                                 In section .text, align 2, keep-with-next
    765          ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    766          {
   \                     RTC_SetTime: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x460C             MOV      R4,R1
    767            uint32_t tmpreg = 0;
    768            ErrorStatus status = ERROR;
   \   00000008   0x2500             MOVS     R5,#+0
    769              
    770            /* Check the parameters */
    771            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000A   0x2F00             CMP      R7,#+0
   \   0000000C   0xD007             BEQ.N    ??RTC_SetTime_0
   \   0000000E   0x2F01             CMP      R7,#+1
   \   00000010   0xD005             BEQ.N    ??RTC_SetTime_0
   \   00000012   0xF240 0x3103      MOVW     R1,#+771
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000001A   0x.... 0x....      BL       assert_failed
    772            
    773            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetTime_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable27  ;; 0x40002800
   \   00000022   0x2F00             CMP      R7,#+0
   \   00000024   0x68B0             LDR      R0,[R6, #+8]
   \   00000026   0xD136             BNE.N    ??RTC_SetTime_1
    774            {
    775              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   00000028   0x0640             LSLS     R0,R0,#+25
   \   0000002A   0xD516             BPL.N    ??RTC_SetTime_2
    776              {
    777                assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??RTC_SetTime_3
   \   00000032   0x280D             CMP      R0,#+13
   \   00000034   0xDB05             BLT.N    ??RTC_SetTime_4
   \                     ??RTC_SetTime_3: (+1)
   \   00000036   0xF240 0x3109      MOVW     R1,#+777
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000003E   0x.... 0x....      BL       assert_failed
    778                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
   \                     ??RTC_SetTime_4: (+1)
   \   00000042   0x78E0             LDRB     R0,[R4, #+3]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD013             BEQ.N    ??RTC_SetTime_5
   \   00000048   0x2840             CMP      R0,#+64
   \   0000004A   0xD011             BEQ.N    ??RTC_SetTime_5
   \   0000004C   0xF240 0x310A      MOVW     R1,#+778
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000054   0x.... 0x....      BL       assert_failed
   \   00000058   0xE00A             B.N      ??RTC_SetTime_5
    779              } 
    780              else
    781              {
    782                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_2: (+1)
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x70E0             STRB     R0,[R4, #+3]
    783                assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
   \   0000005E   0x7820             LDRB     R0,[R4, #+0]
   \   00000060   0x2818             CMP      R0,#+24
   \   00000062   0xDB05             BLT.N    ??RTC_SetTime_5
   \   00000064   0xF240 0x310F      MOVW     R1,#+783
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000006C   0x.... 0x....      BL       assert_failed
    784              }
    785              assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
   \                     ??RTC_SetTime_5: (+1)
   \   00000070   0x7860             LDRB     R0,[R4, #+1]
   \   00000072   0x283C             CMP      R0,#+60
   \   00000074   0xDB05             BLT.N    ??RTC_SetTime_6
   \   00000076   0xF240 0x3111      MOVW     R1,#+785
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000007E   0x.... 0x....      BL       assert_failed
    786              assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
   \                     ??RTC_SetTime_6: (+1)
   \   00000082   0x78A0             LDRB     R0,[R4, #+2]
   \   00000084   0x283C             CMP      R0,#+60
   \   00000086   0xDB44             BLT.N    ??RTC_SetTime_7
   \   00000088   0xF240 0x3112      MOVW     R1,#+786
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000090   0x.... 0x....      BL       assert_failed
   \   00000094   0xE03D             B.N      ??RTC_SetTime_7
    787            }
    788            else
    789            {
    790              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetTime_1: (+1)
   \   00000096   0x0640             LSLS     R0,R0,#+25
   \   00000098   0xD518             BPL.N    ??RTC_SetTime_8
    791              {
    792                tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   0000009A   0x7820             LDRB     R0,[R4, #+0]
   \   0000009C   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
    793                assert_param(IS_RTC_HOUR12(tmpreg));
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD001             BEQ.N    ??RTC_SetTime_9
   \   000000A4   0x280D             CMP      R0,#+13
   \   000000A6   0xD305             BCC.N    ??RTC_SetTime_10
   \                     ??RTC_SetTime_9: (+1)
   \   000000A8   0xF240 0x3119      MOVW     R1,#+793
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   000000B0   0x.... 0x....      BL       assert_failed
    794                assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
   \                     ??RTC_SetTime_10: (+1)
   \   000000B4   0x78E0             LDRB     R0,[R4, #+3]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD015             BEQ.N    ??RTC_SetTime_11
   \   000000BA   0x2840             CMP      R0,#+64
   \   000000BC   0xD013             BEQ.N    ??RTC_SetTime_11
   \   000000BE   0xF240 0x311A      MOVW     R1,#+794
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   000000C6   0x.... 0x....      BL       assert_failed
   \   000000CA   0xE00C             B.N      ??RTC_SetTime_11
    795              } 
    796              else
    797              {
    798                RTC_TimeStruct->RTC_H12 = 0x00;
   \                     ??RTC_SetTime_8: (+1)
   \   000000CC   0x4628             MOV      R0,R5
   \   000000CE   0x70E0             STRB     R0,[R4, #+3]
    799                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
   \   000000D0   0x7820             LDRB     R0,[R4, #+0]
   \   000000D2   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   000000D6   0x2818             CMP      R0,#+24
   \   000000D8   0xDB05             BLT.N    ??RTC_SetTime_11
   \   000000DA   0xF240 0x311F      MOVW     R1,#+799
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   000000E2   0x.... 0x....      BL       assert_failed
    800              }
    801              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
   \                     ??RTC_SetTime_11: (+1)
   \   000000E6   0x7860             LDRB     R0,[R4, #+1]
   \   000000E8   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   000000EC   0x283C             CMP      R0,#+60
   \   000000EE   0xDB05             BLT.N    ??RTC_SetTime_12
   \   000000F0   0xF240 0x3121      MOVW     R1,#+801
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   000000F8   0x.... 0x....      BL       assert_failed
    802              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
   \                     ??RTC_SetTime_12: (+1)
   \   000000FC   0x78A0             LDRB     R0,[R4, #+2]
   \   000000FE   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000102   0x283C             CMP      R0,#+60
   \   00000104   0xDB05             BLT.N    ??RTC_SetTime_7
   \   00000106   0xF240 0x3122      MOVW     R1,#+802
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   0000010E   0x.... 0x....      BL       assert_failed
    803            }
    804            
    805            /* Check the input parameters format */
    806            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetTime_7: (+1)
   \   00000112   0x7820             LDRB     R0,[R4, #+0]
   \   00000114   0x2F00             CMP      R7,#+0
   \   00000116   0xD009             BEQ.N    ??RTC_SetTime_13
    807            {
    808              tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
    809                       ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
    810                       ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
    811                       ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
   \   00000118   0x7861             LDRB     R1,[R4, #+1]
   \   0000011A   0x0209             LSLS     R1,R1,#+8
   \   0000011C   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   00000120   0x78A1             LDRB     R1,[R4, #+2]
   \   00000122   0x4308             ORRS     R0,R1,R0
   \   00000124   0x78E1             LDRB     R1,[R4, #+3]
   \   00000126   0xEA40 0x4401      ORR      R4,R0,R1, LSL #+16
   \   0000012A   0xE011             B.N      ??RTC_SetTime_14
    812            }  
    813            else
    814            {
    815              tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
    816                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
    817                             ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
    818                             (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
   \                     ??RTC_SetTime_13: (+1)
   \   0000012C   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   00000130   0x4607             MOV      R7,R0
   \   00000132   0x7860             LDRB     R0,[R4, #+1]
   \   00000134   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   00000138   0x4680             MOV      R8,R0
   \   0000013A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000013C   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   00000140   0xEA4F 0x2108      LSL      R1,R8,#+8
   \   00000144   0xEA41 0x4107      ORR      R1,R1,R7, LSL #+16
   \   00000148   0x4308             ORRS     R0,R0,R1
   \   0000014A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000014C   0xEA40 0x4401      ORR      R4,R0,R1, LSL #+16
    819            }  
    820          
    821            /* Disable the write protection for RTC registers */
    822            RTC->WPR = 0xCA;
   \                     ??RTC_SetTime_14: (+1)
   \   00000150   0x20CA             MOVS     R0,#+202
   \   00000152   0x6270             STR      R0,[R6, #+36]
    823            RTC->WPR = 0x53;
   \   00000154   0x2053             MOVS     R0,#+83
   \   00000156   0x6270             STR      R0,[R6, #+36]
    824          
    825            /* Set Initialization mode */
    826            if (RTC_EnterInitMode() == ERROR)
   \   00000158   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000015C   0x2800             CMP      R0,#+0
   \   0000015E   0xD00F             BEQ.N    ??RTC_SetTime_15
    827            {
    828              status = ERROR;
    829            } 
    830            else
    831            {
    832              /* Set the RTC_TR register */
    833              RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable40  ;; 0x7f7f7f
   \   00000164   0x4020             ANDS     R0,R0,R4
   \   00000166   0x6030             STR      R0,[R6, #+0]
    834          
    835              /* Exit Initialization mode */
    836              RTC_ExitInitMode(); 
   \   00000168   0x.... 0x....      BL       RTC_ExitInitMode
    837          
    838              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    839              if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
   \   0000016C   0x68B0             LDR      R0,[R6, #+8]
   \   0000016E   0x0680             LSLS     R0,R0,#+26
   \   00000170   0xD405             BMI.N    ??RTC_SetTime_16
    840              {
    841              if(RTC_WaitForSynchro() == ERROR)
   \   00000172   0x.... 0x....      BL       RTC_WaitForSynchro
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD002             BEQ.N    ??RTC_SetTime_15
    842              {
    843                status = ERROR;
    844              }
    845              else
    846              {
    847                status = SUCCESS;
   \   0000017A   0x2501             MOVS     R5,#+1
   \   0000017C   0xE000             B.N      ??RTC_SetTime_15
    848              }
    849            }
    850              else
    851              {
    852                status = SUCCESS;
   \                     ??RTC_SetTime_16: (+1)
   \   0000017E   0x2501             MOVS     R5,#+1
    853              }
    854            }
    855            /* Enable the write protection for RTC registers */
    856            RTC->WPR = 0xFF; 
   \                     ??RTC_SetTime_15: (+1)
   \   00000180   0x20FF             MOVS     R0,#+255
   \   00000182   0x6270             STR      R0,[R6, #+36]
    857              
    858            return status;
   \   00000184   0x4628             MOV      R0,R5
   \   00000186   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    859          }
    860          
    861          /**
    862            * @brief  Fills each RTC_TimeStruct member with its default value
    863            *         (Time = 00h:00min:00sec).
    864            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
    865            *         initialized.
    866            * @retval None
    867            */

   \                                 In section .text, align 2, keep-with-next
    868          void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
    869          {
    870            /* Time = 00h:00min:00sec */
    871            RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   \                     RTC_TimeStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x70C1             STRB     R1,[R0, #+3]
    872            RTC_TimeStruct->RTC_Hours = 0;
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    873            RTC_TimeStruct->RTC_Minutes = 0;
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    874            RTC_TimeStruct->RTC_Seconds = 0; 
   \   00000008   0x7081             STRB     R1,[R0, #+2]
    875          }
   \   0000000A   0x4770             BX       LR               ;; return
    876          
    877          /**
    878            * @brief  Get the RTC current Time.
    879            * @param  RTC_Format: specifies the format of the returned parameters.
    880            *          This parameter can be  one of the following values:
    881            *            @arg RTC_Format_BIN:  Binary data format 
    882            *            @arg RTC_Format_BCD:  BCD data format
    883            * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
    884            *                        contain the returned current time configuration.     
    885            * @retval None
    886            */

   \                                 In section .text, align 2, keep-with-next
    887          void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
    888          {
   \                     RTC_GetTime: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    889            uint32_t tmpreg = 0;
    890          
    891            /* Check the parameters */
    892            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??RTC_GetTime_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD005             BEQ.N    ??RTC_GetTime_0
   \   0000000E   0xF44F 0x715F      MOV      R1,#+892
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000016   0x.... 0x....      BL       assert_failed
    893          
    894            /* Get the RTC_TR register */
    895            tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
   \                     ??RTC_GetTime_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable27  ;; 0x40002800
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable40  ;; 0x7f7f7f
   \   00000024   0x4008             ANDS     R0,R1,R0
   \   00000026   0x0C01             LSRS     R1,R0,#+16
   \   00000028   0xF001 0x023F      AND      R2,R1,#0x3F
   \   0000002C   0x702A             STRB     R2,[R5, #+0]
    896            
    897            /* Fill the structure fields with the read parameters */
    898            RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
    899            RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
   \   0000002E   0x0A02             LSRS     R2,R0,#+8
   \   00000030   0xF002 0x027F      AND      R2,R2,#0x7F
   \   00000034   0x706A             STRB     R2,[R5, #+1]
    900            RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
   \   00000036   0xF000 0x007F      AND      R0,R0,#0x7F
   \   0000003A   0x70A8             STRB     R0,[R5, #+2]
    901            RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
   \   0000003C   0xF001 0x0040      AND      R0,R1,#0x40
   \   00000040   0x70E8             STRB     R0,[R5, #+3]
    902          
    903            /* Check the input parameters format */
    904            if (RTC_Format == RTC_Format_BIN)
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD10B             BNE.N    ??RTC_GetTime_1
    905            {
    906              /* Convert the structure parameters to Binary format */
    907              RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
   \   00000046   0x7828             LDRB     R0,[R5, #+0]
   \   00000048   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000004C   0x7028             STRB     R0,[R5, #+0]
    908              RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
   \   0000004E   0x7868             LDRB     R0,[R5, #+1]
   \   00000050   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000054   0x7068             STRB     R0,[R5, #+1]
    909              RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
   \   00000056   0x78A8             LDRB     R0,[R5, #+2]
   \   00000058   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000005C   0x70A8             STRB     R0,[R5, #+2]
    910            }
    911          }
   \                     ??RTC_GetTime_1: (+1)
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    912          
    913          /**
    914            * @brief  Gets the RTC current Calendar Sub seconds value.
    915            * @note   This function freeze the Time and Date registers after reading the 
    916            *         SSR register.
    917            * @param  None
    918            * @retval RTC current Calendar Sub seconds value.
    919            */

   \                                 In section .text, align 2, keep-with-next
    920          uint32_t RTC_GetSubSecond(void)
    921          {
    922            uint32_t tmpreg = 0;
    923            
    924            /* Get sub seconds values from the correspondent registers*/
    925            tmpreg = (uint32_t)(RTC->SSR);
   \                     RTC_GetSubSecond: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable41  ;; 0x40002828
   \   00000004   0x6800             LDR      R0,[R0, #+0]
    926            
    927            /* Read DR register to unfroze calendar registers */
    928            (void) (RTC->DR);
    929            
    930            return (tmpreg);
   \   00000006   0x4770             BX       LR               ;; return
    931          }
    932          
    933          /**
    934            * @brief  Set the RTC current date.
    935            * @param  RTC_Format: specifies the format of the entered parameters.
    936            *          This parameter can be  one of the following values:
    937            *            @arg RTC_Format_BIN:  Binary data format 
    938            *            @arg RTC_Format_BCD:  BCD data format
    939            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure that contains 
    940            *                         the date configuration information for the RTC.
    941            * @retval An ErrorStatus enumeration value:
    942            *          - SUCCESS: RTC Date register is configured
    943            *          - ERROR: RTC Date register is not configured
    944            */

   \                                 In section .text, align 2, keep-with-next
    945          ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
    946          {
   \                     RTC_SetDate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
    947            uint32_t tmpreg = 0;
    948            ErrorStatus status = ERROR;
   \   00000006   0x2400             MOVS     R4,#+0
    949            
    950            /* Check the parameters */
    951            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000008   0x.... 0x....      LDR.W    R7,??DataTable29_1
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD006             BEQ.N    ??RTC_SetDate_0
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xD004             BEQ.N    ??RTC_SetDate_0
   \   00000014   0xF240 0x31B7      MOVW     R1,#+951
   \   00000018   0x4638             MOV      R0,R7
   \   0000001A   0x.... 0x....      BL       assert_failed
    952          
    953            if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
   \                     ??RTC_SetDate_0: (+1)
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD106             BNE.N    ??RTC_SetDate_1
   \   00000022   0x7868             LDRB     R0,[R5, #+1]
   \   00000024   0x06C1             LSLS     R1,R0,#+27
   \   00000026   0xD503             BPL.N    ??RTC_SetDate_1
    954            {
    955              RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
   \   00000028   0xF000 0x00EF      AND      R0,R0,#0xEF
   \   0000002C   0x300A             ADDS     R0,R0,#+10
   \   0000002E   0x7068             STRB     R0,[R5, #+1]
    956            }  
    957            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetDate_1: (+1)
   \   00000030   0x78E8             LDRB     R0,[R5, #+3]
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD11B             BNE.N    ??RTC_SetDate_2
    958            {
    959              assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
   \   00000036   0x2864             CMP      R0,#+100
   \   00000038   0xDB04             BLT.N    ??RTC_SetDate_3
   \   0000003A   0xF240 0x31BF      MOVW     R1,#+959
   \   0000003E   0x4638             MOV      R0,R7
   \   00000040   0x.... 0x....      BL       assert_failed
    960              assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
   \                     ??RTC_SetDate_3: (+1)
   \   00000044   0x7868             LDRB     R0,[R5, #+1]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD001             BEQ.N    ??RTC_SetDate_4
   \   0000004A   0x280D             CMP      R0,#+13
   \   0000004C   0xDB04             BLT.N    ??RTC_SetDate_5
   \                     ??RTC_SetDate_4: (+1)
   \   0000004E   0xF44F 0x7170      MOV      R1,#+960
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0x.... 0x....      BL       assert_failed
    961              assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
   \                     ??RTC_SetDate_5: (+1)
   \   00000058   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ.N    ??RTC_SetDate_6
   \   0000005E   0x2820             CMP      R0,#+32
   \   00000060   0xDB26             BLT.N    ??RTC_SetDate_7
   \                     ??RTC_SetDate_6: (+1)
   \   00000062   0xF240 0x31C1      MOVW     R1,#+961
   \   00000066   0x4638             MOV      R0,R7
   \   00000068   0x.... 0x....      BL       assert_failed
   \   0000006C   0xE020             B.N      ??RTC_SetDate_7
    962            }
    963            else
    964            {
    965              assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
   \                     ??RTC_SetDate_2: (+1)
   \   0000006E   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000072   0x2864             CMP      R0,#+100
   \   00000074   0xDB04             BLT.N    ??RTC_SetDate_8
   \   00000076   0xF240 0x31C5      MOVW     R1,#+965
   \   0000007A   0x4638             MOV      R0,R7
   \   0000007C   0x.... 0x....      BL       assert_failed
    966              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \                     ??RTC_SetDate_8: (+1)
   \   00000080   0x7868             LDRB     R0,[R5, #+1]
   \   00000082   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
    967              assert_param(IS_RTC_MONTH(tmpreg));
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD001             BEQ.N    ??RTC_SetDate_9
   \   0000008A   0x280D             CMP      R0,#+13
   \   0000008C   0xD304             BCC.N    ??RTC_SetDate_10
   \                     ??RTC_SetDate_9: (+1)
   \   0000008E   0xF240 0x31C7      MOVW     R1,#+967
   \   00000092   0x4638             MOV      R0,R7
   \   00000094   0x.... 0x....      BL       assert_failed
    968              tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \                     ??RTC_SetDate_10: (+1)
   \   00000098   0x78A8             LDRB     R0,[R5, #+2]
   \   0000009A   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
    969              assert_param(IS_RTC_DATE(tmpreg));
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD001             BEQ.N    ??RTC_SetDate_11
   \   000000A2   0x2820             CMP      R0,#+32
   \   000000A4   0xD304             BCC.N    ??RTC_SetDate_7
   \                     ??RTC_SetDate_11: (+1)
   \   000000A6   0xF240 0x31C9      MOVW     R1,#+969
   \   000000AA   0x4638             MOV      R0,R7
   \   000000AC   0x.... 0x....      BL       assert_failed
    970            }
    971            assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
   \                     ??RTC_SetDate_7: (+1)
   \   000000B0   0x7828             LDRB     R0,[R5, #+0]
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD010             BEQ.N    ??RTC_SetDate_12
   \   000000B6   0x2802             CMP      R0,#+2
   \   000000B8   0xD00E             BEQ.N    ??RTC_SetDate_12
   \   000000BA   0x2803             CMP      R0,#+3
   \   000000BC   0xD00C             BEQ.N    ??RTC_SetDate_12
   \   000000BE   0x2804             CMP      R0,#+4
   \   000000C0   0xD00A             BEQ.N    ??RTC_SetDate_12
   \   000000C2   0x2805             CMP      R0,#+5
   \   000000C4   0xD008             BEQ.N    ??RTC_SetDate_12
   \   000000C6   0x2806             CMP      R0,#+6
   \   000000C8   0xD006             BEQ.N    ??RTC_SetDate_12
   \   000000CA   0x2807             CMP      R0,#+7
   \   000000CC   0xD004             BEQ.N    ??RTC_SetDate_12
   \   000000CE   0xF240 0x31CB      MOVW     R1,#+971
   \   000000D2   0x4638             MOV      R0,R7
   \   000000D4   0x.... 0x....      BL       assert_failed
    972          
    973            /* Check the input parameters format */
    974            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetDate_12: (+1)
   \   000000D8   0x78E8             LDRB     R0,[R5, #+3]
   \   000000DA   0x2E00             CMP      R6,#+0
   \   000000DC   0xD009             BEQ.N    ??RTC_SetDate_13
    975            {
    976              tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
    977                        (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
    978                        ((uint32_t)RTC_DateStruct->RTC_Date) | \
    979                        (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
   \   000000DE   0x7869             LDRB     R1,[R5, #+1]
   \   000000E0   0x0209             LSLS     R1,R1,#+8
   \   000000E2   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   000000E6   0x78A9             LDRB     R1,[R5, #+2]
   \   000000E8   0x4308             ORRS     R0,R1,R0
   \   000000EA   0x7829             LDRB     R1,[R5, #+0]
   \   000000EC   0xEA40 0x3641      ORR      R6,R0,R1, LSL #+13
   \   000000F0   0xE010             B.N      ??RTC_SetDate_14
    980            }  
    981            else
    982            {
    983              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
    984                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
    985                        ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
    986                        ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
   \                     ??RTC_SetDate_13: (+1)
   \   000000F2   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   000000F6   0x4606             MOV      R6,R0
   \   000000F8   0x7868             LDRB     R0,[R5, #+1]
   \   000000FA   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   000000FE   0x4607             MOV      R7,R0
   \   00000100   0x78A8             LDRB     R0,[R5, #+2]
   \   00000102   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   00000106   0x0239             LSLS     R1,R7,#+8
   \   00000108   0xEA41 0x4106      ORR      R1,R1,R6, LSL #+16
   \   0000010C   0x4308             ORRS     R0,R0,R1
   \   0000010E   0x7829             LDRB     R1,[R5, #+0]
   \   00000110   0xEA40 0x3641      ORR      R6,R0,R1, LSL #+13
    987            }
    988          
    989            /* Disable the write protection for RTC registers */
    990            RTC->WPR = 0xCA;
   \                     ??RTC_SetDate_14: (+1)
   \   00000114   0x.... 0x....      LDR.W    R5,??DataTable45  ;; 0x40002804
   \   00000118   0x20CA             MOVS     R0,#+202
   \   0000011A   0x6228             STR      R0,[R5, #+32]
    991            RTC->WPR = 0x53;
   \   0000011C   0x2053             MOVS     R0,#+83
   \   0000011E   0x6228             STR      R0,[R5, #+32]
    992          
    993            /* Set Initialization mode */
    994            if (RTC_EnterInitMode() == ERROR)
   \   00000120   0x.... 0x....      BL       RTC_EnterInitMode
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD00F             BEQ.N    ??RTC_SetDate_15
    995            {
    996              status = ERROR;
    997            } 
    998            else
    999            {
   1000              /* Set the RTC_DR register */
   1001              RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable45_1  ;; 0xffff3f
   \   0000012C   0x4030             ANDS     R0,R0,R6
   \   0000012E   0x6028             STR      R0,[R5, #+0]
   1002          
   1003              /* Exit Initialization mode */
   1004              RTC_ExitInitMode(); 
   \   00000130   0x.... 0x....      BL       RTC_ExitInitMode
   1005          
   1006              /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
   1007              if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
   \   00000134   0x6868             LDR      R0,[R5, #+4]
   \   00000136   0x0680             LSLS     R0,R0,#+26
   \   00000138   0xD405             BMI.N    ??RTC_SetDate_16
   1008              {
   1009              if(RTC_WaitForSynchro() == ERROR)
   \   0000013A   0x.... 0x....      BL       RTC_WaitForSynchro
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD002             BEQ.N    ??RTC_SetDate_15
   1010              {
   1011                status = ERROR;
   1012              }
   1013              else
   1014              {
   1015                status = SUCCESS;
   \   00000142   0x2401             MOVS     R4,#+1
   \   00000144   0xE000             B.N      ??RTC_SetDate_15
   1016              }
   1017            }
   1018              else
   1019              {
   1020                status = SUCCESS;
   \                     ??RTC_SetDate_16: (+1)
   \   00000146   0x2401             MOVS     R4,#+1
   1021              }
   1022            }
   1023            /* Enable the write protection for RTC registers */
   1024            RTC->WPR = 0xFF;   
   \                     ??RTC_SetDate_15: (+1)
   \   00000148   0x20FF             MOVS     R0,#+255
   \   0000014A   0x6228             STR      R0,[R5, #+32]
   1025            
   1026            return status;
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1027          }
   1028          
   1029          /**
   1030            * @brief  Fills each RTC_DateStruct member with its default value
   1031            *         (Monday, January 01 xx00).
   1032            * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
   1033            *         initialized.
   1034            * @retval None
   1035            */

   \                                 In section .text, align 2, keep-with-next
   1036          void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
   1037          {
   1038            /* Monday, January 01 xx00 */
   1039            RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   \                     RTC_DateStructInit: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   1040            RTC_DateStruct->RTC_Date = 1;
   \   00000004   0x7081             STRB     R1,[R0, #+2]
   1041            RTC_DateStruct->RTC_Month = RTC_Month_January;
   \   00000006   0x7041             STRB     R1,[R0, #+1]
   1042            RTC_DateStruct->RTC_Year = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x70C1             STRB     R1,[R0, #+3]
   1043          }
   \   0000000C   0x4770             BX       LR               ;; return
   1044          
   1045          /**
   1046            * @brief  Get the RTC current date. 
   1047            * @param  RTC_Format: specifies the format of the returned parameters.
   1048            *          This parameter can be one of the following values:
   1049            *            @arg RTC_Format_BIN: Binary data format 
   1050            *            @arg RTC_Format_BCD: BCD data format
   1051            * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
   1052            *                        contain the returned current date configuration.     
   1053            * @retval None
   1054            */

   \                                 In section .text, align 2, keep-with-next
   1055          void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
   1056          {
   \                     RTC_GetDate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1057            uint32_t tmpreg = 0;
   1058          
   1059            /* Check the parameters */
   1060            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??RTC_GetDate_0
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD005             BEQ.N    ??RTC_GetDate_0
   \   0000000E   0xF240 0x4124      MOVW     R1,#+1060
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable29_1
   \   00000016   0x.... 0x....      BL       assert_failed
   1061            
   1062            /* Get the RTC_TR register */
   1063            tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
   \                     ??RTC_GetDate_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable45  ;; 0x40002804
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable45_1  ;; 0xffff3f
   \   00000024   0x4008             ANDS     R0,R1,R0
   1064          
   1065            /* Fill the structure fields with the read parameters */
   1066            RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
   \   00000026   0x0C01             LSRS     R1,R0,#+16
   \   00000028   0x70E9             STRB     R1,[R5, #+3]
   1067            RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   0000002A   0x0A01             LSRS     R1,R0,#+8
   \   0000002C   0xF001 0x011F      AND      R1,R1,#0x1F
   \   00000030   0x7069             STRB     R1,[R5, #+1]
   1068            RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
   \   00000032   0xF000 0x013F      AND      R1,R0,#0x3F
   \   00000036   0x70A9             STRB     R1,[R5, #+2]
   1069            RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
   \   00000038   0x0B40             LSRS     R0,R0,#+13
   \   0000003A   0xF000 0x0007      AND      R0,R0,#0x7
   \   0000003E   0x7028             STRB     R0,[R5, #+0]
   1070          
   1071            /* Check the input parameters format */
   1072            if (RTC_Format == RTC_Format_BIN)
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD10B             BNE.N    ??RTC_GetDate_1
   1073            {
   1074              /* Convert the structure parameters to Binary format */
   1075              RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
   \   00000044   0x78E8             LDRB     R0,[R5, #+3]
   \   00000046   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000004A   0x70E8             STRB     R0,[R5, #+3]
   1076              RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
   \   0000004C   0x7868             LDRB     R0,[R5, #+1]
   \   0000004E   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000052   0x7068             STRB     R0,[R5, #+1]
   1077              RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
   \   00000054   0x78A8             LDRB     R0,[R5, #+2]
   \   00000056   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000005A   0x70A8             STRB     R0,[R5, #+2]
   1078            }
   1079          }
   \                     ??RTC_GetDate_1: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1080          
   1081          /**
   1082            * @}
   1083            */
   1084          
   1085          /** @defgroup RTC_Group3 Alarms configuration functions
   1086           *  @brief   Alarms (Alarm A and Alarm B) configuration functions 
   1087           *
   1088          @verbatim   
   1089           ===============================================================================
   1090                   ##### Alarms A and B configuration functions #####
   1091           ===============================================================================  
   1092           
   1093           [..] This section provide functions allowing to program and read the RTC Alarms.
   1094          
   1095          @endverbatim
   1096            * @{
   1097            */
   1098          
   1099          /**
   1100            * @brief  Set the specified RTC Alarm.
   1101            * @note   The Alarm register can only be written when the corresponding Alarm
   1102            *         is disabled (Use the RTC_AlarmCmd(DISABLE)).    
   1103            * @param  RTC_Format: specifies the format of the returned parameters.
   1104            *          This parameter can be one of the following values:
   1105            *            @arg RTC_Format_BIN: Binary data format 
   1106            *            @arg RTC_Format_BCD: BCD data format
   1107            * @param  RTC_Alarm: specifies the alarm to be configured.
   1108            *          This parameter can be one of the following values:
   1109            *            @arg RTC_Alarm_A: to select Alarm A
   1110            *            @arg RTC_Alarm_B: to select Alarm B  
   1111            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
   1112            *                          contains the alarm configuration parameters.     
   1113            * @retval None
   1114            */

   \                                 In section .text, align 2, keep-with-next
   1115          void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1116          {
   \                     RTC_SetAlarm: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
   1117            uint32_t tmpreg = 0;
   1118            
   1119            /* Check the parameters */
   1120            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable29_1
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD006             BEQ.N    ??RTC_SetAlarm_0
   \   00000012   0x2F01             CMP      R7,#+1
   \   00000014   0xD004             BEQ.N    ??RTC_SetAlarm_0
   \   00000016   0xF44F 0x618C      MOV      R1,#+1120
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       assert_failed
   1121            assert_param(IS_RTC_ALARM(RTC_Alarm));
   \                     ??RTC_SetAlarm_0: (+1)
   \   00000020   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000024   0xD007             BEQ.N    ??RTC_SetAlarm_1
   \   00000026   0xF5B4 0x7F00      CMP      R4,#+512
   \   0000002A   0xD004             BEQ.N    ??RTC_SetAlarm_1
   \   0000002C   0xF240 0x4161      MOVW     R1,#+1121
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0x.... 0x....      BL       assert_failed
   1122            assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
   \                     ??RTC_SetAlarm_1: (+1)
   \   00000036   0x6868             LDR      R0,[R5, #+4]
   \   00000038   0xF010 0x3F7F      TST      R0,#0x7F7F7F7F
   \   0000003C   0xD004             BEQ.N    ??RTC_SetAlarm_2
   \   0000003E   0xF240 0x4162      MOVW     R1,#+1122
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0x.... 0x....      BL       assert_failed
   1123            assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
   \                     ??RTC_SetAlarm_2: (+1)
   \   00000048   0x68A8             LDR      R0,[R5, #+8]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD007             BEQ.N    ??RTC_SetAlarm_3
   \   0000004E   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   00000052   0xD004             BEQ.N    ??RTC_SetAlarm_3
   \   00000054   0xF240 0x4163      MOVW     R1,#+1123
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x.... 0x....      BL       assert_failed
   1124          
   1125            if (RTC_Format == RTC_Format_BIN)
   \                     ??RTC_SetAlarm_3: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R6,??DataTable30  ;; 0x40002808
   \   00000062   0x2F00             CMP      R7,#+0
   \   00000064   0x6830             LDR      R0,[R6, #+0]
   \   00000066   0xD152             BNE.N    ??RTC_SetAlarm_4
   1126            {
   1127              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \   00000068   0x0640             LSLS     R0,R0,#+25
   \   0000006A   0xD514             BPL.N    ??RTC_SetAlarm_5
   1128              {
   1129                assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   \   0000006C   0x7828             LDRB     R0,[R5, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD001             BEQ.N    ??RTC_SetAlarm_6
   \   00000072   0x280D             CMP      R0,#+13
   \   00000074   0xDB04             BLT.N    ??RTC_SetAlarm_7
   \                     ??RTC_SetAlarm_6: (+1)
   \   00000076   0xF240 0x4169      MOVW     R1,#+1129
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       assert_failed
   1130                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \                     ??RTC_SetAlarm_7: (+1)
   \   00000080   0x78E8             LDRB     R0,[R5, #+3]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD011             BEQ.N    ??RTC_SetAlarm_8
   \   00000086   0x2840             CMP      R0,#+64
   \   00000088   0xD00F             BEQ.N    ??RTC_SetAlarm_8
   \   0000008A   0xF240 0x416A      MOVW     R1,#+1130
   \   0000008E   0x4640             MOV      R0,R8
   \   00000090   0x.... 0x....      BL       assert_failed
   \   00000094   0xE009             B.N      ??RTC_SetAlarm_8
   1131              } 
   1132              else
   1133              {
   1134                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_5: (+1)
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x70E8             STRB     R0,[R5, #+3]
   1135                assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
   \   0000009A   0x7828             LDRB     R0,[R5, #+0]
   \   0000009C   0x2818             CMP      R0,#+24
   \   0000009E   0xDB04             BLT.N    ??RTC_SetAlarm_8
   \   000000A0   0xF240 0x416F      MOVW     R1,#+1135
   \   000000A4   0x4640             MOV      R0,R8
   \   000000A6   0x.... 0x....      BL       assert_failed
   1136              }
   1137              assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
   \                     ??RTC_SetAlarm_8: (+1)
   \   000000AA   0x7868             LDRB     R0,[R5, #+1]
   \   000000AC   0x283C             CMP      R0,#+60
   \   000000AE   0xDB04             BLT.N    ??RTC_SetAlarm_9
   \   000000B0   0xF240 0x4171      MOVW     R1,#+1137
   \   000000B4   0x4640             MOV      R0,R8
   \   000000B6   0x.... 0x....      BL       assert_failed
   1138              assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
   \                     ??RTC_SetAlarm_9: (+1)
   \   000000BA   0x78A8             LDRB     R0,[R5, #+2]
   \   000000BC   0x283C             CMP      R0,#+60
   \   000000BE   0xDB04             BLT.N    ??RTC_SetAlarm_10
   \   000000C0   0xF240 0x4172      MOVW     R1,#+1138
   \   000000C4   0x4640             MOV      R0,R8
   \   000000C6   0x.... 0x....      BL       assert_failed
   1139              
   1140              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_10: (+1)
   \   000000CA   0x7B28             LDRB     R0,[R5, #+12]
   \   000000CC   0x68A9             LDR      R1,[R5, #+8]
   \   000000CE   0x2900             CMP      R1,#+0
   \   000000D0   0xD109             BNE.N    ??RTC_SetAlarm_11
   1141              {
   1142                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD001             BEQ.N    ??RTC_SetAlarm_12
   \   000000D6   0x2820             CMP      R0,#+32
   \   000000D8   0xDB77             BLT.N    ??RTC_SetAlarm_13
   \                     ??RTC_SetAlarm_12: (+1)
   \   000000DA   0xF240 0x4176      MOVW     R1,#+1142
   \   000000DE   0x4640             MOV      R0,R8
   \   000000E0   0x.... 0x....      BL       assert_failed
   \   000000E4   0xE071             B.N      ??RTC_SetAlarm_13
   1143              }
   1144              else
   1145              {
   1146                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
   \                     ??RTC_SetAlarm_11: (+1)
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD06F             BEQ.N    ??RTC_SetAlarm_13
   \   000000EA   0x2802             CMP      R0,#+2
   \   000000EC   0xD06D             BEQ.N    ??RTC_SetAlarm_13
   \   000000EE   0x2803             CMP      R0,#+3
   \   000000F0   0xD06B             BEQ.N    ??RTC_SetAlarm_13
   \   000000F2   0x2804             CMP      R0,#+4
   \   000000F4   0xD069             BEQ.N    ??RTC_SetAlarm_13
   \   000000F6   0x2805             CMP      R0,#+5
   \   000000F8   0xD067             BEQ.N    ??RTC_SetAlarm_13
   \   000000FA   0x2806             CMP      R0,#+6
   \   000000FC   0xD065             BEQ.N    ??RTC_SetAlarm_13
   \   000000FE   0x2807             CMP      R0,#+7
   \   00000100   0xD063             BEQ.N    ??RTC_SetAlarm_13
   \   00000102   0xF240 0x417A      MOVW     R1,#+1146
   \   00000106   0x4640             MOV      R0,R8
   \   00000108   0x.... 0x....      BL       assert_failed
   \   0000010C   0xE05D             B.N      ??RTC_SetAlarm_13
   1147              }
   1148            }
   1149            else
   1150            {
   1151              if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
   \                     ??RTC_SetAlarm_4: (+1)
   \   0000010E   0x0640             LSLS     R0,R0,#+25
   \   00000110   0xD516             BPL.N    ??RTC_SetAlarm_14
   1152              {
   1153                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
   \   00000112   0x7828             LDRB     R0,[R5, #+0]
   \   00000114   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   1154                assert_param(IS_RTC_HOUR12(tmpreg));
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD001             BEQ.N    ??RTC_SetAlarm_15
   \   0000011C   0x280D             CMP      R0,#+13
   \   0000011E   0xD304             BCC.N    ??RTC_SetAlarm_16
   \                     ??RTC_SetAlarm_15: (+1)
   \   00000120   0xF240 0x4182      MOVW     R1,#+1154
   \   00000124   0x4640             MOV      R0,R8
   \   00000126   0x.... 0x....      BL       assert_failed
   1155                assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
   \                     ??RTC_SetAlarm_16: (+1)
   \   0000012A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD013             BEQ.N    ??RTC_SetAlarm_17
   \   00000130   0x2840             CMP      R0,#+64
   \   00000132   0xD011             BEQ.N    ??RTC_SetAlarm_17
   \   00000134   0xF240 0x4183      MOVW     R1,#+1155
   \   00000138   0x4640             MOV      R0,R8
   \   0000013A   0x.... 0x....      BL       assert_failed
   \   0000013E   0xE00B             B.N      ??RTC_SetAlarm_17
   1156              } 
   1157              else
   1158              {
   1159                RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
   \                     ??RTC_SetAlarm_14: (+1)
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0x70E8             STRB     R0,[R5, #+3]
   1160                assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
   \   00000144   0x7828             LDRB     R0,[R5, #+0]
   \   00000146   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000014A   0x2818             CMP      R0,#+24
   \   0000014C   0xDB04             BLT.N    ??RTC_SetAlarm_17
   \   0000014E   0xF44F 0x6191      MOV      R1,#+1160
   \   00000152   0x4640             MOV      R0,R8
   \   00000154   0x.... 0x....      BL       assert_failed
   1161              }
   1162              
   1163              assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
   \                     ??RTC_SetAlarm_17: (+1)
   \   00000158   0x7868             LDRB     R0,[R5, #+1]
   \   0000015A   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000015E   0x283C             CMP      R0,#+60
   \   00000160   0xDB04             BLT.N    ??RTC_SetAlarm_18
   \   00000162   0xF240 0x418B      MOVW     R1,#+1163
   \   00000166   0x4640             MOV      R0,R8
   \   00000168   0x.... 0x....      BL       assert_failed
   1164              assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
   \                     ??RTC_SetAlarm_18: (+1)
   \   0000016C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000016E   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000172   0x283C             CMP      R0,#+60
   \   00000174   0xDB04             BLT.N    ??RTC_SetAlarm_19
   \   00000176   0xF240 0x418C      MOVW     R1,#+1164
   \   0000017A   0x4640             MOV      R0,R8
   \   0000017C   0x.... 0x....      BL       assert_failed
   1165              
   1166              if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
   \                     ??RTC_SetAlarm_19: (+1)
   \   00000180   0x7B28             LDRB     R0,[R5, #+12]
   \   00000182   0x68A9             LDR      R1,[R5, #+8]
   \   00000184   0x2900             CMP      R1,#+0
   \   00000186   0xD10B             BNE.N    ??RTC_SetAlarm_20
   1167              {
   1168                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   00000188   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   1169                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD001             BEQ.N    ??RTC_SetAlarm_21
   \   00000190   0x2820             CMP      R0,#+32
   \   00000192   0xD31A             BCC.N    ??RTC_SetAlarm_13
   \                     ??RTC_SetAlarm_21: (+1)
   \   00000194   0xF240 0x4191      MOVW     R1,#+1169
   \   00000198   0x4640             MOV      R0,R8
   \   0000019A   0x.... 0x....      BL       assert_failed
   \   0000019E   0xE014             B.N      ??RTC_SetAlarm_13
   1170              }
   1171              else
   1172              {
   1173                tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \                     ??RTC_SetAlarm_20: (+1)
   \   000001A0   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   1174                assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
   \   000001A4   0x2801             CMP      R0,#+1
   \   000001A6   0xD010             BEQ.N    ??RTC_SetAlarm_13
   \   000001A8   0x2802             CMP      R0,#+2
   \   000001AA   0xD00E             BEQ.N    ??RTC_SetAlarm_13
   \   000001AC   0x2803             CMP      R0,#+3
   \   000001AE   0xD00C             BEQ.N    ??RTC_SetAlarm_13
   \   000001B0   0x2804             CMP      R0,#+4
   \   000001B2   0xD00A             BEQ.N    ??RTC_SetAlarm_13
   \   000001B4   0x2805             CMP      R0,#+5
   \   000001B6   0xD008             BEQ.N    ??RTC_SetAlarm_13
   \   000001B8   0x2806             CMP      R0,#+6
   \   000001BA   0xD006             BEQ.N    ??RTC_SetAlarm_13
   \   000001BC   0x2807             CMP      R0,#+7
   \   000001BE   0xD004             BEQ.N    ??RTC_SetAlarm_13
   \   000001C0   0xF240 0x4196      MOVW     R1,#+1174
   \   000001C4   0x4640             MOV      R0,R8
   \   000001C6   0x.... 0x....      BL       assert_failed
   1175              }    
   1176            }
   1177          
   1178            /* Check the input parameters format */
   1179            if (RTC_Format != RTC_Format_BIN)
   \                     ??RTC_SetAlarm_13: (+1)
   \   000001CA   0x7828             LDRB     R0,[R5, #+0]
   \   000001CC   0x2F00             CMP      R7,#+0
   \   000001CE   0xD010             BEQ.N    ??RTC_SetAlarm_22
   1180            {
   1181              tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1182                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1183                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
   1184                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1185                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1186                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1187                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \   000001D0   0x7869             LDRB     R1,[R5, #+1]
   \   000001D2   0x0209             LSLS     R1,R1,#+8
   \   000001D4   0xEA41 0x4000      ORR      R0,R1,R0, LSL #+16
   \   000001D8   0x78A9             LDRB     R1,[R5, #+2]
   \   000001DA   0x4308             ORRS     R0,R1,R0
   \   000001DC   0x78E9             LDRB     R1,[R5, #+3]
   \   000001DE   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   000001E2   0x7B29             LDRB     R1,[R5, #+12]
   \   000001E4   0xEA40 0x6001      ORR      R0,R0,R1, LSL #+24
   \   000001E8   0x68A9             LDR      R1,[R5, #+8]
   \   000001EA   0x4308             ORRS     R0,R1,R0
   \   000001EC   0x6869             LDR      R1,[R5, #+4]
   \   000001EE   0x4308             ORRS     R0,R1,R0
   \   000001F0   0xE01B             B.N      ??RTC_SetAlarm_23
   1188            }  
   1189            else
   1190            {
   1191              tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
   1192                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
   1193                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
   1194                        ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
   1195                        ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
   1196                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
   1197                        ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
   \                     ??RTC_SetAlarm_22: (+1)
   \   000001F2   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   000001F6   0x4680             MOV      R8,R0
   \   000001F8   0x7868             LDRB     R0,[R5, #+1]
   \   000001FA   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   000001FE   0x4681             MOV      R9,R0
   \   00000200   0x78A8             LDRB     R0,[R5, #+2]
   \   00000202   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   00000206   0x4607             MOV      R7,R0
   \   00000208   0x7B28             LDRB     R0,[R5, #+12]
   \   0000020A   0x.... 0x....      BL       _Z14RTC_ByteToBcd2h
   \   0000020E   0xEA4F 0x2109      LSL      R1,R9,#+8
   \   00000212   0xEA41 0x4108      ORR      R1,R1,R8, LSL #+16
   \   00000216   0x4339             ORRS     R1,R7,R1
   \   00000218   0x78EA             LDRB     R2,[R5, #+3]
   \   0000021A   0xEA41 0x4102      ORR      R1,R1,R2, LSL #+16
   \   0000021E   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000222   0x68A9             LDR      R1,[R5, #+8]
   \   00000224   0x4308             ORRS     R0,R1,R0
   \   00000226   0x6869             LDR      R1,[R5, #+4]
   \   00000228   0x4308             ORRS     R0,R1,R0
   1198            } 
   1199          
   1200            /* Disable the write protection for RTC registers */
   1201            RTC->WPR = 0xCA;
   \                     ??RTC_SetAlarm_23: (+1)
   \   0000022A   0x21CA             MOVS     R1,#+202
   \   0000022C   0x61F1             STR      R1,[R6, #+28]
   1202            RTC->WPR = 0x53;
   \   0000022E   0x2153             MOVS     R1,#+83
   \   00000230   0x61F1             STR      R1,[R6, #+28]
   1203          
   1204            /* Configure the Alarm register */
   1205            if (RTC_Alarm == RTC_Alarm_A)
   \   00000232   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000236   0xD101             BNE.N    ??RTC_SetAlarm_24
   1206            {
   1207              RTC->ALRMAR = (uint32_t)tmpreg;
   \   00000238   0x6170             STR      R0,[R6, #+20]
   \   0000023A   0xE000             B.N      ??RTC_SetAlarm_25
   1208            }
   1209            else
   1210            {
   1211              RTC->ALRMBR = (uint32_t)tmpreg;
   \                     ??RTC_SetAlarm_24: (+1)
   \   0000023C   0x61B0             STR      R0,[R6, #+24]
   1212            }
   1213          
   1214            /* Enable the write protection for RTC registers */
   1215            RTC->WPR = 0xFF;   
   \                     ??RTC_SetAlarm_25: (+1)
   \   0000023E   0x20FF             MOVS     R0,#+255
   \   00000240   0x61F0             STR      R0,[R6, #+28]
   1216          }
   \   00000242   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1217          
   1218          /**
   1219            * @brief  Fills each RTC_AlarmStruct member with its default value
   1220            *         (Time = 00h:00mn:00sec / Date = 1st day of the month/Mask =
   1221            *         all fields are masked).
   1222            * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
   1223            *         will be initialized.
   1224            * @retval None
   1225            */

   \                                 In section .text, align 2, keep-with-next
   1226          void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
   1227          {
   1228            /* Alarm Time Settings : Time = 00h:00mn:00sec */
   1229            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   \                     RTC_AlarmStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x70C1             STRB     R1,[R0, #+3]
   1230            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
   \   00000004   0x7001             STRB     R1,[R0, #+0]
   1231            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
   \   00000006   0x7041             STRB     R1,[R0, #+1]
   1232            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
   \   00000008   0x7081             STRB     R1,[R0, #+2]
   1233          
   1234            /* Alarm Date Settings : Date = 1st day of the month */
   1235            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
   \   0000000A   0x6081             STR      R1,[R0, #+8]
   1236            RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7301             STRB     R1,[R0, #+12]
   1237          
   1238            /* Alarm Masks Settings : Mask =  all fields are not masked */
   1239            RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6041             STR      R1,[R0, #+4]
   1240          }
   \   00000014   0x4770             BX       LR               ;; return
   1241          
   1242          /**
   1243            * @brief  Get the RTC Alarm value and masks.
   1244            * @param  RTC_Format: specifies the format of the output parameters.
   1245            *          This parameter can be one of the following values:
   1246            *            @arg RTC_Format_BIN: Binary data format 
   1247            *            @arg RTC_Format_BCD: BCD data format
   1248            * @param  RTC_Alarm: specifies the alarm to be read.
   1249            *          This parameter can be one of the following values:
   1250            *            @arg RTC_Alarm_A: to select Alarm A
   1251            *            @arg RTC_Alarm_B: to select Alarm B  
   1252            * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
   1253            *                          contains the output alarm configuration values.     
   1254            * @retval None
   1255            */

   \                                 In section .text, align 2, keep-with-next
   1256          void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
   1257          {
   \                     RTC_GetAlarm: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   1258            uint32_t tmpreg = 0;
   1259          
   1260            /* Check the parameters */
   1261            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_GetAlarm_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_GetAlarm_0
   \   00000010   0xF240 0x41ED      MOVW     R1,#+1261
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1262            assert_param(IS_RTC_ALARM(RTC_Alarm)); 
   \                     ??RTC_GetAlarm_0: (+1)
   \   0000001C   0xF5B6 0x7F80      CMP      R6,#+256
   \   00000020   0xD008             BEQ.N    ??RTC_GetAlarm_1
   \   00000022   0xF5B6 0x7F00      CMP      R6,#+512
   \   00000026   0xD005             BEQ.N    ??RTC_GetAlarm_1
   \   00000028   0xF240 0x41EE      MOVW     R1,#+1262
   \   0000002C   0x.... 0x....      ADR.W    R0,?_0
   \   00000030   0x.... 0x....      BL       assert_failed
   1263          
   1264            /* Get the RTC_ALRMxR register */
   1265            if (RTC_Alarm == RTC_Alarm_A)
   \                     ??RTC_GetAlarm_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable51  ;; 0x4000281c
   \   00000038   0xF5B6 0x7F80      CMP      R6,#+256
   \   0000003C   0xD101             BNE.N    ??RTC_GetAlarm_2
   1266            {
   1267              tmpreg = (uint32_t)(RTC->ALRMAR);
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xE000             B.N      ??RTC_GetAlarm_3
   1268            }
   1269            else
   1270            {
   1271              tmpreg = (uint32_t)(RTC->ALRMBR);
   \                     ??RTC_GetAlarm_2: (+1)
   \   00000042   0x6840             LDR      R0,[R0, #+4]
   \                     ??RTC_GetAlarm_3: (+1)
   \   00000044   0x0C01             LSRS     R1,R0,#+16
   \   00000046   0xF001 0x023F      AND      R2,R1,#0x3F
   \   0000004A   0x702A             STRB     R2,[R5, #+0]
   1272            }
   1273          
   1274            /* Fill the structure with the read parameters */
   1275            RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
   1276                                                               RTC_ALRMAR_HU)) >> 16);
   1277            RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
   1278                                                               RTC_ALRMAR_MNU)) >> 8);
   \   0000004C   0x0A02             LSRS     R2,R0,#+8
   \   0000004E   0xF002 0x027F      AND      R2,R2,#0x7F
   \   00000052   0x706A             STRB     R2,[R5, #+1]
   1279            RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
   1280                                                               RTC_ALRMAR_SU));
   \   00000054   0xF000 0x027F      AND      R2,R0,#0x7F
   \   00000058   0x70AA             STRB     R2,[R5, #+2]
   1281            RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
   \   0000005A   0xF001 0x0140      AND      R1,R1,#0x40
   \   0000005E   0x70E9             STRB     R1,[R5, #+3]
   1282            RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
   \   00000060   0x0E01             LSRS     R1,R0,#+24
   \   00000062   0xF001 0x013F      AND      R1,R1,#0x3F
   \   00000066   0x7329             STRB     R1,[R5, #+12]
   1283            RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
   \   00000068   0xF000 0x4180      AND      R1,R0,#0x40000000
   \   0000006C   0x60A9             STR      R1,[R5, #+8]
   1284            RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
   \   0000006E   0xF020 0x307F      BIC      R0,R0,#0x7F7F7F7F
   \   00000072   0x6068             STR      R0,[R5, #+4]
   1285          
   1286            if (RTC_Format == RTC_Format_BIN)
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD10F             BNE.N    ??RTC_GetAlarm_4
   1287            {
   1288              RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1289                                                                  RTC_AlarmTime.RTC_Hours);
   \   00000078   0x7828             LDRB     R0,[R5, #+0]
   \   0000007A   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000007E   0x7028             STRB     R0,[R5, #+0]
   1290              RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1291                                                                  RTC_AlarmTime.RTC_Minutes);
   \   00000080   0x7868             LDRB     R0,[R5, #+1]
   \   00000082   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000086   0x7068             STRB     R0,[R5, #+1]
   1292              RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
   1293                                                                  RTC_AlarmTime.RTC_Seconds);
   \   00000088   0x78A8             LDRB     R0,[R5, #+2]
   \   0000008A   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000008E   0x70A8             STRB     R0,[R5, #+2]
   1294              RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
   \   00000090   0x7B28             LDRB     R0,[R5, #+12]
   \   00000092   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000096   0x7328             STRB     R0,[R5, #+12]
   1295            }  
   1296          }
   \                     ??RTC_GetAlarm_4: (+1)
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
   1297          
   1298          /**
   1299            * @brief  Enables or disables the specified RTC Alarm.
   1300            * @param  RTC_Alarm: specifies the alarm to be configured.
   1301            *          This parameter can be any combination of the following values:
   1302            *            @arg RTC_Alarm_A: to select Alarm A
   1303            *            @arg RTC_Alarm_B: to select Alarm B  
   1304            * @param  NewState: new state of the specified alarm.
   1305            *          This parameter can be: ENABLE or DISABLE.
   1306            * @retval An ErrorStatus enumeration value:
   1307            *          - SUCCESS: RTC Alarm is enabled/disabled
   1308            *          - ERROR: RTC Alarm is not enabled/disabled  
   1309            */

   \                                 In section .text, align 2, keep-with-next
   1310          ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
   1311          {
   \                     RTC_AlarmCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   1312            __IO uint32_t alarmcounter = 0x00;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   1313            uint32_t alarmstatus = 0x00;
   1314            ErrorStatus status = ERROR;
   \   0000000C   0x4605             MOV      R5,R0
   1315              
   1316            /* Check the parameters */
   1317            assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
   \   0000000E   0xF414 0x7F40      TST      R4,#0x300
   \   00000012   0xD105             BNE.N    ??RTC_AlarmCmd_0
   \   00000014   0xF240 0x5125      MOVW     R1,#+1317
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       assert_failed
   1318            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_AlarmCmd_0: (+1)
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD007             BEQ.N    ??RTC_AlarmCmd_1
   \   00000024   0x2E01             CMP      R6,#+1
   \   00000026   0xD005             BEQ.N    ??RTC_AlarmCmd_1
   \   00000028   0xF240 0x5126      MOVW     R1,#+1318
   \   0000002C   0x.... 0x....      ADR.W    R0,?_0
   \   00000030   0x.... 0x....      BL       assert_failed
   1319          
   1320            /* Disable the write protection for RTC registers */
   1321            RTC->WPR = 0xCA;
   \                     ??RTC_AlarmCmd_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   00000038   0x21CA             MOVS     R1,#+202
   \   0000003A   0x61C1             STR      R1,[R0, #+28]
   1322            RTC->WPR = 0x53;
   \   0000003C   0x2153             MOVS     R1,#+83
   \   0000003E   0x61C1             STR      R1,[R0, #+28]
   1323          
   1324            /* Configure the Alarm state */
   1325            if (NewState != DISABLE)
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0xD003             BEQ.N    ??RTC_AlarmCmd_2
   1326            {
   1327              RTC->CR |= (uint32_t)RTC_Alarm;
   \   00000046   0x4321             ORRS     R1,R4,R1
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1328          
   1329              status = SUCCESS;    
   \   0000004A   0x2501             MOVS     R5,#+1
   \   0000004C   0xE012             B.N      ??RTC_AlarmCmd_3
   1330            }
   1331            else
   1332            { 
   1333              /* Disable the Alarm in RTC_CR register */
   1334              RTC->CR &= (uint32_t)~RTC_Alarm;
   \                     ??RTC_AlarmCmd_2: (+1)
   \   0000004E   0x43A1             BICS     R1,R1,R4
   \   00000050   0x6001             STR      R1,[R0, #+0]
   1335             
   1336              /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
   1337              do
   1338              {
   1339                alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
   \                     ??RTC_AlarmCmd_4: (+1)
   \   00000052   0x6842             LDR      R2,[R0, #+4]
   \   00000054   0xEA12 0x2214      ANDS     R2,R2,R4, LSR #+8
   1340                alarmcounter++;  
   \   00000058   0x9B00             LDR      R3,[SP, #+0]
   \   0000005A   0x1C5B             ADDS     R3,R3,#+1
   \   0000005C   0x9300             STR      R3,[SP, #+0]
   1341              } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
   \   0000005E   0x9B00             LDR      R3,[SP, #+0]
   \   00000060   0xF5B3 0x3F80      CMP      R3,#+65536
   \   00000064   0xD001             BEQ.N    ??RTC_AlarmCmd_5
   \   00000066   0x2A00             CMP      R2,#+0
   \   00000068   0xD0F3             BEQ.N    ??RTC_AlarmCmd_4
   1342              
   1343              if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
   \                     ??RTC_AlarmCmd_5: (+1)
   \   0000006A   0x6842             LDR      R2,[R0, #+4]
   \   0000006C   0xEA12 0x2F14      TST      R2,R4, LSR #+8
   \   00000070   0xD000             BEQ.N    ??RTC_AlarmCmd_3
   1344              {
   1345                status = ERROR;
   1346              } 
   1347              else
   1348              {
   1349                status = SUCCESS;
   \   00000072   0x2501             MOVS     R5,#+1
   1350              }        
   1351            } 
   1352          
   1353            /* Enable the write protection for RTC registers */
   1354            RTC->WPR = 0xFF; 
   \                     ??RTC_AlarmCmd_3: (+1)
   \   00000074   0x21FF             MOVS     R1,#+255
   \   00000076   0x61C1             STR      R1,[R0, #+28]
   1355            
   1356            return status;
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1357          }
   1358          
   1359          /**
   1360            * @brief  Configure the RTC AlarmA/B Sub seconds value and mask.*
   1361            * @note   This function is performed only when the Alarm is disabled. 
   1362            * @param  RTC_Alarm: specifies the alarm to be configured.
   1363            *   This parameter can be one of the following values:
   1364            *     @arg RTC_Alarm_A: to select Alarm A
   1365            *     @arg RTC_Alarm_B: to select Alarm B
   1366            * @param  RTC_AlarmSubSecondValue: specifies the Sub seconds value.
   1367            *   This parameter can be a value from 0 to 0x00007FFF.
   1368            * @param  RTC_AlarmSubSecondMask:  specifies the Sub seconds Mask.
   1369            *   This parameter can be any combination of the following values:
   1370            *     @arg RTC_AlarmSubSecondMask_All    : All Alarm SS fields are masked.
   1371            *                                          There is no comparison on sub seconds for Alarm.
   1372            *     @arg RTC_AlarmSubSecondMask_SS14_1 : SS[14:1] are don't care in Alarm comparison.
   1373            *                                          Only SS[0] is compared
   1374            *     @arg RTC_AlarmSubSecondMask_SS14_2 : SS[14:2] are don't care in Alarm comparison.
   1375            *                                          Only SS[1:0] are compared
   1376            *     @arg RTC_AlarmSubSecondMask_SS14_3 : SS[14:3] are don't care in Alarm comparison.
   1377            *                                          Only SS[2:0] are compared
   1378            *     @arg RTC_AlarmSubSecondMask_SS14_4 : SS[14:4] are don't care in Alarm comparison.
   1379            *                                          Only SS[3:0] are compared
   1380            *     @arg RTC_AlarmSubSecondMask_SS14_5 : SS[14:5] are don't care in Alarm comparison.
   1381            *                                          Only SS[4:0] are compared
   1382            *     @arg RTC_AlarmSubSecondMask_SS14_6 : SS[14:6] are don't care in Alarm comparison.
   1383            *                                          Only SS[5:0] are compared
   1384            *     @arg RTC_AlarmSubSecondMask_SS14_7 : SS[14:7] are don't care in Alarm comparison.
   1385            *                                          Only SS[6:0] are compared
   1386            *     @arg RTC_AlarmSubSecondMask_SS14_8 : SS[14:8] are don't care in Alarm comparison.
   1387            *                                          Only SS[7:0] are compared
   1388            *     @arg RTC_AlarmSubSecondMask_SS14_9 : SS[14:9] are don't care in Alarm comparison.
   1389            *                                          Only SS[8:0] are compared
   1390            *     @arg RTC_AlarmSubSecondMask_SS14_10: SS[14:10] are don't care in Alarm comparison.
   1391            *                                          Only SS[9:0] are compared
   1392            *     @arg RTC_AlarmSubSecondMask_SS14_11: SS[14:11] are don't care in Alarm comparison.
   1393            *                                          Only SS[10:0] are compared
   1394            *     @arg RTC_AlarmSubSecondMask_SS14_12: SS[14:12] are don't care in Alarm comparison.
   1395            *                                          Only SS[11:0] are compared
   1396            *     @arg RTC_AlarmSubSecondMask_SS14_13: SS[14:13] are don't care in Alarm comparison.
   1397            *                                          Only SS[12:0] are compared
   1398            *     @arg RTC_AlarmSubSecondMask_SS14   : SS[14] is don't care in Alarm comparison.
   1399            *                                          Only SS[13:0] are compared
   1400            *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
   1401            *                                          to activate alarm
   1402            * @retval None
   1403            */

   \                                 In section .text, align 2, keep-with-next
   1404          void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
   1405          {
   \                     RTC_AlarmSubSecondConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1406            uint32_t tmpreg = 0;
   1407          
   1408            /* Check the parameters */
   1409            assert_param(IS_RTC_ALARM(RTC_Alarm));
   \   00000008   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000C   0xD008             BEQ.N    ??RTC_AlarmSubSecondConfig_0
   \   0000000E   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000012   0xD005             BEQ.N    ??RTC_AlarmSubSecondConfig_0
   \   00000014   0xF240 0x5181      MOVW     R1,#+1409
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       assert_failed
   1410            assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
   \                     ??RTC_AlarmSubSecondConfig_0: (+1)
   \   00000020   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000024   0xD305             BCC.N    ??RTC_AlarmSubSecondConfig_1
   \   00000026   0xF240 0x5182      MOVW     R1,#+1410
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1411            assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
   \                     ??RTC_AlarmSubSecondConfig_1: (+1)
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD032             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000036   0xF1B6 0x7F80      CMP      R6,#+16777216
   \   0000003A   0xD02F             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000003C   0xF1B6 0x7F00      CMP      R6,#+33554432
   \   00000040   0xD02C             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000042   0xF1B6 0x7F40      CMP      R6,#+50331648
   \   00000046   0xD029             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000048   0xF1B6 0x6F80      CMP      R6,#+67108864
   \   0000004C   0xD026             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000004E   0xF1B6 0x6FA0      CMP      R6,#+83886080
   \   00000052   0xD023             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000054   0xF1B6 0x6FC0      CMP      R6,#+100663296
   \   00000058   0xD020             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000005A   0xF1B6 0x6FE0      CMP      R6,#+117440512
   \   0000005E   0xD01D             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000060   0xF1B6 0x6F00      CMP      R6,#+134217728
   \   00000064   0xD01A             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000066   0xF1B6 0x6F10      CMP      R6,#+150994944
   \   0000006A   0xD017             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000006C   0xF1B6 0x6F20      CMP      R6,#+167772160
   \   00000070   0xD014             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000072   0xF1B6 0x6F30      CMP      R6,#+184549376
   \   00000076   0xD011             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000078   0xF1B6 0x6F40      CMP      R6,#+201326592
   \   0000007C   0xD00E             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000007E   0xF1B6 0x6F50      CMP      R6,#+218103808
   \   00000082   0xD00B             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000084   0xF1B6 0x6F60      CMP      R6,#+234881024
   \   00000088   0xD008             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   0000008A   0xF1B6 0x6F70      CMP      R6,#+251658240
   \   0000008E   0xD005             BEQ.N    ??RTC_AlarmSubSecondConfig_2
   \   00000090   0xF240 0x5183      MOVW     R1,#+1411
   \   00000094   0x.... 0x....      ADR.W    R0,?_0
   \   00000098   0x.... 0x....      BL       assert_failed
   1412            
   1413            /* Disable the write protection for RTC registers */
   1414            RTC->WPR = 0xCA;
   \                     ??RTC_AlarmSubSecondConfig_2: (+1)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable31  ;; 0x40002824
   \   000000A0   0x21CA             MOVS     R1,#+202
   \   000000A2   0x6001             STR      R1,[R0, #+0]
   1415            RTC->WPR = 0x53;
   \   000000A4   0x2153             MOVS     R1,#+83
   \   000000A6   0x6001             STR      R1,[R0, #+0]
   1416            
   1417            /* Configure the Alarm A or Alarm B Sub Second registers */
   1418            tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
   \   000000A8   0xEA46 0x0105      ORR      R1,R6,R5
   1419            
   1420            if (RTC_Alarm == RTC_Alarm_A)
   \   000000AC   0xF5B4 0x7F80      CMP      R4,#+256
   \   000000B0   0xD101             BNE.N    ??RTC_AlarmSubSecondConfig_3
   1421            {
   1422              /* Configure the Alarm A Sub Second register */
   1423              RTC->ALRMASSR = tmpreg;
   \   000000B2   0x6201             STR      R1,[R0, #+32]
   \   000000B4   0xE000             B.N      ??RTC_AlarmSubSecondConfig_4
   1424            }
   1425            else
   1426            {
   1427              /* Configure the Alarm B Sub Second register */
   1428              RTC->ALRMBSSR = tmpreg;
   \                     ??RTC_AlarmSubSecondConfig_3: (+1)
   \   000000B6   0x6241             STR      R1,[R0, #+36]
   1429            }
   1430          
   1431            /* Enable the write protection for RTC registers */
   1432            RTC->WPR = 0xFF;
   \                     ??RTC_AlarmSubSecondConfig_4: (+1)
   \   000000B8   0x21FF             MOVS     R1,#+255
   \   000000BA   0x6001             STR      R1,[R0, #+0]
   1433          
   1434          }
   \   000000BC   0xBD70             POP      {R4-R6,PC}       ;; return
   1435          
   1436          /**
   1437            * @brief  Gets the RTC Alarm Sub seconds value.
   1438            * @param  RTC_Alarm: specifies the alarm to be read.
   1439            *   This parameter can be one of the following values:
   1440            *     @arg RTC_Alarm_A: to select Alarm A
   1441            *     @arg RTC_Alarm_B: to select Alarm B
   1442            * @param  None
   1443            * @retval RTC Alarm Sub seconds value.
   1444            */

   \                                 In section .text, align 2, keep-with-next
   1445          uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
   1446          {
   1447            uint32_t tmpreg = 0;
   1448            
   1449            /* Get the RTC_ALRMxR register */
   1450            if (RTC_Alarm == RTC_Alarm_A)
   \                     RTC_GetAlarmSubSecond: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable51_2  ;; 0x40002844
   \   00000004   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000008   0xD103             BNE.N    ??RTC_GetAlarmSubSecond_0
   1451            {
   1452              tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
   \   0000000A   0x6808             LDR      R0,[R1, #+0]
   \   0000000C   0x0440             LSLS     R0,R0,#+17
   \   0000000E   0x0C40             LSRS     R0,R0,#+17
   \   00000010   0x4770             BX       LR
   1453            }
   1454            else
   1455            {
   1456              tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
   \                     ??RTC_GetAlarmSubSecond_0: (+1)
   \   00000012   0x6848             LDR      R0,[R1, #+4]
   \   00000014   0x0440             LSLS     R0,R0,#+17
   \   00000016   0x0C40             LSRS     R0,R0,#+17
   1457            } 
   1458            
   1459            return (tmpreg);
   \   00000018   0x4770             BX       LR               ;; return
   1460          }
   1461          
   1462          /**
   1463            * @}
   1464            */
   1465          
   1466          /** @defgroup RTC_Group4 WakeUp Timer configuration functions
   1467           *  @brief   WakeUp Timer configuration functions 
   1468           *
   1469          @verbatim   
   1470           ===============================================================================
   1471                           ##### WakeUp Timer configuration functions #####
   1472           ===============================================================================  
   1473          
   1474           [..] This section provide functions allowing to program and read the RTC WakeUp.
   1475          
   1476          @endverbatim
   1477            * @{
   1478            */
   1479          
   1480          /**
   1481            * @brief  Configures the RTC Wakeup clock source.
   1482            * @note   The WakeUp Clock source can only be changed when the RTC WakeUp
   1483            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).      
   1484            * @param  RTC_WakeUpClock: Wakeup Clock source.
   1485            *          This parameter can be one of the following values:
   1486            *            @arg RTC_WakeUpClock_RTCCLK_Div16: RTC Wakeup Counter Clock = RTCCLK/16
   1487            *            @arg RTC_WakeUpClock_RTCCLK_Div8: RTC Wakeup Counter Clock = RTCCLK/8
   1488            *            @arg RTC_WakeUpClock_RTCCLK_Div4: RTC Wakeup Counter Clock = RTCCLK/4
   1489            *            @arg RTC_WakeUpClock_RTCCLK_Div2: RTC Wakeup Counter Clock = RTCCLK/2
   1490            *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
   1491            *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
   1492            * @retval None
   1493            */

   \                                 In section .text, align 2, keep-with-next
   1494          void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
   1495          {
   \                     RTC_WakeUpClockConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1496            /* Check the parameters */
   1497            assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
   \   00000004   0xD00F             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD00D             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD00B             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   0000000E   0x2C03             CMP      R4,#+3
   \   00000010   0xD009             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000012   0x2C04             CMP      R4,#+4
   \   00000014   0xD007             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   00000016   0x2C06             CMP      R4,#+6
   \   00000018   0xD005             BEQ.N    ??RTC_WakeUpClockConfig_0
   \   0000001A   0xF240 0x51D9      MOVW     R1,#+1497
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
   1498          
   1499            /* Disable the write protection for RTC registers */
   1500            RTC->WPR = 0xCA;
   \                     ??RTC_WakeUpClockConfig_0: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   0000002A   0x21CA             MOVS     R1,#+202
   \   0000002C   0x61C1             STR      R1,[R0, #+28]
   1501            RTC->WPR = 0x53;
   \   0000002E   0x2153             MOVS     R1,#+83
   \   00000030   0x61C1             STR      R1,[R0, #+28]
   1502          
   1503            /* Clear the Wakeup Timer clock source bits in CR register */
   1504            RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x08C9             LSRS     R1,R1,#+3
   \   00000036   0x00C9             LSLS     R1,R1,#+3
   \   00000038   0x6001             STR      R1,[R0, #+0]
   1505          
   1506            /* Configure the clock source */
   1507            RTC->CR |= (uint32_t)RTC_WakeUpClock;
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   1508            
   1509            /* Enable the write protection for RTC registers */
   1510            RTC->WPR = 0xFF; 
   \   00000040   0x21FF             MOVS     R1,#+255
   \   00000042   0x61C1             STR      R1,[R0, #+28]
   1511          }
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
   1512          
   1513          /**
   1514            * @brief  Configures the RTC Wakeup counter.
   1515            * @note   The RTC WakeUp counter can only be written when the RTC WakeUp
   1516            *         is disabled (Use the RTC_WakeUpCmd(DISABLE)).        
   1517            * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
   1518            *          This parameter can be a value from 0x0000 to 0xFFFF. 
   1519            * @retval None
   1520            */

   \                                 In section .text, align 2, keep-with-next
   1521          void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
   1522          {
   \                     RTC_SetWakeUpCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1523            /* Check the parameters */
   1524            assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
   \   00000004   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000008   0xD305             BCC.N    ??RTC_SetWakeUpCounter_0
   \   0000000A   0xF240 0x51F4      MOVW     R1,#+1524
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1525            
   1526            /* Disable the write protection for RTC registers */
   1527            RTC->WPR = 0xCA;
   \                     ??RTC_SetWakeUpCounter_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_3  ;; 0x40002814
   \   0000001A   0x21CA             MOVS     R1,#+202
   \   0000001C   0x6101             STR      R1,[R0, #+16]
   1528            RTC->WPR = 0x53;
   \   0000001E   0x2153             MOVS     R1,#+83
   \   00000020   0x6101             STR      R1,[R0, #+16]
   1529            
   1530            /* Configure the Wakeup Timer counter */
   1531            RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
   \   00000022   0x6004             STR      R4,[R0, #+0]
   1532            
   1533            /* Enable the write protection for RTC registers */
   1534            RTC->WPR = 0xFF; 
   \   00000024   0x21FF             MOVS     R1,#+255
   \   00000026   0x6101             STR      R1,[R0, #+16]
   1535          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   1536          
   1537          /**
   1538            * @brief  Returns the RTC WakeUp timer counter value.
   1539            * @param  None
   1540            * @retval The RTC WakeUp Counter value.
   1541            */

   \                                 In section .text, align 2, keep-with-next
   1542          uint32_t RTC_GetWakeUpCounter(void)
   1543          {
   1544            /* Get the counter value */
   1545            return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
   \                     RTC_GetWakeUpCounter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable51_3  ;; 0x40002814
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
   1546          }
   1547          
   1548          /**
   1549            * @brief  Enables or Disables the RTC WakeUp timer.
   1550            * @param  NewState: new state of the WakeUp timer.
   1551            *          This parameter can be: ENABLE or DISABLE.
   1552            * @retval None
   1553            */

   \                                 In section .text, align 2, keep-with-next
   1554          ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
   1555          {
   \                     RTC_WakeUpCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   1556            __IO uint32_t wutcounter = 0x00;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1557            uint32_t wutwfstatus = 0x00;
   1558            ErrorStatus status = ERROR;
   1559            
   1560            /* Check the parameters */
   1561            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD007             BEQ.N    ??RTC_WakeUpCmd_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD005             BEQ.N    ??RTC_WakeUpCmd_0
   \   00000012   0xF240 0x6119      MOVW     R1,#+1561
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1562          
   1563            /* Disable the write protection for RTC registers */
   1564            RTC->WPR = 0xCA;
   \                     ??RTC_WakeUpCmd_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable51_1  ;; 0x40002808
   \   00000022   0x20CA             MOVS     R0,#+202
   \   00000024   0x61C8             STR      R0,[R1, #+28]
   1565            RTC->WPR = 0x53;
   \   00000026   0x2053             MOVS     R0,#+83
   \   00000028   0x61C8             STR      R0,[R1, #+28]
   1566          
   1567            if (NewState != DISABLE)
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0x6808             LDR      R0,[R1, #+0]
   \   0000002E   0xD004             BEQ.N    ??RTC_WakeUpCmd_1
   1568            {
   1569              /* Enable the Wakeup Timer */
   1570              RTC->CR |= (uint32_t)RTC_CR_WUTE;
   \   00000030   0xF440 0x6080      ORR      R0,R0,#0x400
   \   00000034   0x6008             STR      R0,[R1, #+0]
   1571              status = SUCCESS;    
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE012             B.N      ??RTC_WakeUpCmd_2
   1572            }
   1573            else
   1574            {
   1575              /* Disable the Wakeup Timer */
   1576              RTC->CR &= (uint32_t)~RTC_CR_WUTE;
   \                     ??RTC_WakeUpCmd_1: (+1)
   \   0000003A   0xF420 0x6080      BIC      R0,R0,#0x400
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   1577              /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1578              do
   1579              {
   1580                wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
   \                     ??RTC_WakeUpCmd_3: (+1)
   \   00000040   0x6848             LDR      R0,[R1, #+4]
   \   00000042   0xF000 0x0004      AND      R0,R0,#0x4
   1581                wutcounter++;  
   \   00000046   0x9A00             LDR      R2,[SP, #+0]
   \   00000048   0x1C52             ADDS     R2,R2,#+1
   \   0000004A   0x9200             STR      R2,[SP, #+0]
   1582              } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
   \   0000004C   0x9A00             LDR      R2,[SP, #+0]
   \   0000004E   0xF5B2 0x3F80      CMP      R2,#+65536
   \   00000052   0xD001             BEQ.N    ??RTC_WakeUpCmd_4
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0F3             BEQ.N    ??RTC_WakeUpCmd_3
   1583              
   1584              if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
   \                     ??RTC_WakeUpCmd_4: (+1)
   \   00000058   0x6848             LDR      R0,[R1, #+4]
   1585              {
   1586                status = ERROR;
   \   0000005A   0x0880             LSRS     R0,R0,#+2
   \   0000005C   0xF000 0x0001      AND      R0,R0,#0x1
   1587              }
   1588              else
   1589              {
   1590                status = SUCCESS;
   1591              }    
   1592            }
   1593          
   1594            /* Enable the write protection for RTC registers */
   1595            RTC->WPR = 0xFF; 
   \                     ??RTC_WakeUpCmd_2: (+1)
   \   00000060   0x22FF             MOVS     R2,#+255
   \   00000062   0x61CA             STR      R2,[R1, #+28]
   1596            
   1597            return status;
   \   00000064   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1598          }
   1599          
   1600          /**
   1601            * @}
   1602            */
   1603          
   1604          /** @defgroup RTC_Group5 Daylight Saving configuration functions
   1605           *  @brief   Daylight Saving configuration functions 
   1606           *
   1607          @verbatim   
   1608           ===============================================================================
   1609                        ##### Daylight Saving configuration functions #####
   1610           ===============================================================================  
   1611          
   1612           [..] This section provide functions allowing to configure the RTC DayLight Saving.
   1613          
   1614          @endverbatim
   1615            * @{
   1616            */
   1617          
   1618          /**
   1619            * @brief  Adds or substract one hour from the current time.
   1620            * @param  RTC_DayLightSaveOperation: the value of hour adjustment. 
   1621            *          This parameter can be one of the following values:
   1622            *            @arg RTC_DayLightSaving_SUB1H: Substract one hour (winter time)
   1623            *            @arg RTC_DayLightSaving_ADD1H: Add one hour (summer time)
   1624            * @param  RTC_StoreOperation: Specifies the value to be written in the BCK bit 
   1625            *                            in CR register to store the operation.
   1626            *          This parameter can be one of the following values:
   1627            *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
   1628            *            @arg RTC_StoreOperation_Set: BCK Bit Set
   1629            * @retval None
   1630            */

   \                                 In section .text, align 2, keep-with-next
   1631          void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
   1632          {
   \                     RTC_DayLightSavingConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1633            /* Check the parameters */
   1634            assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
   \   00000006   0xF5B4 0x3F00      CMP      R4,#+131072
   \   0000000A   0xD008             BEQ.N    ??RTC_DayLightSavingConfig_0
   \   0000000C   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000010   0xD005             BEQ.N    ??RTC_DayLightSavingConfig_0
   \   00000012   0xF240 0x6162      MOVW     R1,#+1634
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1635            assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
   \                     ??RTC_DayLightSavingConfig_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD008             BEQ.N    ??RTC_DayLightSavingConfig_1
   \   00000022   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000026   0xD005             BEQ.N    ??RTC_DayLightSavingConfig_1
   \   00000028   0xF240 0x6163      MOVW     R1,#+1635
   \   0000002C   0x.... 0x....      ADR.W    R0,?_0
   \   00000030   0x.... 0x....      BL       assert_failed
   1636          
   1637            /* Disable the write protection for RTC registers */
   1638            RTC->WPR = 0xCA;
   \                     ??RTC_DayLightSavingConfig_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   00000038   0x21CA             MOVS     R1,#+202
   \   0000003A   0x61C1             STR      R1,[R0, #+28]
   1639            RTC->WPR = 0x53;
   \   0000003C   0x2153             MOVS     R1,#+83
   \   0000003E   0x61C1             STR      R1,[R0, #+28]
   1640          
   1641            /* Clear the bits to be configured */
   1642            RTC->CR &= (uint32_t)~(RTC_CR_BCK);
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1643          
   1644            /* Configure the RTC_CR register */
   1645            RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0xEA45 0x0204      ORR      R2,R5,R4
   \   0000004E   0x4311             ORRS     R1,R2,R1
   \   00000050   0x6001             STR      R1,[R0, #+0]
   1646          
   1647            /* Enable the write protection for RTC registers */
   1648            RTC->WPR = 0xFF; 
   \   00000052   0x21FF             MOVS     R1,#+255
   \   00000054   0x61C1             STR      R1,[R0, #+28]
   1649          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1650          
   1651          /**
   1652            * @brief  Returns the RTC Day Light Saving stored operation.
   1653            * @param  None
   1654            * @retval RTC Day Light Saving stored operation.
   1655            *          - RTC_StoreOperation_Reset
   1656            *          - RTC_StoreOperation_Set       
   1657            */

   \                                 In section .text, align 2, keep-with-next
   1658          uint32_t RTC_GetStoreOperation(void)
   1659          {
   1660            return (RTC->CR & RTC_CR_BCK);
   \                     RTC_GetStoreOperation: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF400 0x2080      AND      R0,R0,#0x40000
   \   0000000A   0x4770             BX       LR               ;; return
   1661          }
   1662          
   1663          /**
   1664            * @}
   1665            */
   1666          
   1667          /** @defgroup RTC_Group6 Output pin Configuration function
   1668           *  @brief   Output pin Configuration function 
   1669           *
   1670          @verbatim   
   1671           ===============================================================================
   1672                           ##### Output pin Configuration function #####
   1673           ===============================================================================  
   1674          
   1675           [..] This section provide functions allowing to configure the RTC Output source.
   1676          
   1677          @endverbatim
   1678            * @{
   1679            */
   1680          
   1681          /**
   1682            * @brief  Configures the RTC output source (AFO_ALARM).
   1683            * @param  RTC_Output: Specifies which signal will be routed to the RTC output. 
   1684            *          This parameter can be one of the following values:
   1685            *            @arg RTC_Output_Disable: No output selected
   1686            *            @arg RTC_Output_AlarmA: signal of AlarmA mapped to output
   1687            *            @arg RTC_Output_AlarmB: signal of AlarmB mapped to output
   1688            *            @arg RTC_Output_WakeUp: signal of WakeUp mapped to output
   1689            * @param  RTC_OutputPolarity: Specifies the polarity of the output signal. 
   1690            *          This parameter can be one of the following:
   1691            *            @arg RTC_OutputPolarity_High: The output pin is high when the 
   1692            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1693            *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
   1694            *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
   1695            * @retval None
   1696            */

   \                                 In section .text, align 2, keep-with-next
   1697          void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
   1698          {
   \                     RTC_OutputConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1699            /* Check the parameters */
   1700            assert_param(IS_RTC_OUTPUT(RTC_Output));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??RTC_OutputConfig_0
   \   0000000A   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   0000000E   0xD00B             BEQ.N    ??RTC_OutputConfig_0
   \   00000010   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000014   0xD008             BEQ.N    ??RTC_OutputConfig_0
   \   00000016   0xF5B4 0x0FC0      CMP      R4,#+6291456
   \   0000001A   0xD005             BEQ.N    ??RTC_OutputConfig_0
   \   0000001C   0xF240 0x61A4      MOVW     R1,#+1700
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
   1701            assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
   \                     ??RTC_OutputConfig_0: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD008             BEQ.N    ??RTC_OutputConfig_1
   \   0000002C   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000030   0xD005             BEQ.N    ??RTC_OutputConfig_1
   \   00000032   0xF240 0x61A5      MOVW     R1,#+1701
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
   1702          
   1703            /* Disable the write protection for RTC registers */
   1704            RTC->WPR = 0xCA;
   \                     ??RTC_OutputConfig_1: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   00000042   0x21CA             MOVS     R1,#+202
   \   00000044   0x61C1             STR      R1,[R0, #+28]
   1705            RTC->WPR = 0x53;
   \   00000046   0x2153             MOVS     R1,#+83
   \   00000048   0x61C1             STR      R1,[R0, #+28]
   1706          
   1707            /* Clear the bits to be configured */
   1708            RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF421 0x01E0      BIC      R1,R1,#0x700000
   \   00000050   0x6001             STR      R1,[R0, #+0]
   1709          
   1710            /* Configure the output selection and polarity */
   1711            RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xEA45 0x0204      ORR      R2,R5,R4
   \   00000058   0x4311             ORRS     R1,R2,R1
   \   0000005A   0x6001             STR      R1,[R0, #+0]
   1712          
   1713            /* Enable the write protection for RTC registers */
   1714            RTC->WPR = 0xFF; 
   \   0000005C   0x21FF             MOVS     R1,#+255
   \   0000005E   0x61C1             STR      R1,[R0, #+28]
   1715          }
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1716          
   1717          /**
   1718            * @}
   1719            */
   1720          
   1721          /** @defgroup RTC_Group7 Digital Calibration configuration functions
   1722           *  @brief   Coarse Calibration configuration functions 
   1723           *
   1724          @verbatim   
   1725           ===============================================================================
   1726                        ##### Digital Calibration configuration functions #####
   1727           ===============================================================================  
   1728          
   1729          @endverbatim
   1730            * @{
   1731            */
   1732          
   1733          /**
   1734            * @brief  Configures the Coarse calibration parameters.
   1735            * @param  RTC_CalibSign: specifies the sign of the coarse calibration value.
   1736            *          This parameter can be  one of the following values:
   1737            *            @arg RTC_CalibSign_Positive: The value sign is positive 
   1738            *            @arg RTC_CalibSign_Negative: The value sign is negative
   1739            * @param  Value: value of coarse calibration expressed in ppm (coded on 5 bits).
   1740            *    
   1741            * @note   This Calibration value should be between 0 and 63 when using negative
   1742            *         sign with a 2-ppm step.
   1743            *           
   1744            * @note   This Calibration value should be between 0 and 126 when using positive
   1745            *         sign with a 4-ppm step.
   1746            *           
   1747            * @retval An ErrorStatus enumeration value:
   1748            *          - SUCCESS: RTC Coarse calibration are initialized
   1749            *          - ERROR: RTC Coarse calibration are not initialized     
   1750            */

   \                                 In section .text, align 2, keep-with-next
   1751          ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
   1752          {
   \                     RTC_CoarseCalibConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1753            ErrorStatus status = ERROR;
   \   00000006   0x2600             MOVS     R6,#+0
   1754             
   1755            /* Check the parameters */
   1756            assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_CoarseCalibConfig_0
   \   0000000C   0x2C80             CMP      R4,#+128
   \   0000000E   0xD005             BEQ.N    ??RTC_CoarseCalibConfig_0
   \   00000010   0xF240 0x61DC      MOVW     R1,#+1756
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1757            assert_param(IS_RTC_CALIB_VALUE(Value)); 
   \                     ??RTC_CoarseCalibConfig_0: (+1)
   \   0000001C   0x2D20             CMP      R5,#+32
   \   0000001E   0xD305             BCC.N    ??RTC_CoarseCalibConfig_1
   \   00000020   0xF240 0x61DD      MOVW     R1,#+1757
   \   00000024   0x.... 0x....      ADR.W    R0,?_0
   \   00000028   0x.... 0x....      BL       assert_failed
   1758          
   1759            /* Disable the write protection for RTC registers */
   1760            RTC->WPR = 0xCA;
   \                     ??RTC_CoarseCalibConfig_1: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R7,??DataTable51_4  ;; 0x40002818
   \   00000030   0x20CA             MOVS     R0,#+202
   \   00000032   0x60F8             STR      R0,[R7, #+12]
   1761            RTC->WPR = 0x53;
   \   00000034   0x2053             MOVS     R0,#+83
   \   00000036   0x60F8             STR      R0,[R7, #+12]
   1762          
   1763            /* Set Initialization mode */
   1764            if (RTC_EnterInitMode() == ERROR)
   \   00000038   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD005             BEQ.N    ??RTC_CoarseCalibConfig_2
   1765            {
   1766              status = ERROR;
   1767            } 
   1768            else
   1769            {
   1770              /* Set the coarse calibration value */
   1771              RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
   \   00000040   0xEA45 0x0004      ORR      R0,R5,R4
   \   00000044   0x6038             STR      R0,[R7, #+0]
   1772              /* Exit Initialization mode */
   1773              RTC_ExitInitMode();
   \   00000046   0x.... 0x....      BL       RTC_ExitInitMode
   1774              
   1775              status = SUCCESS;
   \   0000004A   0x2601             MOVS     R6,#+1
   1776            } 
   1777          
   1778            /* Enable the write protection for RTC registers */
   1779            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibConfig_2: (+1)
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0x60F8             STR      R0,[R7, #+12]
   1780            
   1781            return status;
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1782          }
   1783          
   1784          /**
   1785            * @brief  Enables or disables the Coarse calibration process.
   1786            * @param  NewState: new state of the Coarse calibration.
   1787            *          This parameter can be: ENABLE or DISABLE.
   1788            * @retval An ErrorStatus enumeration value:
   1789            *          - SUCCESS: RTC Coarse calibration are enabled/disabled
   1790            *          - ERROR: RTC Coarse calibration are not enabled/disabled    
   1791            */

   \                                 In section .text, align 2, keep-with-next
   1792          ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
   1793          {
   \                     RTC_CoarseCalibCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   1794            ErrorStatus status = ERROR;
   \   00000004   0x2600             MOVS     R6,#+0
   1795            
   1796            /* Check the parameters */
   1797            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD007             BEQ.N    ??RTC_CoarseCalibCmd_0
   \   0000000A   0x2D01             CMP      R5,#+1
   \   0000000C   0xD005             BEQ.N    ??RTC_CoarseCalibCmd_0
   \   0000000E   0xF240 0x7105      MOVW     R1,#+1797
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       assert_failed
   1798          
   1799            /* Disable the write protection for RTC registers */
   1800            RTC->WPR = 0xCA;
   \                     ??RTC_CoarseCalibCmd_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R4,??DataTable51_1  ;; 0x40002808
   \   0000001E   0x20CA             MOVS     R0,#+202
   \   00000020   0x61E0             STR      R0,[R4, #+28]
   1801            RTC->WPR = 0x53;
   \   00000022   0x2053             MOVS     R0,#+83
   \   00000024   0x61E0             STR      R0,[R4, #+28]
   1802            
   1803            /* Set Initialization mode */
   1804            if (RTC_EnterInitMode() == ERROR)
   \   00000026   0x.... 0x....      BL       RTC_EnterInitMode
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD00C             BEQ.N    ??RTC_CoarseCalibCmd_1
   1805            {
   1806              status =  ERROR;
   1807            }
   1808            else
   1809            {
   1810              if (NewState != DISABLE)
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0xD003             BEQ.N    ??RTC_CoarseCalibCmd_2
   1811              {
   1812                /* Enable the Coarse Calibration */
   1813                RTC->CR |= (uint32_t)RTC_CR_DCE;
   \   00000034   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000038   0x6020             STR      R0,[R4, #+0]
   \   0000003A   0xE002             B.N      ??RTC_CoarseCalibCmd_3
   1814              }
   1815              else
   1816              { 
   1817                /* Disable the Coarse Calibration */
   1818                RTC->CR &= (uint32_t)~RTC_CR_DCE;
   \                     ??RTC_CoarseCalibCmd_2: (+1)
   \   0000003C   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000040   0x6020             STR      R0,[R4, #+0]
   1819              }
   1820              /* Exit Initialization mode */
   1821              RTC_ExitInitMode();
   \                     ??RTC_CoarseCalibCmd_3: (+1)
   \   00000042   0x.... 0x....      BL       RTC_ExitInitMode
   1822              
   1823              status = SUCCESS;
   \   00000046   0x2601             MOVS     R6,#+1
   1824            } 
   1825            
   1826            /* Enable the write protection for RTC registers */
   1827            RTC->WPR = 0xFF; 
   \                     ??RTC_CoarseCalibCmd_1: (+1)
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0x61E0             STR      R0,[R4, #+28]
   1828            
   1829            return status;
   \   0000004C   0x4630             MOV      R0,R6
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
   1830          }
   1831          
   1832          /**
   1833            * @brief  Enables or disables the RTC clock to be output through the relative pin.
   1834            * @param  NewState: new state of the digital calibration Output.
   1835            *          This parameter can be: ENABLE or DISABLE.
   1836            * @retval None
   1837            */

   \                                 In section .text, align 2, keep-with-next
   1838          void RTC_CalibOutputCmd(FunctionalState NewState)
   1839          {
   \                     RTC_CalibOutputCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1840            /* Check the parameters */
   1841            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RTC_CalibOutputCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_CalibOutputCmd_0
   \   0000000A   0xF240 0x7131      MOVW     R1,#+1841
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1842            
   1843            /* Disable the write protection for RTC registers */
   1844            RTC->WPR = 0xCA;
   \                     ??RTC_CalibOutputCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   0000001A   0x21CA             MOVS     R1,#+202
   \   0000001C   0x61C1             STR      R1,[R0, #+28]
   1845            RTC->WPR = 0x53;
   \   0000001E   0x2153             MOVS     R1,#+83
   \   00000020   0x61C1             STR      R1,[R0, #+28]
   1846            
   1847            if (NewState != DISABLE)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xD003             BEQ.N    ??RTC_CalibOutputCmd_1
   1848            {
   1849              /* Enable the RTC clock output */
   1850              RTC->CR |= (uint32_t)RTC_CR_COE;
   \   00000028   0xF441 0x0100      ORR      R1,R1,#0x800000
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   \   0000002E   0xE002             B.N      ??RTC_CalibOutputCmd_2
   1851            }
   1852            else
   1853            { 
   1854              /* Disable the RTC clock output */
   1855              RTC->CR &= (uint32_t)~RTC_CR_COE;
   \                     ??RTC_CalibOutputCmd_1: (+1)
   \   00000030   0xF421 0x0100      BIC      R1,R1,#0x800000
   \   00000034   0x6001             STR      R1,[R0, #+0]
   1856            }
   1857            
   1858            /* Enable the write protection for RTC registers */
   1859            RTC->WPR = 0xFF; 
   \                     ??RTC_CalibOutputCmd_2: (+1)
   \   00000036   0x21FF             MOVS     R1,#+255
   \   00000038   0x61C1             STR      R1,[R0, #+28]
   1860          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
   1861          
   1862          /**
   1863            * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1864            * @param  RTC_CalibOutput : Select the Calibration output Selection .
   1865            *   This parameter can be one of the following values:
   1866            *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
   1867            *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
   1868            * @retval None
   1869          */

   \                                 In section .text, align 2, keep-with-next
   1870          void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
   1871          {
   \                     RTC_CalibOutputConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1872            /* Check the parameters */
   1873            assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
   \   00000004   0xD008             BEQ.N    ??RTC_CalibOutputConfig_0
   \   00000006   0xF5B4 0x2F00      CMP      R4,#+524288
   \   0000000A   0xD005             BEQ.N    ??RTC_CalibOutputConfig_0
   \   0000000C   0xF240 0x7151      MOVW     R1,#+1873
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   1874          
   1875            /* Disable the write protection for RTC registers */
   1876            RTC->WPR = 0xCA;
   \                     ??RTC_CalibOutputConfig_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   0000001C   0x21CA             MOVS     R1,#+202
   \   0000001E   0x61C1             STR      R1,[R0, #+28]
   1877            RTC->WPR = 0x53;
   \   00000020   0x2153             MOVS     R1,#+83
   \   00000022   0x61C1             STR      R1,[R0, #+28]
   1878            
   1879            /*clear flags before configuration */
   1880            RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF421 0x2100      BIC      R1,R1,#0x80000
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   1881          
   1882            /* Configure the RTC_CR register */
   1883            RTC->CR |= (uint32_t)RTC_CalibOutput;
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0x4321             ORRS     R1,R4,R1
   \   00000030   0x6001             STR      R1,[R0, #+0]
   1884          
   1885            /* Enable the write protection for RTC registers */
   1886            RTC->WPR = 0xFF;
   \   00000032   0x21FF             MOVS     R1,#+255
   \   00000034   0x61C1             STR      R1,[R0, #+28]
   1887          }
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   1888          
   1889          /**
   1890            * @brief  Configures the Smooth Calibration Settings.
   1891            * @param  RTC_SmoothCalibPeriod : Select the Smooth Calibration Period.
   1892            *   This parameter can be can be one of the following values:
   1893            *     @arg RTC_SmoothCalibPeriod_32sec : The smooth calibration period is 32s.
   1894            *     @arg RTC_SmoothCalibPeriod_16sec : The smooth calibration period is 16s.
   1895            *     @arg RTC_SmoothCalibPeriod_8sec  : The smooth calibartion period is 8s.
   1896            * @param  RTC_SmoothCalibPlusPulses : Select to Set or reset the CALP bit.
   1897            *   This parameter can be one of the following values:
   1898            *     @arg RTC_SmoothCalibPlusPulses_Set  : Add one RTCCLK puls every 2**11 pulses.
   1899            *     @arg RTC_SmoothCalibPlusPulses_Reset: No RTCCLK pulses are added.
   1900            * @param  RTC_SmouthCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1901            *   This parameter can be one any value from 0 to 0x000001FF.
   1902            * @retval An ErrorStatus enumeration value:
   1903            *          - SUCCESS: RTC Calib registers are configured
   1904            *          - ERROR: RTC Calib registers are not configured
   1905          */

   \                                 In section .text, align 2, keep-with-next
   1906          ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
   1907                                            uint32_t RTC_SmoothCalibPlusPulses,
   1908                                            uint32_t RTC_SmouthCalibMinusPulsesValue)
   1909          {
   \                     RTC_SmoothCalibConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   1910            ErrorStatus status = ERROR;
   \   0000000A   0x2700             MOVS     R7,#+0
   1911            uint32_t recalpfcount = 0;
   \   0000000C   0x46B8             MOV      R8,R7
   1912          
   1913            /* Check the parameters */
   1914            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD00B             BEQ.N    ??RTC_SmoothCalibConfig_0
   \   00000012   0xF5B4 0x5F00      CMP      R4,#+8192
   \   00000016   0xD008             BEQ.N    ??RTC_SmoothCalibConfig_0
   \   00000018   0xF5B4 0x4F80      CMP      R4,#+16384
   \   0000001C   0xD005             BEQ.N    ??RTC_SmoothCalibConfig_0
   \   0000001E   0xF240 0x717A      MOVW     R1,#+1914
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
   1915            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
   \                     ??RTC_SmoothCalibConfig_0: (+1)
   \   0000002A   0xF5B5 0x4F00      CMP      R5,#+32768
   \   0000002E   0xD007             BEQ.N    ??RTC_SmoothCalibConfig_1
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD005             BEQ.N    ??RTC_SmoothCalibConfig_1
   \   00000034   0xF240 0x717B      MOVW     R1,#+1915
   \   00000038   0x.... 0x....      ADR.W    R0,?_0
   \   0000003C   0x.... 0x....      BL       assert_failed
   1916            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
   \                     ??RTC_SmoothCalibConfig_1: (+1)
   \   00000040   0xF5B6 0x7F00      CMP      R6,#+512
   \   00000044   0xD305             BCC.N    ??RTC_SmoothCalibConfig_2
   \   00000046   0xF240 0x717C      MOVW     R1,#+1916
   \   0000004A   0x.... 0x....      ADR.W    R0,?_0
   \   0000004E   0x.... 0x....      BL       assert_failed
   1917          
   1918            /* Disable the write protection for RTC registers */
   1919            RTC->WPR = 0xCA;
   \                     ??RTC_SmoothCalibConfig_2: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable51_5  ;; 0x4000280c
   \   00000056   0x21CA             MOVS     R1,#+202
   \   00000058   0x6181             STR      R1,[R0, #+24]
   1920            RTC->WPR = 0x53;
   \   0000005A   0x2153             MOVS     R1,#+83
   \   0000005C   0x6181             STR      R1,[R0, #+24]
   1921            
   1922            /* check if a calibration is pending*/
   1923            if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
   \   00000060   0x03C9             LSLS     R1,R1,#+15
   \   00000062   0xD402             BMI.N    ??RTC_SmoothCalibConfig_3
   \   00000064   0xE007             B.N      ??RTC_SmoothCalibConfig_4
   1924            {
   1925              /* wait until the Calibration is completed*/
   1926              while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
   1927              {
   1928                recalpfcount++;
   \                     ??RTC_SmoothCalibConfig_5: (+1)
   \   00000066   0xF108 0x0801      ADD      R8,R8,#+1
   1929              }
   \                     ??RTC_SmoothCalibConfig_3: (+1)
   \   0000006A   0x6801             LDR      R1,[R0, #+0]
   \   0000006C   0x03C9             LSLS     R1,R1,#+15
   \   0000006E   0xD502             BPL.N    ??RTC_SmoothCalibConfig_4
   \   00000070   0xF5B8 0x3F00      CMP      R8,#+131072
   \   00000074   0xD1F7             BNE.N    ??RTC_SmoothCalibConfig_5
   1930            }
   1931          
   1932            /* check if the calibration pending is completed or if there is no calibration operation at all*/
   1933            if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
   \                     ??RTC_SmoothCalibConfig_4: (+1)
   \   00000076   0x6801             LDR      R1,[R0, #+0]
   \   00000078   0x03C9             LSLS     R1,R1,#+15
   \   0000007A   0xD404             BMI.N    ??RTC_SmoothCalibConfig_6
   1934            {
   1935              /* Configure the Smooth calibration settings */
   1936              RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
   \   0000007C   0xEA45 0x0104      ORR      R1,R5,R4
   \   00000080   0x4331             ORRS     R1,R6,R1
   \   00000082   0x6301             STR      R1,[R0, #+48]
   1937          
   1938              status = SUCCESS;
   \   00000084   0x2701             MOVS     R7,#+1
   1939            }
   1940            else
   1941            {
   1942              status = ERROR;
   1943            }
   1944          
   1945            /* Enable the write protection for RTC registers */
   1946            RTC->WPR = 0xFF;
   \                     ??RTC_SmoothCalibConfig_6: (+1)
   \   00000086   0x21FF             MOVS     R1,#+255
   \   00000088   0x6181             STR      R1,[R0, #+24]
   1947            
   1948            return (ErrorStatus)(status);
   \   0000008A   0x4638             MOV      R0,R7
   \   0000008C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1949          }
   1950          
   1951          /**
   1952            * @}
   1953            */
   1954          
   1955          
   1956          /** @defgroup RTC_Group8 TimeStamp configuration functions
   1957           *  @brief   TimeStamp configuration functions 
   1958           *
   1959          @verbatim   
   1960           ===============================================================================
   1961                           ##### TimeStamp configuration functions #####
   1962           ===============================================================================  
   1963          
   1964          @endverbatim
   1965            * @{
   1966            */
   1967          
   1968          /**
   1969            * @brief  Enables or Disables the RTC TimeStamp functionality with the 
   1970            *         specified time stamp pin stimulating edge.
   1971            * @param  RTC_TimeStampEdge: Specifies the pin edge on which the TimeStamp is 
   1972            *         activated.
   1973            *          This parameter can be one of the following:
   1974            *            @arg RTC_TimeStampEdge_Rising: the Time stamp event occurs on the rising 
   1975            *                                    edge of the related pin.
   1976            *            @arg RTC_TimeStampEdge_Falling: the Time stamp event occurs on the 
   1977            *                                     falling edge of the related pin.
   1978            * @param  NewState: new state of the TimeStamp.
   1979            *          This parameter can be: ENABLE or DISABLE.
   1980            * @retval None
   1981            */

   \                                 In section .text, align 2, keep-with-next
   1982          void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
   1983          {
   \                     RTC_TimeStampCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1984            uint32_t tmpreg = 0;
   1985          
   1986            /* Check the parameters */
   1987            assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD007             BEQ.N    ??RTC_TimeStampCmd_0
   \   0000000A   0x2C08             CMP      R4,#+8
   \   0000000C   0xD005             BEQ.N    ??RTC_TimeStampCmd_0
   \   0000000E   0xF240 0x71C3      MOVW     R1,#+1987
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       assert_failed
   1988            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_TimeStampCmd_0: (+1)
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD007             BEQ.N    ??RTC_TimeStampCmd_1
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD005             BEQ.N    ??RTC_TimeStampCmd_1
   \   00000022   0xF240 0x71C4      MOVW     R1,#+1988
   \   00000026   0x.... 0x....      ADR.W    R0,?_0
   \   0000002A   0x.... 0x....      BL       assert_failed
   1989          
   1990            /* Get the RTC_CR register and clear the bits to be configured */
   1991            tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
   \                     ??RTC_TimeStampCmd_1: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x40002808
   \   00000032   0x6801             LDR      R1,[R0, #+0]
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable51_6  ;; 0xfffff7f7
   \   00000038   0x4011             ANDS     R1,R2,R1
   1992          
   1993            /* Get the new configuration */
   1994            if (NewState != DISABLE)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD003             BEQ.N    ??RTC_TimeStampCmd_2
   1995            {
   1996              tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
   \   0000003E   0xF444 0x6200      ORR      R2,R4,#0x800
   \   00000042   0x4311             ORRS     R1,R2,R1
   \   00000044   0xE000             B.N      ??RTC_TimeStampCmd_3
   1997            }
   1998            else
   1999            {
   2000              tmpreg |= (uint32_t)(RTC_TimeStampEdge);
   \                     ??RTC_TimeStampCmd_2: (+1)
   \   00000046   0x4321             ORRS     R1,R4,R1
   2001            }
   2002          
   2003            /* Disable the write protection for RTC registers */
   2004            RTC->WPR = 0xCA;
   \                     ??RTC_TimeStampCmd_3: (+1)
   \   00000048   0x22CA             MOVS     R2,#+202
   \   0000004A   0x61C2             STR      R2,[R0, #+28]
   2005            RTC->WPR = 0x53;
   \   0000004C   0x2253             MOVS     R2,#+83
   \   0000004E   0x61C2             STR      R2,[R0, #+28]
   2006          
   2007            /* Configure the Time Stamp TSEDGE and Enable bits */
   2008            RTC->CR = (uint32_t)tmpreg;
   \   00000050   0x6001             STR      R1,[R0, #+0]
   2009          
   2010            /* Enable the write protection for RTC registers */
   2011            RTC->WPR = 0xFF; 
   \   00000052   0x21FF             MOVS     R1,#+255
   \   00000054   0x61C1             STR      R1,[R0, #+28]
   2012          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2013          
   2014          /**
   2015            * @brief  Get the RTC TimeStamp value and masks.
   2016            * @param  RTC_Format: specifies the format of the output parameters.
   2017            *          This parameter can be one of the following values:
   2018            *            @arg RTC_Format_BIN: Binary data format 
   2019            *            @arg RTC_Format_BCD: BCD data format
   2020            * @param RTC_StampTimeStruct: pointer to a RTC_TimeTypeDef structure that will 
   2021            *                             contains the TimeStamp time values. 
   2022            * @param RTC_StampDateStruct: pointer to a RTC_DateTypeDef structure that will 
   2023            *                             contains the TimeStamp date values.     
   2024            * @retval None
   2025            */

   \                                 In section .text, align 2, keep-with-next
   2026          void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
   2027                                                RTC_DateTypeDef* RTC_StampDateStruct)
   2028          {
   \                     RTC_GetTimeStamp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   2029            uint32_t tmptime = 0, tmpdate = 0;
   2030          
   2031            /* Check the parameters */
   2032            assert_param(IS_RTC_FORMAT(RTC_Format));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??RTC_GetTimeStamp_0
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD005             BEQ.N    ??RTC_GetTimeStamp_0
   \   00000010   0xF44F 0x61FE      MOV      R1,#+2032
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   2033          
   2034            /* Get the TimeStamp time and date registers values */
   2035            tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
   \                     ??RTC_GetTimeStamp_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable51_7  ;; 0x40002830
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x....             LDR.N    R2,??DataTable40  ;; 0x7f7f7f
   \   00000024   0x4011             ANDS     R1,R2,R1
   2036            tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
   \   00000026   0x6840             LDR      R0,[R0, #+4]
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable45_1  ;; 0xffff3f
   \   0000002C   0x4010             ANDS     R0,R2,R0
   \   0000002E   0x0C0A             LSRS     R2,R1,#+16
   \   00000030   0xF002 0x033F      AND      R3,R2,#0x3F
   \   00000034   0x702B             STRB     R3,[R5, #+0]
   2037          
   2038            /* Fill the Time structure fields with the read parameters */
   2039            RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
   2040            RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
   \   00000036   0x0A0B             LSRS     R3,R1,#+8
   \   00000038   0xF003 0x037F      AND      R3,R3,#0x7F
   \   0000003C   0x706B             STRB     R3,[R5, #+1]
   2041            RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
   \   0000003E   0xF001 0x017F      AND      R1,R1,#0x7F
   \   00000042   0x70A9             STRB     R1,[R5, #+2]
   2042            RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
   \   00000044   0xF002 0x0140      AND      R1,R2,#0x40
   \   00000048   0x70E9             STRB     R1,[R5, #+3]
   2043          
   2044            /* Fill the Date structure fields with the read parameters */
   2045            RTC_StampDateStruct->RTC_Year = 0;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x70F1             STRB     R1,[R6, #+3]
   2046            RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
   \   0000004E   0x0A01             LSRS     R1,R0,#+8
   \   00000050   0xF001 0x011F      AND      R1,R1,#0x1F
   \   00000054   0x7071             STRB     R1,[R6, #+1]
   2047            RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
   \   00000056   0xF000 0x013F      AND      R1,R0,#0x3F
   \   0000005A   0x70B1             STRB     R1,[R6, #+2]
   2048            RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
   \   0000005C   0x0B40             LSRS     R0,R0,#+13
   \   0000005E   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000062   0x7030             STRB     R0,[R6, #+0]
   2049          
   2050            /* Check the input parameters format */
   2051            if (RTC_Format == RTC_Format_BIN)
   \   00000064   0x2C00             CMP      R4,#+0
   \   00000066   0xD117             BNE.N    ??RTC_GetTimeStamp_1
   2052            {
   2053              /* Convert the Time structure parameters to Binary format */
   2054              RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
   \   00000068   0x7828             LDRB     R0,[R5, #+0]
   \   0000006A   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000006E   0x7028             STRB     R0,[R5, #+0]
   2055              RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
   \   00000070   0x7868             LDRB     R0,[R5, #+1]
   \   00000072   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000076   0x7068             STRB     R0,[R5, #+1]
   2056              RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
   \   00000078   0x78A8             LDRB     R0,[R5, #+2]
   \   0000007A   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000007E   0x70A8             STRB     R0,[R5, #+2]
   2057          
   2058              /* Convert the Date structure parameters to Binary format */
   2059              RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
   \   00000080   0x7870             LDRB     R0,[R6, #+1]
   \   00000082   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000086   0x7070             STRB     R0,[R6, #+1]
   2060              RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
   \   00000088   0x78B0             LDRB     R0,[R6, #+2]
   \   0000008A   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   0000008E   0x70B0             STRB     R0,[R6, #+2]
   2061              RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
   \   00000090   0x7830             LDRB     R0,[R6, #+0]
   \   00000092   0x.... 0x....      BL       _Z14RTC_Bcd2ToByteh
   \   00000096   0x7030             STRB     R0,[R6, #+0]
   2062            }
   2063          }
   \                     ??RTC_GetTimeStamp_1: (+1)
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return
   2064          
   2065          /**
   2066            * @brief  Get the RTC timestamp Sub seconds value.
   2067            * @param  None
   2068            * @retval RTC current timestamp Sub seconds value.
   2069            */

   \                                 In section .text, align 2, keep-with-next
   2070          uint32_t RTC_GetTimeStampSubSecond(void)
   2071          {
   2072            /* Get timestamp sub seconds values from the correspondent registers */
   2073            return (uint32_t)(RTC->TSSSR);
   \                     RTC_GetTimeStampSubSecond: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable51_8  ;; 0x40002838
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   2074          }
   2075          
   2076          /**
   2077            * @}
   2078            */
   2079          
   2080          /** @defgroup RTC_Group9 Tampers configuration functions
   2081           *  @brief   Tampers configuration functions 
   2082           *
   2083          @verbatim   
   2084           ===============================================================================
   2085                           ##### Tampers configuration functions #####
   2086           ===============================================================================  
   2087          
   2088          @endverbatim
   2089            * @{
   2090            */
   2091          
   2092          /**
   2093            * @brief  Configures the select Tamper pin edge.
   2094            * @param  RTC_Tamper: Selected tamper pin.
   2095            *          This parameter can be RTC_Tamper_1.
   2096            * @param  RTC_TamperTrigger: Specifies the trigger on the tamper pin that 
   2097            *         stimulates tamper event. 
   2098            *   This parameter can be one of the following values:
   2099            *     @arg RTC_TamperTrigger_RisingEdge: Rising Edge of the tamper pin causes tamper event.
   2100            *     @arg RTC_TamperTrigger_FallingEdge: Falling Edge of the tamper pin causes tamper event.
   2101            *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
   2102            *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
   2103            * @retval None
   2104            */

   \                                 In section .text, align 2, keep-with-next
   2105          void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
   2106          {
   \                     RTC_TamperTriggerConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2107            /* Check the parameters */
   2108            assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TamperTriggerConfig_0
   \   0000000A   0xF640 0x013C      MOVW     R1,#+2108
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   2109            assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
   \                     ??RTC_TamperTriggerConfig_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD00B             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD009             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RTC_TamperTriggerConfig_1
   \   00000026   0xF640 0x013D      MOVW     R1,#+2109
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   2110           
   2111            if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
   \                     ??RTC_TamperTriggerConfig_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable51_9  ;; 0x40002840
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x680A             LDR      R2,[R1, #+0]
   \   0000003A   0xD103             BNE.N    ??RTC_TamperTriggerConfig_2
   2112            {  
   2113              /* Configure the RTC_TAFCR register */
   2114              RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
   \   0000003C   0xEA22 0x0044      BIC      R0,R2,R4, LSL #+1
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}
   2115            }
   2116            else
   2117            { 
   2118              /* Configure the RTC_TAFCR register */
   2119              RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
   \                     ??RTC_TamperTriggerConfig_2: (+1)
   \   00000044   0xEA52 0x0044      ORRS     R0,R2,R4, LSL #+1
   \   00000048   0x6008             STR      R0,[R1, #+0]
   2120            }  
   2121          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2122          
   2123          /**
   2124            * @brief  Enables or Disables the Tamper detection.
   2125            * @param  RTC_Tamper: Selected tamper pin.
   2126            *          This parameter can be RTC_Tamper_1.
   2127            * @param  NewState: new state of the tamper pin.
   2128            *          This parameter can be: ENABLE or DISABLE.                   
   2129            * @retval None
   2130            */

   \                                 In section .text, align 2, keep-with-next
   2131          void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
   2132          {
   \                     RTC_TamperCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2133            /* Check the parameters */
   2134            assert_param(IS_RTC_TAMPER(RTC_Tamper));  
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TamperCmd_0
   \   0000000A   0xF640 0x0156      MOVW     R1,#+2134
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   2135            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_TamperCmd_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD007             BEQ.N    ??RTC_TamperCmd_1
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD005             BEQ.N    ??RTC_TamperCmd_1
   \   0000001E   0xF640 0x0157      MOVW     R1,#+2135
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
   2136            
   2137            if (NewState != DISABLE)
   \                     ??RTC_TamperCmd_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable51_9  ;; 0x40002840
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0xD002             BEQ.N    ??RTC_TamperCmd_2
   2138            {
   2139              /* Enable the selected Tamper pin */
   2140              RTC->TAFCR |= (uint32_t)RTC_Tamper;
   \   00000034   0x4321             ORRS     R1,R4,R1
   \   00000036   0x6001             STR      R1,[R0, #+0]
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}
   2141            }
   2142            else
   2143            {
   2144              /* Disable the selected Tamper pin */
   2145              RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
   \                     ??RTC_TamperCmd_2: (+1)
   \   0000003A   0x43A1             BICS     R1,R1,R4
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   2146            }  
   2147          }
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2148          
   2149          /**
   2150            * @brief  Configures the Tampers Filter.
   2151            * @param  RTC_TamperFilter: Specifies the tampers filter.
   2152            *   This parameter can be one of the following values:
   2153            *     @arg RTC_TamperFilter_Disable: Tamper filter is disabled.
   2154            *     @arg RTC_TamperFilter_2Sample: Tamper is activated after 2 consecutive 
   2155            *                                    samples at the active level 
   2156            *     @arg RTC_TamperFilter_4Sample: Tamper is activated after 4 consecutive 
   2157            *                                    samples at the active level
   2158            *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
   2159            *                                    samples at the active level 
   2160            * @retval None
   2161            */

   \                                 In section .text, align 2, keep-with-next
   2162          void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
   2163          {
   \                     RTC_TamperFilterConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2164            /* Check the parameters */
   2165            assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   \   00000004   0xD00E             BEQ.N    ??RTC_TamperFilterConfig_0
   \   00000006   0xF5B4 0x6F00      CMP      R4,#+2048
   \   0000000A   0xD00B             BEQ.N    ??RTC_TamperFilterConfig_0
   \   0000000C   0xF5B4 0x5F80      CMP      R4,#+4096
   \   00000010   0xD008             BEQ.N    ??RTC_TamperFilterConfig_0
   \   00000012   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   00000016   0xD005             BEQ.N    ??RTC_TamperFilterConfig_0
   \   00000018   0xF640 0x0175      MOVW     R1,#+2165
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   2166             
   2167            /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
   2168            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
   \                     ??RTC_TamperFilterConfig_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable51_9  ;; 0x40002840
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF421 0x51C0      BIC      R1,R1,#0x1800
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   2169          
   2170            /* Configure the RTC_TAFCR register */
   2171            RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x4321             ORRS     R1,R4,R1
   \   00000034   0x6001             STR      R1,[R0, #+0]
   2172          }
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   2173          
   2174          /**
   2175            * @brief  Configures the Tampers Sampling Frequency.
   2176            * @param  RTC_TamperSamplingFreq: Specifies the tampers Sampling Frequency.
   2177            *   This parameter can be one of the following values:
   2178            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div32768: Each of the tamper inputs are sampled
   2179            *                                           with a frequency =  RTCCLK / 32768
   2180            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div16384: Each of the tamper inputs are sampled
   2181            *                                           with a frequency =  RTCCLK / 16384
   2182            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div8192: Each of the tamper inputs are sampled
   2183            *                                           with a frequency =  RTCCLK / 8192
   2184            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div4096: Each of the tamper inputs are sampled
   2185            *                                           with a frequency =  RTCCLK / 4096
   2186            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div2048: Each of the tamper inputs are sampled
   2187            *                                           with a frequency =  RTCCLK / 2048
   2188            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div1024: Each of the tamper inputs are sampled
   2189            *                                           with a frequency =  RTCCLK / 1024
   2190            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div512: Each of the tamper inputs are sampled
   2191            *                                           with a frequency =  RTCCLK / 512  
   2192            *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
   2193            *                                           with a frequency =  RTCCLK / 256  
   2194            * @retval None
   2195            */

   \                                 In section .text, align 2, keep-with-next
   2196          void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
   2197          {
   \                     RTC_TamperSamplingFreqConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2198            /* Check the parameters */
   2199            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
   \   00000004   0xD01A             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000006   0xF5B4 0x7F80      CMP      R4,#+256
   \   0000000A   0xD017             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   0000000C   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000010   0xD014             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000012   0xF5B4 0x7F40      CMP      R4,#+768
   \   00000016   0xD011             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000018   0xF5B4 0x6F80      CMP      R4,#+1024
   \   0000001C   0xD00E             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   0000001E   0xF5B4 0x6FA0      CMP      R4,#+1280
   \   00000022   0xD00B             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000024   0xF5B4 0x6FC0      CMP      R4,#+1536
   \   00000028   0xD008             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   0000002A   0xF5B4 0x6FE0      CMP      R4,#+1792
   \   0000002E   0xD005             BEQ.N    ??RTC_TamperSamplingFreqConfig_0
   \   00000030   0xF640 0x0197      MOVW     R1,#+2199
   \   00000034   0x.... 0x....      ADR.W    R0,?_0
   \   00000038   0x.... 0x....      BL       assert_failed
   2200           
   2201            /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
   2202            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
   \                     ??RTC_TamperSamplingFreqConfig_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable51_9  ;; 0x40002840
   \   00000040   0x6801             LDR      R1,[R0, #+0]
   \   00000042   0xF421 0x61E0      BIC      R1,R1,#0x700
   \   00000046   0x6001             STR      R1,[R0, #+0]
   2203          
   2204            /* Configure the RTC_TAFCR register */
   2205            RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
   \   00000048   0x6801             LDR      R1,[R0, #+0]
   \   0000004A   0x4321             ORRS     R1,R4,R1
   \   0000004C   0x6001             STR      R1,[R0, #+0]
   2206          }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   2207          
   2208          /**
   2209            * @brief  Configures the Tampers Pins input Precharge Duration.
   2210            * @param  RTC_TamperPrechargeDuration: Specifies the Tampers Pins input
   2211            *         Precharge Duration.
   2212            *   This parameter can be one of the following values:
   2213            *     @arg RTC_TamperPrechargeDuration_1RTCCLK: Tamper pins are precharged before sampling during 1 RTCCLK cycle
   2214            *     @arg RTC_TamperPrechargeDuration_2RTCCLK: Tamper pins are precharged before sampling during 2 RTCCLK cycle
   2215            *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are precharged before sampling during 4 RTCCLK cycle    
   2216            *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are precharged before sampling during 8 RTCCLK cycle
   2217            * @retval None
   2218            */

   \                                 In section .text, align 2, keep-with-next
   2219          void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
   2220          {
   \                     RTC_TamperPinsPrechargeDuration: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2221            /* Check the parameters */
   2222            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   \   00000004   0xD00E             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   00000006   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000000A   0xD00B             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   0000000C   0xF5B4 0x4F80      CMP      R4,#+16384
   \   00000010   0xD008             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   00000012   0xF5B4 0x4FC0      CMP      R4,#+24576
   \   00000016   0xD005             BEQ.N    ??RTC_TamperPinsPrechargeDuration_0
   \   00000018   0xF640 0x01AE      MOVW     R1,#+2222
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   2223             
   2224            /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
   2225            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
   \                     ??RTC_TamperPinsPrechargeDuration_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable51_9  ;; 0x40002840
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xF421 0x41C0      BIC      R1,R1,#0x6000
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   2226          
   2227            /* Configure the RTC_TAFCR register */
   2228            RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0x4321             ORRS     R1,R4,R1
   \   00000034   0x6001             STR      R1,[R0, #+0]
   2229          }
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
   2230          
   2231          /**
   2232            * @brief  Enables or Disables the TimeStamp on Tamper Detection Event.
   2233            * @note   The timestamp is valid even the TSE bit in tamper control register 
   2234            *         is reset.   
   2235            * @param  NewState: new state of the timestamp on tamper event.
   2236            *         This parameter can be: ENABLE or DISABLE.
   2237            * @retval None
   2238            */

   \                                 In section .text, align 2, keep-with-next
   2239          void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
   2240          {
   \                     RTC_TimeStampOnTamperDetectionCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2241            /* Check the parameters */
   2242            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RTC_TimeStampOnTamperDetectionCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TimeStampOnTamperDetectionCmd_0
   \   0000000A   0xF640 0x01C2      MOVW     R1,#+2242
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   2243             
   2244            if (NewState != DISABLE)
   \                     ??RTC_TimeStampOnTamperDetectionCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_9  ;; 0x40002840
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??RTC_TimeStampOnTamperDetectionCmd_1
   2245            {
   2246              /* Save timestamp on tamper detection event */
   2247              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
   \   00000020   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
   2248            }
   2249            else
   2250            {
   2251              /* Tamper detection does not cause a timestamp to be saved */
   2252              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
   \                     ??RTC_TimeStampOnTamperDetectionCmd_1: (+1)
   \   00000028   0xF021 0x0180      BIC      R1,R1,#0x80
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   2253            }
   2254          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2255          
   2256          /**
   2257            * @brief  Enables or Disables the Precharge of Tamper pin.
   2258            * @param  NewState: new state of tamper pull up.
   2259            *   This parameter can be: ENABLE or DISABLE.                   
   2260            * @retval None
   2261            */

   \                                 In section .text, align 2, keep-with-next
   2262          void RTC_TamperPullUpCmd(FunctionalState NewState)
   2263          {
   \                     RTC_TamperPullUpCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2264            /* Check the parameters */
   2265            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RTC_TamperPullUpCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RTC_TamperPullUpCmd_0
   \   0000000A   0xF640 0x01D9      MOVW     R1,#+2265
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   2266            
   2267           if (NewState != DISABLE)
   \                     ??RTC_TamperPullUpCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_9  ;; 0x40002840
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??RTC_TamperPullUpCmd_1
   2268            {
   2269              /* Enable precharge of the selected Tamper pin */
   2270              RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
   \   00000020   0xF421 0x4100      BIC      R1,R1,#0x8000
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
   2271            }
   2272            else
   2273            {
   2274              /* Disable precharge of the selected Tamper pin */
   2275              RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
   \                     ??RTC_TamperPullUpCmd_1: (+1)
   \   00000028   0xF441 0x4100      ORR      R1,R1,#0x8000
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   2276            } 
   2277          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   2278          
   2279          /**
   2280            * @}
   2281            */
   2282          
   2283          /** @defgroup RTC_Group10 Backup Data Registers configuration functions
   2284           *  @brief   Backup Data Registers configuration functions  
   2285           *
   2286          @verbatim   
   2287           ===============================================================================
   2288                       ##### Backup Data Registers configuration functions ##### 
   2289           ===============================================================================  
   2290          
   2291          @endverbatim
   2292            * @{
   2293            */
   2294          
   2295          /**
   2296            * @brief  Writes a data in a specified RTC Backup data register.
   2297            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2298            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2299            *                          specify the register.
   2300            * @param  Data: Data to be written in the specified RTC Backup data register.                     
   2301            * @retval None
   2302            */

   \                                 In section .text, align 2, keep-with-next
   2303          void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
   2304          {
   \                     RTC_WriteBackupRegister: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
   2305            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2306            
   2307            /* Check the parameters */
   2308            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD02B             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xD029             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000012   0x2D02             CMP      R5,#+2
   \   00000014   0xD027             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000016   0x2D03             CMP      R5,#+3
   \   00000018   0xD025             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000001A   0x2D04             CMP      R5,#+4
   \   0000001C   0xD023             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000001E   0x2D05             CMP      R5,#+5
   \   00000020   0xD021             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000022   0x2D06             CMP      R5,#+6
   \   00000024   0xD01F             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000026   0x2D07             CMP      R5,#+7
   \   00000028   0xD01D             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000002A   0x2D08             CMP      R5,#+8
   \   0000002C   0xD01B             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000002E   0x2D09             CMP      R5,#+9
   \   00000030   0xD019             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000032   0x2D0A             CMP      R5,#+10
   \   00000034   0xD017             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000036   0x2D0B             CMP      R5,#+11
   \   00000038   0xD015             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000003A   0x2D0C             CMP      R5,#+12
   \   0000003C   0xD013             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000003E   0x2D0D             CMP      R5,#+13
   \   00000040   0xD011             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000042   0x2D0E             CMP      R5,#+14
   \   00000044   0xD00F             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000046   0x2D0F             CMP      R5,#+15
   \   00000048   0xD00D             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000004A   0x2D10             CMP      R5,#+16
   \   0000004C   0xD00B             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000004E   0x2D11             CMP      R5,#+17
   \   00000050   0xD009             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000052   0x2D12             CMP      R5,#+18
   \   00000054   0xD007             BEQ.N    ??RTC_WriteBackupRegister_0
   \   00000056   0x2D13             CMP      R5,#+19
   \   00000058   0xD005             BEQ.N    ??RTC_WriteBackupRegister_0
   \   0000005A   0xF640 0x1104      MOVW     R1,#+2308
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
   2309          
   2310            tmp = RTC_BASE + 0x50;
   \                     ??RTC_WriteBackupRegister_0: (+1)
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable51_10  ;; 0x40002850
   \   0000006A   0x9000             STR      R0,[SP, #+0]
   2311            tmp += (RTC_BKP_DR * 4);
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000072   0x9000             STR      R0,[SP, #+0]
   2312          
   2313            /* Write the specified register */
   2314            *(__IO uint32_t *)tmp = (uint32_t)Data;
   \   00000074   0x9800             LDR      R0,[SP, #+0]
   \   00000076   0x6004             STR      R4,[R0, #+0]
   2315          }
   \   00000078   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2316          
   2317          /**
   2318            * @brief  Reads data from the specified RTC Backup data Register.
   2319            * @param  RTC_BKP_DR: RTC Backup data Register number.
   2320            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   2321            *                          specify the register.                   
   2322            * @retval None
   2323            */

   \                                 In section .text, align 2, keep-with-next
   2324          uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
   2325          {
   \                     RTC_ReadBackupRegister: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   2326            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   2327            
   2328            /* Check the parameters */
   2329            assert_param(IS_RTC_BKP(RTC_BKP_DR));
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD02B             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD029             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000012   0x2C02             CMP      R4,#+2
   \   00000014   0xD027             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000016   0x2C03             CMP      R4,#+3
   \   00000018   0xD025             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000001A   0x2C04             CMP      R4,#+4
   \   0000001C   0xD023             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000001E   0x2C05             CMP      R4,#+5
   \   00000020   0xD021             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000022   0x2C06             CMP      R4,#+6
   \   00000024   0xD01F             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000026   0x2C07             CMP      R4,#+7
   \   00000028   0xD01D             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000002A   0x2C08             CMP      R4,#+8
   \   0000002C   0xD01B             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000002E   0x2C09             CMP      R4,#+9
   \   00000030   0xD019             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000032   0x2C0A             CMP      R4,#+10
   \   00000034   0xD017             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000036   0x2C0B             CMP      R4,#+11
   \   00000038   0xD015             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000003A   0x2C0C             CMP      R4,#+12
   \   0000003C   0xD013             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000003E   0x2C0D             CMP      R4,#+13
   \   00000040   0xD011             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000042   0x2C0E             CMP      R4,#+14
   \   00000044   0xD00F             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000046   0x2C0F             CMP      R4,#+15
   \   00000048   0xD00D             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000004A   0x2C10             CMP      R4,#+16
   \   0000004C   0xD00B             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000004E   0x2C11             CMP      R4,#+17
   \   00000050   0xD009             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000052   0x2C12             CMP      R4,#+18
   \   00000054   0xD007             BEQ.N    ??RTC_ReadBackupRegister_0
   \   00000056   0x2C13             CMP      R4,#+19
   \   00000058   0xD005             BEQ.N    ??RTC_ReadBackupRegister_0
   \   0000005A   0xF640 0x1119      MOVW     R1,#+2329
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
   2330          
   2331            tmp = RTC_BASE + 0x50;
   \                     ??RTC_ReadBackupRegister_0: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable51_10  ;; 0x40002850
   \   00000068   0x9000             STR      R0,[SP, #+0]
   2332            tmp += (RTC_BKP_DR * 4);
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000070   0x9000             STR      R0,[SP, #+0]
   2333            
   2334            /* Read the specified register */
   2335            return (*(__IO uint32_t *)tmp);
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2336          }
   2337          
   2338          /**
   2339            * @}
   2340            */
   2341          
   2342          /** @defgroup RTC_Group11 RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions
   2343           *  @brief   RTC Tamper and TimeStamp Pins Selection and Output Type Config 
   2344           *           configuration functions  
   2345           *
   2346          @verbatim   
   2347           ==================================================================================================
   2348           ##### RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration functions ##### 
   2349           ==================================================================================================  
   2350          
   2351          @endverbatim
   2352            * @{
   2353            */
   2354          
   2355          /**
   2356            * @brief  Selects the RTC Tamper Pin.
   2357            * @param  RTC_TamperPin: specifies the RTC Tamper Pin.
   2358            *          This parameter can be one of the following values:
   2359            *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
   2360            *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
   2361            * @retval None
   2362            */

   \                                 In section .text, align 2, keep-with-next
   2363          void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
   2364          {
   \                     RTC_TamperPinSelection: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2365            /* Check the parameters */
   2366            assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
   \   00000004   0xD008             BEQ.N    ??RTC_TamperPinSelection_0
   \   00000006   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000000A   0xD005             BEQ.N    ??RTC_TamperPinSelection_0
   \   0000000C   0xF640 0x113E      MOVW     R1,#+2366
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   2367            
   2368            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
   \                     ??RTC_TamperPinSelection_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable51_9  ;; 0x40002840
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   00000020   0x6001             STR      R1,[R0, #+0]
   2369            RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x4321             ORRS     R1,R4,R1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2370          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   2371          
   2372          /**
   2373            * @brief  Selects the RTC TimeStamp Pin.
   2374            * @param  RTC_TimeStampPin: specifies the RTC TimeStamp Pin.
   2375            *          This parameter can be one of the following values:
   2376            *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
   2377            *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
   2378            * @retval None
   2379            */

   \                                 In section .text, align 2, keep-with-next
   2380          void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
   2381          {
   \                     RTC_TimeStampPinSelection: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2382            /* Check the parameters */
   2383            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
   \   00000004   0xD008             BEQ.N    ??RTC_TimeStampPinSelection_0
   \   00000006   0xF5B4 0x3F00      CMP      R4,#+131072
   \   0000000A   0xD005             BEQ.N    ??RTC_TimeStampPinSelection_0
   \   0000000C   0xF640 0x114F      MOVW     R1,#+2383
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   2384            
   2385            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
   \                     ??RTC_TimeStampPinSelection_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable51_9  ;; 0x40002840
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF421 0x3100      BIC      R1,R1,#0x20000
   \   00000020   0x6001             STR      R1,[R0, #+0]
   2386            RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x4321             ORRS     R1,R4,R1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2387          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   2388          
   2389          /**
   2390            * @brief  Configures the RTC Output Pin mode. 
   2391            * @param  RTC_OutputType: specifies the RTC Output (PC13) pin mode.
   2392            *          This parameter can be one of the following values:
   2393            *            @arg RTC_OutputType_OpenDrain: RTC Output (PC13) is configured in 
   2394            *                                    Open Drain mode.
   2395            *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
   2396            *                                    Push Pull mode.    
   2397            * @retval None
   2398            */

   \                                 In section .text, align 2, keep-with-next
   2399          void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
   2400          {
   \                     RTC_OutputTypeConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2401            /* Check the parameters */
   2402            assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
   \   00000004   0xD008             BEQ.N    ??RTC_OutputTypeConfig_0
   \   00000006   0xF5B4 0x2F80      CMP      R4,#+262144
   \   0000000A   0xD005             BEQ.N    ??RTC_OutputTypeConfig_0
   \   0000000C   0xF640 0x1162      MOVW     R1,#+2402
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   2403            
   2404            RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
   \                     ??RTC_OutputTypeConfig_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable51_9  ;; 0x40002840
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   00000020   0x6001             STR      R1,[R0, #+0]
   2405            RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x4321             ORRS     R1,R4,R1
   \   00000026   0x6001             STR      R1,[R0, #+0]
   2406          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   2407          
   2408          /**
   2409            * @}
   2410            */
   2411          
   2412          /** @defgroup RTC_Group12 Shift control synchronisation functions
   2413           *  @brief   Shift control synchronisation functions 
   2414           *
   2415          @verbatim   
   2416           ===============================================================================
   2417                        ##### Shift control synchronisation functions #####
   2418           ===============================================================================  
   2419          
   2420          @endverbatim
   2421            * @{
   2422            */
   2423          
   2424          /**
   2425            * @brief  Configures the Synchronization Shift Control Settings.
   2426            * @note   When REFCKON is set, firmware must not write to Shift control register 
   2427            * @param  RTC_ShiftAdd1S : Select to add or not 1 second to the time Calendar.
   2428            *   This parameter can be one of the following values :
   2429            *     @arg RTC_ShiftAdd1S_Set  : Add one second to the clock calendar. 
   2430            *     @arg RTC_ShiftAdd1S_Reset: No effect.
   2431            * @param  RTC_ShiftSubFS: Select the number of Second Fractions to Substitute.
   2432            *         This parameter can be one any value from 0 to 0x7FFF.
   2433            * @retval An ErrorStatus enumeration value:
   2434            *          - SUCCESS: RTC Shift registers are configured
   2435            *          - ERROR: RTC Shift registers are not configured
   2436          */

   \                                 In section .text, align 2, keep-with-next
   2437          ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
   2438          {
   \                     RTC_SynchroShiftConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   2439            ErrorStatus status = ERROR;
   \   00000008   0x2600             MOVS     R6,#+0
   2440            uint32_t shpfcount = 0;
   \   0000000A   0x4637             MOV      R7,R6
   2441          
   2442            /* Check the parameters */
   2443            assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??RTC_SynchroShiftConfig_0
   \   00000010   0xF1B4 0x4F00      CMP      R4,#-2147483648
   \   00000014   0xD005             BEQ.N    ??RTC_SynchroShiftConfig_0
   \   00000016   0xF640 0x118B      MOVW     R1,#+2443
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       assert_failed
   2444            assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
   \                     ??RTC_SynchroShiftConfig_0: (+1)
   \   00000022   0xF5B5 0x4F00      CMP      R5,#+32768
   \   00000026   0xD305             BCC.N    ??RTC_SynchroShiftConfig_1
   \   00000028   0xF640 0x118C      MOVW     R1,#+2444
   \   0000002C   0x.... 0x....      ADR.W    R0,?_0
   \   00000030   0x.... 0x....      BL       assert_failed
   2445          
   2446            /* Disable the write protection for RTC registers */
   2447            RTC->WPR = 0xCA;
   \                     ??RTC_SynchroShiftConfig_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R8,??DataTable51_1  ;; 0x40002808
   \   00000038   0x20CA             MOVS     R0,#+202
   \   0000003A   0xF8C8 0x001C      STR      R0,[R8, #+28]
   2448            RTC->WPR = 0x53;
   \   0000003E   0x2053             MOVS     R0,#+83
   \   00000040   0xF8C8 0x001C      STR      R0,[R8, #+28]
   2449            
   2450            /* Check if a Shift is pending*/
   2451            if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
   \   00000044   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000048   0x0700             LSLS     R0,R0,#+28
   \   0000004A   0xD401             BMI.N    ??RTC_SynchroShiftConfig_2
   \   0000004C   0xE007             B.N      ??RTC_SynchroShiftConfig_3
   2452            {
   2453              /* Wait until the shift is completed*/
   2454              while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
   2455              {
   2456                shpfcount++;
   \                     ??RTC_SynchroShiftConfig_4: (+1)
   \   0000004E   0x1C7F             ADDS     R7,R7,#+1
   2457              }
   \                     ??RTC_SynchroShiftConfig_2: (+1)
   \   00000050   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000054   0x0700             LSLS     R0,R0,#+28
   \   00000056   0xD502             BPL.N    ??RTC_SynchroShiftConfig_3
   \   00000058   0xF5B7 0x5F80      CMP      R7,#+4096
   \   0000005C   0xD1F7             BNE.N    ??RTC_SynchroShiftConfig_4
   2458            }
   2459          
   2460            /* Check if the Shift pending is completed or if there is no Shift operation at all*/
   2461            if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
   \                     ??RTC_SynchroShiftConfig_3: (+1)
   \   0000005E   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000062   0x0700             LSLS     R0,R0,#+28
   \   00000064   0xD40C             BMI.N    ??RTC_SynchroShiftConfig_5
   2462            {
   2463              /* check if the reference clock detection is disabled */
   2464              if((RTC->CR & RTC_CR_REFCKON) == RESET)
   \   00000066   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000006A   0x06C0             LSLS     R0,R0,#+27
   \   0000006C   0xD408             BMI.N    ??RTC_SynchroShiftConfig_5
   2465              {
   2466                /* Configure the Shift settings */
   2467                RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
   \   0000006E   0xEA44 0x0005      ORR      R0,R4,R5
   \   00000072   0xF8C8 0x0024      STR      R0,[R8, #+36]
   2468              
   2469                if(RTC_WaitForSynchro() == ERROR)
   \   00000076   0x.... 0x....      BL       RTC_WaitForSynchro
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD000             BEQ.N    ??RTC_SynchroShiftConfig_5
   2470                {
   2471                  status = ERROR;
   2472                }
   2473                else
   2474                {
   2475                  status = SUCCESS;
   \   0000007E   0x2601             MOVS     R6,#+1
   2476                }
   2477              }
   2478              else
   2479              {
   2480                status = ERROR;
   2481              }
   2482            }
   2483            else
   2484            {
   2485              status = ERROR;
   2486            }
   2487          
   2488            /* Enable the write protection for RTC registers */
   2489            RTC->WPR = 0xFF;
   \                     ??RTC_SynchroShiftConfig_5: (+1)
   \   00000080   0x20FF             MOVS     R0,#+255
   \   00000082   0xF8C8 0x001C      STR      R0,[R8, #+28]
   2490            
   2491            return (ErrorStatus)(status);
   \   00000086   0x4630             MOV      R0,R6
   \   00000088   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2492          }
   2493          
   2494          /**
   2495            * @}
   2496            */
   2497          
   2498          /** @defgroup RTC_Group13 Interrupts and flags management functions
   2499           *  @brief   Interrupts and flags management functions  
   2500           *
   2501          @verbatim   
   2502           ===============================================================================
   2503                        ##### Interrupts and flags management functions #####
   2504           ===============================================================================  
   2505           [..] All RTC interrupts are connected to the EXTI controller.
   2506           
   2507             (+) To enable the RTC Alarm interrupt, the following sequence is required:
   2508                 (++) Configure and enable the EXTI Line 17 in interrupt mode and select 
   2509                      the rising edge sensitivity using the EXTI_Init() function.
   2510                 (++) Configure and enable the RTC_Alarm IRQ channel in the NVIC using the 
   2511                      NVIC_Init() function.
   2512                 (++) Configure the RTC to generate RTC alarms (Alarm A and/or Alarm B) using
   2513                      the RTC_SetAlarm() and RTC_AlarmCmd() functions.
   2514          
   2515             (+) To enable the RTC Wakeup interrupt, the following sequence is required:
   2516                 (++) Configure and enable the EXTI Line 22 in interrupt mode and select the
   2517                      rising edge sensitivity using the EXTI_Init() function.
   2518                 (++) Configure and enable the RTC_WKUP IRQ channel in the NVIC using the 
   2519                      NVIC_Init() function.
   2520                 (++) Configure the RTC to generate the RTC wakeup timer event using the 
   2521                      RTC_WakeUpClockConfig(), RTC_SetWakeUpCounter() and RTC_WakeUpCmd() 
   2522                      functions.
   2523          
   2524             (+) To enable the RTC Tamper interrupt, the following sequence is required:
   2525                 (++) Configure and enable the EXTI Line 21 in interrupt mode and select 
   2526                      the rising edge sensitivity using the EXTI_Init() function.
   2527                 (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the
   2528                      NVIC_Init() function.
   2529                 (++) Configure the RTC to detect the RTC tamper event using the 
   2530                      RTC_TamperTriggerConfig() and RTC_TamperCmd() functions.
   2531          
   2532             (+) To enable the RTC TimeStamp interrupt, the following sequence is required:
   2533                 (++) Configure and enable the EXTI Line 21 in interrupt mode and select the
   2534                      rising edge sensitivity using the EXTI_Init() function.
   2535                 (++) Configure and enable the TAMP_STAMP IRQ channel in the NVIC using the 
   2536                      NVIC_Init() function.
   2537                 (++) Configure the RTC to detect the RTC time stamp event using the 
   2538                      RTC_TimeStampCmd() functions.
   2539          
   2540          @endverbatim
   2541            * @{
   2542            */
   2543          
   2544          /**
   2545            * @brief  Enables or disables the specified RTC interrupts.
   2546            * @param  RTC_IT: specifies the RTC interrupt sources to be enabled or disabled. 
   2547            *          This parameter can be any combination of the following values:
   2548            *            @arg RTC_IT_TS:  Time Stamp interrupt mask
   2549            *            @arg RTC_IT_WUT:  WakeUp Timer interrupt mask
   2550            *            @arg RTC_IT_ALRB:  Alarm B interrupt mask
   2551            *            @arg RTC_IT_ALRA:  Alarm A interrupt mask
   2552            *            @arg RTC_IT_TAMP: Tamper event interrupt mask
   2553            * @param  NewState: new state of the specified RTC interrupts.
   2554            *          This parameter can be: ENABLE or DISABLE.
   2555            * @retval None
   2556            */

   \                                 In section .text, align 2, keep-with-next
   2557          void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
   2558          {
   \                     RTC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2559            /* Check the parameters */
   2560            assert_param(IS_RTC_CONFIG_IT(RTC_IT));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??RTC_ITConfig_0
   \   0000000A   0x....             LDR.N    R0,??DataTable51_11  ;; 0xffff0ffb
   \   0000000C   0x4204             TST      R4,R0
   \   0000000E   0xD005             BEQ.N    ??RTC_ITConfig_1
   \                     ??RTC_ITConfig_0: (+1)
   \   00000010   0xF44F 0x6120      MOV      R1,#+2560
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   2561            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RTC_ITConfig_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RTC_ITConfig_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RTC_ITConfig_2
   \   00000024   0xF640 0x2101      MOVW     R1,#+2561
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   2562          
   2563            /* Disable the write protection for RTC registers */
   2564            RTC->WPR = 0xCA;
   \                     ??RTC_ITConfig_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable51_1  ;; 0x40002808
   \   00000032   0x21CA             MOVS     R1,#+202
   \   00000034   0x61C1             STR      R1,[R0, #+28]
   2565            RTC->WPR = 0x53;
   \   00000036   0x2153             MOVS     R1,#+83
   \   00000038   0x61C1             STR      R1,[R0, #+28]
   2566          
   2567            if (NewState != DISABLE)
   \   0000003A   0xF004 0x0104      AND      R1,R4,#0x4
   \   0000003E   0xF024 0x0204      BIC      R2,R4,#0x4
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0x6803             LDR      R3,[R0, #+0]
   \   00000046   0xD005             BEQ.N    ??RTC_ITConfig_3
   2568            {
   2569              /* Configure the Interrupts in the RTC_CR register */
   2570              RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
   \   00000048   0x431A             ORRS     R2,R2,R3
   \   0000004A   0x6002             STR      R2,[R0, #+0]
   2571              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2572              RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
   \   0000004C   0x6B82             LDR      R2,[R0, #+56]
   \   0000004E   0x4311             ORRS     R1,R1,R2
   \   00000050   0x6381             STR      R1,[R0, #+56]
   \   00000052   0xE006             B.N      ??RTC_ITConfig_4
   2573            }
   2574            else
   2575            {
   2576              /* Configure the Interrupts in the RTC_CR register */
   2577              RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
   \                     ??RTC_ITConfig_3: (+1)
   \   00000054   0xEA23 0x0202      BIC      R2,R3,R2
   \   00000058   0x6002             STR      R2,[R0, #+0]
   2578              /* Configure the Tamper Interrupt in the RTC_TAFCR */
   2579              RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
   \   0000005A   0x6B82             LDR      R2,[R0, #+56]
   \   0000005C   0xEA22 0x0101      BIC      R1,R2,R1
   \   00000060   0x6381             STR      R1,[R0, #+56]
   2580            }
   2581            /* Enable the write protection for RTC registers */
   2582            RTC->WPR = 0xFF; 
   \                     ??RTC_ITConfig_4: (+1)
   \   00000062   0x21FF             MOVS     R1,#+255
   \   00000064   0x61C1             STR      R1,[R0, #+28]
   2583          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2584          
   2585          /**
   2586            * @brief  Checks whether the specified RTC flag is set or not.
   2587            * @param  RTC_FLAG: specifies the flag to check.
   2588            *          This parameter can be one of the following values:
   2589            *            @arg RTC_FLAG_RECALPF: RECALPF event flag.
   2590            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2591            *            @arg RTC_FLAG_TSOVF: Time Stamp OverFlow flag
   2592            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2593            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2594            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2595            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2596            *            @arg RTC_FLAG_INITF: Initialization mode flag
   2597            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2598            *            @arg RTC_FLAG_INITS: Registers Configured flag
   2599            *            @arg RTC_FLAG_SHPF: Shift operation pending flag.
   2600            *            @arg RTC_FLAG_WUTWF: WakeUp Timer Write flag
   2601            *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
   2602            *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
   2603            * @retval The new state of RTC_FLAG (SET or RESET).
   2604            */

   \                                 In section .text, align 2, keep-with-next
   2605          FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
   2606          {
   \                     RTC_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2607            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   2608            uint32_t tmpreg = 0;
   2609            
   2610            /* Check the parameters */
   2611            assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
   \   00000006   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000000A   0xD023             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000000C   0xF5B4 0x6F00      CMP      R4,#+2048
   \   00000010   0xD020             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000012   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000016   0xD01D             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000018   0xF5B4 0x7F00      CMP      R4,#+512
   \   0000001C   0xD01A             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000001E   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000022   0xD017             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000024   0x2C40             CMP      R4,#+64
   \   00000026   0xD015             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000028   0x2C20             CMP      R4,#+32
   \   0000002A   0xD013             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000002C   0x2C04             CMP      R4,#+4
   \   0000002E   0xD011             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000030   0x2C02             CMP      R4,#+2
   \   00000032   0xD00F             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000034   0x2C01             CMP      R4,#+1
   \   00000036   0xD00D             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000038   0xF5B4 0x5F00      CMP      R4,#+8192
   \   0000003C   0xD00A             BEQ.N    ??RTC_GetFlagStatus_0
   \   0000003E   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000042   0xD007             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000044   0x2C08             CMP      R4,#+8
   \   00000046   0xD005             BEQ.N    ??RTC_GetFlagStatus_0
   \   00000048   0xF640 0x2133      MOVW     R1,#+2611
   \   0000004C   0x.... 0x....      ADR.W    R0,?_0
   \   00000050   0x.... 0x....      BL       assert_failed
   2612            
   2613            /* Get all the flags */
   2614            tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
   \                     ??RTC_GetFlagStatus_0: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable51_5  ;; 0x4000280c
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x....             LDR.N    R1,??DataTable51_12  ;; 0x13f7f
   \   0000005A   0x4008             ANDS     R0,R1,R0
   2615            
   2616            /* Return the status of the flag */
   2617            if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
   \   0000005C   0x4220             TST      R0,R4
   \   0000005E   0xD000             BEQ.N    ??RTC_GetFlagStatus_1
   2618            {
   2619              bitstatus = SET;
   \   00000060   0x2501             MOVS     R5,#+1
   2620            }
   2621            else
   2622            {
   2623              bitstatus = RESET;
   2624            }
   2625            return bitstatus;
   \                     ??RTC_GetFlagStatus_1: (+1)
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2626          }
   2627          
   2628          /**
   2629            * @brief  Clears the RTC's pending flags.
   2630            * @param  RTC_FLAG: specifies the RTC flag to clear.
   2631            *          This parameter can be any combination of the following values:
   2632            *            @arg RTC_FLAG_TAMP1F: Tamper 1 event flag
   2633            *            @arg RTC_FLAG_TSOVF: Time Stamp Overflow flag 
   2634            *            @arg RTC_FLAG_TSF: Time Stamp event flag
   2635            *            @arg RTC_FLAG_WUTF: WakeUp Timer flag
   2636            *            @arg RTC_FLAG_ALRBF: Alarm B flag
   2637            *            @arg RTC_FLAG_ALRAF: Alarm A flag
   2638            *            @arg RTC_FLAG_RSF: Registers Synchronized flag
   2639            * @retval None
   2640            */

   \                                 In section .text, align 2, keep-with-next
   2641          void RTC_ClearFlag(uint32_t RTC_FLAG)
   2642          {
   \                     RTC_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2643            /* Check the parameters */
   2644            assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
   \   00000004   0xD002             BEQ.N    ??RTC_ClearFlag_0
   \   00000006   0x....             LDR.N    R0,??DataTable51_13  ;; 0xffff00df
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD005             BEQ.N    ??RTC_ClearFlag_1
   \                     ??RTC_ClearFlag_0: (+1)
   \   0000000C   0xF640 0x2154      MOVW     R1,#+2644
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   2645          
   2646            /* Clear the Flags in the RTC_ISR register */
   2647            RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
   \                     ??RTC_ClearFlag_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable51_5  ;; 0x4000280c
   \   0000001A   0xB2A1             UXTH     R1,R4
   \   0000001C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000020   0x6802             LDR      R2,[R0, #+0]
   \   00000022   0xF002 0x0280      AND      R2,R2,#0x80
   \   00000026   0xEA62 0x0101      ORN      R1,R2,R1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
   2648          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
   2649          
   2650          /**
   2651            * @brief  Checks whether the specified RTC interrupt has occurred or not.
   2652            * @param  RTC_IT: specifies the RTC interrupt source to check.
   2653            *          This parameter can be one of the following values:
   2654            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2655            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2656            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2657            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2658            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2659            * @retval The new state of RTC_IT (SET or RESET).
   2660            */

   \                                 In section .text, align 2, keep-with-next
   2661          ITStatus RTC_GetITStatus(uint32_t RTC_IT)
   2662          {
   \                     RTC_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   2663            ITStatus bitstatus = RESET;
   \   00000004   0x2400             MOVS     R4,#+0
   2664            uint32_t tmpreg = 0, enablestatus = 0;
   2665           
   2666            /* Check the parameters */
   2667            assert_param(IS_RTC_GET_IT(RTC_IT));
   \   00000006   0xF5B5 0x4F00      CMP      R5,#+32768
   \   0000000A   0xD011             BEQ.N    ??RTC_GetITStatus_0
   \   0000000C   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000010   0xD00E             BEQ.N    ??RTC_GetITStatus_0
   \   00000012   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000016   0xD00B             BEQ.N    ??RTC_GetITStatus_0
   \   00000018   0xF5B5 0x5F80      CMP      R5,#+4096
   \   0000001C   0xD008             BEQ.N    ??RTC_GetITStatus_0
   \   0000001E   0xF5B5 0x3F00      CMP      R5,#+131072
   \   00000022   0xD005             BEQ.N    ??RTC_GetITStatus_0
   \   00000024   0xF640 0x216B      MOVW     R1,#+2667
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   2668            
   2669            /* Get the TAMPER Interrupt enable bit and pending bit */
   2670            tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
   \                     ??RTC_GetITStatus_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable51_1  ;; 0x40002808
   \   00000032   0x6B81             LDR      R1,[R0, #+56]
   \   00000034   0xF001 0x0104      AND      R1,R1,#0x4
   2671           
   2672            /* Get the Interrupt enable Status */
   2673            enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
   \   00000038   0x6802             LDR      R2,[R0, #+0]
   \   0000003A   0x402A             ANDS     R2,R5,R2
   \   0000003C   0xEA01 0x31D5      AND      R1,R1,R5, LSR #+15
   \   00000040   0x4311             ORRS     R1,R1,R2
   2674            
   2675            /* Get the Interrupt pending bit */
   2676            tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
   \   00000042   0x6840             LDR      R0,[R0, #+4]
   \   00000044   0xEA00 0x1015      AND      R0,R0,R5, LSR #+4
   2677            
   2678            /* Get the status of the Interrupt */
   2679            if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
   \   00000048   0xD002             BEQ.N    ??RTC_GetITStatus_1
   \   0000004A   0x0400             LSLS     R0,R0,#+16
   \   0000004C   0xD000             BEQ.N    ??RTC_GetITStatus_1
   2680            {
   2681              bitstatus = SET;
   \   0000004E   0x2401             MOVS     R4,#+1
   2682            }
   2683            else
   2684            {
   2685              bitstatus = RESET;
   2686            }
   2687            return bitstatus;
   \                     ??RTC_GetITStatus_1: (+1)
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2688          }
   2689          
   2690          /**
   2691            * @brief  Clears the RTC's interrupt pending bits.
   2692            * @param  RTC_IT: specifies the RTC interrupt pending bit to clear.
   2693            *          This parameter can be any combination of the following values:
   2694            *            @arg RTC_IT_TS: Time Stamp interrupt 
   2695            *            @arg RTC_IT_WUT: WakeUp Timer interrupt 
   2696            *            @arg RTC_IT_ALRB: Alarm B interrupt 
   2697            *            @arg RTC_IT_ALRA: Alarm A interrupt 
   2698            *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
   2699            * @retval None
   2700            */

   \                                 In section .text, align 2, keep-with-next
   2701          void RTC_ClearITPendingBit(uint32_t RTC_IT)
   2702          {
   \                     RTC_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2703            uint32_t tmpreg = 0;
   2704          
   2705            /* Check the parameters */
   2706            assert_param(IS_RTC_CLEAR_IT(RTC_IT));
   \   00000004   0xD002             BEQ.N    ??RTC_ClearITPendingBit_0
   \   00000006   0xF434 0x303C      BICS     R0,R4,#0x2F000
   \   0000000A   0xD005             BEQ.N    ??RTC_ClearITPendingBit_1
   \                     ??RTC_ClearITPendingBit_0: (+1)
   \   0000000C   0xF640 0x2192      MOVW     R1,#+2706
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   2707          
   2708            /* Get the RTC_ISR Interrupt pending bits mask */
   2709            tmpreg = (uint32_t)(RTC_IT >> 4);
   2710          
   2711            /* Clear the interrupt pending bits in the RTC_ISR register */
   2712            RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
   \                     ??RTC_ClearITPendingBit_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable51_5  ;; 0x4000280c
   \   0000001A   0x4621             MOV      R1,R4
   \   0000001C   0x0309             LSLS     R1,R1,#+12
   \   0000001E   0x0C09             LSRS     R1,R1,#+16
   \   00000020   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000024   0x6802             LDR      R2,[R0, #+0]
   \   00000026   0xF002 0x0280      AND      R2,R2,#0x80
   \   0000002A   0xEA62 0x0101      ORN      R1,R2,R1
   \   0000002E   0x6001             STR      R1,[R0, #+0]
   2713          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   2714          
   2715          /**
   2716            * @}
   2717            */
   2718          
   2719          /**
   2720            * @brief  Converts a 2 digit decimal to BCD format.
   2721            * @param  Value: Byte to be converted.
   2722            * @retval Converted byte
   2723            */

   \                                 In section .text, align 2, keep-with-next
   2724          static uint8_t RTC_ByteToBcd2(uint8_t Value)
   2725          {
   2726            uint8_t bcdhigh = 0;
   \                     _Z14RTC_ByteToBcd2h: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE001             B.N      ??RTC_ByteToBcd2_0
   2727            
   2728            while (Value >= 10)
   2729            {
   2730              bcdhigh++;
   \                     ??RTC_ByteToBcd2_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   2731              Value -= 10;
   \   00000006   0x380A             SUBS     R0,R0,#+10
   2732            }
   \                     ??RTC_ByteToBcd2_0: (+1)
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x280A             CMP      R0,#+10
   \   0000000C   0xDAFA             BGE.N    ??RTC_ByteToBcd2_1
   2733            
   2734            return  ((uint8_t)(bcdhigh << 4) | Value);
   \   0000000E   0xEA40 0x1001      ORR      R0,R0,R1, LSL #+4
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x4770             BX       LR               ;; return
   2735          }
   2736          
   2737          /**
   2738            * @brief  Convert from 2 digit BCD to Binary.
   2739            * @param  Value: BCD value to be converted.
   2740            * @retval Converted word
   2741            */

   \                                 In section .text, align 2, keep-with-next
   2742          static uint8_t RTC_Bcd2ToByte(uint8_t Value)
   2743          {
   2744            uint8_t tmp = 0;
   2745            tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
   2746            return (tmp + (Value & (uint8_t)0x0F));
   \                     _Z14RTC_Bcd2ToByteh: (+1)
   \   00000000   0x0901             LSRS     R1,R0,#+4
   \   00000002   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0xEB00 0x0042      ADD      R0,R0,R2, LSL #+1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x4770             BX       LR               ;; return
   2747          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x40002800         DC32     0x40002800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x007F00FF         DC32     0x7f00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x40002824         DC32     0x40002824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31_1:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40:
   \   00000000   0x007F7F7F         DC32     0x7f7f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x40002828         DC32     0x40002828

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \   00000000   0x40002804         DC32     0x40002804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \   00000000   0x00FFFF3F         DC32     0xffff3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51:
   \   00000000   0x4000281C         DC32     0x4000281c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_1:
   \   00000000   0x40002808         DC32     0x40002808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_2:
   \   00000000   0x40002844         DC32     0x40002844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_3:
   \   00000000   0x40002814         DC32     0x40002814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_4:
   \   00000000   0x40002818         DC32     0x40002818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_5:
   \   00000000   0x4000280C         DC32     0x4000280c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_6:
   \   00000000   0xFFFFF7F7         DC32     0xfffff7f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_7:
   \   00000000   0x40002830         DC32     0x40002830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_8:
   \   00000000   0x40002838         DC32     0x40002838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_9:
   \   00000000   0x40002840         DC32     0x40002840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_10:
   \   00000000   0x40002850         DC32     0x40002850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_11:
   \   00000000   0xFFFF0FFB         DC32     0xffff0ffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_12:
   \   00000000   0x00013F7F         DC32     0x13f7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_13:
   \   00000000   0xFFFF00DF         DC32     0xffff00df

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x72 0x74          DC8 72H, 74H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   00000066   0x00 0x00          DC8 0, 0
   2748          
   2749          /**
   2750            * @}
   2751            */ 
   2752          
   2753          /**
   2754            * @}
   2755            */ 
   2756          
   2757          /**
   2758            * @}
   2759            */ 
   2760          
   2761          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   RTC_AlarmCmd
        24   -> assert_failed
       0   RTC_AlarmStructInit
      16   RTC_AlarmSubSecondConfig
        16   -> assert_failed
       0   RTC_Bcd2ToByte(uint8_t)
       8   RTC_BypassShadowCmd
         8   -> assert_failed
       0   RTC_ByteToBcd2(uint8_t)
       8   RTC_CalibOutputCmd
         8   -> assert_failed
       8   RTC_CalibOutputConfig
         8   -> assert_failed
       8   RTC_ClearFlag
         8   -> assert_failed
       8   RTC_ClearITPendingBit
         8   -> assert_failed
      16   RTC_CoarseCalibCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      24   RTC_CoarseCalibConfig
        24   -> RTC_EnterInitMode
        24   -> RTC_ExitInitMode
        24   -> assert_failed
       0   RTC_DateStructInit
      16   RTC_DayLightSavingConfig
        16   -> assert_failed
      16   RTC_DeInit
        16   -> RTC_EnterInitMode
        16   -> RTC_WaitForSynchro
       4   RTC_EnterInitMode
       0   RTC_ExitInitMode
      16   RTC_GetAlarm
        16   -> RTC_Bcd2ToByte(uint8_t)
        16   -> assert_failed
       0   RTC_GetAlarmSubSecond
      16   RTC_GetDate
        16   -> RTC_Bcd2ToByte(uint8_t)
        16   -> assert_failed
      16   RTC_GetFlagStatus
        16   -> assert_failed
      16   RTC_GetITStatus
        16   -> assert_failed
       0   RTC_GetStoreOperation
       0   RTC_GetSubSecond
      16   RTC_GetTime
        16   -> RTC_Bcd2ToByte(uint8_t)
        16   -> assert_failed
      16   RTC_GetTimeStamp
        16   -> RTC_Bcd2ToByte(uint8_t)
        16   -> assert_failed
       0   RTC_GetTimeStampSubSecond
       0   RTC_GetWakeUpCounter
      16   RTC_ITConfig
        16   -> assert_failed
      16   RTC_Init
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      16   RTC_OutputConfig
        16   -> assert_failed
       8   RTC_OutputTypeConfig
         8   -> assert_failed
      16   RTC_ReadBackupRegister
        16   -> assert_failed
      16   RTC_RefClockCmd
        16   -> RTC_EnterInitMode
        16   -> RTC_ExitInitMode
        16   -> assert_failed
      32   RTC_SetAlarm
        32   -> RTC_Bcd2ToByte(uint8_t)
        32   -> RTC_ByteToBcd2(uint8_t)
        32   -> assert_failed
      24   RTC_SetDate
        24   -> RTC_Bcd2ToByte(uint8_t)
        24   -> RTC_ByteToBcd2(uint8_t)
        24   -> RTC_EnterInitMode
        24   -> RTC_ExitInitMode
        24   -> RTC_WaitForSynchro
        24   -> assert_failed
      24   RTC_SetTime
        24   -> RTC_Bcd2ToByte(uint8_t)
        24   -> RTC_ByteToBcd2(uint8_t)
        24   -> RTC_EnterInitMode
        24   -> RTC_ExitInitMode
        24   -> RTC_WaitForSynchro
        24   -> assert_failed
       8   RTC_SetWakeUpCounter
         8   -> assert_failed
      24   RTC_SmoothCalibConfig
        24   -> assert_failed
       0   RTC_StructInit
      24   RTC_SynchroShiftConfig
        24   -> RTC_WaitForSynchro
        24   -> assert_failed
      16   RTC_TamperCmd
        16   -> assert_failed
       8   RTC_TamperFilterConfig
         8   -> assert_failed
       8   RTC_TamperPinSelection
         8   -> assert_failed
       8   RTC_TamperPinsPrechargeDuration
         8   -> assert_failed
       8   RTC_TamperPullUpCmd
         8   -> assert_failed
       8   RTC_TamperSamplingFreqConfig
         8   -> assert_failed
      16   RTC_TamperTriggerConfig
        16   -> assert_failed
      16   RTC_TimeStampCmd
        16   -> assert_failed
       8   RTC_TimeStampOnTamperDetectionCmd
         8   -> assert_failed
       8   RTC_TimeStampPinSelection
         8   -> assert_failed
       0   RTC_TimeStructInit
       4   RTC_WaitForSynchro
       8   RTC_WakeUpClockConfig
         8   -> assert_failed
      16   RTC_WakeUpCmd
        16   -> assert_failed
      16   RTC_WriteBackupRegister
        16   -> assert_failed
       8   RTC_WriteProtectionCmd
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable30
       4  ??DataTable31
       4  ??DataTable31_1
       4  ??DataTable40
       4  ??DataTable41
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable51
       4  ??DataTable51_1
       4  ??DataTable51_10
       4  ??DataTable51_11
       4  ??DataTable51_12
       4  ??DataTable51_13
       4  ??DataTable51_2
       4  ??DataTable51_3
       4  ??DataTable51_4
       4  ??DataTable51_5
       4  ??DataTable51_6
       4  ??DataTable51_7
       4  ??DataTable51_8
       4  ??DataTable51_9
     104  ?_0
     124  RTC_AlarmCmd
      22  RTC_AlarmStructInit
     190  RTC_AlarmSubSecondConfig
      18  RTC_Bcd2ToByte(uint8_t)
      60  RTC_BypassShadowCmd
      22  RTC_ByteToBcd2(uint8_t)
      60  RTC_CalibOutputCmd
      56  RTC_CalibOutputConfig
      46  RTC_ClearFlag
      50  RTC_ClearITPendingBit
      80  RTC_CoarseCalibCmd
      84  RTC_CoarseCalibConfig
      14  RTC_DateStructInit
      88  RTC_DayLightSavingConfig
     132  RTC_DeInit
      62  RTC_EnterInitMode
      14  RTC_ExitInitMode
     154  RTC_GetAlarm
      26  RTC_GetAlarmSubSecond
      94  RTC_GetDate
     102  RTC_GetFlagStatus
      84  RTC_GetITStatus
      12  RTC_GetStoreOperation
       8  RTC_GetSubSecond
      96  RTC_GetTime
     154  RTC_GetTimeStamp
       8  RTC_GetTimeStampSubSecond
      10  RTC_GetWakeUpCounter
     104  RTC_ITConfig
     130  RTC_Init
      98  RTC_OutputConfig
      42  RTC_OutputTypeConfig
     120  RTC_ReadBackupRegister
      80  RTC_RefClockCmd
     582  RTC_SetAlarm
     336  RTC_SetDate
     394  RTC_SetTime
      42  RTC_SetWakeUpCounter
     144  RTC_SmoothCalibConfig
      14  RTC_StructInit
     140  RTC_SynchroShiftConfig
      64  RTC_TamperCmd
      56  RTC_TamperFilterConfig
      42  RTC_TamperPinSelection
      56  RTC_TamperPinsPrechargeDuration
      48  RTC_TamperPullUpCmd
      80  RTC_TamperSamplingFreqConfig
      76  RTC_TamperTriggerConfig
      88  RTC_TimeStampCmd
      48  RTC_TimeStampOnTamperDetectionCmd
      42  RTC_TimeStampPinSelection
      12  RTC_TimeStructInit
      66  RTC_WaitForSynchro
      70  RTC_WakeUpClockConfig
     102  RTC_WakeUpCmd
     122  RTC_WriteBackupRegister
      46  RTC_WriteProtectionCmd

 
 5 314 bytes in section .text
 
 5 314 bytes of CODE memory

Errors: none
Warnings: none
