###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        09/Oct/2018  16:32:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_gpio.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_gpio.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_gpio.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_gpio.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the GPIO peripheral:           
      9            *           + Initialization and Configuration
     10            *           + GPIO Read and Write
     11            *           + GPIO Alternate functions configuration
     12            * 
     13          @verbatim  
     14           ===============================================================================
     15                                ##### How to use this driver #####
     16           ===============================================================================       
     17           [..]             
     18             (#) Enable the GPIO AHB clock using the following function
     19                 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     20                         
     21             (#) Configure the GPIO pin(s) using GPIO_Init()
     22                 Four possible configuration are available for each pin:
     23                 (++) Input: Floating, Pull-up, Pull-down.
     24                 (++) Output: Push-Pull (Pull-up, Pull-down or no Pull)
     25                      Open Drain (Pull-up, Pull-down or no Pull). In output mode, the speed 
     26                      is configurable: 2 MHz, 25 MHz, 50 MHz or 100 MHz.
     27                 (++) Alternate Function: Push-Pull (Pull-up, Pull-down or no Pull) Open 
     28                      Drain (Pull-up, Pull-down or no Pull).
     29                 (++) Analog: required mode when a pin is to be used as ADC channel or DAC 
     30                      output.
     31             
     32             (#) Peripherals alternate function:
     33                 (++) For ADC and DAC, configure the desired pin in analog mode using 
     34                      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AN;
     35                      (+++) For other peripherals (TIM, USART...):
     36                      (+++) Connect the pin to the desired peripherals' Alternate 
     37                               Function (AF) using GPIO_PinAFConfig() function
     38                      (+++) Configure the desired pin in alternate function mode using
     39                               GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     40                      (+++) Select the type, pull-up/pull-down and output speed via 
     41                               GPIO_PuPd, GPIO_OType and GPIO_Speed members
     42                      (+++) Call GPIO_Init() function
     43                    
     44             (#) To get the level of a pin configured in input mode use GPIO_ReadInputDataBit()
     45                      
     46             (#) To set/reset the level of a pin configured in output mode use 
     47                 GPIO_SetBits()/GPIO_ResetBits()
     48                           
     49             (#) During and just after reset, the alternate functions are not 
     50                 active and the GPIO pins are configured in input floating mode (except JTAG
     51                 pins).
     52            
     53             (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose 
     54                 (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has 
     55                 priority over the GPIO function.
     56            
     57             (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     58                 general purpose PH0 and PH1, respectively, when the HSE oscillator is off. 
     59                 The HSE has priority over the GPIO function.
     60                         
     61          @endverbatim        
     62            *
     63            ******************************************************************************
     64            * @attention
     65            *
     66            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     67            *
     68            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     69            * You may not use this file except in compliance with the License.
     70            * You may obtain a copy of the License at:
     71            *
     72            *        http://www.st.com/software_license_agreement_liberty_v2
     73            *
     74            * Unless required by applicable law or agreed to in writing, software 
     75            * distributed under the License is distributed on an "AS IS" BASIS, 
     76            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     77            * See the License for the specific language governing permissions and
     78            * limitations under the License.
     79            *
     80            ******************************************************************************
     81            */
     82          
     83          /* Includes ------------------------------------------------------------------*/
     84          #include "stm32f4xx_gpio.h"
     85          #include "stm32f4xx_rcc.h"
     86          
     87          /** @addtogroup STM32F4xx_StdPeriph_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup GPIO 
     92            * @brief GPIO driver modules
     93            * @{
     94            */ 
     95          
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          /* Private function prototypes -----------------------------------------------*/
    101          /* Private functions ---------------------------------------------------------*/
    102          
    103          /** @defgroup GPIO_Private_Functions
    104            * @{
    105            */ 
    106          
    107          /** @defgroup GPIO_Group1 Initialization and Configuration
    108           *  @brief   Initialization and Configuration
    109           *
    110          @verbatim   
    111           ===============================================================================
    112                           ##### Initialization and Configuration #####
    113           ===============================================================================  
    114          
    115          @endverbatim
    116            * @{
    117            */
    118          
    119          /**
    120            * @brief  De-initializes the GPIOx peripheral registers to their default reset values.
    121            * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
    122            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    123            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    124            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices.  
    125            * @retval None
    126            */

   \                                 In section .text, align 2, keep-with-next
    127          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
    128          {
   \                     GPIO_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    129            /* Check the parameters */
    130            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable12  ;; 0x40020000
   \   00000008   0x42AC             CMP      R4,R5
   \   0000000A   0xD02C             BEQ.N    ??GPIO_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD028             BEQ.N    ??GPIO_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD024             BEQ.N    ??GPIO_DeInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40020c00
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD020             BEQ.N    ??GPIO_DeInit_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40021000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD01C             BEQ.N    ??GPIO_DeInit_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40021400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD018             BEQ.N    ??GPIO_DeInit_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021800
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD014             BEQ.N    ??GPIO_DeInit_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40021c00
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD010             BEQ.N    ??GPIO_DeInit_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40022000
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD00C             BEQ.N    ??GPIO_DeInit_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40022400
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD008             BEQ.N    ??GPIO_DeInit_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD004             BEQ.N    ??GPIO_DeInit_0
   \   0000005C   0x2182             MOVS     R1,#+130
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
    131          
    132            if (GPIOx == GPIOA)
   \                     ??GPIO_DeInit_0: (+1)
   \   00000066   0x42AC             CMP      R4,R5
   \   00000068   0xD109             BNE.N    ??GPIO_DeInit_1
    133            {
    134              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x4608             MOV      R0,R1
   \   0000006E   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    135              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000007A   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    136            }
    137            else if (GPIOx == GPIOB)
   \                     ??GPIO_DeInit_1: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020400
   \   00000082   0x4284             CMP      R4,R0
   \   00000084   0xD109             BNE.N    ??GPIO_DeInit_2
    138            {
    139              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    140              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000096   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    141            }
    142            else if (GPIOx == GPIOC)
   \                     ??GPIO_DeInit_2: (+1)
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020800
   \   0000009E   0x4284             CMP      R4,R0
   \   000000A0   0xD109             BNE.N    ??GPIO_DeInit_3
    143            {
    144              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0x2004             MOVS     R0,#+4
   \   000000A6   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    145              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x2004             MOVS     R0,#+4
   \   000000AE   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000B2   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    146            }
    147            else if (GPIOx == GPIOD)
   \                     ??GPIO_DeInit_3: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40020c00
   \   000000BA   0x4284             CMP      R4,R0
   \   000000BC   0xD109             BNE.N    ??GPIO_DeInit_4
    148            {
    149              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    150              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x2008             MOVS     R0,#+8
   \   000000CA   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000CE   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    151            }
    152            else if (GPIOx == GPIOE)
   \                     ??GPIO_DeInit_4: (+1)
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40021000
   \   000000D6   0x4284             CMP      R4,R0
   \   000000D8   0xD109             BNE.N    ??GPIO_DeInit_5
    153            {
    154              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
   \   000000DA   0x2101             MOVS     R1,#+1
   \   000000DC   0x2010             MOVS     R0,#+16
   \   000000DE   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    155              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0x2010             MOVS     R0,#+16
   \   000000E6   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000EA   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    156            }
    157            else if (GPIOx == GPIOF)
   \                     ??GPIO_DeInit_5: (+1)
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40021400
   \   000000F2   0x4284             CMP      R4,R0
   \   000000F4   0xD109             BNE.N    ??GPIO_DeInit_6
    158            {
    159              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
   \   000000F6   0x2101             MOVS     R1,#+1
   \   000000F8   0x2020             MOVS     R0,#+32
   \   000000FA   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    160              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
   \   000000FE   0x2100             MOVS     R1,#+0
   \   00000100   0x2020             MOVS     R0,#+32
   \   00000102   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000106   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    161            }
    162            else if (GPIOx == GPIOG)
   \                     ??GPIO_DeInit_6: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021800
   \   0000010E   0x4284             CMP      R4,R0
   \   00000110   0xD109             BNE.N    ??GPIO_DeInit_7
    163            {
    164              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
   \   00000112   0x2101             MOVS     R1,#+1
   \   00000114   0x2040             MOVS     R0,#+64
   \   00000116   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    165              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
   \   0000011A   0x2100             MOVS     R1,#+0
   \   0000011C   0x2040             MOVS     R0,#+64
   \   0000011E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000122   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    166            }
    167            else if (GPIOx == GPIOH)
   \                     ??GPIO_DeInit_7: (+1)
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40021c00
   \   0000012A   0x4284             CMP      R4,R0
   \   0000012C   0xD109             BNE.N    ??GPIO_DeInit_8
    168            {
    169              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
   \   0000012E   0x2101             MOVS     R1,#+1
   \   00000130   0x2080             MOVS     R0,#+128
   \   00000132   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    170              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
   \   00000136   0x2100             MOVS     R1,#+0
   \   00000138   0x2080             MOVS     R0,#+128
   \   0000013A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000013E   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    171            }
    172          
    173            else if (GPIOx == GPIOI)
   \                     ??GPIO_DeInit_8: (+1)
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40022000
   \   00000146   0x4284             CMP      R4,R0
   \   00000148   0xD10B             BNE.N    ??GPIO_DeInit_9
    174            {
    175              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
   \   0000014A   0x2101             MOVS     R1,#+1
   \   0000014C   0xF44F 0x7080      MOV      R0,#+256
   \   00000150   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    176              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
   \   00000154   0x2100             MOVS     R1,#+0
   \   00000156   0xF44F 0x7080      MOV      R0,#+256
   \   0000015A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000015E   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    177            }
    178            else if (GPIOx == GPIOJ)
   \                     ??GPIO_DeInit_9: (+1)
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40022400
   \   00000166   0x4284             CMP      R4,R0
   \   00000168   0xD10B             BNE.N    ??GPIO_DeInit_10
    179            {
    180              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, ENABLE);
   \   0000016A   0x2101             MOVS     R1,#+1
   \   0000016C   0xF44F 0x7000      MOV      R0,#+512
   \   00000170   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    181              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOJ, DISABLE);
   \   00000174   0x2100             MOVS     R1,#+0
   \   00000176   0xF44F 0x7000      MOV      R0,#+512
   \   0000017A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000017E   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    182            }
    183            else
    184            {
    185              if (GPIOx == GPIOK)
   \                     ??GPIO_DeInit_10: (+1)
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   00000186   0x4284             CMP      R4,R0
   \   00000188   0xD10B             BNE.N    ??GPIO_DeInit_11
    186              {
    187                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, ENABLE);
   \   0000018A   0x2101             MOVS     R1,#+1
   \   0000018C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000190   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    188                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOK, DISABLE);
   \   00000194   0x2100             MOVS     R1,#+0
   \   00000196   0xF44F 0x6080      MOV      R0,#+1024
   \   0000019A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000019E   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    189              }
    190            }
    191          }
   \                     ??GPIO_DeInit_11: (+1)
   \   000001A2   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    192          
    193          /**
    194            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_InitStruct.
    195            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    196            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    197            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices.   
    198            * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
    199            *         the configuration information for the specified GPIO peripheral.
    200            * @retval None
    201            */

   \                                 In section .text, align 2, keep-with-next
    202          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    203          {
   \                     GPIO_Init: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    204            uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
   \   00000008   0x2600             MOVS     R6,#+0
    205          
    206            /* Check the parameters */
    207            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40020000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD02C             BEQ.N    ??GPIO_Init_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020400
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD028             BEQ.N    ??GPIO_Init_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020800
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD024             BEQ.N    ??GPIO_Init_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40020c00
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD020             BEQ.N    ??GPIO_Init_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40021000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD01C             BEQ.N    ??GPIO_Init_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40021400
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD018             BEQ.N    ??GPIO_Init_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021800
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD014             BEQ.N    ??GPIO_Init_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40021c00
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD010             BEQ.N    ??GPIO_Init_0
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40022000
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD00C             BEQ.N    ??GPIO_Init_0
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40022400
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD008             BEQ.N    ??GPIO_Init_0
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD004             BEQ.N    ??GPIO_Init_0
   \   00000062   0x21CF             MOVS     R1,#+207
   \   00000064   0x.... 0x....      ADR.W    R0,?_0
   \   00000068   0x.... 0x....      BL       assert_failed
    208            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
   \                     ??GPIO_Init_0: (+1)
   \   0000006C   0x6828             LDR      R0,[R5, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD104             BNE.N    ??GPIO_Init_1
   \   00000072   0x21D0             MOVS     R1,#+208
   \   00000074   0x.... 0x....      ADR.W    R0,?_0
   \   00000078   0x.... 0x....      BL       assert_failed
    209            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
   \                     ??GPIO_Init_1: (+1)
   \   0000007C   0x7928             LDRB     R0,[R5, #+4]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD00A             BEQ.N    ??GPIO_Init_2
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xD008             BEQ.N    ??GPIO_Init_2
   \   00000086   0x2802             CMP      R0,#+2
   \   00000088   0xD006             BEQ.N    ??GPIO_Init_2
   \   0000008A   0x2803             CMP      R0,#+3
   \   0000008C   0xD004             BEQ.N    ??GPIO_Init_2
   \   0000008E   0x21D1             MOVS     R1,#+209
   \   00000090   0x.... 0x....      ADR.W    R0,?_0
   \   00000094   0x.... 0x....      BL       assert_failed
    210            assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
   \                     ??GPIO_Init_2: (+1)
   \   00000098   0x79E8             LDRB     R0,[R5, #+7]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD05C             BEQ.N    ??GPIO_Init_3
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD05A             BEQ.N    ??GPIO_Init_3
   \   000000A2   0x2802             CMP      R0,#+2
   \   000000A4   0xD058             BEQ.N    ??GPIO_Init_3
   \   000000A6   0x21D2             MOVS     R1,#+210
   \   000000A8   0x.... 0x....      ADR.W    R0,?_0
   \   000000AC   0x.... 0x....      BL       assert_failed
   \   000000B0   0xE052             B.N      ??GPIO_Init_3
    211          
    212            /* ------------------------- Configure the port pins ---------------- */
    213            /*-- GPIO Mode Configuration --*/
    214            for (pinpos = 0x00; pinpos < 0x10; pinpos++)
   \                     ??GPIO_Init_4: (+1)
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xFA00 0xF706      LSL      R7,R0,R6
    215            {
    216              pos = ((uint32_t)0x01) << pinpos;
    217              /* Get the port pins position */
    218              currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    219          
    220              if (currentpin == pos)
   \   000000B8   0x6828             LDR      R0,[R5, #+0]
   \   000000BA   0x4038             ANDS     R0,R7,R0
   \   000000BC   0x42B8             CMP      R0,R7
   \   000000BE   0xD14A             BNE.N    ??GPIO_Init_5
    221              {
    222                GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
   \   000000C0   0xEA4F 0x0846      LSL      R8,R6,#+1
   \   000000C4   0x2003             MOVS     R0,#+3
   \   000000C6   0xFA00 0xF008      LSL      R0,R0,R8
   \   000000CA   0xEA6F 0x0900      MVN      R9,R0
   \   000000CE   0x6820             LDR      R0,[R4, #+0]
   \   000000D0   0xEA09 0x0000      AND      R0,R9,R0
   \   000000D4   0x6020             STR      R0,[R4, #+0]
    223                GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x7929             LDRB     R1,[R5, #+4]
   \   000000DA   0xFA01 0xF108      LSL      R1,R1,R8
   \   000000DE   0x4308             ORRS     R0,R1,R0
   \   000000E0   0x6020             STR      R0,[R4, #+0]
    224          
    225                if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
   \   000000E2   0x7928             LDRB     R0,[R5, #+4]
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xD001             BEQ.N    ??GPIO_Init_6
   \   000000E8   0x2802             CMP      R0,#+2
   \   000000EA   0xD12A             BNE.N    ??GPIO_Init_7
    226                {
    227                  /* Check Speed mode parameters */
    228                  assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
   \                     ??GPIO_Init_6: (+1)
   \   000000EC   0x7968             LDRB     R0,[R5, #+5]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD00A             BEQ.N    ??GPIO_Init_8
   \   000000F2   0x2801             CMP      R0,#+1
   \   000000F4   0xD008             BEQ.N    ??GPIO_Init_8
   \   000000F6   0x2802             CMP      R0,#+2
   \   000000F8   0xD006             BEQ.N    ??GPIO_Init_8
   \   000000FA   0x2803             CMP      R0,#+3
   \   000000FC   0xD004             BEQ.N    ??GPIO_Init_8
   \   000000FE   0x21E4             MOVS     R1,#+228
   \   00000100   0x.... 0x....      ADR.W    R0,?_0
   \   00000104   0x.... 0x....      BL       assert_failed
    229          
    230                  /* Speed mode configuration */
    231                  GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
   \                     ??GPIO_Init_8: (+1)
   \   00000108   0x68A0             LDR      R0,[R4, #+8]
   \   0000010A   0xEA09 0x0000      AND      R0,R9,R0
   \   0000010E   0x60A0             STR      R0,[R4, #+8]
    232                  GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
   \   00000110   0x68A0             LDR      R0,[R4, #+8]
   \   00000112   0x7969             LDRB     R1,[R5, #+5]
   \   00000114   0xFA01 0xF108      LSL      R1,R1,R8
   \   00000118   0x4308             ORRS     R0,R1,R0
   \   0000011A   0x60A0             STR      R0,[R4, #+8]
    233          
    234                  /* Check Output mode parameters */
    235                  assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
   \   0000011C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD006             BEQ.N    ??GPIO_Init_9
   \   00000122   0x2801             CMP      R0,#+1
   \   00000124   0xD004             BEQ.N    ??GPIO_Init_9
   \   00000126   0x21EB             MOVS     R1,#+235
   \   00000128   0x.... 0x....      ADR.W    R0,?_0
   \   0000012C   0x.... 0x....      BL       assert_failed
    236          
    237                  /* Output mode configuration*/
    238                  GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
   \                     ??GPIO_Init_9: (+1)
   \   00000130   0x6860             LDR      R0,[R4, #+4]
   \   00000132   0x43B8             BICS     R0,R0,R7
   \   00000134   0x6060             STR      R0,[R4, #+4]
    239                  GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
   \   00000136   0x6860             LDR      R0,[R4, #+4]
   \   00000138   0x79A9             LDRB     R1,[R5, #+6]
   \   0000013A   0x40B1             LSLS     R1,R1,R6
   \   0000013C   0xB289             UXTH     R1,R1
   \   0000013E   0x4308             ORRS     R0,R1,R0
   \   00000140   0x6060             STR      R0,[R4, #+4]
    240                }
    241          
    242                /* Pull-up Pull down resistor configuration*/
    243                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
   \                     ??GPIO_Init_7: (+1)
   \   00000142   0x68E0             LDR      R0,[R4, #+12]
   \   00000144   0xEA09 0x0000      AND      R0,R9,R0
   \   00000148   0x60E0             STR      R0,[R4, #+12]
    244                GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
   \   0000014A   0x68E0             LDR      R0,[R4, #+12]
   \   0000014C   0x79E9             LDRB     R1,[R5, #+7]
   \   0000014E   0xFA01 0xF108      LSL      R1,R1,R8
   \   00000152   0x4308             ORRS     R0,R1,R0
   \   00000154   0x60E0             STR      R0,[R4, #+12]
    245              }
    246            }
   \                     ??GPIO_Init_5: (+1)
   \   00000156   0x1C76             ADDS     R6,R6,#+1
   \                     ??GPIO_Init_3: (+1)
   \   00000158   0x2E10             CMP      R6,#+16
   \   0000015A   0xD3AA             BCC.N    ??GPIO_Init_4
    247          }
   \   0000015C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    248          
    249          /**
    250            * @brief  Fills each GPIO_InitStruct member with its default value.
    251            * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    255          {
    256            /* Reset GPIO init structure parameters values */
    257            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit: (+1)
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x6001             STR      R1,[R0, #+0]
    258            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    259            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    260            GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
   \   0000000C   0x7181             STRB     R1,[R0, #+6]
    261            GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   0000000E   0x71C1             STRB     R1,[R0, #+7]
    262          }
   \   00000010   0x4770             BX       LR               ;; return
    263          
    264          /**
    265            * @brief  Locks GPIO Pins configuration registers.
    266            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    267            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    268            * @note   The configuration of the locked GPIO pins can no longer be modified
    269            *         until the next reset.
    270            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    271            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    272            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    273            * @param  GPIO_Pin: specifies the port bit to be locked.
    274            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    275            * @retval None
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    278          {
   \                     GPIO_PinLockConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    279            __IO uint32_t tmp = 0x00010000;
   \   00000006   0xF44F 0x3080      MOV      R0,#+65536
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    280          
    281            /* Check the parameters */
    282            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40020000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD02D             BEQ.N    ??GPIO_PinLockConfig_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD029             BEQ.N    ??GPIO_PinLockConfig_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020800
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD025             BEQ.N    ??GPIO_PinLockConfig_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40020c00
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD021             BEQ.N    ??GPIO_PinLockConfig_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40021000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD01D             BEQ.N    ??GPIO_PinLockConfig_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40021400
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD019             BEQ.N    ??GPIO_PinLockConfig_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021800
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD015             BEQ.N    ??GPIO_PinLockConfig_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40021c00
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD011             BEQ.N    ??GPIO_PinLockConfig_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40022000
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD00D             BEQ.N    ??GPIO_PinLockConfig_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40022400
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD009             BEQ.N    ??GPIO_PinLockConfig_0
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD005             BEQ.N    ??GPIO_PinLockConfig_0
   \   00000064   0xF44F 0x718D      MOV      R1,#+282
   \   00000068   0x.... 0x....      ADR.W    R0,?_0
   \   0000006C   0x.... 0x....      BL       assert_failed
    283            assert_param(IS_GPIO_PIN(GPIO_Pin));
   \                     ??GPIO_PinLockConfig_0: (+1)
   \   00000070   0x2D00             CMP      R5,#+0
   \   00000072   0xD105             BNE.N    ??GPIO_PinLockConfig_1
   \   00000074   0xF240 0x111B      MOVW     R1,#+283
   \   00000078   0x.... 0x....      ADR.W    R0,?_0
   \   0000007C   0x.... 0x....      BL       assert_failed
    284          
    285            tmp |= GPIO_Pin;
   \                     ??GPIO_PinLockConfig_1: (+1)
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x4328             ORRS     R0,R5,R0
   \   00000084   0x9000             STR      R0,[SP, #+0]
    286            /* Set LCKK bit */
    287            GPIOx->LCKR = tmp;
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x61E0             STR      R0,[R4, #+28]
    288            /* Reset LCKK bit */
    289            GPIOx->LCKR =  GPIO_Pin;
   \   0000008A   0x61E5             STR      R5,[R4, #+28]
    290            /* Set LCKK bit */
    291            GPIOx->LCKR = tmp;
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x61E0             STR      R0,[R4, #+28]
    292            /* Read LCKK bit*/
    293            tmp = GPIOx->LCKR;
   \   00000090   0x69E0             LDR      R0,[R4, #+28]
   \   00000092   0x9000             STR      R0,[SP, #+0]
    294            /* Read LCKK bit*/
    295            tmp = GPIOx->LCKR;
   \   00000094   0x69E0             LDR      R0,[R4, #+28]
   \   00000096   0x9000             STR      R0,[SP, #+0]
    296          }
   \   00000098   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    297          
    298          /**
    299            * @}
    300            */
    301          
    302          /** @defgroup GPIO_Group2 GPIO Read and Write
    303           *  @brief   GPIO Read and Write
    304           *
    305          @verbatim   
    306           ===============================================================================
    307                                   ##### GPIO Read and Write #####
    308           ===============================================================================  
    309          
    310          @endverbatim
    311            * @{
    312            */
    313          
    314          /**
    315            * @brief  Reads the specified input port pin.
    316            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    317            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    318            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    319            * @param  GPIO_Pin: specifies the port bit to read.
    320            *         This parameter can be GPIO_Pin_x where x can be (0..15).
    321            * @retval The input port pin value.
    322            */

   \                                 In section .text, align 2, keep-with-next
    323          uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    324          {
   \                     GPIO_ReadInputDataBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    325            uint8_t bitstatus = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
    326          
    327            /* Check the parameters */
    328            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40020000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD02D             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD029             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD025             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40020c00
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD021             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40021000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD01D             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40021400
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD019             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021800
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD015             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40021c00
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD011             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40022000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD00D             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40022400
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD009             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD005             BEQ.N    ??GPIO_ReadInputDataBit_0
   \   00000060   0xF44F 0x71A4      MOV      R1,#+328
   \   00000064   0x.... 0x....      ADR.W    R0,?_0
   \   00000068   0x.... 0x....      BL       assert_failed
    329            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
   \                     ??GPIO_ReadInputDataBit_0: (+1)
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD02B             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD029             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD027             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   0000007A   0x2808             CMP      R0,#+8
   \   0000007C   0xD025             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   0000007E   0x2810             CMP      R0,#+16
   \   00000080   0xD023             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   00000082   0x2820             CMP      R0,#+32
   \   00000084   0xD021             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   00000086   0x2840             CMP      R0,#+64
   \   00000088   0xD01F             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   0000008A   0x2880             CMP      R0,#+128
   \   0000008C   0xD01D             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   0000008E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000092   0xD01A             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   00000094   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000098   0xD017             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   0000009A   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000009E   0xD014             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   000000A0   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000A4   0xD011             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   000000A6   0xF5B0 0x5F80      CMP      R0,#+4096
   \   000000AA   0xD00E             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   000000AC   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000B0   0xD00B             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   000000B2   0xF5B0 0x4F80      CMP      R0,#+16384
   \   000000B6   0xD008             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   000000B8   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000BC   0xD005             BEQ.N    ??GPIO_ReadInputDataBit_1
   \   000000BE   0xF240 0x1149      MOVW     R1,#+329
   \   000000C2   0x.... 0x....      ADR.W    R0,?_0
   \   000000C6   0x.... 0x....      BL       assert_failed
    330          
    331            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \                     ??GPIO_ReadInputDataBit_1: (+1)
   \   000000CA   0x6920             LDR      R0,[R4, #+16]
   \   000000CC   0x4228             TST      R0,R5
   \   000000CE   0xD000             BEQ.N    ??GPIO_ReadInputDataBit_2
    332            {
    333              bitstatus = (uint8_t)Bit_SET;
   \   000000D0   0x2601             MOVS     R6,#+1
    334            }
    335            else
    336            {
    337              bitstatus = (uint8_t)Bit_RESET;
    338            }
    339            return bitstatus;
   \                     ??GPIO_ReadInputDataBit_2: (+1)
   \   000000D2   0x4630             MOV      R0,R6
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return
    340          }
    341          
    342          /**
    343            * @brief  Reads the specified GPIO input data port.
    344            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    345            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    346            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    347            * @retval GPIO input data port value.
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    350          {
   \                     GPIO_ReadInputData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    351            /* Check the parameters */
    352            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40020000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD02D             BEQ.N    ??GPIO_ReadInputData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD029             BEQ.N    ??GPIO_ReadInputData_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020800
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD025             BEQ.N    ??GPIO_ReadInputData_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40020c00
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD021             BEQ.N    ??GPIO_ReadInputData_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40021000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD01D             BEQ.N    ??GPIO_ReadInputData_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40021400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD019             BEQ.N    ??GPIO_ReadInputData_0
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021800
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD015             BEQ.N    ??GPIO_ReadInputData_0
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40021c00
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD011             BEQ.N    ??GPIO_ReadInputData_0
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40022000
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD00D             BEQ.N    ??GPIO_ReadInputData_0
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40022400
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD009             BEQ.N    ??GPIO_ReadInputData_0
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD005             BEQ.N    ??GPIO_ReadInputData_0
   \   0000005C   0xF44F 0x71B0      MOV      R1,#+352
   \   00000060   0x.... 0x....      ADR.W    R0,?_0
   \   00000064   0x.... 0x....      BL       assert_failed
    353          
    354            return ((uint16_t)GPIOx->IDR);
   \                     ??GPIO_ReadInputData_0: (+1)
   \   00000068   0x6920             LDR      R0,[R4, #+16]
   \   0000006A   0xB280             UXTH     R0,R0
   \   0000006C   0xBD10             POP      {R4,PC}          ;; return
    355          }
    356          
    357          /**
    358            * @brief  Reads the specified output data port bit.
    359            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    360            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    361            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    362            * @param  GPIO_Pin: specifies the port bit to read.
    363            *          This parameter can be GPIO_Pin_x where x can be (0..15).
    364            * @retval The output port pin value.
    365            */

   \                                 In section .text, align 2, keep-with-next
    366          uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    367          {
   \                     GPIO_ReadOutputDataBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    368            uint8_t bitstatus = 0x00;
   \   00000006   0x2600             MOVS     R6,#+0
    369          
    370            /* Check the parameters */
    371            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40020000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD02D             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40020400
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD029             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0x40020800
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD025             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40020c00
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD021             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40021000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD01D             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x40021400
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD019             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021800
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD015             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_7  ;; 0x40021c00
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD011             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable12_8  ;; 0x40022000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD00D             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40022400
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0xD009             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD005             BEQ.N    ??GPIO_ReadOutputDataBit_0
   \   00000060   0xF240 0x1173      MOVW     R1,#+371
   \   00000064   0x.... 0x....      ADR.W    R0,?_0
   \   00000068   0x.... 0x....      BL       assert_failed
    372            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
   \                     ??GPIO_ReadOutputDataBit_0: (+1)
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD02B             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD029             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD027             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   0000007A   0x2808             CMP      R0,#+8
   \   0000007C   0xD025             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   0000007E   0x2810             CMP      R0,#+16
   \   00000080   0xD023             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   00000082   0x2820             CMP      R0,#+32
   \   00000084   0xD021             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   00000086   0x2840             CMP      R0,#+64
   \   00000088   0xD01F             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   0000008A   0x2880             CMP      R0,#+128
   \   0000008C   0xD01D             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   0000008E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000092   0xD01A             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   00000094   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000098   0xD017             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   0000009A   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000009E   0xD014             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   000000A0   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000A4   0xD011             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   000000A6   0xF5B0 0x5F80      CMP      R0,#+4096
   \   000000AA   0xD00E             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   000000AC   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000B0   0xD00B             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   000000B2   0xF5B0 0x4F80      CMP      R0,#+16384
   \   000000B6   0xD008             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   000000B8   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000BC   0xD005             BEQ.N    ??GPIO_ReadOutputDataBit_1
   \   000000BE   0xF44F 0x71BA      MOV      R1,#+372
   \   000000C2   0x.... 0x....      ADR.W    R0,?_0
   \   000000C6   0x.... 0x....      BL       assert_failed
    373          
    374            if (((GPIOx->ODR) & GPIO_Pin) != (uint32_t)Bit_RESET)
   \                     ??GPIO_ReadOutputDataBit_1: (+1)
   \   000000CA   0x6960             LDR      R0,[R4, #+20]
   \   000000CC   0x4228             TST      R0,R5
   \   000000CE   0xD000             BEQ.N    ??GPIO_ReadOutputDataBit_2
    375            {
    376              bitstatus = (uint8_t)Bit_SET;
   \   000000D0   0x2601             MOVS     R6,#+1
    377            }
    378            else
    379            {
    380              bitstatus = (uint8_t)Bit_RESET;
    381            }
    382            return bitstatus;
   \                     ??GPIO_ReadOutputDataBit_2: (+1)
   \   000000D2   0x4630             MOV      R0,R6
   \   000000D4   0xBD70             POP      {R4-R6,PC}       ;; return
    383          }
    384          
    385          /**
    386            * @brief  Reads the specified GPIO output data port.
    387            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    388            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    389            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    390            * @retval GPIO output data port value.
    391            */

   \                                 In section .text, align 2, keep-with-next
    392          uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    393          {
   \                     GPIO_ReadOutputData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    394            /* Check the parameters */
    395            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000004   0x....             LDR.N    R0,??DataTable12  ;; 0x40020000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD024             BEQ.N    ??GPIO_ReadOutputData_0
   \   0000000A   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD021             BEQ.N    ??GPIO_ReadOutputData_0
   \   00000010   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01E             BEQ.N    ??GPIO_ReadOutputData_0
   \   00000016   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40020c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD01B             BEQ.N    ??GPIO_ReadOutputData_0
   \   0000001C   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40021000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD018             BEQ.N    ??GPIO_ReadOutputData_0
   \   00000022   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40021400
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD015             BEQ.N    ??GPIO_ReadOutputData_0
   \   00000028   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40021800
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD012             BEQ.N    ??GPIO_ReadOutputData_0
   \   0000002E   0x....             LDR.N    R0,??DataTable12_7  ;; 0x40021c00
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD00F             BEQ.N    ??GPIO_ReadOutputData_0
   \   00000034   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40022000
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD00C             BEQ.N    ??GPIO_ReadOutputData_0
   \   0000003A   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40022400
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD009             BEQ.N    ??GPIO_ReadOutputData_0
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD005             BEQ.N    ??GPIO_ReadOutputData_0
   \   00000048   0xF240 0x118B      MOVW     R1,#+395
   \   0000004C   0x.... 0x....      ADR.W    R0,?_0
   \   00000050   0x.... 0x....      BL       assert_failed
    396          
    397            return ((uint16_t)GPIOx->ODR);
   \                     ??GPIO_ReadOutputData_0: (+1)
   \   00000054   0x6960             LDR      R0,[R4, #+20]
   \   00000056   0xB280             UXTH     R0,R0
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    398          }
    399          
    400          /**
    401            * @brief  Sets the selected data port bits.
    402            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    403            *         accesses. In this way, there is no risk of an IRQ occurring between
    404            *         the read and the modify access.
    405            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    406            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    407            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    408            * @param  GPIO_Pin: specifies the port bits to be written.
    409            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    410            * @retval None
    411            */

   \                                 In section .text, align 2, keep-with-next
    412          void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    413          {
   \                     GPIO_SetBits: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    414            /* Check the parameters */
    415            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000006   0x....             LDR.N    R0,??DataTable12  ;; 0x40020000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD024             BEQ.N    ??GPIO_SetBits_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD021             BEQ.N    ??GPIO_SetBits_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD01E             BEQ.N    ??GPIO_SetBits_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40020c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD01B             BEQ.N    ??GPIO_SetBits_0
   \   0000001E   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40021000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD018             BEQ.N    ??GPIO_SetBits_0
   \   00000024   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40021400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD015             BEQ.N    ??GPIO_SetBits_0
   \   0000002A   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40021800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD012             BEQ.N    ??GPIO_SetBits_0
   \   00000030   0x....             LDR.N    R0,??DataTable12_7  ;; 0x40021c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00F             BEQ.N    ??GPIO_SetBits_0
   \   00000036   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40022000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD00C             BEQ.N    ??GPIO_SetBits_0
   \   0000003C   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40022400
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD009             BEQ.N    ??GPIO_SetBits_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD005             BEQ.N    ??GPIO_SetBits_0
   \   0000004A   0xF240 0x119F      MOVW     R1,#+415
   \   0000004E   0x.... 0x....      ADR.W    R0,?_0
   \   00000052   0x.... 0x....      BL       assert_failed
    416            assert_param(IS_GPIO_PIN(GPIO_Pin));
   \                     ??GPIO_SetBits_0: (+1)
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD105             BNE.N    ??GPIO_SetBits_1
   \   0000005A   0xF44F 0x71D0      MOV      R1,#+416
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
    417          
    418            GPIOx->BSRRL = GPIO_Pin;
   \                     ??GPIO_SetBits_1: (+1)
   \   00000066   0x8325             STRH     R5,[R4, #+24]
    419          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    420          
    421          /**
    422            * @brief  Clears the selected data port bits.
    423            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    424            *         accesses. In this way, there is no risk of an IRQ occurring between
    425            *         the read and the modify access.
    426            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    427            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    428            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    429            * @param  GPIO_Pin: specifies the port bits to be written.
    430            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    431            * @retval None
    432            */

   \                                 In section .text, align 2, keep-with-next
    433          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    434          {
   \                     GPIO_ResetBits: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    435            /* Check the parameters */
    436            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000006   0x....             LDR.N    R0,??DataTable12  ;; 0x40020000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD024             BEQ.N    ??GPIO_ResetBits_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD021             BEQ.N    ??GPIO_ResetBits_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD01E             BEQ.N    ??GPIO_ResetBits_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40020c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD01B             BEQ.N    ??GPIO_ResetBits_0
   \   0000001E   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40021000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD018             BEQ.N    ??GPIO_ResetBits_0
   \   00000024   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40021400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD015             BEQ.N    ??GPIO_ResetBits_0
   \   0000002A   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40021800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD012             BEQ.N    ??GPIO_ResetBits_0
   \   00000030   0x....             LDR.N    R0,??DataTable12_7  ;; 0x40021c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00F             BEQ.N    ??GPIO_ResetBits_0
   \   00000036   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40022000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD00C             BEQ.N    ??GPIO_ResetBits_0
   \   0000003C   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40022400
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD009             BEQ.N    ??GPIO_ResetBits_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x40022800
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD005             BEQ.N    ??GPIO_ResetBits_0
   \   0000004A   0xF44F 0x71DA      MOV      R1,#+436
   \   0000004E   0x.... 0x....      ADR.W    R0,?_0
   \   00000052   0x.... 0x....      BL       assert_failed
    437            assert_param(IS_GPIO_PIN(GPIO_Pin));
   \                     ??GPIO_ResetBits_0: (+1)
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD105             BNE.N    ??GPIO_ResetBits_1
   \   0000005A   0xF240 0x11B5      MOVW     R1,#+437
   \   0000005E   0x.... 0x....      ADR.W    R0,?_0
   \   00000062   0x.... 0x....      BL       assert_failed
    438          
    439            GPIOx->BSRRH = GPIO_Pin;
   \                     ??GPIO_ResetBits_1: (+1)
   \   00000066   0x8365             STRH     R5,[R4, #+26]
    440          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    441          
    442          /**
    443            * @brief  Sets or clears the selected data port bit.
    444            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    445            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    446            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    447            * @param  GPIO_Pin: specifies the port bit to be written.
    448            *          This parameter can be one of GPIO_Pin_x where x can be (0..15).
    449            * @param  BitVal: specifies the value to be written to the selected bit.
    450            *          This parameter can be one of the BitAction enum values:
    451            *            @arg Bit_RESET: to clear the port pin
    452            *            @arg Bit_SET: to set the port pin
    453            * @retval None
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
    456          {
   \                     GPIO_WriteBit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    457            /* Check the parameters */
    458            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000008   0x....             LDR.N    R0,??DataTable12  ;; 0x40020000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD023             BEQ.N    ??GPIO_WriteBit_0
   \   0000000E   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020400
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD020             BEQ.N    ??GPIO_WriteBit_0
   \   00000014   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD01D             BEQ.N    ??GPIO_WriteBit_0
   \   0000001A   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40020c00
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD01A             BEQ.N    ??GPIO_WriteBit_0
   \   00000020   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40021000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD017             BEQ.N    ??GPIO_WriteBit_0
   \   00000026   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40021400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD014             BEQ.N    ??GPIO_WriteBit_0
   \   0000002C   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40021800
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD011             BEQ.N    ??GPIO_WriteBit_0
   \   00000032   0x....             LDR.N    R0,??DataTable12_7  ;; 0x40021c00
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD00E             BEQ.N    ??GPIO_WriteBit_0
   \   00000038   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40022000
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD00B             BEQ.N    ??GPIO_WriteBit_0
   \   0000003E   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40022400
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD008             BEQ.N    ??GPIO_WriteBit_0
   \   00000044   0x....             LDR.N    R0,??DataTable13  ;; 0x40022800
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD005             BEQ.N    ??GPIO_WriteBit_0
   \   0000004A   0xF44F 0x71E5      MOV      R1,#+458
   \   0000004E   0x.... 0x....      ADR.W    R0,?_0
   \   00000052   0x.... 0x....      BL       assert_failed
    459            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
   \                     ??GPIO_WriteBit_0: (+1)
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD02B             BEQ.N    ??GPIO_WriteBit_1
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD029             BEQ.N    ??GPIO_WriteBit_1
   \   00000060   0x2804             CMP      R0,#+4
   \   00000062   0xD027             BEQ.N    ??GPIO_WriteBit_1
   \   00000064   0x2808             CMP      R0,#+8
   \   00000066   0xD025             BEQ.N    ??GPIO_WriteBit_1
   \   00000068   0x2810             CMP      R0,#+16
   \   0000006A   0xD023             BEQ.N    ??GPIO_WriteBit_1
   \   0000006C   0x2820             CMP      R0,#+32
   \   0000006E   0xD021             BEQ.N    ??GPIO_WriteBit_1
   \   00000070   0x2840             CMP      R0,#+64
   \   00000072   0xD01F             BEQ.N    ??GPIO_WriteBit_1
   \   00000074   0x2880             CMP      R0,#+128
   \   00000076   0xD01D             BEQ.N    ??GPIO_WriteBit_1
   \   00000078   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000007C   0xD01A             BEQ.N    ??GPIO_WriteBit_1
   \   0000007E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000082   0xD017             BEQ.N    ??GPIO_WriteBit_1
   \   00000084   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000088   0xD014             BEQ.N    ??GPIO_WriteBit_1
   \   0000008A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000008E   0xD011             BEQ.N    ??GPIO_WriteBit_1
   \   00000090   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000094   0xD00E             BEQ.N    ??GPIO_WriteBit_1
   \   00000096   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000009A   0xD00B             BEQ.N    ??GPIO_WriteBit_1
   \   0000009C   0xF5B0 0x4F80      CMP      R0,#+16384
   \   000000A0   0xD008             BEQ.N    ??GPIO_WriteBit_1
   \   000000A2   0xF5B0 0x4F00      CMP      R0,#+32768
   \   000000A6   0xD005             BEQ.N    ??GPIO_WriteBit_1
   \   000000A8   0xF240 0x11CB      MOVW     R1,#+459
   \   000000AC   0x.... 0x....      ADR.W    R0,?_0
   \   000000B0   0x.... 0x....      BL       assert_failed
    460            assert_param(IS_GPIO_BIT_ACTION(BitVal));
   \                     ??GPIO_WriteBit_1: (+1)
   \   000000B4   0x2E00             CMP      R6,#+0
   \   000000B6   0xD007             BEQ.N    ??GPIO_WriteBit_2
   \   000000B8   0x2E01             CMP      R6,#+1
   \   000000BA   0xD005             BEQ.N    ??GPIO_WriteBit_2
   \   000000BC   0xF44F 0x71E6      MOV      R1,#+460
   \   000000C0   0x.... 0x....      ADR.W    R0,?_0
   \   000000C4   0x.... 0x....      BL       assert_failed
    461          
    462            if (BitVal != Bit_RESET)
   \                     ??GPIO_WriteBit_2: (+1)
   \   000000C8   0x2E00             CMP      R6,#+0
   \   000000CA   0xD001             BEQ.N    ??GPIO_WriteBit_3
    463            {
    464              GPIOx->BSRRL = GPIO_Pin;
   \   000000CC   0x8325             STRH     R5,[R4, #+24]
   \   000000CE   0xBD70             POP      {R4-R6,PC}
    465            }
    466            else
    467            {
    468              GPIOx->BSRRH = GPIO_Pin ;
   \                     ??GPIO_WriteBit_3: (+1)
   \   000000D0   0x8365             STRH     R5,[R4, #+26]
    469            }
    470          }
   \   000000D2   0xBD70             POP      {R4-R6,PC}       ;; return
    471          
    472          /**
    473            * @brief  Writes data to the specified GPIO data port.
    474            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    475            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    476            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    477            * @param  PortVal: specifies the value to be written to the port output data register.
    478            * @retval None
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
    481          {
   \                     GPIO_Write: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    482            /* Check the parameters */
    483            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000006   0x....             LDR.N    R0,??DataTable12  ;; 0x40020000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD023             BEQ.N    ??GPIO_Write_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD020             BEQ.N    ??GPIO_Write_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD01D             BEQ.N    ??GPIO_Write_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40020c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD01A             BEQ.N    ??GPIO_Write_0
   \   0000001E   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40021000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD017             BEQ.N    ??GPIO_Write_0
   \   00000024   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40021400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD014             BEQ.N    ??GPIO_Write_0
   \   0000002A   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40021800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD011             BEQ.N    ??GPIO_Write_0
   \   00000030   0x....             LDR.N    R0,??DataTable12_7  ;; 0x40021c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00E             BEQ.N    ??GPIO_Write_0
   \   00000036   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40022000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD00B             BEQ.N    ??GPIO_Write_0
   \   0000003C   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40022400
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD008             BEQ.N    ??GPIO_Write_0
   \   00000042   0x....             LDR.N    R0,??DataTable13  ;; 0x40022800
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD005             BEQ.N    ??GPIO_Write_0
   \   00000048   0xF240 0x11E3      MOVW     R1,#+483
   \   0000004C   0x.... 0x....      ADR.W    R0,?_0
   \   00000050   0x.... 0x....      BL       assert_failed
    484          
    485            GPIOx->ODR = PortVal;
   \                     ??GPIO_Write_0: (+1)
   \   00000054   0x6165             STR      R5,[R4, #+20]
    486          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    487          
    488          /**
    489            * @brief  Toggles the specified GPIO pins..
    490            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    491            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    492            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    493            * @param  GPIO_Pin: Specifies the pins to be toggled.
    494            * @retval None
    495            */

   \                                 In section .text, align 2, keep-with-next
    496          void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    497          {
   \                     GPIO_ToggleBits: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    498            /* Check the parameters */
    499            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000006   0x....             LDR.N    R0,??DataTable12  ;; 0x40020000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD023             BEQ.N    ??GPIO_ToggleBits_0
   \   0000000C   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40020400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD020             BEQ.N    ??GPIO_ToggleBits_0
   \   00000012   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40020800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD01D             BEQ.N    ??GPIO_ToggleBits_0
   \   00000018   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40020c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD01A             BEQ.N    ??GPIO_ToggleBits_0
   \   0000001E   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40021000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD017             BEQ.N    ??GPIO_ToggleBits_0
   \   00000024   0x....             LDR.N    R0,??DataTable12_5  ;; 0x40021400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD014             BEQ.N    ??GPIO_ToggleBits_0
   \   0000002A   0x....             LDR.N    R0,??DataTable12_6  ;; 0x40021800
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD011             BEQ.N    ??GPIO_ToggleBits_0
   \   00000030   0x....             LDR.N    R0,??DataTable12_7  ;; 0x40021c00
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD00E             BEQ.N    ??GPIO_ToggleBits_0
   \   00000036   0x....             LDR.N    R0,??DataTable12_8  ;; 0x40022000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD00B             BEQ.N    ??GPIO_ToggleBits_0
   \   0000003C   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40022400
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD008             BEQ.N    ??GPIO_ToggleBits_0
   \   00000042   0x....             LDR.N    R0,??DataTable13  ;; 0x40022800
   \   00000044   0x4284             CMP      R4,R0
   \   00000046   0xD005             BEQ.N    ??GPIO_ToggleBits_0
   \   00000048   0xF240 0x11F3      MOVW     R1,#+499
   \   0000004C   0x.... 0x....      ADR.W    R0,?_0
   \   00000050   0x.... 0x....      BL       assert_failed
    500          
    501            GPIOx->ODR ^= GPIO_Pin;
   \                     ??GPIO_ToggleBits_0: (+1)
   \   00000054   0x6960             LDR      R0,[R4, #+20]
   \   00000056   0x4068             EORS     R0,R5,R0
   \   00000058   0x6160             STR      R0,[R4, #+20]
    502          }
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    503          
    504          /**
    505            * @}
    506            */
    507          
    508          /** @defgroup GPIO_Group3 GPIO Alternate functions configuration function
    509           *  @brief   GPIO Alternate functions configuration function
    510           *
    511          @verbatim   
    512           ===============================================================================
    513                     ##### GPIO Alternate functions configuration function #####
    514           ===============================================================================  
    515          
    516          @endverbatim
    517            * @{
    518            */
    519          
    520          /**
    521            * @brief  Changes the mapping of the specified pin.
    522            * @param  GPIOx: where x can be (A..K) to select the GPIO peripheral for STM32F405xx/407xx and STM32F415xx/417xx devices
    523            *                      x can be (A..I) to select the GPIO peripheral for STM32F42xxx/43xxx devices.
    524            *                      x can be (A, B, C, D and H) to select the GPIO peripheral for STM32F401xx devices. 
    525            * @param  GPIO_PinSource: specifies the pin for the Alternate function.
    526            *         This parameter can be GPIO_PinSourcex where x can be (0..15).
    527            * @param  GPIO_AFSelection: selects the pin to used as Alternate function.
    528            *          This parameter can be one of the following values:
    529            *            @arg GPIO_AF_RTC_50Hz: Connect RTC_50Hz pin to AF0 (default after reset) 
    530            *            @arg GPIO_AF_MCO: Connect MCO pin (MCO1 and MCO2) to AF0 (default after reset) 
    531            *            @arg GPIO_AF_TAMPER: Connect TAMPER pins (TAMPER_1 and TAMPER_2) to AF0 (default after reset) 
    532            *            @arg GPIO_AF_SWJ: Connect SWJ pins (SWD and JTAG)to AF0 (default after reset) 
    533            *            @arg GPIO_AF_TRACE: Connect TRACE pins to AF0 (default after reset)
    534            *            @arg GPIO_AF_TIM1: Connect TIM1 pins to AF1
    535            *            @arg GPIO_AF_TIM2: Connect TIM2 pins to AF1
    536            *            @arg GPIO_AF_TIM3: Connect TIM3 pins to AF2
    537            *            @arg GPIO_AF_TIM4: Connect TIM4 pins to AF2
    538            *            @arg GPIO_AF_TIM5: Connect TIM5 pins to AF2
    539            *            @arg GPIO_AF_TIM8: Connect TIM8 pins to AF3
    540            *            @arg GPIO_AF_TIM9: Connect TIM9 pins to AF3
    541            *            @arg GPIO_AF_TIM10: Connect TIM10 pins to AF3
    542            *            @arg GPIO_AF_TIM11: Connect TIM11 pins to AF3
    543            *            @arg GPIO_AF_I2C1: Connect I2C1 pins to AF4
    544            *            @arg GPIO_AF_I2C2: Connect I2C2 pins to AF4
    545            *            @arg GPIO_AF_I2C3: Connect I2C3 pins to AF4
    546            *            @arg GPIO_AF_SPI1: Connect SPI1 pins to AF5
    547            *            @arg GPIO_AF_SPI2: Connect SPI2/I2S2 pins to AF5
    548            *            @arg GPIO_AF_SPI4: Connect SPI4 pins to AF5 
    549            *            @arg GPIO_AF_SPI5: Connect SPI5 pins to AF5 
    550            *            @arg GPIO_AF_SPI6: Connect SPI6 pins to AF5
    551            *            @arg GPIO_AF_SAI1: Connect SAI1 pins to AF6 for STM32F42xxx/43xxx devices.       
    552            *            @arg GPIO_AF_SPI3: Connect SPI3/I2S3 pins to AF6
    553            *            @arg GPIO_AF_I2S3ext: Connect I2S3ext pins to AF7
    554            *            @arg GPIO_AF_USART1: Connect USART1 pins to AF7
    555            *            @arg GPIO_AF_USART2: Connect USART2 pins to AF7
    556            *            @arg GPIO_AF_USART3: Connect USART3 pins to AF7
    557            *            @arg GPIO_AF_UART4: Connect UART4 pins to AF8
    558            *            @arg GPIO_AF_UART5: Connect UART5 pins to AF8
    559            *            @arg GPIO_AF_USART6: Connect USART6 pins to AF8
    560            *            @arg GPIO_AF_UART7: Connect UART7 pins to AF8
    561            *            @arg GPIO_AF_UART8: Connect UART8 pins to AF8
    562            *            @arg GPIO_AF_CAN1: Connect CAN1 pins to AF9
    563            *            @arg GPIO_AF_CAN2: Connect CAN2 pins to AF9
    564            *            @arg GPIO_AF_TIM12: Connect TIM12 pins to AF9
    565            *            @arg GPIO_AF_TIM13: Connect TIM13 pins to AF9
    566            *            @arg GPIO_AF_TIM14: Connect TIM14 pins to AF9
    567            *            @arg GPIO_AF_OTG_FS: Connect OTG_FS pins to AF10
    568            *            @arg GPIO_AF_OTG_HS: Connect OTG_HS pins to AF10
    569            *            @arg GPIO_AF_ETH: Connect ETHERNET pins to AF11
    570            *            @arg GPIO_AF_FSMC: Connect FSMC pins to AF12 
    571            *            @arg GPIO_AF_FMC: Connect FMC pins to AF12 for STM32F42xxx/43xxx devices.   
    572            *            @arg GPIO_AF_OTG_HS_FS: Connect OTG HS (configured in FS) pins to AF12
    573            *            @arg GPIO_AF_SDIO: Connect SDIO pins to AF12
    574            *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
    575            *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices. 
    576            *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
    577            * @retval None
    578            */

   \                                 In section .text, align 2, keep-with-next
    579          void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
    580          {
   \                     GPIO_PinAFConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4614             MOV      R4,R2
    581            uint32_t temp = 0x00;
    582            uint32_t temp_2 = 0x00;
    583            
    584            /* Check the parameters */
    585            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
   \   00000008   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40020000
   \   0000000A   0x4286             CMP      R6,R0
   \   0000000C   0xD023             BEQ.N    ??GPIO_PinAFConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40020400
   \   00000010   0x4286             CMP      R6,R0
   \   00000012   0xD020             BEQ.N    ??GPIO_PinAFConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable13_3  ;; 0x40020800
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xD01D             BEQ.N    ??GPIO_PinAFConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable13_4  ;; 0x40020c00
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xD01A             BEQ.N    ??GPIO_PinAFConfig_0
   \   00000020   0x....             LDR.N    R0,??DataTable13_5  ;; 0x40021000
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xD017             BEQ.N    ??GPIO_PinAFConfig_0
   \   00000026   0x....             LDR.N    R0,??DataTable13_6  ;; 0x40021400
   \   00000028   0x4286             CMP      R6,R0
   \   0000002A   0xD014             BEQ.N    ??GPIO_PinAFConfig_0
   \   0000002C   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40021800
   \   0000002E   0x4286             CMP      R6,R0
   \   00000030   0xD011             BEQ.N    ??GPIO_PinAFConfig_0
   \   00000032   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40021c00
   \   00000034   0x4286             CMP      R6,R0
   \   00000036   0xD00E             BEQ.N    ??GPIO_PinAFConfig_0
   \   00000038   0x....             LDR.N    R0,??DataTable13_9  ;; 0x40022000
   \   0000003A   0x4286             CMP      R6,R0
   \   0000003C   0xD00B             BEQ.N    ??GPIO_PinAFConfig_0
   \   0000003E   0x....             LDR.N    R0,??DataTable13_10  ;; 0x40022400
   \   00000040   0x4286             CMP      R6,R0
   \   00000042   0xD008             BEQ.N    ??GPIO_PinAFConfig_0
   \   00000044   0x....             LDR.N    R0,??DataTable13  ;; 0x40022800
   \   00000046   0x4286             CMP      R6,R0
   \   00000048   0xD005             BEQ.N    ??GPIO_PinAFConfig_0
   \   0000004A   0xF240 0x2149      MOVW     R1,#+585
   \   0000004E   0x.... 0x....      ADR.W    R0,?_0
   \   00000052   0x.... 0x....      BL       assert_failed
    586            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
   \                     ??GPIO_PinAFConfig_0: (+1)
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD024             BEQ.N    ??GPIO_PinAFConfig_1
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD021             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000060   0x2802             CMP      R0,#+2
   \   00000062   0xD01F             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000064   0x2803             CMP      R0,#+3
   \   00000066   0xD01D             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000068   0x2804             CMP      R0,#+4
   \   0000006A   0xD01B             BEQ.N    ??GPIO_PinAFConfig_1
   \   0000006C   0x2805             CMP      R0,#+5
   \   0000006E   0xD019             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000070   0x2806             CMP      R0,#+6
   \   00000072   0xD017             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000074   0x2807             CMP      R0,#+7
   \   00000076   0xD015             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000078   0x2808             CMP      R0,#+8
   \   0000007A   0xD013             BEQ.N    ??GPIO_PinAFConfig_1
   \   0000007C   0x2809             CMP      R0,#+9
   \   0000007E   0xD011             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000080   0x280A             CMP      R0,#+10
   \   00000082   0xD00F             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000084   0x280B             CMP      R0,#+11
   \   00000086   0xD00D             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000088   0x280C             CMP      R0,#+12
   \   0000008A   0xD00B             BEQ.N    ??GPIO_PinAFConfig_1
   \   0000008C   0x280D             CMP      R0,#+13
   \   0000008E   0xD009             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000090   0x280E             CMP      R0,#+14
   \   00000092   0xD007             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000094   0x280F             CMP      R0,#+15
   \   00000096   0xD005             BEQ.N    ??GPIO_PinAFConfig_1
   \   00000098   0xF240 0x214A      MOVW     R1,#+586
   \   0000009C   0x.... 0x....      ADR.W    R0,?_0
   \   000000A0   0x.... 0x....      BL       assert_failed
    587            assert_param(IS_GPIO_AF(GPIO_AF));
   \                     ??GPIO_PinAFConfig_1: (+1)
   \   000000A4   0x2C00             CMP      R4,#+0
   \   000000A6   0xD02C             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x2809             CMP      R0,#+9
   \   000000AC   0xD029             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000AE   0x2C00             CMP      R4,#+0
   \   000000B0   0xD027             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD025             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000B6   0x2802             CMP      R0,#+2
   \   000000B8   0xD023             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000BA   0x2803             CMP      R0,#+3
   \   000000BC   0xD021             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000BE   0x2804             CMP      R0,#+4
   \   000000C0   0xD01F             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000C2   0x2805             CMP      R0,#+5
   \   000000C4   0xD01D             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000C6   0x2809             CMP      R0,#+9
   \   000000C8   0xD01B             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000CA   0x2806             CMP      R0,#+6
   \   000000CC   0xD019             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000CE   0x2809             CMP      R0,#+9
   \   000000D0   0xD017             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000D2   0x2807             CMP      R0,#+7
   \   000000D4   0xD015             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000D6   0x2808             CMP      R0,#+8
   \   000000D8   0xD013             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000DA   0x2809             CMP      R0,#+9
   \   000000DC   0xD011             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000DE   0x280A             CMP      R0,#+10
   \   000000E0   0xD00F             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000E2   0x280B             CMP      R0,#+11
   \   000000E4   0xD00D             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000E6   0x280C             CMP      R0,#+12
   \   000000E8   0xD00B             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000EA   0x280D             CMP      R0,#+13
   \   000000EC   0xD009             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000EE   0x280F             CMP      R0,#+15
   \   000000F0   0xD007             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000F2   0x280C             CMP      R0,#+12
   \   000000F4   0xD005             BEQ.N    ??GPIO_PinAFConfig_2
   \   000000F6   0xF240 0x214B      MOVW     R1,#+587
   \   000000FA   0x.... 0x....      ADR.W    R0,?_0
   \   000000FE   0x.... 0x....      BL       assert_failed
    588            
    589            temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
    590            GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
   \                     ??GPIO_PinAFConfig_2: (+1)
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0x10C0             ASRS     R0,R0,#+3
   \   00000106   0xEB06 0x0080      ADD      R0,R6,R0, LSL #+2
   \   0000010A   0xF005 0x0107      AND      R1,R5,#0x7
   \   0000010E   0x0089             LSLS     R1,R1,#+2
   \   00000110   0x6A02             LDR      R2,[R0, #+32]
   \   00000112   0x230F             MOVS     R3,#+15
   \   00000114   0x408B             LSLS     R3,R3,R1
   \   00000116   0x439A             BICS     R2,R2,R3
   \   00000118   0x6202             STR      R2,[R0, #+32]
    591            temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
   \   0000011A   0x6A02             LDR      R2,[R0, #+32]
   \   0000011C   0xFA04 0xF101      LSL      R1,R4,R1
   \   00000120   0x4311             ORRS     R1,R1,R2
    592            GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
   \   00000122   0x6201             STR      R1,[R0, #+32]
    593          }
   \   00000124   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x40022400         DC32     0x40022400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40022800         DC32     0x40022800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x40022400         DC32     0x40022400

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x67 0x70          DC8 67H, 70H, 69H, 6FH, 2EH, 63H, 0
   \              0x69 0x6F    
   \              0x2E 0x63    
   \              0x00         
   \   00000067   0x00               DC8 0
    594          
    595          /**
    596            * @}
    597            */ 
    598          
    599          /**
    600            * @}
    601            */
    602          
    603          /**
    604            * @}
    605            */ 
    606          
    607          /**
    608            * @}
    609            */ 
    610          
    611          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GPIO_DeInit
        16   -> RCC_AHB1PeriphResetCmd
        16   -> assert_failed
      32   GPIO_Init
        32   -> assert_failed
      16   GPIO_PinAFConfig
        16   -> assert_failed
      16   GPIO_PinLockConfig
        16   -> assert_failed
       8   GPIO_ReadInputData
         8   -> assert_failed
      16   GPIO_ReadInputDataBit
        16   -> assert_failed
       8   GPIO_ReadOutputData
         8   -> assert_failed
      16   GPIO_ReadOutputDataBit
        16   -> assert_failed
      16   GPIO_ResetBits
        16   -> assert_failed
      16   GPIO_SetBits
        16   -> assert_failed
       0   GPIO_StructInit
      16   GPIO_ToggleBits
        16   -> assert_failed
      16   GPIO_Write
        16   -> assert_failed
      16   GPIO_WriteBit
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
     104  ?_0
     420  GPIO_DeInit
     352  GPIO_Init
     294  GPIO_PinAFConfig
     154  GPIO_PinLockConfig
     110  GPIO_ReadInputData
     214  GPIO_ReadInputDataBit
      90  GPIO_ReadOutputData
     214  GPIO_ReadOutputDataBit
     106  GPIO_ResetBits
     106  GPIO_SetBits
      18  GPIO_StructInit
      92  GPIO_ToggleBits
      88  GPIO_Write
     212  GPIO_WriteBit

 
 2 658 bytes in section .text
 
 2 658 bytes of CODE memory

Errors: none
Warnings: none
