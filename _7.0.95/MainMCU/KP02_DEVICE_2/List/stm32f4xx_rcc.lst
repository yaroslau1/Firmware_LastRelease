###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        08/Oct/2018  17:04:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_rcc.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_rcc.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Reset and clock control (RCC) peripheral:
      9            *           + Internal/external clocks, PLL, CSS and MCO configuration
     10            *           + System, AHB and APB busses clocks configuration
     11            *           + Peripheral clocks configuration
     12            *           + Interrupts and flags management
     13            *
     14           @verbatim                
     15           ===============================================================================
     16                                ##### RCC specific features #####
     17           ===============================================================================
     18              [..]  
     19                After reset the device is running from Internal High Speed oscillator 
     20                (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache 
     21                and I-Cache are disabled, and all peripherals are off except internal
     22                SRAM, Flash and JTAG.
     23                (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     24                    all peripherals mapped on these busses are running at HSI speed.
     25                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     26                (+) All GPIOs are in input floating state, except the JTAG pins which
     27                    are assigned to be used for debug purpose.
     28              [..]          
     29                Once the device started from reset, the user application has to:        
     30                (+) Configure the clock source to be used to drive the System clock
     31                    (if the application needs higher frequency/performance)
     32                (+) Configure the System clock frequency and Flash settings  
     33                (+) Configure the AHB and APB busses prescalers
     34                (+) Enable the clock for the peripheral(s) to be used
     35                (+) Configure the clock source(s) for peripherals which clocks are not
     36                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)                                
     37           @endverbatim    
     38            ******************************************************************************
     39            * @attention
     40            *
     41            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     42            *
     43            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     44            * You may not use this file except in compliance with the License.
     45            * You may obtain a copy of the License at:
     46            *
     47            *        http://www.st.com/software_license_agreement_liberty_v2
     48            *
     49            * Unless required by applicable law or agreed to in writing, software 
     50            * distributed under the License is distributed on an "AS IS" BASIS, 
     51            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     52            * See the License for the specific language governing permissions and
     53            * limitations under the License.
     54            *
     55            ******************************************************************************
     56            */
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "stm32f4xx_rcc.h"
     60          
     61          /** @addtogroup STM32F4xx_StdPeriph_Driver
     62            * @{
     63            */
     64          
     65          /** @defgroup RCC 
     66            * @brief RCC driver modules
     67            * @{
     68            */ 
     69          
     70          /* Private typedef -----------------------------------------------------------*/
     71          /* Private define ------------------------------------------------------------*/
     72          /* ------------ RCC registers bit address in the alias region ----------- */
     73          #define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
     74          /* --- CR Register ---*/
     75          /* Alias word address of HSION bit */
     76          #define CR_OFFSET                 (RCC_OFFSET + 0x00)
     77          #define HSION_BitNumber           0x00
     78          #define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
     79          /* Alias word address of CSSON bit */
     80          #define CSSON_BitNumber           0x13
     81          #define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
     82          /* Alias word address of PLLON bit */
     83          #define PLLON_BitNumber           0x18
     84          #define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
     85          /* Alias word address of PLLI2SON bit */
     86          #define PLLI2SON_BitNumber        0x1A
     87          #define CR_PLLI2SON_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLI2SON_BitNumber * 4))
     88          
     89          /* Alias word address of PLLSAION bit */
     90          #define PLLSAION_BitNumber        0x1C
     91          #define CR_PLLSAION_BB            (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLSAION_BitNumber * 4))
     92          
     93          /* --- CFGR Register ---*/
     94          /* Alias word address of I2SSRC bit */
     95          #define CFGR_OFFSET               (RCC_OFFSET + 0x08)
     96          #define I2SSRC_BitNumber          0x17
     97          #define CFGR_I2SSRC_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (I2SSRC_BitNumber * 4))
     98          
     99          /* --- BDCR Register ---*/
    100          /* Alias word address of RTCEN bit */
    101          #define BDCR_OFFSET               (RCC_OFFSET + 0x70)
    102          #define RTCEN_BitNumber           0x0F
    103          #define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
    104          /* Alias word address of BDRST bit */
    105          #define BDRST_BitNumber           0x10
    106          #define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
    107          
    108          /* --- CSR Register ---*/
    109          /* Alias word address of LSION bit */
    110          #define CSR_OFFSET                (RCC_OFFSET + 0x74)
    111          #define LSION_BitNumber           0x00
    112          #define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
    113          
    114          /* --- DCKCFGR Register ---*/
    115          /* Alias word address of TIMPRE bit */
    116          #define DCKCFGR_OFFSET            (RCC_OFFSET + 0x8C)
    117          #define TIMPRE_BitNumber          0x18
    118          #define DCKCFGR_TIMPRE_BB         (PERIPH_BB_BASE + (DCKCFGR_OFFSET * 32) + (TIMPRE_BitNumber * 4))
    119          /* ---------------------- RCC registers bit mask ------------------------ */
    120          /* CFGR register bit mask */
    121          #define CFGR_MCO2_RESET_MASK      ((uint32_t)0x07FFFFFF)
    122          #define CFGR_MCO1_RESET_MASK      ((uint32_t)0xF89FFFFF)
    123          
    124          /* RCC Flag Mask */
    125          #define FLAG_MASK                 ((uint8_t)0x1F)
    126          
    127          /* CR register byte 3 (Bits[23:16]) base address */
    128          #define CR_BYTE3_ADDRESS          ((uint32_t)0x40023802)
    129          
    130          /* CIR register byte 2 (Bits[15:8]) base address */
    131          #define CIR_BYTE2_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x01))
    132          
    133          /* CIR register byte 3 (Bits[23:16]) base address */
    134          #define CIR_BYTE3_ADDRESS         ((uint32_t)(RCC_BASE + 0x0C + 0x02))
    135          
    136          /* BDCR register base address */
    137          #define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)
    138          
    139          /* Private macro -------------------------------------------------------------*/
    140          /* Private variables ---------------------------------------------------------*/

   \                                 In section .data, align 4
    141          static __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     APBAHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
    142          
    143          /* Private function prototypes -----------------------------------------------*/
    144          /* Private functions ---------------------------------------------------------*/
    145          
    146          /** @defgroup RCC_Private_Functions
    147            * @{
    148            */ 
    149          
    150          /** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
    151           *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
    152           *
    153          @verbatim   
    154           ===================================================================================
    155           ##### Internal and  external clocks, PLL, CSS and MCO configuration functions #####
    156           ===================================================================================  
    157              [..]
    158                This section provide functions allowing to configure the internal/external clocks,
    159                PLLs, CSS and MCO pins.
    160            
    161                (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    162                    the PLL as System clock source.
    163          
    164                (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
    165                    clock source.
    166          
    167                (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
    168                    through the PLL as System clock source. Can be used also as RTC clock source.
    169          
    170                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    171          
    172                (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
    173                  (++) The first output is used to generate the high speed system clock (up to 168 MHz)
    174                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
    175                       the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
    176          
    177                (#) PLLI2S (clocked by HSI or HSE), used to generate an accurate clock to achieve 
    178                    high-quality audio performance on the I2S interface or SAI interface in case 
    179                    of STM32F429x/439x devices.
    180               
    181                (#) PLLSAI clocked by (HSI or HSE), used to generate an accurate clock to SAI 
    182                    interface and LCD TFT controller available only for STM32F42xxx/43xxx devices.
    183            
    184                (#) CSS (Clock security system), once enable and if a HSE clock failure occurs 
    185                   (HSE used directly or through PLL as System clock source), the System clock
    186                   is automatically switched to HSI and an interrupt is generated if enabled. 
    187                   The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
    188                   exception vector.   
    189          
    190                (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
    191                    clock (through a configurable prescaler) on PA8 pin.
    192          
    193                (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
    194                    clock (through a configurable prescaler) on PC9 pin.
    195           @endverbatim
    196            * @{
    197            */
    198          
    199          /**
    200            * @brief  Resets the RCC clock configuration to the default reset state.
    201            * @note   The default reset state of the clock configuration is given below:
    202            *            - HSI ON and used as system clock source
    203            *            - HSE, PLL and PLLI2S OFF
    204            *            - AHB, APB1 and APB2 prescaler set to 1.
    205            *            - CSS, MCO1 and MCO2 OFF
    206            *            - All interrupts disabled
    207            * @note   This function doesn't modify the configuration of the
    208            *            - Peripheral clocks  
    209            *            - LSI, LSE and RTC clocks 
    210            * @param  None
    211            * @retval None
    212            */

   \                                 In section .text, align 2, keep-with-next
    213          void RCC_DeInit(void)
    214          {
    215            /* Set HSION bit */
    216            RCC->CR |= (uint32_t)0x00000001;
   \                     RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable41  ;; 0x40023800
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    217          
    218            /* Reset CFGR register */
    219            RCC->CFGR = 0x00000000;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    220          
    221            /* Reset HSEON, CSSON, PLLON, PLLI2S and PLLSAI(STM32F42/43xxx devices) bits */
    222            RCC->CR &= (uint32_t)0xEAF6FFFF;
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable41_1  ;; 0xeaf6ffff
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x6001             STR      R1,[R0, #+0]
    223          
    224            /* Reset PLLCFGR register */
    225            RCC->PLLCFGR = 0x24003010;
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable42  ;; 0x24003010
   \   0000001E   0x6041             STR      R1,[R0, #+4]
    226          
    227            /* Reset PLLI2SCFGR register */
    228            RCC->PLLI2SCFGR = 0x20003000;
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable42_1  ;; 0x40023884
   \   00000024   0x.... 0x....      LDR.W    R2,??DataTable42_2  ;; 0x20003000
   \   00000028   0x600A             STR      R2,[R1, #+0]
    229          
    230            /* Reset PLLSAICFGR register, only available for STM32F42/43xxx devices */
    231            RCC->PLLSAICFGR = 0x24003000;
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable47  ;; 0x24003000
   \   0000002E   0x604A             STR      R2,[R1, #+4]
    232           
    233            /* Reset HSEBYP bit */
    234            RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000030   0x6802             LDR      R2,[R0, #+0]
   \   00000032   0xF422 0x2280      BIC      R2,R2,#0x40000
   \   00000036   0x6002             STR      R2,[R0, #+0]
    235          
    236            /* Disable all interrupts */
    237            RCC->CIR = 0x00000000;
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x60C2             STR      R2,[R0, #+12]
    238          
    239            /* Disable Timers clock prescalers selection, only available for STM32F42/43xxx devices */
    240            RCC->DCKCFGR = 0x00000000; 
   \   0000003C   0x4610             MOV      R0,R2
   \   0000003E   0x6088             STR      R0,[R1, #+8]
    241          
    242          }
   \   00000040   0x4770             BX       LR               ;; return
    243          
    244          /**
    245            * @brief  Configures the External High Speed oscillator (HSE).
    246            * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
    247            *         software should wait on HSERDY flag to be set indicating that HSE clock
    248            *         is stable and can be used to clock the PLL and/or system clock.
    249            * @note   HSE state can not be changed if it is used directly or through the
    250            *         PLL as system clock. In this case, you have to select another source
    251            *         of the system clock then change the HSE state (ex. disable it).
    252            * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.  
    253            * @note   This function reset the CSSON bit, so if the Clock security system(CSS)
    254            *         was previously enabled you have to enable it again after calling this
    255            *         function.    
    256            * @param  RCC_HSE: specifies the new state of the HSE.
    257            *          This parameter can be one of the following values:
    258            *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
    259            *                              6 HSE oscillator clock cycles.
    260            *            @arg RCC_HSE_ON: turn ON the HSE oscillator
    261            *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
    262            * @retval None
    263            */

   \                                 In section .text, align 2, keep-with-next
    264          void RCC_HSEConfig(uint8_t RCC_HSE)
    265          {
   \                     RCC_HSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    266            /* Check the parameters */
    267            assert_param(IS_RCC_HSE(RCC_HSE));
   \   00000004   0xD009             BEQ.N    ??RCC_HSEConfig_0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD007             BEQ.N    ??RCC_HSEConfig_0
   \   0000000A   0x2805             CMP      R0,#+5
   \   0000000C   0xD005             BEQ.N    ??RCC_HSEConfig_0
   \   0000000E   0xF240 0x110B      MOVW     R1,#+267
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000016   0x.... 0x....      BL       assert_failed
    268          
    269            /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
    270            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
   \                     ??RCC_HSEConfig_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable47_1  ;; 0x40023802
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    271          
    272            /* Set the new HSE configuration -------------------------------------------*/
    273            *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
   \   00000022   0x7004             STRB     R4,[R0, #+0]
    274          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    275          
    276          /**
    277            * @brief  Waits for HSE start-up.
    278            * @note   This functions waits on HSERDY flag to be set and return SUCCESS if 
    279            *         this flag is set, otherwise returns ERROR if the timeout is reached 
    280            *         and this flag is not set. The timeout value is defined by the constant
    281            *         HSE_STARTUP_TIMEOUT in stm32f4xx.h file. You can tailor it depending
    282            *         on the HSE crystal used in your application. 
    283            * @param  None
    284            * @retval An ErrorStatus enumeration value:
    285            *          - SUCCESS: HSE oscillator is stable and ready to use
    286            *          - ERROR: HSE oscillator not yet ready
    287            */

   \                                 In section .text, align 2, keep-with-next
    288          ErrorStatus RCC_WaitForHSEStartUp(void)
    289          {
   \                     RCC_WaitForHSEStartUp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    290            __IO uint32_t startupcounter = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    291            ErrorStatus status = ERROR;
   \   00000008   0x4604             MOV      R4,R0
    292            FlagStatus hsestatus = RESET;
    293            /* Wait till HSE is ready and if Time out is reached exit */
    294            do
    295            {
    296              hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
   \                     ??RCC_WaitForHSEStartUp_0: (+1)
   \   0000000A   0x2031             MOVS     R0,#+49
   \   0000000C   0x.... 0x....      BL       RCC_GetFlagStatus
    297              startupcounter++;
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x9100             STR      R1,[SP, #+0]
    298            } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
   \   00000016   0x9900             LDR      R1,[SP, #+0]
   \   00000018   0xF5B1 0x4FA0      CMP      R1,#+20480
   \   0000001C   0xD001             BEQ.N    ??RCC_WaitForHSEStartUp_1
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD0F3             BEQ.N    ??RCC_WaitForHSEStartUp_0
    299          
    300            if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
   \                     ??RCC_WaitForHSEStartUp_1: (+1)
   \   00000022   0x2031             MOVS     R0,#+49
   \   00000024   0x.... 0x....      BL       RCC_GetFlagStatus
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD000             BEQ.N    ??RCC_WaitForHSEStartUp_2
    301            {
    302              status = SUCCESS;
   \   0000002C   0x2401             MOVS     R4,#+1
    303            }
    304            else
    305            {
    306              status = ERROR;
    307            }
    308            return (status);
   \                     ??RCC_WaitForHSEStartUp_2: (+1)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    309          }
    310          
    311          /**
    312            * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
    313            * @note   The calibration is used to compensate for the variations in voltage
    314            *         and temperature that influence the frequency of the internal HSI RC.
    315            * @param  HSICalibrationValue: specifies the calibration trimming value.
    316            *         This parameter must be a number between 0 and 0x1F.
    317            * @retval None
    318            */

   \                                 In section .text, align 2, keep-with-next
    319          void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
    320          {
   \                     RCC_AdjustHSICalibrationValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    321            uint32_t tmpreg = 0;
    322            /* Check the parameters */
    323            assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
   \   00000004   0x2C20             CMP      R4,#+32
   \   00000006   0xDB05             BLT.N    ??RCC_AdjustHSICalibrationValue_0
   \   00000008   0xF240 0x1143      MOVW     R1,#+323
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000010   0x.... 0x....      BL       assert_failed
    324          
    325            tmpreg = RCC->CR;
   \                     ??RCC_AdjustHSICalibrationValue_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable41  ;; 0x40023800
   \   00000018   0x6801             LDR      R1,[R0, #+0]
    326          
    327            /* Clear HSITRIM[4:0] bits */
    328            tmpreg &= ~RCC_CR_HSITRIM;
    329          
    330            /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
    331            tmpreg |= (uint32_t)HSICalibrationValue << 3;
    332          
    333            /* Store the new value */
    334            RCC->CR = tmpreg;
   \   0000001A   0xF021 0x01F8      BIC      R1,R1,#0xF8
   \   0000001E   0xEA41 0x01C4      ORR      R1,R1,R4, LSL #+3
   \   00000022   0x6001             STR      R1,[R0, #+0]
    335          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    336          
    337          /**
    338            * @brief  Enables or disables the Internal High Speed oscillator (HSI).
    339            * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
    340            *         It is used (enabled by hardware) as system clock source after startup
    341            *         from Reset, wakeup from STOP and STANDBY mode, or in case of failure
    342            *         of the HSE used directly or indirectly as system clock (if the Clock
    343            *         Security System CSS is enabled).             
    344            * @note   HSI can not be stopped if it is used as system clock source. In this case,
    345            *         you have to select another source of the system clock then stop the HSI.  
    346            * @note   After enabling the HSI, the application software should wait on HSIRDY
    347            *         flag to be set indicating that HSI clock is stable and can be used as
    348            *         system clock source.  
    349            * @param  NewState: new state of the HSI.
    350            *          This parameter can be: ENABLE or DISABLE.
    351            * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
    352            *         clock cycles.  
    353            * @retval None
    354            */

   \                                 In section .text, align 2, keep-with-next
    355          void RCC_HSICmd(FunctionalState NewState)
    356          {
   \                     RCC_HSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    357            /* Check the parameters */
    358            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_HSICmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_HSICmd_0
   \   0000000A   0xF44F 0x71B3      MOV      R1,#+358
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000012   0x.... 0x....      BL       assert_failed
    359          
    360            *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
   \                     ??RCC_HSICmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable49  ;; 0x42470000
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    361          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    362          
    363          /**
    364            * @brief  Configures the External Low Speed oscillator (LSE).
    365            * @note   As the LSE is in the Backup domain and write access is denied to
    366            *         this domain after reset, you have to enable write access using 
    367            *         PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
    368            *         (to be done once after reset).  
    369            * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
    370            *         software should wait on LSERDY flag to be set indicating that LSE clock
    371            *         is stable and can be used to clock the RTC.
    372            * @param  RCC_LSE: specifies the new state of the LSE.
    373            *          This parameter can be one of the following values:
    374            *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
    375            *                              6 LSE oscillator clock cycles.
    376            *            @arg RCC_LSE_ON: turn ON the LSE oscillator
    377            *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
    378            * @retval None
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          void RCC_LSEConfig(uint8_t RCC_LSE)
    381          {
   \                     RCC_LSEConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    382            /* Check the parameters */
    383            assert_param(IS_RCC_LSE(RCC_LSE));
   \   00000004   0xD009             BEQ.N    ??RCC_LSEConfig_0
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD007             BEQ.N    ??RCC_LSEConfig_0
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD005             BEQ.N    ??RCC_LSEConfig_0
   \   0000000E   0xF240 0x117F      MOVW     R1,#+383
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000016   0x.... 0x....      BL       assert_failed
    384          
    385            /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
    386            /* Reset LSEON bit */
    387            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \                     ??RCC_LSEConfig_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable50  ;; 0x40023870
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    388          
    389            /* Reset LSEBYP bit */
    390            *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    391          
    392            /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
    393            switch (RCC_LSE)
   \   00000024   0x2C01             CMP      R4,#+1
   \   00000026   0xD002             BEQ.N    ??RCC_LSEConfig_1
   \   00000028   0x2C04             CMP      R4,#+4
   \   0000002A   0xD003             BEQ.N    ??RCC_LSEConfig_2
   \   0000002C   0xBD10             POP      {R4,PC}
    394            {
    395              case RCC_LSE_ON:
    396                /* Set LSEON bit */
    397                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
   \                     ??RCC_LSEConfig_1: (+1)
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x7001             STRB     R1,[R0, #+0]
    398                break;
   \   00000032   0xBD10             POP      {R4,PC}
    399              case RCC_LSE_Bypass:
    400                /* Set LSEBYP and LSEON bits */
    401                *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
   \                     ??RCC_LSEConfig_2: (+1)
   \   00000034   0x2105             MOVS     R1,#+5
   \   00000036   0x7001             STRB     R1,[R0, #+0]
    402                break;
    403              default:
    404                break;
    405            }
    406          }
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    407          
    408          /**
    409            * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
    410            * @note   After enabling the LSI, the application software should wait on 
    411            *         LSIRDY flag to be set indicating that LSI clock is stable and can
    412            *         be used to clock the IWDG and/or the RTC.
    413            * @note   LSI can not be disabled if the IWDG is running.  
    414            * @param  NewState: new state of the LSI.
    415            *          This parameter can be: ENABLE or DISABLE.
    416            * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
    417            *         clock cycles. 
    418            * @retval None
    419            */

   \                                 In section .text, align 2, keep-with-next
    420          void RCC_LSICmd(FunctionalState NewState)
    421          {
   \                     RCC_LSICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    422            /* Check the parameters */
    423            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_LSICmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_LSICmd_0
   \   0000000A   0xF240 0x11A7      MOVW     R1,#+423
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000012   0x.... 0x....      BL       assert_failed
    424          
    425            *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
   \                     ??RCC_LSICmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable50_1  ;; 0x42470e80
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    426          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    427          
    428          /**
    429            * @brief  Configures the main PLL clock source, multiplication and division factors.
    430            * @note   This function must be used only when the main PLL is disabled.
    431            *  
    432            * @param  RCC_PLLSource: specifies the PLL entry clock source.
    433            *          This parameter can be one of the following values:
    434            *            @arg RCC_PLLSource_HSI: HSI oscillator clock selected as PLL clock entry
    435            *            @arg RCC_PLLSource_HSE: HSE oscillator clock selected as PLL clock entry
    436            * @note   This clock source (RCC_PLLSource) is common for the main PLL and PLLI2S.  
    437            *  
    438            * @param  PLLM: specifies the division factor for PLL VCO input clock
    439            *          This parameter must be a number between 0 and 63.
    440            * @note   You have to set the PLLM parameter correctly to ensure that the VCO input
    441            *         frequency ranges from 1 to 2 MHz. It is recommended to select a frequency
    442            *         of 2 MHz to limit PLL jitter.
    443            *  
    444            * @param  PLLN: specifies the multiplication factor for PLL VCO output clock
    445            *          This parameter must be a number between 192 and 432.
    446            * @note   You have to set the PLLN parameter correctly to ensure that the VCO
    447            *         output frequency is between 192 and 432 MHz.
    448            *   
    449            * @param  PLLP: specifies the division factor for main system clock (SYSCLK)
    450            *          This parameter must be a number in the range {2, 4, 6, or 8}.
    451            * @note   You have to set the PLLP parameter correctly to not exceed 168 MHz on
    452            *         the System clock frequency.
    453            *  
    454            * @param  PLLQ: specifies the division factor for OTG FS, SDIO and RNG clocks
    455            *          This parameter must be a number between 4 and 15.
    456            * @note   If the USB OTG FS is used in your application, you have to set the
    457            *         PLLQ parameter correctly to have 48 MHz clock for the USB. However,
    458            *         the SDIO and RNG need a frequency lower than or equal to 48 MHz to work
    459            *         correctly.
    460            *   
    461            * @retval None
    462            */

   \                                 In section .text, align 2, keep-with-next
    463          void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
    464          {
   \                     RCC_PLLConfig: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
    465            /* Check the parameters */
    466            assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD008             BEQ.N    ??RCC_PLLConfig_0
   \   00000010   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000014   0xD005             BEQ.N    ??RCC_PLLConfig_0
   \   00000016   0xF44F 0x71E9      MOV      R1,#+466
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable43
   \   0000001E   0x.... 0x....      BL       assert_failed
    467            assert_param(IS_RCC_PLLM_VALUE(PLLM));
   \                     ??RCC_PLLConfig_0: (+1)
   \   00000022   0x2E40             CMP      R6,#+64
   \   00000024   0xD305             BCC.N    ??RCC_PLLConfig_1
   \   00000026   0xF240 0x11D3      MOVW     R1,#+467
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable43
   \   0000002E   0x.... 0x....      BL       assert_failed
    468            assert_param(IS_RCC_PLLN_VALUE(PLLN));
   \                     ??RCC_PLLConfig_1: (+1)
   \   00000032   0xF1A7 0x00C0      SUB      R0,R7,#+192
   \   00000036   0x28F1             CMP      R0,#+241
   \   00000038   0xD305             BCC.N    ??RCC_PLLConfig_2
   \   0000003A   0xF44F 0x71EA      MOV      R1,#+468
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000042   0x.... 0x....      BL       assert_failed
    469            assert_param(IS_RCC_PLLP_VALUE(PLLP));
   \                     ??RCC_PLLConfig_2: (+1)
   \   00000046   0xF1B8 0x0F02      CMP      R8,#+2
   \   0000004A   0xD00E             BEQ.N    ??RCC_PLLConfig_3
   \   0000004C   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000050   0xD00B             BEQ.N    ??RCC_PLLConfig_3
   \   00000052   0xF1B8 0x0F06      CMP      R8,#+6
   \   00000056   0xD008             BEQ.N    ??RCC_PLLConfig_3
   \   00000058   0xF1B8 0x0F08      CMP      R8,#+8
   \   0000005C   0xD005             BEQ.N    ??RCC_PLLConfig_3
   \   0000005E   0xF240 0x11D5      MOVW     R1,#+469
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000066   0x.... 0x....      BL       assert_failed
   \                     ??RCC_PLLConfig_3: (+1)
   \   0000006A   0x9D06             LDR      R5,[SP, #+24]
    470            assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
   \   0000006C   0x1F28             SUBS     R0,R5,#+4
   \   0000006E   0x280C             CMP      R0,#+12
   \   00000070   0xD305             BCC.N    ??RCC_PLLConfig_4
   \   00000072   0xF44F 0x71EB      MOV      R1,#+470
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable43
   \   0000007A   0x.... 0x....      BL       assert_failed
    471          
    472            RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
    473                           (PLLQ << 24);
   \                     ??RCC_PLLConfig_4: (+1)
   \   0000007E   0xEA46 0x1087      ORR      R0,R6,R7, LSL #+6
   \   00000082   0xF1A8 0x0102      SUB      R1,R8,#+2
   \   00000086   0x03C9             LSLS     R1,R1,#+15
   \   00000088   0x0C09             LSRS     R1,R1,#+16
   \   0000008A   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   0000008E   0x4320             ORRS     R0,R4,R0
   \   00000090   0xEA40 0x6005      ORR      R0,R0,R5, LSL #+24
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable51  ;; 0x40023804
   \   00000098   0x6008             STR      R0,[R1, #+0]
    474          }
   \   0000009A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    475          
    476          /**
    477            * @brief  Enables or disables the main PLL.
    478            * @note   After enabling the main PLL, the application software should wait on 
    479            *         PLLRDY flag to be set indicating that PLL clock is stable and can
    480            *         be used as system clock source.
    481            * @note   The main PLL can not be disabled if it is used as system clock source
    482            * @note   The main PLL is disabled by hardware when entering STOP and STANDBY modes.
    483            * @param  NewState: new state of the main PLL. This parameter can be: ENABLE or DISABLE.
    484            * @retval None
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          void RCC_PLLCmd(FunctionalState NewState)
    487          {
   \                     RCC_PLLCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    488            /* Check the parameters */
    489            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_PLLCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_PLLCmd_0
   \   0000000A   0xF240 0x11E9      MOVW     R1,#+489
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000012   0x.... 0x....      BL       assert_failed
    490            *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
   \                     ??RCC_PLLCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_1  ;; 0x42470060
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    491          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    492          
    493          #if defined (STM32F40_41xxx) || defined (STM32F401xx)
    494          /**
    495            * @brief  Configures the PLLI2S clock multiplication and division factors.
    496            *  
    497            * @note   This function can be used only for STM32F405xx/407xx, STM32F415xx/417xx 
    498            *         or STM32F401xx devices. 
    499            *    
    500            * @note   This function must be used only when the PLLI2S is disabled.
    501            * @note   PLLI2S clock source is common with the main PLL (configured in 
    502            *         RCC_PLLConfig function )  
    503            *             
    504            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    505            *          This parameter must be a number between 192 and 432.
    506            * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
    507            *         output frequency is between 192 and 432 MHz.
    508            *    
    509            * @param  PLLI2SR: specifies the division factor for I2S clock
    510            *          This parameter must be a number between 2 and 7.
    511            * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
    512            *         on the I2S clock frequency.
    513            *   
    514            * @retval None
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
    517          {
   \                     RCC_PLLI2SConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    518            /* Check the parameters */
    519            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
   \   00000006   0xF1A4 0x00C0      SUB      R0,R4,#+192
   \   0000000A   0x28F1             CMP      R0,#+241
   \   0000000C   0xD305             BCC.N    ??RCC_PLLI2SConfig_0
   \   0000000E   0xF240 0x2107      MOVW     R1,#+519
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000016   0x.... 0x....      BL       assert_failed
    520            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
   \                     ??RCC_PLLI2SConfig_0: (+1)
   \   0000001A   0x1EA8             SUBS     R0,R5,#+2
   \   0000001C   0x2806             CMP      R0,#+6
   \   0000001E   0xD305             BCC.N    ??RCC_PLLI2SConfig_1
   \   00000020   0xF44F 0x7102      MOV      R1,#+520
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable43
   \   00000028   0x.... 0x....      BL       assert_failed
    521          
    522            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
   \                     ??RCC_PLLI2SConfig_1: (+1)
   \   0000002C   0x0728             LSLS     R0,R5,#+28
   \   0000002E   0xEA40 0x1084      ORR      R0,R0,R4, LSL #+6
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable42_1  ;; 0x40023884
   \   00000036   0x6008             STR      R0,[R1, #+0]
    523          }
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    524          #endif /* STM32F40_41xxx || STM32F401xx */
    525          
    526          #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
    527          /**
    528            * @brief  Configures the PLLI2S clock multiplication and division factors.
    529            * 
    530            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    531            *         
    532            * @note   This function must be used only when the PLLI2S is disabled.
    533            * @note   PLLI2S clock source is common with the main PLL (configured in 
    534            *         RCC_PLLConfig function )  
    535            *             
    536            * @param  PLLI2SN: specifies the multiplication factor for PLLI2S VCO output clock
    537            *          This parameter must be a number between 192 and 432.
    538            * @note   You have to set the PLLI2SN parameter correctly to ensure that the VCO 
    539            *         output frequency is between 192 and 432 MHz.
    540            * 
    541            * @param  PLLI2SQ: specifies the division factor for SAI1 clock
    542            *          This parameter must be a number between 2 and 15.
    543            *                 
    544            * @param  PLLI2SR: specifies the division factor for I2S clock
    545            *          This parameter must be a number between 2 and 7.
    546            * @note   You have to set the PLLI2SR parameter correctly to not exceed 192 MHz
    547            *         on the I2S clock frequency.
    548            * @note   the PLLI2SR parameter is only available with STM32F42xxx/43xxx devices.  
    549            *   
    550            * @retval None
    551            */
    552          void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SQ, uint32_t PLLI2SR)
    553          {
    554            /* Check the parameters */
    555            assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
    556            assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SQ));
    557            assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
    558          
    559            RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SQ << 24) | (PLLI2SR << 28);
    560          }
    561          #endif /* STM32F427_437xx ||  STM32F429_439xx */
    562          
    563          /**
    564            * @brief  Enables or disables the PLLI2S. 
    565            * @note   The PLLI2S is disabled by hardware when entering STOP and STANDBY modes.  
    566            * @param  NewState: new state of the PLLI2S. This parameter can be: ENABLE or DISABLE.
    567            * @retval None
    568            */

   \                                 In section .text, align 2, keep-with-next
    569          void RCC_PLLI2SCmd(FunctionalState NewState)
    570          {
   \                     RCC_PLLI2SCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    571            /* Check the parameters */
    572            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_PLLI2SCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_PLLI2SCmd_0
   \   0000000A   0xF44F 0x710F      MOV      R1,#+572
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    573            *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
   \                     ??RCC_PLLI2SCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_2  ;; 0x42470068
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    574          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    575          
    576          /**
    577            * @brief  Configures the PLLSAI clock multiplication and division factors.
    578            *
    579            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    580            *        
    581            * @note   This function must be used only when the PLLSAI is disabled.
    582            * @note   PLLSAI clock source is common with the main PLL (configured in 
    583            *         RCC_PLLConfig function )  
    584            *             
    585            * @param  PLLSAIN: specifies the multiplication factor for PLLSAI VCO output clock
    586            *          This parameter must be a number between 192 and 432.
    587            * @note   You have to set the PLLSAIN parameter correctly to ensure that the VCO 
    588            *         output frequency is between 192 and 432 MHz.
    589            *           
    590            * @param  PLLSAIQ: specifies the division factor for SAI1 clock
    591            *          This parameter must be a number between 2 and 15.
    592            *            
    593            * @param  PLLSAIR: specifies the division factor for LTDC clock
    594            *          This parameter must be a number between 2 and 7.
    595            *   
    596            * @retval None
    597            */

   \                                 In section .text, align 2, keep-with-next
    598          void RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR)
    599          {
   \                     RCC_PLLSAIConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    600            /* Check the parameters */
    601            assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIN));
   \   00000008   0xF1A4 0x00C0      SUB      R0,R4,#+192
   \   0000000C   0x28F1             CMP      R0,#+241
   \   0000000E   0xD305             BCC.N    ??RCC_PLLSAIConfig_0
   \   00000010   0xF240 0x2159      MOVW     R1,#+601
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
    602            assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIR));
   \                     ??RCC_PLLSAIConfig_0: (+1)
   \   0000001C   0x1EB0             SUBS     R0,R6,#+2
   \   0000001E   0x2806             CMP      R0,#+6
   \   00000020   0xD305             BCC.N    ??RCC_PLLSAIConfig_1
   \   00000022   0xF240 0x215A      MOVW     R1,#+602
   \   00000026   0x.... 0x....      ADR.W    R0,?_0
   \   0000002A   0x.... 0x....      BL       assert_failed
    603          
    604            RCC->PLLSAICFGR = (PLLSAIN << 6) | (PLLSAIQ << 24) | (PLLSAIR << 28);
   \                     ??RCC_PLLSAIConfig_1: (+1)
   \   0000002E   0x0628             LSLS     R0,R5,#+24
   \   00000030   0xEA40 0x1084      ORR      R0,R0,R4, LSL #+6
   \   00000034   0xEA40 0x7006      ORR      R0,R0,R6, LSL #+28
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable51_3  ;; 0x40023888
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    605          }
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
    606          
    607          /**
    608            * @brief  Enables or disables the PLLSAI. 
    609            * 
    610            * @note   This function can be used only for STM32F42xxx/43xxx devices 
    611            *       
    612            * @note   The PLLSAI is disabled by hardware when entering STOP and STANDBY modes.  
    613            * @param  NewState: new state of the PLLSAI. This parameter can be: ENABLE or DISABLE.
    614            * @retval None
    615            */

   \                                 In section .text, align 2, keep-with-next
    616          void RCC_PLLSAICmd(FunctionalState NewState)
    617          {
   \                     RCC_PLLSAICmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    618            /* Check the parameters */
    619            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_PLLSAICmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_PLLSAICmd_0
   \   0000000A   0xF240 0x216B      MOVW     R1,#+619
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    620            *(__IO uint32_t *) CR_PLLSAION_BB = (uint32_t)NewState;
   \                     ??RCC_PLLSAICmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_4  ;; 0x42470070
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    621          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    622          
    623          /**
    624            * @brief  Enables or disables the Clock Security System.
    625            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    626            *         is automatically disabled and an interrupt is generated to inform the
    627            *         software about the failure (Clock Security System Interrupt, CSSI),
    628            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    629            *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
    630            * @param  NewState: new state of the Clock Security System.
    631            *         This parameter can be: ENABLE or DISABLE.
    632            * @retval None
    633            */

   \                                 In section .text, align 2, keep-with-next
    634          void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
    635          {
   \                     RCC_ClockSecuritySystemCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    636            /* Check the parameters */
    637            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_ClockSecuritySystemCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_ClockSecuritySystemCmd_0
   \   0000000A   0xF240 0x217D      MOVW     R1,#+637
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    638            *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
   \                     ??RCC_ClockSecuritySystemCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_5  ;; 0x4247004c
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    639          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    640          
    641          /**
    642            * @brief  Selects the clock source to output on MCO1 pin(PA8).
    643            * @note   PA8 should be configured in alternate function mode.
    644            * @param  RCC_MCO1Source: specifies the clock source to output.
    645            *          This parameter can be one of the following values:
    646            *            @arg RCC_MCO1Source_HSI: HSI clock selected as MCO1 source
    647            *            @arg RCC_MCO1Source_LSE: LSE clock selected as MCO1 source
    648            *            @arg RCC_MCO1Source_HSE: HSE clock selected as MCO1 source
    649            *            @arg RCC_MCO1Source_PLLCLK: main PLL clock selected as MCO1 source
    650            * @param  RCC_MCO1Div: specifies the MCO1 prescaler.
    651            *          This parameter can be one of the following values:
    652            *            @arg RCC_MCO1Div_1: no division applied to MCO1 clock
    653            *            @arg RCC_MCO1Div_2: division by 2 applied to MCO1 clock
    654            *            @arg RCC_MCO1Div_3: division by 3 applied to MCO1 clock
    655            *            @arg RCC_MCO1Div_4: division by 4 applied to MCO1 clock
    656            *            @arg RCC_MCO1Div_5: division by 5 applied to MCO1 clock
    657            * @retval None
    658            */

   \                                 In section .text, align 2, keep-with-next
    659          void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
    660          {
   \                     RCC_MCO1Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    661            uint32_t tmpreg = 0;
    662            
    663            /* Check the parameters */
    664            assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??RCC_MCO1Config_0
   \   0000000A   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   0000000E   0xD00B             BEQ.N    ??RCC_MCO1Config_0
   \   00000010   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000014   0xD008             BEQ.N    ??RCC_MCO1Config_0
   \   00000016   0xF5B4 0x0FC0      CMP      R4,#+6291456
   \   0000001A   0xD005             BEQ.N    ??RCC_MCO1Config_0
   \   0000001C   0xF44F 0x7126      MOV      R1,#+664
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
    665            assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
   \                     ??RCC_MCO1Config_0: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD011             BEQ.N    ??RCC_MCO1Config_1
   \   0000002C   0xF1B5 0x6F80      CMP      R5,#+67108864
   \   00000030   0xD00E             BEQ.N    ??RCC_MCO1Config_1
   \   00000032   0xF1B5 0x6FA0      CMP      R5,#+83886080
   \   00000036   0xD00B             BEQ.N    ??RCC_MCO1Config_1
   \   00000038   0xF1B5 0x6FC0      CMP      R5,#+100663296
   \   0000003C   0xD008             BEQ.N    ??RCC_MCO1Config_1
   \   0000003E   0xF1B5 0x6FE0      CMP      R5,#+117440512
   \   00000042   0xD005             BEQ.N    ??RCC_MCO1Config_1
   \   00000044   0xF240 0x2199      MOVW     R1,#+665
   \   00000048   0x.... 0x....      ADR.W    R0,?_0
   \   0000004C   0x.... 0x....      BL       assert_failed
    666          
    667            tmpreg = RCC->CFGR;
   \                     ??RCC_MCO1Config_1: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   00000054   0x6801             LDR      R1,[R0, #+0]
    668          
    669            /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
    670            tmpreg &= CFGR_MCO1_RESET_MASK;
    671          
    672            /* Select MCO1 clock source and prescaler */
    673            tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
    674          
    675            /* Store the new value */
    676            RCC->CFGR = tmpreg;  
   \   00000056   0xF021 0x61EC      BIC      R1,R1,#0x7600000
   \   0000005A   0x4321             ORRS     R1,R4,R1
   \   0000005C   0x4329             ORRS     R1,R5,R1
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    677          }
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    678          
    679          /**
    680            * @brief  Selects the clock source to output on MCO2 pin(PC9).
    681            * @note   PC9 should be configured in alternate function mode.
    682            * @param  RCC_MCO2Source: specifies the clock source to output.
    683            *          This parameter can be one of the following values:
    684            *            @arg RCC_MCO2Source_SYSCLK: System clock (SYSCLK) selected as MCO2 source
    685            *            @arg RCC_MCO2Source_PLLI2SCLK: PLLI2S clock selected as MCO2 source
    686            *            @arg RCC_MCO2Source_HSE: HSE clock selected as MCO2 source
    687            *            @arg RCC_MCO2Source_PLLCLK: main PLL clock selected as MCO2 source
    688            * @param  RCC_MCO2Div: specifies the MCO2 prescaler.
    689            *          This parameter can be one of the following values:
    690            *            @arg RCC_MCO2Div_1: no division applied to MCO2 clock
    691            *            @arg RCC_MCO2Div_2: division by 2 applied to MCO2 clock
    692            *            @arg RCC_MCO2Div_3: division by 3 applied to MCO2 clock
    693            *            @arg RCC_MCO2Div_4: division by 4 applied to MCO2 clock
    694            *            @arg RCC_MCO2Div_5: division by 5 applied to MCO2 clock
    695            * @retval None
    696            */

   \                                 In section .text, align 2, keep-with-next
    697          void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
    698          {
   \                     RCC_MCO2Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    699            uint32_t tmpreg = 0;
    700            
    701            /* Check the parameters */
    702            assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00E             BEQ.N    ??RCC_MCO2Config_0
   \   0000000A   0xF1B4 0x4F80      CMP      R4,#+1073741824
   \   0000000E   0xD00B             BEQ.N    ??RCC_MCO2Config_0
   \   00000010   0xF1B4 0x4F00      CMP      R4,#-2147483648
   \   00000014   0xD008             BEQ.N    ??RCC_MCO2Config_0
   \   00000016   0xF114 0x4F80      CMN      R4,#+1073741824
   \   0000001A   0xD005             BEQ.N    ??RCC_MCO2Config_0
   \   0000001C   0xF240 0x21BE      MOVW     R1,#+702
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
    703            assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
   \                     ??RCC_MCO2Config_0: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD011             BEQ.N    ??RCC_MCO2Config_1
   \   0000002C   0xF1B5 0x5F00      CMP      R5,#+536870912
   \   00000030   0xD00E             BEQ.N    ??RCC_MCO2Config_1
   \   00000032   0xF1B5 0x5F20      CMP      R5,#+671088640
   \   00000036   0xD00B             BEQ.N    ??RCC_MCO2Config_1
   \   00000038   0xF1B5 0x5F40      CMP      R5,#+805306368
   \   0000003C   0xD008             BEQ.N    ??RCC_MCO2Config_1
   \   0000003E   0xF1B5 0x5F60      CMP      R5,#+939524096
   \   00000042   0xD005             BEQ.N    ??RCC_MCO2Config_1
   \   00000044   0xF240 0x21BF      MOVW     R1,#+703
   \   00000048   0x.... 0x....      ADR.W    R0,?_0
   \   0000004C   0x.... 0x....      BL       assert_failed
    704            
    705            tmpreg = RCC->CFGR;
   \                     ??RCC_MCO2Config_1: (+1)
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   00000054   0x6801             LDR      R1,[R0, #+0]
    706            
    707            /* Clear MCO2 and MCO2PRE[2:0] bits */
    708            tmpreg &= CFGR_MCO2_RESET_MASK;
    709          
    710            /* Select MCO2 clock source and prescaler */
    711            tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
    712          
    713            /* Store the new value */
    714            RCC->CFGR = tmpreg;  
   \   00000056   0x0149             LSLS     R1,R1,#+5
   \   00000058   0xEA54 0x1151      ORRS     R1,R4,R1, LSR #+5
   \   0000005C   0x4329             ORRS     R1,R5,R1
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    715          }
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    716          
    717          /**
    718            * @}
    719            */
    720          
    721          /** @defgroup RCC_Group2 System AHB and APB busses clocks configuration functions
    722           *  @brief   System, AHB and APB busses clocks configuration functions
    723           *
    724          @verbatim   
    725           ===============================================================================
    726                ##### System, AHB and APB busses clocks configuration functions #####
    727           ===============================================================================  
    728              [..]
    729                This section provide functions allowing to configure the System, AHB, APB1 and 
    730                APB2 busses clocks.
    731            
    732                (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    733                    HSE and PLL.
    734                    The AHB clock (HCLK) is derived from System clock through configurable 
    735                    prescaler and used to clock the CPU, memory and peripherals mapped 
    736                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived 
    737                    from AHB clock through configurable prescalers and used to clock 
    738                    the peripherals mapped on these busses. You can use 
    739                    "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.  
    740          
    741                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    742                  (+@) I2S: the I2S clock can be derived either from a specific PLL (PLLI2S) or
    743                       from an external clock mapped on the I2S_CKIN pin. 
    744                       You have to use RCC_I2SCLKConfig() function to configure this clock. 
    745                  (+@) RTC: the RTC clock can be derived either from the LSI, LSE or HSE clock
    746                       divided by 2 to 31. You have to use RCC_RTCCLKConfig() and RCC_RTCCLKCmd()
    747                       functions to configure this clock. 
    748                  (+@) USB OTG FS, SDIO and RTC: USB OTG FS require a frequency equal to 48 MHz
    749                       to work correctly, while the SDIO require a frequency equal or lower than
    750                       to 48. This clock is derived of the main PLL through PLLQ divider.
    751                  (+@) IWDG clock which is always the LSI clock.
    752                 
    753                (#) For STM32F405xx/407xx and STM32F415xx/417xx devices, the maximum frequency 
    754                   of the SYSCLK and HCLK is 168 MHz, PCLK2 84 MHz and PCLK1 42 MHz. Depending 
    755                   on the device voltage range, the maximum frequency should be adapted accordingly:
    756           +-------------------------------------------------------------------------------------+     
    757           | Latency       |                HCLK clock frequency (MHz)                           |
    758           |               |---------------------------------------------------------------------|     
    759           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    760           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    761           |---------------|----------------|----------------|-----------------|-----------------|              
    762           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    763           |---------------|----------------|----------------|-----------------|-----------------|   
    764           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    765           |---------------|----------------|----------------|-----------------|-----------------|   
    766           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    767           |---------------|----------------|----------------|-----------------|-----------------| 
    768           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    769           |---------------|----------------|----------------|-----------------|-----------------| 
    770           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    771           |---------------|----------------|----------------|-----------------|-----------------| 
    772           |5WS(6CPU cycle)|150< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    773           |---------------|----------------|----------------|-----------------|-----------------| 
    774           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    775           |---------------|----------------|----------------|-----------------|-----------------| 
    776           |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
    777           +---------------|----------------|----------------|-----------------|-----------------+ 
    778                (#) For STM32F42xxx/43xxx devices, the maximum frequency of the SYSCLK and HCLK is 180 MHz, 
    779                    PCLK2 90 MHz and PCLK1 45 MHz. Depending on the device voltage range, the maximum 
    780                    frequency should be adapted accordingly:
    781           +-------------------------------------------------------------------------------------+     
    782           | Latency       |                HCLK clock frequency (MHz)                           |
    783           |               |---------------------------------------------------------------------|     
    784           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    785           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    786           |---------------|----------------|----------------|-----------------|-----------------|              
    787           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    788           |---------------|----------------|----------------|-----------------|-----------------|   
    789           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    790           |---------------|----------------|----------------|-----------------|-----------------|   
    791           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    792           |---------------|----------------|----------------|-----------------|-----------------| 
    793           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    794           |---------------|----------------|----------------|-----------------|-----------------| 
    795           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    796           |---------------|----------------|----------------|-----------------|-----------------| 
    797           |5WS(6CPU cycle)|120< HCLK <= 180|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    798           |---------------|----------------|----------------|-----------------|-----------------| 
    799           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    800           |---------------|----------------|----------------|-----------------|-----------------| 
    801           |7WS(8CPU cycle)|      NA        |168< HCLK <= 180|154 < HCLK <= 176|140 < HCLK <= 160|
    802           |---------------|----------------|----------------|-----------------|-----------------| 
    803           |8WS(9CPU cycle)|      NA        |      NA        |176 < HCLK <= 180|160 < HCLK <= 168|
    804           +-------------------------------------------------------------------------------------+
    805             
    806                (#) For STM32F401xx devices, the maximum frequency of the SYSCLK and HCLK is 84 MHz, 
    807                    PCLK2 84 MHz and PCLK1 42 MHz. Depending on the device voltage range, the maximum 
    808                    frequency should be adapted accordingly:
    809           +-------------------------------------------------------------------------------------+     
    810           | Latency       |                HCLK clock frequency (MHz)                           |
    811           |               |---------------------------------------------------------------------|     
    812           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    813           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    814           |---------------|----------------|----------------|-----------------|-----------------|              
    815           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    816           |---------------|----------------|----------------|-----------------|-----------------|   
    817           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    818           |---------------|----------------|----------------|-----------------|-----------------|   
    819           |2WS(3CPU cycle)|60 < HCLK <= 84 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    820           |---------------|----------------|----------------|-----------------|-----------------| 
    821           |3WS(4CPU cycle)|      NA        |72 < HCLK <= 84 |66 < HCLK <= 84  |60 < HCLK <= 80  |
    822           |---------------|----------------|----------------|-----------------|-----------------| 
    823           |4WS(5CPU cycle)|      NA        |      NA        |      NA         |80 < HCLK <= 84  | 
    824           +-------------------------------------------------------------------------------------+ 
    825            
    826                -@- On STM32F405xx/407xx and STM32F415xx/417xx devices: 
    827                     (++) when VOS = '0', the maximum value of fHCLK = 144MHz. 
    828                     (++) when VOS = '1', the maximum value of fHCLK = 168MHz. 
    829                    [..] 
    830                    On STM32F42xxx/43xxx devices:
    831                     (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 120MHz.
    832                     (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 144MHz.
    833                     (++) when VOS[1:0] = '0x11', the maximum value of f  is 168MHz 
    834                    [..]  
    835                    On STM32F401x devices:
    836                     (++) when VOS[1:0] = '0x01', the maximum value of fHCLK is 64MHz.
    837                     (++) when VOS[1:0] = '0x10', the maximum value of fHCLK is 84MHz.
    838                     You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
    839          
    840          @endverbatim
    841            * @{
    842            */
    843          
    844          /**
    845            * @brief  Configures the system clock (SYSCLK).
    846            * @note   The HSI is used (enabled by hardware) as system clock source after
    847            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    848            *         of failure of the HSE used directly or indirectly as system clock
    849            *         (if the Clock Security System CSS is enabled).
    850            * @note   A switch from one clock source to another occurs only if the target
    851            *         clock source is ready (clock stable after startup delay or PLL locked). 
    852            *         If a clock source which is not yet ready is selected, the switch will
    853            *         occur when the clock source will be ready. 
    854            *         You can use RCC_GetSYSCLKSource() function to know which clock is
    855            *         currently used as system clock source. 
    856            * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.
    857            *          This parameter can be one of the following values:
    858            *            @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
    859            *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
    860            *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
    861            * @retval None
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
    864          {
   \                     RCC_SYSCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    865            uint32_t tmpreg = 0;
    866          
    867            /* Check the parameters */
    868            assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
   \   00000004   0xD009             BEQ.N    ??RCC_SYSCLKConfig_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD007             BEQ.N    ??RCC_SYSCLKConfig_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD005             BEQ.N    ??RCC_SYSCLKConfig_0
   \   0000000E   0xF44F 0x7159      MOV      R1,#+868
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       assert_failed
    869          
    870            tmpreg = RCC->CFGR;
   \                     ??RCC_SYSCLKConfig_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
    871          
    872            /* Clear SW[1:0] bits */
    873            tmpreg &= ~RCC_CFGR_SW;
    874          
    875            /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
    876            tmpreg |= RCC_SYSCLKSource;
    877          
    878            /* Store the new value */
    879            RCC->CFGR = tmpreg;
   \   00000020   0x0889             LSRS     R1,R1,#+2
   \   00000022   0xEA54 0x0181      ORRS     R1,R4,R1, LSL #+2
   \   00000026   0x6001             STR      R1,[R0, #+0]
    880          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    881          
    882          /**
    883            * @brief  Returns the clock source used as system clock.
    884            * @param  None
    885            * @retval The clock source used as system clock. The returned value can be one
    886            *         of the following:
    887            *              - 0x00: HSI used as system clock
    888            *              - 0x04: HSE used as system clock
    889            *              - 0x08: PLL used as system clock
    890            */

   \                                 In section .text, align 2, keep-with-next
    891          uint8_t RCC_GetSYSCLKSource(void)
    892          {
    893            return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
   \                     RCC_GetSYSCLKSource: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF000 0x000C      AND      R0,R0,#0xC
   \   0000000A   0x4770             BX       LR               ;; return
    894          }
    895          
    896          /**
    897            * @brief  Configures the AHB clock (HCLK).
    898            * @note   Depending on the device voltage range, the software has to set correctly
    899            *         these bits to ensure that HCLK not exceed the maximum allowed frequency
    900            *         (for more details refer to section above
    901            *           "CPU, AHB and APB busses clocks configuration functions")
    902            * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
    903            *         the system clock (SYSCLK).
    904            *          This parameter can be one of the following values:
    905            *            @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK
    906            *            @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2
    907            *            @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4
    908            *            @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8
    909            *            @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16
    910            *            @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64
    911            *            @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
    912            *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
    913            *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
    914            * @retval None
    915            */

   \                                 In section .text, align 2, keep-with-next
    916          void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
    917          {
   \                     RCC_HCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    918            uint32_t tmpreg = 0;
    919            
    920            /* Check the parameters */
    921            assert_param(IS_RCC_HCLK(RCC_SYSCLK));
   \   00000004   0xD015             BEQ.N    ??RCC_HCLKConfig_0
   \   00000006   0x2C80             CMP      R4,#+128
   \   00000008   0xD013             BEQ.N    ??RCC_HCLKConfig_0
   \   0000000A   0x2C90             CMP      R4,#+144
   \   0000000C   0xD011             BEQ.N    ??RCC_HCLKConfig_0
   \   0000000E   0x2CA0             CMP      R4,#+160
   \   00000010   0xD00F             BEQ.N    ??RCC_HCLKConfig_0
   \   00000012   0x2CB0             CMP      R4,#+176
   \   00000014   0xD00D             BEQ.N    ??RCC_HCLKConfig_0
   \   00000016   0x2CC0             CMP      R4,#+192
   \   00000018   0xD00B             BEQ.N    ??RCC_HCLKConfig_0
   \   0000001A   0x2CD0             CMP      R4,#+208
   \   0000001C   0xD009             BEQ.N    ??RCC_HCLKConfig_0
   \   0000001E   0x2CE0             CMP      R4,#+224
   \   00000020   0xD007             BEQ.N    ??RCC_HCLKConfig_0
   \   00000022   0x2CF0             CMP      R4,#+240
   \   00000024   0xD005             BEQ.N    ??RCC_HCLKConfig_0
   \   00000026   0xF240 0x3199      MOVW     R1,#+921
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
    922          
    923            tmpreg = RCC->CFGR;
   \                     ??RCC_HCLKConfig_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   00000036   0x6801             LDR      R1,[R0, #+0]
    924          
    925            /* Clear HPRE[3:0] bits */
    926            tmpreg &= ~RCC_CFGR_HPRE;
    927          
    928            /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
    929            tmpreg |= RCC_SYSCLK;
    930          
    931            /* Store the new value */
    932            RCC->CFGR = tmpreg;
   \   00000038   0xF021 0x01F0      BIC      R1,R1,#0xF0
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    933          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
    934          
    935          
    936          /**
    937            * @brief  Configures the Low Speed APB clock (PCLK1).
    938            * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
    939            *         the AHB clock (HCLK).
    940            *          This parameter can be one of the following values:
    941            *            @arg RCC_HCLK_Div1:  APB1 clock = HCLK
    942            *            @arg RCC_HCLK_Div2:  APB1 clock = HCLK/2
    943            *            @arg RCC_HCLK_Div4:  APB1 clock = HCLK/4
    944            *            @arg RCC_HCLK_Div8:  APB1 clock = HCLK/8
    945            *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
    946            * @retval None
    947            */

   \                                 In section .text, align 2, keep-with-next
    948          void RCC_PCLK1Config(uint32_t RCC_HCLK)
    949          {
   \                     RCC_PCLK1Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    950            uint32_t tmpreg = 0;
    951          
    952            /* Check the parameters */
    953            assert_param(IS_RCC_PCLK(RCC_HCLK));
   \   00000004   0xD011             BEQ.N    ??RCC_PCLK1Config_0
   \   00000006   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000000A   0xD00E             BEQ.N    ??RCC_PCLK1Config_0
   \   0000000C   0xF5B4 0x5FA0      CMP      R4,#+5120
   \   00000010   0xD00B             BEQ.N    ??RCC_PCLK1Config_0
   \   00000012   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   00000016   0xD008             BEQ.N    ??RCC_PCLK1Config_0
   \   00000018   0xF5B4 0x5FE0      CMP      R4,#+7168
   \   0000001C   0xD005             BEQ.N    ??RCC_PCLK1Config_0
   \   0000001E   0xF240 0x31B9      MOVW     R1,#+953
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    954          
    955            tmpreg = RCC->CFGR;
   \                     ??RCC_PCLK1Config_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
    956          
    957            /* Clear PPRE1[2:0] bits */
    958            tmpreg &= ~RCC_CFGR_PPRE1;
    959          
    960            /* Set PPRE1[2:0] bits according to RCC_HCLK value */
    961            tmpreg |= RCC_HCLK;
    962          
    963            /* Store the new value */
    964            RCC->CFGR = tmpreg;
   \   00000030   0xF421 0x51E0      BIC      R1,R1,#0x1C00
   \   00000034   0x4321             ORRS     R1,R4,R1
   \   00000036   0x6001             STR      R1,[R0, #+0]
    965          }
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    966          
    967          /**
    968            * @brief  Configures the High Speed APB clock (PCLK2).
    969            * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
    970            *         the AHB clock (HCLK).
    971            *          This parameter can be one of the following values:
    972            *            @arg RCC_HCLK_Div1:  APB2 clock = HCLK
    973            *            @arg RCC_HCLK_Div2:  APB2 clock = HCLK/2
    974            *            @arg RCC_HCLK_Div4:  APB2 clock = HCLK/4
    975            *            @arg RCC_HCLK_Div8:  APB2 clock = HCLK/8
    976            *            @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
    977            * @retval None
    978            */

   \                                 In section .text, align 2, keep-with-next
    979          void RCC_PCLK2Config(uint32_t RCC_HCLK)
    980          {
   \                     RCC_PCLK2Config: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    981            uint32_t tmpreg = 0;
    982          
    983            /* Check the parameters */
    984            assert_param(IS_RCC_PCLK(RCC_HCLK));
   \   00000004   0xD011             BEQ.N    ??RCC_PCLK2Config_0
   \   00000006   0xF5B4 0x5F80      CMP      R4,#+4096
   \   0000000A   0xD00E             BEQ.N    ??RCC_PCLK2Config_0
   \   0000000C   0xF5B4 0x5FA0      CMP      R4,#+5120
   \   00000010   0xD00B             BEQ.N    ??RCC_PCLK2Config_0
   \   00000012   0xF5B4 0x5FC0      CMP      R4,#+6144
   \   00000016   0xD008             BEQ.N    ??RCC_PCLK2Config_0
   \   00000018   0xF5B4 0x5FE0      CMP      R4,#+7168
   \   0000001C   0xD005             BEQ.N    ??RCC_PCLK2Config_0
   \   0000001E   0xF44F 0x7176      MOV      R1,#+984
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    985          
    986            tmpreg = RCC->CFGR;
   \                     ??RCC_PCLK2Config_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
    987          
    988            /* Clear PPRE2[2:0] bits */
    989            tmpreg &= ~RCC_CFGR_PPRE2;
    990          
    991            /* Set PPRE2[2:0] bits according to RCC_HCLK value */
    992            tmpreg |= RCC_HCLK << 3;
    993          
    994            /* Store the new value */
    995            RCC->CFGR = tmpreg;
   \   00000030   0xF421 0x4160      BIC      R1,R1,#0xE000
   \   00000034   0xEA41 0x01C4      ORR      R1,R1,R4, LSL #+3
   \   00000038   0x6001             STR      R1,[R0, #+0]
    996          }
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    997          
    998          /**
    999            * @brief  Returns the frequencies of different on chip clocks; SYSCLK, HCLK, 
   1000            *         PCLK1 and PCLK2.       
   1001            * 
   1002            * @note   The system frequency computed by this function is not the real 
   1003            *         frequency in the chip. It is calculated based on the predefined 
   1004            *         constant and the selected clock source:
   1005            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
   1006            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
   1007            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**) 
   1008            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.         
   1009            * @note     (*) HSI_VALUE is a constant defined in stm32f4xx.h file (default value
   1010            *               16 MHz) but the real value may vary depending on the variations
   1011            *               in voltage and temperature.
   1012            * @note     (**) HSE_VALUE is a constant defined in stm32f4xx.h file (default value
   1013            *                25 MHz), user has to ensure that HSE_VALUE is same as the real
   1014            *                frequency of the crystal used. Otherwise, this function may
   1015            *                have wrong result.
   1016            *                
   1017            * @note   The result of this function could be not correct when using fractional
   1018            *         value for HSE crystal.
   1019            *   
   1020            * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
   1021            *          the clocks frequencies.
   1022            *     
   1023            * @note   This function can be used by the user application to compute the 
   1024            *         baudrate for the communication peripherals or configure other parameters.
   1025            * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
   1026            *         must be called to update the structure's field. Otherwise, any
   1027            *         configuration based on this function will be incorrect.
   1028            *    
   1029            * @retval None
   1030            */

   \                                 In section .text, align 2, keep-with-next
   1031          void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
   1032          {
   \                     RCC_GetClocksFreq: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1033            uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
   1034          
   1035            /* Get SYSCLK source -------------------------------------------------------*/
   1036            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable51  ;; 0x40023804
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0xF002 0x020C      AND      R2,R2,#0xC
   1037          
   1038            switch (tmp)
   \   0000000C   0x2A04             CMP      R2,#+4
   \   0000000E   0xD002             BEQ.N    ??RCC_GetClocksFreq_0
   \   00000010   0x2A08             CMP      R2,#+8
   \   00000012   0xD004             BEQ.N    ??RCC_GetClocksFreq_1
   \   00000014   0xE025             B.N      ??RCC_GetClocksFreq_2
   1039            {
   1040              case 0x00:  /* HSI used as system clock source */
   1041                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   1042                break;
   1043              case 0x04:  /* HSE used as system clock  source */
   1044                RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
   \                     ??RCC_GetClocksFreq_0: (+1)
   \   00000016   0xF44F 0x12FA      MOV      R2,#+2048000
   \   0000001A   0x6002             STR      R2,[R0, #+0]
   1045                break;
   \   0000001C   0xE024             B.N      ??RCC_GetClocksFreq_3
   1046              case 0x08:  /* PLL used as system clock  source */
   1047          
   1048                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
   1049                   SYSCLK = PLL_VCO / PLLP
   1050                   */    
   1051                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??RCC_GetClocksFreq_1: (+1)
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0xF3C2 0x5280      UBFX     R2,R2,#+22,#+1
   1052                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \   00000024   0x680B             LDR      R3,[R1, #+0]
   \   00000026   0xF003 0x033F      AND      R3,R3,#0x3F
   1053                
   1054                if (pllsource != 0)
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD008             BEQ.N    ??RCC_GetClocksFreq_4
   1055                {
   1056                  /* HSE used as PLL clock source */
   1057                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \   0000002E   0xF44F 0x12FA      MOV      R2,#+2048000
   \   00000032   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000036   0x680B             LDR      R3,[R1, #+0]
   \   00000038   0xF3C3 0x1388      UBFX     R3,R3,#+6,#+9
   \   0000003C   0x435A             MULS     R2,R3,R2
   \   0000003E   0xE007             B.N      ??RCC_GetClocksFreq_5
   1058                }
   1059                else
   1060                {
   1061                  /* HSI used as PLL clock source */
   1062                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
   \                     ??RCC_GetClocksFreq_4: (+1)
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable51_7  ;; 0xf42400
   \   00000044   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   00000048   0x680B             LDR      R3,[R1, #+0]
   \   0000004A   0xF3C3 0x1388      UBFX     R3,R3,#+6,#+9
   \   0000004E   0x435A             MULS     R2,R3,R2
   1063                }
   1064          
   1065                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \                     ??RCC_GetClocksFreq_5: (+1)
   \   00000050   0x680B             LDR      R3,[R1, #+0]
   \   00000052   0xF3C3 0x4301      UBFX     R3,R3,#+16,#+2
   \   00000056   0x1C5B             ADDS     R3,R3,#+1
   \   00000058   0x005B             LSLS     R3,R3,#+1
   1066                RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
   \   0000005A   0xFBB2 0xF2F3      UDIV     R2,R2,R3
   \   0000005E   0x6002             STR      R2,[R0, #+0]
   1067                break;
   \   00000060   0xE002             B.N      ??RCC_GetClocksFreq_3
   1068              default:
   1069                RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
   \                     ??RCC_GetClocksFreq_2: (+1)
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable51_7  ;; 0xf42400
   \   00000066   0x6002             STR      R2,[R0, #+0]
   1070                break;
   1071            }
   1072            /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
   1073          
   1074            /* Get HCLK prescaler */
   1075            tmp = RCC->CFGR & RCC_CFGR_HPRE;
   \                     ??RCC_GetClocksFreq_3: (+1)
   \   00000068   0x684A             LDR      R2,[R1, #+4]
   \   0000006A   0xF002 0x03F0      AND      R3,R2,#0xF0
   1076            tmp = tmp >> 4;
   1077            presc = APBAHBPrescTable[tmp];
   \   0000006E   0x.... 0x....      LDR.W    R2,??DataTable51_8
   \   00000072   0x091B             LSRS     R3,R3,#+4
   \   00000074   0x5C9B             LDRB     R3,[R3, R2]
   1078            /* HCLK clock frequency */
   1079            RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
   \   00000076   0x6805             LDR      R5,[R0, #+0]
   \   00000078   0x462C             MOV      R4,R5
   \   0000007A   0x40DC             LSRS     R4,R4,R3
   \   0000007C   0x6044             STR      R4,[R0, #+4]
   1080          
   1081            /* Get PCLK1 prescaler */
   1082            tmp = RCC->CFGR & RCC_CFGR_PPRE1;
   \   0000007E   0x684B             LDR      R3,[R1, #+4]
   \   00000080   0xF403 0x53E0      AND      R3,R3,#0x1C00
   1083            tmp = tmp >> 10;
   1084            presc = APBAHBPrescTable[tmp];
   \   00000084   0x0A9B             LSRS     R3,R3,#+10
   \   00000086   0x5C9B             LDRB     R3,[R3, R2]
   1085            /* PCLK1 clock frequency */
   1086            RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   00000088   0x4625             MOV      R5,R4
   \   0000008A   0x40DD             LSRS     R5,R5,R3
   \   0000008C   0x6085             STR      R5,[R0, #+8]
   1087          
   1088            /* Get PCLK2 prescaler */
   1089            tmp = RCC->CFGR & RCC_CFGR_PPRE2;
   \   0000008E   0x6849             LDR      R1,[R1, #+4]
   \   00000090   0xF401 0x4160      AND      R1,R1,#0xE000
   1090            tmp = tmp >> 13;
   1091            presc = APBAHBPrescTable[tmp];
   \   00000094   0x0B49             LSRS     R1,R1,#+13
   \   00000096   0x5C89             LDRB     R1,[R1, R2]
   1092            /* PCLK2 clock frequency */
   1093            RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
   \   00000098   0x6842             LDR      R2,[R0, #+4]
   \   0000009A   0x4613             MOV      R3,R2
   \   0000009C   0x40CB             LSRS     R3,R3,R1
   \   0000009E   0x60C3             STR      R3,[R0, #+12]
   1094          }
   \   000000A0   0xBC30             POP      {R4,R5}
   \   000000A2   0x4770             BX       LR               ;; return
   1095          
   1096          /**
   1097            * @}
   1098            */
   1099          
   1100          /** @defgroup RCC_Group3 Peripheral clocks configuration functions
   1101           *  @brief   Peripheral clocks configuration functions 
   1102           *
   1103          @verbatim   
   1104           ===============================================================================
   1105                        ##### Peripheral clocks configuration functions #####
   1106           ===============================================================================  
   1107              [..] This section provide functions allowing to configure the Peripheral clocks. 
   1108            
   1109                (#) The RTC clock which is derived from the LSI, LSE or HSE clock divided 
   1110                    by 2 to 31.
   1111               
   1112                (#) After restart from Reset or wakeup from STANDBY, all peripherals are off
   1113                    except internal SRAM, Flash and JTAG. Before to start using a peripheral 
   1114                    you have to enable its interface clock. You can do this using 
   1115                    RCC_AHBPeriphClockCmd(), RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
   1116          
   1117                (#) To reset the peripherals configuration (to the default state after device reset)
   1118                    you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
   1119                    RCC_APB1PeriphResetCmd() functions.
   1120               
   1121                (#) To further reduce power consumption in SLEEP mode the peripheral clocks 
   1122                    can be disabled prior to executing the WFI or WFE instructions. 
   1123                    You can do this using RCC_AHBPeriphClockLPModeCmd(), 
   1124                    RCC_APB2PeriphClockLPModeCmd() and RCC_APB1PeriphClockLPModeCmd() functions.  
   1125          
   1126          @endverbatim
   1127            * @{
   1128            */
   1129          
   1130          /**
   1131            * @brief  Configures the RTC clock (RTCCLK).
   1132            * @note   As the RTC clock configuration bits are in the Backup domain and write
   1133            *         access is denied to this domain after reset, you have to enable write
   1134            *         access using PWR_BackupAccessCmd(ENABLE) function before to configure
   1135            *         the RTC clock source (to be done once after reset).    
   1136            * @note   Once the RTC clock is configured it can't be changed unless the  
   1137            *         Backup domain is reset using RCC_BackupResetCmd() function, or by
   1138            *         a Power On Reset (POR).
   1139            *    
   1140            * @param  RCC_RTCCLKSource: specifies the RTC clock source.
   1141            *          This parameter can be one of the following values:
   1142            *            @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
   1143            *            @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
   1144            *            @arg RCC_RTCCLKSource_HSE_Divx: HSE clock divided by x selected
   1145            *                                            as RTC clock, where x:[2,31]
   1146            *  
   1147            * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
   1148            *         work in STOP and STANDBY modes, and can be used as wakeup source.
   1149            *         However, when the HSE clock is used as RTC clock source, the RTC
   1150            *         cannot be used in STOP and STANDBY modes.    
   1151            * @note   The maximum input clock frequency for RTC is 1MHz (when using HSE as
   1152            *         RTC clock source).
   1153            *  
   1154            * @retval None
   1155            */

   \                                 In section .text, align 2, keep-with-next
   1156          void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
   1157          {
   \                     RCC_RTCCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1158            uint32_t tmpreg = 0;
   1159          
   1160            /* Check the parameters */
   1161            assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
   \   00000004   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000008   0xF000 0x8081      BEQ.W    ??RCC_RTCCLKConfig_0
   \   0000000C   0xF5B4 0x7F00      CMP      R4,#+512
   \   00000010   0xD07D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable51_9  ;; 0x20300
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD079             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable51_10  ;; 0x30300
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD075             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable51_11  ;; 0x40300
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD071             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable51_12  ;; 0x50300
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD06D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_13  ;; 0x60300
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD069             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable51_14  ;; 0x70300
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD065             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable51_15  ;; 0x80300
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD061             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable51_16  ;; 0x90300
   \   0000004E   0x4284             CMP      R4,R0
   \   00000050   0xD05D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable51_17  ;; 0xa0300
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD059             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable51_18  ;; 0xb0300
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD055             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable51_19  ;; 0xc0300
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD051             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable51_20  ;; 0xd0300
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD04D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable51_21  ;; 0xe0300
   \   00000076   0x4284             CMP      R4,R0
   \   00000078   0xD049             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable51_22  ;; 0xf0300
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD045             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable51_23  ;; 0x100300
   \   00000086   0x4284             CMP      R4,R0
   \   00000088   0xD041             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable51_24  ;; 0x110300
   \   0000008E   0x4284             CMP      R4,R0
   \   00000090   0xD03D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable51_25  ;; 0x120300
   \   00000096   0x4284             CMP      R4,R0
   \   00000098   0xD039             BEQ.N    ??RCC_RTCCLKConfig_0
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable51_26  ;; 0x130300
   \   0000009E   0x4284             CMP      R4,R0
   \   000000A0   0xD035             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable51_27  ;; 0x140300
   \   000000A6   0x4284             CMP      R4,R0
   \   000000A8   0xD031             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable51_28  ;; 0x150300
   \   000000AE   0x4284             CMP      R4,R0
   \   000000B0   0xD02D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable51_29  ;; 0x160300
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xD029             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable51_30  ;; 0x170300
   \   000000BE   0x4284             CMP      R4,R0
   \   000000C0   0xD025             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable51_31  ;; 0x180300
   \   000000C6   0x4284             CMP      R4,R0
   \   000000C8   0xD021             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable51_32  ;; 0x190300
   \   000000CE   0x4284             CMP      R4,R0
   \   000000D0   0xD01D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable51_33  ;; 0x1a0300
   \   000000D6   0x4284             CMP      R4,R0
   \   000000D8   0xD019             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable51_34  ;; 0x1b0300
   \   000000DE   0x4284             CMP      R4,R0
   \   000000E0   0xD015             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable51_35  ;; 0x1c0300
   \   000000E6   0x4284             CMP      R4,R0
   \   000000E8   0xD011             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable51_36  ;; 0x1d0300
   \   000000EE   0x4284             CMP      R4,R0
   \   000000F0   0xD00D             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000F2   0x.... 0x....      LDR.W    R0,??DataTable51_37  ;; 0x1e0300
   \   000000F6   0x4284             CMP      R4,R0
   \   000000F8   0xD009             BEQ.N    ??RCC_RTCCLKConfig_0
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable51_38  ;; 0x1f0300
   \   000000FE   0x4284             CMP      R4,R0
   \   00000100   0xD005             BEQ.N    ??RCC_RTCCLKConfig_0
   \   00000102   0xF240 0x4189      MOVW     R1,#+1161
   \   00000106   0x.... 0x....      ADR.W    R0,?_0
   \   0000010A   0x.... 0x....      BL       assert_failed
   1162          
   1163            if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
   \                     ??RCC_RTCCLKConfig_0: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable51_6  ;; 0x40023808
   \   00000112   0xF404 0x7140      AND      R1,R4,#0x300
   \   00000116   0xF5B1 0x7F40      CMP      R1,#+768
   \   0000011A   0xD107             BNE.N    ??RCC_RTCCLKConfig_1
   1164            { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
   1165              tmpreg = RCC->CFGR;
   \   0000011C   0x6801             LDR      R1,[R0, #+0]
   1166          
   1167              /* Clear RTCPRE[4:0] bits */
   1168              tmpreg &= ~RCC_CFGR_RTCPRE;
   1169          
   1170              /* Configure HSE division factor for RTC clock */
   1171              tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
   1172          
   1173              /* Store the new value */
   1174              RCC->CFGR = tmpreg;
   \   0000011E   0xF421 0x11F8      BIC      R1,R1,#0x1F0000
   \   00000122   0x.... 0x....      LDR.W    R2,??DataTable51_39  ;; 0xffffcff
   \   00000126   0x4022             ANDS     R2,R2,R4
   \   00000128   0x4311             ORRS     R1,R2,R1
   \   0000012A   0x6001             STR      R1,[R0, #+0]
   1175            }
   1176              
   1177            /* Select the RTC clock source */
   1178            RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
   \                     ??RCC_RTCCLKConfig_1: (+1)
   \   0000012C   0x6E81             LDR      R1,[R0, #+104]
   \   0000012E   0x0522             LSLS     R2,R4,#+20
   \   00000130   0xEA51 0x5112      ORRS     R1,R1,R2, LSR #+20
   \   00000134   0x6681             STR      R1,[R0, #+104]
   1179          }
   \   00000136   0xBD10             POP      {R4,PC}          ;; return
   1180          
   1181          /**
   1182            * @brief  Enables or disables the RTC clock.
   1183            * @note   This function must be used only after the RTC clock source was selected
   1184            *         using the RCC_RTCCLKConfig function.
   1185            * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
   1186            * @retval None
   1187            */

   \                                 In section .text, align 2, keep-with-next
   1188          void RCC_RTCCLKCmd(FunctionalState NewState)
   1189          {
   \                     RCC_RTCCLKCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1190            /* Check the parameters */
   1191            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_RTCCLKCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_RTCCLKCmd_0
   \   0000000A   0xF240 0x41A7      MOVW     R1,#+1191
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1192          
   1193            *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
   \                     ??RCC_RTCCLKCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_40  ;; 0x42470e3c
   \   0000001A   0x6004             STR      R4,[R0, #+0]
   1194          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1195          
   1196          /**
   1197            * @brief  Forces or releases the Backup domain reset.
   1198            * @note   This function resets the RTC peripheral (including the backup registers)
   1199            *         and the RTC clock source selection in RCC_CSR register.
   1200            * @note   The BKPSRAM is not affected by this reset.    
   1201            * @param  NewState: new state of the Backup domain reset.
   1202            *          This parameter can be: ENABLE or DISABLE.
   1203            * @retval None
   1204            */

   \                                 In section .text, align 2, keep-with-next
   1205          void RCC_BackupResetCmd(FunctionalState NewState)
   1206          {
   \                     RCC_BackupResetCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1207            /* Check the parameters */
   1208            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??RCC_BackupResetCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_BackupResetCmd_0
   \   0000000A   0xF44F 0x6197      MOV      R1,#+1208
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1209            *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
   \                     ??RCC_BackupResetCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_41  ;; 0x42470e40
   \   0000001A   0x6004             STR      R4,[R0, #+0]
   1210          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1211          
   1212          /**
   1213            * @brief  Configures the I2S clock source (I2SCLK).
   1214            * @note   This function must be called before enabling the I2S APB clock.
   1215            * @param  RCC_I2SCLKSource: specifies the I2S clock source.
   1216            *          This parameter can be one of the following values:
   1217            *            @arg RCC_I2S2CLKSource_PLLI2S: PLLI2S clock used as I2S clock source
   1218            *            @arg RCC_I2S2CLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1219            *                                        used as I2S clock source
   1220            * @retval None
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
   1223          {
   \                     RCC_I2SCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1224            /* Check the parameters */
   1225            assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
   \   00000004   0xD007             BEQ.N    ??RCC_I2SCLKConfig_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_I2SCLKConfig_0
   \   0000000A   0xF240 0x41C9      MOVW     R1,#+1225
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1226          
   1227            *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
   \                     ??RCC_I2SCLKConfig_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_42  ;; 0x4247015c
   \   0000001A   0x6004             STR      R4,[R0, #+0]
   1228          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1229          
   1230          /**
   1231            * @brief  Configures the SAI clock Divider coming from PLLI2S.
   1232            * 
   1233            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1234            *   
   1235            * @note   This function must be called before enabling the PLLI2S.
   1236            *              
   1237            * @param  RCC_PLLI2SDivQ: specifies the PLLI2S division factor for SAI1 clock .
   1238            *          This parameter must be a number between 1 and 32.
   1239            *          SAI1 clock frequency = f(PLLI2S_Q) / RCC_PLLI2SDivQ 
   1240            *              
   1241            * @retval None
   1242            */

   \                                 In section .text, align 2, keep-with-next
   1243          void RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ)  
   1244          {
   \                     RCC_SAIPLLI2SClkDivConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1245            uint32_t tmpreg = 0;
   1246            
   1247            /* Check the parameters */
   1248            assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(RCC_PLLI2SDivQ));
   \   00000004   0xD001             BEQ.N    ??RCC_SAIPLLI2SClkDivConfig_0
   \   00000006   0x2C21             CMP      R4,#+33
   \   00000008   0xD305             BCC.N    ??RCC_SAIPLLI2SClkDivConfig_1
   \                     ??RCC_SAIPLLI2SClkDivConfig_0: (+1)
   \   0000000A   0xF44F 0x619C      MOV      R1,#+1248
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1249            
   1250            tmpreg = RCC->DCKCFGR;
   \                     ??RCC_SAIPLLI2SClkDivConfig_1: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_43  ;; 0x4002388c
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   1251          
   1252            /* Clear PLLI2SDIVQ[4:0] bits */
   1253            tmpreg &= ~(RCC_DCKCFGR_PLLI2SDIVQ);
   1254          
   1255            /* Set PLLI2SDIVQ values */
   1256            tmpreg |= (RCC_PLLI2SDivQ - 1);
   1257          
   1258            /* Store the new value */
   1259            RCC->DCKCFGR = tmpreg;
   \   0000001C   0x0949             LSRS     R1,R1,#+5
   \   0000001E   0x1E62             SUBS     R2,R4,#+1
   \   00000020   0xEA52 0x1141      ORRS     R1,R2,R1, LSL #+5
   \   00000024   0x6001             STR      R1,[R0, #+0]
   1260          }
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1261          
   1262          /**
   1263            * @brief  Configures the SAI clock Divider coming from PLLSAI.
   1264            * 
   1265            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1266            *        
   1267            * @note   This function must be called before enabling the PLLSAI.
   1268            *   
   1269            * @param  RCC_PLLSAIDivQ: specifies the PLLSAI division factor for SAI1 clock .
   1270            *          This parameter must be a number between 1 and 32.
   1271            *          SAI1 clock frequency = f(PLLSAI_Q) / RCC_PLLSAIDivQ  
   1272            *              
   1273            * @retval None
   1274            */

   \                                 In section .text, align 2, keep-with-next
   1275          void RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ)  
   1276          {
   \                     RCC_SAIPLLSAIClkDivConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1277            uint32_t tmpreg = 0;
   1278            
   1279            /* Check the parameters */
   1280            assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(RCC_PLLSAIDivQ));
   \   00000004   0xD001             BEQ.N    ??RCC_SAIPLLSAIClkDivConfig_0
   \   00000006   0x2C21             CMP      R4,#+33
   \   00000008   0xD305             BCC.N    ??RCC_SAIPLLSAIClkDivConfig_1
   \                     ??RCC_SAIPLLSAIClkDivConfig_0: (+1)
   \   0000000A   0xF44F 0x61A0      MOV      R1,#+1280
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1281            
   1282            tmpreg = RCC->DCKCFGR;
   \                     ??RCC_SAIPLLSAIClkDivConfig_1: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_43  ;; 0x4002388c
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   1283          
   1284            /* Clear PLLI2SDIVQ[4:0] and PLLSAIDIVQ[4:0] bits */
   1285            tmpreg &= ~(RCC_DCKCFGR_PLLSAIDIVQ);
   1286          
   1287            /* Set PLLSAIDIVQ values */
   1288            tmpreg |= ((RCC_PLLSAIDivQ - 1) << 8);
   1289          
   1290            /* Store the new value */
   1291            RCC->DCKCFGR = tmpreg;
   \   0000001C   0xF421 0x51F8      BIC      R1,R1,#0x1F00
   \   00000020   0x1E62             SUBS     R2,R4,#+1
   \   00000022   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1292          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   1293          
   1294          /**
   1295            * @brief  Configures SAI1BlockA clock source selection.
   1296            * 
   1297            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1298            *       
   1299            * @note   This function must be called before enabling PLLSAI, PLLI2S and  
   1300            *         the SAI clock.
   1301            * @param  RCC_SAIBlockACLKSource: specifies the SAI Block A clock source.
   1302            *          This parameter can be one of the following values:
   1303            *            @arg RCC_SAIACLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
   1304            *                                           as SAI1 Block A clock 
   1305            *            @arg RCC_SAIACLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
   1306            *                                           as SAI1 Block A clock 
   1307            *            @arg RCC_SAIACLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1308            *                                        used as SAI1 Block A clock
   1309            * @retval None
   1310            */

   \                                 In section .text, align 2, keep-with-next
   1311          void RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource)
   1312          {
   \                     RCC_SAIBlockACLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1313            uint32_t tmpreg = 0;
   1314            
   1315            /* Check the parameters */
   1316            assert_param(IS_RCC_SAIACLK_SOURCE(RCC_SAIBlockACLKSource));
   \   00000004   0xF5B4 0x1F80      CMP      R4,#+1048576
   \   00000008   0xD00A             BEQ.N    ??RCC_SAIBlockACLKConfig_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??RCC_SAIBlockACLKConfig_0
   \   0000000E   0xF5B4 0x1F00      CMP      R4,#+2097152
   \   00000012   0xD005             BEQ.N    ??RCC_SAIBlockACLKConfig_0
   \   00000014   0xF240 0x5124      MOVW     R1,#+1316
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       assert_failed
   1317            
   1318            tmpreg = RCC->DCKCFGR;
   \                     ??RCC_SAIBlockACLKConfig_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable51_43  ;; 0x4002388c
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   1319          
   1320            /* Clear RCC_DCKCFGR_SAI1ASRC[1:0] bits */
   1321            tmpreg &= ~RCC_DCKCFGR_SAI1ASRC;
   1322          
   1323            /* Set SAI Block A source selection value */
   1324            tmpreg |= RCC_SAIBlockACLKSource;
   1325          
   1326            /* Store the new value */
   1327            RCC->DCKCFGR = tmpreg;
   \   00000026   0xF421 0x1140      BIC      R1,R1,#0x300000
   \   0000002A   0x4321             ORRS     R1,R4,R1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   1328          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1329          
   1330          /**
   1331            * @brief  Configures SAI1BlockB clock source selection.
   1332            * 
   1333            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1334            *       
   1335            * @note   This function must be called before enabling PLLSAI, PLLI2S and  
   1336            *         the SAI clock.
   1337            * @param  RCC_SAIBlockBCLKSource: specifies the SAI Block B clock source.
   1338            *          This parameter can be one of the following values:
   1339            *            @arg RCC_SAIBCLKSource_PLLI2S: PLLI2S_Q clock divided by PLLI2SDIVQ used 
   1340            *                                           as SAI1 Block B clock 
   1341            *            @arg RCC_SAIBCLKSource_PLLSAI: PLLISAI_Q clock divided by PLLSAIDIVQ used 
   1342            *                                           as SAI1 Block B clock 
   1343            *            @arg RCC_SAIBCLKSource_Ext: External clock mapped on the I2S_CKIN pin
   1344            *                                        used as SAI1 Block B clock
   1345            * @retval None
   1346            */

   \                                 In section .text, align 2, keep-with-next
   1347          void RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource)
   1348          {
   \                     RCC_SAIBlockBCLKConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1349            uint32_t tmpreg = 0;
   1350            
   1351            /* Check the parameters */
   1352            assert_param(IS_RCC_SAIBCLK_SOURCE(RCC_SAIBlockBCLKSource));
   \   00000004   0xF5B4 0x0F80      CMP      R4,#+4194304
   \   00000008   0xD00A             BEQ.N    ??RCC_SAIBlockBCLKConfig_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD008             BEQ.N    ??RCC_SAIBlockBCLKConfig_0
   \   0000000E   0xF5B4 0x0F00      CMP      R4,#+8388608
   \   00000012   0xD005             BEQ.N    ??RCC_SAIBlockBCLKConfig_0
   \   00000014   0xF44F 0x61A9      MOV      R1,#+1352
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       assert_failed
   1353            
   1354            tmpreg = RCC->DCKCFGR;
   \                     ??RCC_SAIBlockBCLKConfig_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable51_43  ;; 0x4002388c
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   1355          
   1356            /* Clear RCC_DCKCFGR_SAI1BSRC[1:0] bits */
   1357            tmpreg &= ~RCC_DCKCFGR_SAI1BSRC;
   1358          
   1359            /* Set SAI Block B source selection value */
   1360            tmpreg |= RCC_SAIBlockBCLKSource;
   1361          
   1362            /* Store the new value */
   1363            RCC->DCKCFGR = tmpreg;
   \   00000026   0xF421 0x0140      BIC      R1,R1,#0xC00000
   \   0000002A   0x4321             ORRS     R1,R4,R1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
   1364          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1365          
   1366          
   1367          /**
   1368            * @brief  Configures the LTDC clock Divider coming from PLLSAI.
   1369            * 
   1370            * @note   The LTDC peripheral is only available with STM32F429xx/439xx Devices.
   1371            *      
   1372            * @note   This function must be called before enabling the PLLSAI.
   1373            *   
   1374            * @param  RCC_PLLSAIDivR: specifies the PLLSAI division factor for LTDC clock .
   1375            *          This parameter must be a number between 2 and 16.
   1376            *          LTDC clock frequency = f(PLLSAI_R) / RCC_PLLSAIDivR  
   1377            *            
   1378            * @retval None
   1379            */

   \                                 In section .text, align 2, keep-with-next
   1380          void RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR)
   1381          {
   \                     RCC_LTDCCLKDivConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1382            uint32_t tmpreg = 0;
   1383            
   1384            /* Check the parameters */
   1385            assert_param(IS_RCC_PLLSAI_DIVR_VALUE(RCC_PLLSAIDivR));
   \   00000004   0xD00E             BEQ.N    ??RCC_LTDCCLKDivConfig_0
   \   00000006   0xF5B4 0x3F80      CMP      R4,#+65536
   \   0000000A   0xD00B             BEQ.N    ??RCC_LTDCCLKDivConfig_0
   \   0000000C   0xF5B4 0x3F00      CMP      R4,#+131072
   \   00000010   0xD008             BEQ.N    ??RCC_LTDCCLKDivConfig_0
   \   00000012   0xF5B4 0x3F40      CMP      R4,#+196608
   \   00000016   0xD005             BEQ.N    ??RCC_LTDCCLKDivConfig_0
   \   00000018   0xF240 0x5169      MOVW     R1,#+1385
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1386            
   1387            tmpreg = RCC->DCKCFGR;
   \                     ??RCC_LTDCCLKDivConfig_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable51_43  ;; 0x4002388c
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   1388          
   1389            /* Clear PLLSAIDIVR[2:0] bits */
   1390            tmpreg &= ~RCC_DCKCFGR_PLLSAIDIVR;
   1391          
   1392            /* Set PLLSAIDIVR values */
   1393            tmpreg |= RCC_PLLSAIDivR;
   1394          
   1395            /* Store the new value */
   1396            RCC->DCKCFGR = tmpreg;
   \   0000002A   0xF421 0x3140      BIC      R1,R1,#0x30000
   \   0000002E   0x4321             ORRS     R1,R4,R1
   \   00000030   0x6001             STR      R1,[R0, #+0]
   1397          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
   1398          
   1399          /**
   1400            * @brief  Configures the Timers clocks prescalers selection.
   1401            * 
   1402            * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx devices. 
   1403            *   
   1404            * @param  RCC_TIMCLKPrescaler : specifies the Timers clocks prescalers selection
   1405            *         This parameter can be one of the following values:
   1406            *            @arg RCC_TIMPrescDesactivated: The Timers kernels clocks prescaler is 
   1407            *                 equal to HPRE if PPREx is corresponding to division by 1 or 2, 
   1408            *                 else it is equal to [(HPRE * PPREx) / 2] if PPREx is corresponding to 
   1409            *                 division by 4 or more.
   1410            *                   
   1411            *            @arg RCC_TIMPrescActivated: The Timers kernels clocks prescaler is 
   1412            *                 equal to HPRE if PPREx is corresponding to division by 1, 2 or 4, 
   1413            *                 else it is equal to [(HPRE * PPREx) / 4] if PPREx is corresponding 
   1414            *                 to division by 8 or more.
   1415            * @retval None
   1416            */

   \                                 In section .text, align 2, keep-with-next
   1417          void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
   1418          {
   \                     RCC_TIMCLKPresConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1419            /* Check the parameters */
   1420            assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));
   \   00000004   0xD007             BEQ.N    ??RCC_TIMCLKPresConfig_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??RCC_TIMCLKPresConfig_0
   \   0000000A   0xF240 0x518C      MOVW     R1,#+1420
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1421          
   1422            *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
   \                     ??RCC_TIMCLKPresConfig_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable51_44  ;; 0x424711e0
   \   0000001A   0x6004             STR      R4,[R0, #+0]
   1423            
   1424          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1425          
   1426          /**
   1427            * @brief  Enables or disables the AHB1 peripheral clock.
   1428            * @note   After reset, the peripheral clock (used for registers read/write access)
   1429            *         is disabled and the application software has to enable this clock before 
   1430            *         using it.   
   1431            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1432            *          This parameter can be any combination of the following values:
   1433            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1434            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1435            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1436            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1437            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1438            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1439            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1440            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1441            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1442            *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
   1443            *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
   1444            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1445            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1446            *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
   1447            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1448            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1449            *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
   1450            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1451            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1452            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1453            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1454            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1455            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1456            * @param  NewState: new state of the specified peripheral clock.
   1457            *          This parameter can be: ENABLE or DISABLE.
   1458            * @retval None
   1459            */

   \                                 In section .text, align 2, keep-with-next
   1460          void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1461          {
   \                     RCC_AHB1PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1462            /* Check the parameters */
   1463            assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable51_45  ;; 0x810be800
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB1PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHB1PeriphClockCmd_1
   \                     ??RCC_AHB1PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x51B7      MOVW     R1,#+1463
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1464          
   1465            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB1PeriphClockCmd_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB1PeriphClockCmd_2
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RCC_AHB1PeriphClockCmd_2
   \   00000026   0xF240 0x51B9      MOVW     R1,#+1465
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1466            if (NewState != DISABLE)
   \                     ??RCC_AHB1PeriphClockCmd_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_46  ;; 0x40023830
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xD004             BEQ.N    ??RCC_AHB1PeriphClockCmd_3
   1467            {
   1468              RCC->AHB1ENR |= RCC_AHB1Periph;
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   1469              __DSB();
   \   00000040   0xF3BF 0x8F4F      DSB      
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1470            }
   1471            else
   1472            {
   1473              RCC->AHB1ENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockCmd_3: (+1)
   \   00000046   0x43A1             BICS     R1,R1,R4
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1474              __DSB();
   \   0000004A   0xF3BF 0x8F4F      DSB      
   1475            }
   1476          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1477          
   1478          /**
   1479            * @brief  Enables or disables the AHB2 peripheral clock.
   1480            * @note   After reset, the peripheral clock (used for registers read/write access)
   1481            *         is disabled and the application software has to enable this clock before 
   1482            *         using it. 
   1483            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1484            *          This parameter can be any combination of the following values:
   1485            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1486            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1487            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1488            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1489            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1490            * @param  NewState: new state of the specified peripheral clock.
   1491            *          This parameter can be: ENABLE or DISABLE.
   1492            * @retval None
   1493            */

   \                                 In section .text, align 2, keep-with-next
   1494          void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1495          {
   \                     RCC_AHB2PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1496            /* Check the parameters */
   1497            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   \   00000006   0xF034 0x00F1      BICS     R0,R4,#0xF1
   \   0000000A   0xD101             BNE.N    ??RCC_AHB2PeriphClockCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_AHB2PeriphClockCmd_1
   \                     ??RCC_AHB2PeriphClockCmd_0: (+1)
   \   00000010   0xF240 0x51D9      MOVW     R1,#+1497
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1498            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB2PeriphClockCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_AHB2PeriphClockCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_AHB2PeriphClockCmd_2
   \   00000024   0xF240 0x51DA      MOVW     R1,#+1498
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1499          
   1500            if (NewState != DISABLE)
   \                     ??RCC_AHB2PeriphClockCmd_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable51_47  ;; 0x40023834
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0xD004             BEQ.N    ??RCC_AHB2PeriphClockCmd_3
   1501            {
   1502              RCC->AHB2ENR |= RCC_AHB2Periph;
   \   0000003A   0x4321             ORRS     R1,R4,R1
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   1503              __DSB();
   \   0000003E   0xF3BF 0x8F4F      DSB      
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}
   1504            }
   1505            else
   1506            {
   1507              RCC->AHB2ENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockCmd_3: (+1)
   \   00000044   0x43A1             BICS     R1,R1,R4
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1508              __DSB();
   \   00000048   0xF3BF 0x8F4F      DSB      
   1509            }
   1510          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1511          
   1512          /**
   1513            * @brief  Enables or disables the AHB3 peripheral clock.
   1514            * @note   After reset, the peripheral clock (used for registers read/write access)
   1515            *         is disabled and the application software has to enable this clock before 
   1516            *         using it. 
   1517            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1518            *          This parameter must be: RCC_AHB3Periph_FSMC
   1519            *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
   1520            * @param  NewState: new state of the specified peripheral clock.
   1521            *          This parameter can be: ENABLE or DISABLE.
   1522            * @retval None
   1523            */

   \                                 In section .text, align 2, keep-with-next
   1524          void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1525          {
   \                     RCC_AHB3PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1526            /* Check the parameters */
   1527            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
   \   00000006   0x0860             LSRS     R0,R4,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0xD101             BNE.N    ??RCC_AHB3PeriphClockCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_AHB3PeriphClockCmd_1
   \                     ??RCC_AHB3PeriphClockCmd_0: (+1)
   \   00000010   0xF240 0x51F7      MOVW     R1,#+1527
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1528            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB3PeriphClockCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_AHB3PeriphClockCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_AHB3PeriphClockCmd_2
   \   00000024   0xF44F 0x61BF      MOV      R1,#+1528
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1529          
   1530            if (NewState != DISABLE)
   \                     ??RCC_AHB3PeriphClockCmd_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable51_48  ;; 0x40023838
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0xD004             BEQ.N    ??RCC_AHB3PeriphClockCmd_3
   1531            {
   1532              RCC->AHB3ENR |= RCC_AHB3Periph;
   \   0000003A   0x4321             ORRS     R1,R4,R1
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   1533              __DSB();
   \   0000003E   0xF3BF 0x8F4F      DSB      
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}
   1534            }
   1535            else
   1536            {
   1537              RCC->AHB3ENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockCmd_3: (+1)
   \   00000044   0x43A1             BICS     R1,R1,R4
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1538              __DSB();
   \   00000048   0xF3BF 0x8F4F      DSB      
   1539            }
   1540          }
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1541          
   1542          /**
   1543            * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
   1544            * @note   After reset, the peripheral clock (used for registers read/write access)
   1545            *         is disabled and the application software has to enable this clock before 
   1546            *         using it. 
   1547            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1548            *          This parameter can be any combination of the following values:
   1549            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1550            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1551            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1552            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1553            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1554            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1555            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1556            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1557            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1558            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1559            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1560            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1561            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1562            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1563            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1564            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1565            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1566            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1567            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1568            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1569            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1570            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1571            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1572            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1573            *            @arg RCC_APB1Periph_UART8:  UART8 clock
   1574            * @param  NewState: new state of the specified peripheral clock.
   1575            *          This parameter can be: ENABLE or DISABLE.
   1576            * @retval None
   1577            */

   \                                 In section .text, align 2, keep-with-next
   1578          void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1579          {
   \                     RCC_APB1PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1580            /* Check the parameters */
   1581            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable51_49  ;; 0x9013600
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB1PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_APB1PeriphClockCmd_1
   \                     ??RCC_APB1PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x612D      MOVW     R1,#+1581
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1582            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphClockCmd_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB1PeriphClockCmd_2
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RCC_APB1PeriphClockCmd_2
   \   00000026   0xF240 0x612E      MOVW     R1,#+1582
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1583          
   1584            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphClockCmd_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_50  ;; 0x40023840
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xD004             BEQ.N    ??RCC_APB1PeriphClockCmd_3
   1585            {
   1586              RCC->APB1ENR |= RCC_APB1Periph;
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   1587              __DSB();
   \   00000040   0xF3BF 0x8F4F      DSB      
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1588            }
   1589            else
   1590            {
   1591              RCC->APB1ENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockCmd_3: (+1)
   \   00000046   0x43A1             BICS     R1,R1,R4
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1592              __DSB();
   \   0000004A   0xF3BF 0x8F4F      DSB      
   1593            }
   1594          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1595          
   1596          /**
   1597            * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
   1598            * @note   After reset, the peripheral clock (used for registers read/write access)
   1599            *         is disabled and the application software has to enable this clock before 
   1600            *         using it.
   1601            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   1602            *          This parameter can be any combination of the following values:
   1603            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1604            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1605            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1606            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1607            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1608            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1609            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1610            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1611            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1612            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
   1613            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1614            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1615            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1616            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1617            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   1618            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   1619            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   1620            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices) 
   1621            * @param  NewState: new state of the specified peripheral clock.
   1622            *          This parameter can be: ENABLE or DISABLE.
   1623            * @retval None
   1624            */

   \                                 In section .text, align 2, keep-with-next
   1625          void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1626          {
   \                     RCC_APB2PeriphClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1627            /* Check the parameters */
   1628            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable51_51  ;; 0xfb8880cc
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB2PeriphClockCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_APB2PeriphClockCmd_1
   \                     ??RCC_APB2PeriphClockCmd_0: (+1)
   \   00000012   0xF240 0x615C      MOVW     R1,#+1628
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1629            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphClockCmd_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB2PeriphClockCmd_2
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RCC_APB2PeriphClockCmd_2
   \   00000026   0xF240 0x615D      MOVW     R1,#+1629
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1630          
   1631            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphClockCmd_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_52  ;; 0x40023844
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xD004             BEQ.N    ??RCC_APB2PeriphClockCmd_3
   1632            {
   1633              RCC->APB2ENR |= RCC_APB2Periph;
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   1634              __DSB();
   \   00000040   0xF3BF 0x8F4F      DSB      
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1635            }
   1636            else
   1637            {
   1638              RCC->APB2ENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockCmd_3: (+1)
   \   00000046   0x43A1             BICS     R1,R1,R4
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1639              __DSB();
   \   0000004A   0xF3BF 0x8F4F      DSB      
   1640            }
   1641          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1642          
   1643          /**
   1644            * @brief  Forces or releases AHB1 peripheral reset.
   1645            * @param  RCC_AHB1Periph: specifies the AHB1 peripheral to reset.
   1646            *          This parameter can be any combination of the following values:
   1647            *            @arg RCC_AHB1Periph_GPIOA:   GPIOA clock
   1648            *            @arg RCC_AHB1Periph_GPIOB:   GPIOB clock 
   1649            *            @arg RCC_AHB1Periph_GPIOC:   GPIOC clock
   1650            *            @arg RCC_AHB1Periph_GPIOD:   GPIOD clock
   1651            *            @arg RCC_AHB1Periph_GPIOE:   GPIOE clock
   1652            *            @arg RCC_AHB1Periph_GPIOF:   GPIOF clock
   1653            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1654            *            @arg RCC_AHB1Periph_GPIOG:   GPIOG clock
   1655            *            @arg RCC_AHB1Periph_GPIOI:   GPIOI clock
   1656            *            @arg RCC_AHB1Periph_GPIOJ:   GPIOJ clock (STM32F42xxx/43xxx devices) 
   1657            *            @arg RCC_AHB1Periph_GPIOK:   GPIOK clock (STM32F42xxx/43xxxdevices)   
   1658            *            @arg RCC_AHB1Periph_CRC:     CRC clock
   1659            *            @arg RCC_AHB1Periph_DMA1:    DMA1 clock
   1660            *            @arg RCC_AHB1Periph_DMA2:    DMA2 clock
   1661            *            @arg RCC_AHB1Periph_DMA2D:   DMA2D clock (STM32F429xx/439xx devices)   
   1662            *            @arg RCC_AHB1Periph_ETH_MAC: Ethernet MAC clock
   1663            *            @arg RCC_AHB1Periph_OTG_HS:  USB OTG HS clock
   1664            *                  
   1665            * @param  NewState: new state of the specified peripheral reset.
   1666            *          This parameter can be: ENABLE or DISABLE.
   1667            * @retval None
   1668            */

   \                                 In section .text, align 2, keep-with-next
   1669          void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1670          {
   \                     RCC_AHB1PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1671            /* Check the parameters */
   1672            assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable51_53  ;; 0xdd1fe800
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB1PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHB1PeriphResetCmd_1
   \                     ??RCC_AHB1PeriphResetCmd_0: (+1)
   \   00000012   0xF44F 0x61D1      MOV      R1,#+1672
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1673            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB1PeriphResetCmd_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB1PeriphResetCmd_2
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RCC_AHB1PeriphResetCmd_2
   \   00000026   0xF240 0x6189      MOVW     R1,#+1673
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1674          
   1675            if (NewState != DISABLE)
   \                     ??RCC_AHB1PeriphResetCmd_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_54  ;; 0x40023810
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xD002             BEQ.N    ??RCC_AHB1PeriphResetCmd_3
   1676            {
   1677              RCC->AHB1RSTR |= RCC_AHB1Periph;
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
   1678            }
   1679            else
   1680            {
   1681              RCC->AHB1RSTR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphResetCmd_3: (+1)
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x6001             STR      R1,[R0, #+0]
   1682            }
   1683          }
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1684          
   1685          /**
   1686            * @brief  Forces or releases AHB2 peripheral reset.
   1687            * @param  RCC_AHB2Periph: specifies the AHB2 peripheral to reset.
   1688            *          This parameter can be any combination of the following values:
   1689            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1690            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1691            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1692            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1693            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock
   1694            * @param  NewState: new state of the specified peripheral reset.
   1695            *          This parameter can be: ENABLE or DISABLE.
   1696            * @retval None
   1697            */

   \                                 In section .text, align 2, keep-with-next
   1698          void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1699          {
   \                     RCC_AHB2PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1700            /* Check the parameters */
   1701            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   \   00000006   0xF034 0x00F1      BICS     R0,R4,#0xF1
   \   0000000A   0xD101             BNE.N    ??RCC_AHB2PeriphResetCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_AHB2PeriphResetCmd_1
   \                     ??RCC_AHB2PeriphResetCmd_0: (+1)
   \   00000010   0xF240 0x61A5      MOVW     R1,#+1701
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1702            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB2PeriphResetCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_AHB2PeriphResetCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_AHB2PeriphResetCmd_2
   \   00000024   0xF240 0x61A6      MOVW     R1,#+1702
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1703          
   1704            if (NewState != DISABLE)
   \                     ??RCC_AHB2PeriphResetCmd_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable51_55  ;; 0x40023814
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0xD002             BEQ.N    ??RCC_AHB2PeriphResetCmd_3
   1705            {
   1706              RCC->AHB2RSTR |= RCC_AHB2Periph;
   \   0000003A   0x4321             ORRS     R1,R4,R1
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}
   1707            }
   1708            else
   1709            {
   1710              RCC->AHB2RSTR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphResetCmd_3: (+1)
   \   00000040   0x43A1             BICS     R1,R1,R4
   \   00000042   0x6001             STR      R1,[R0, #+0]
   1711            }
   1712          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1713          
   1714          /**
   1715            * @brief  Forces or releases AHB3 peripheral reset.
   1716            * @param  RCC_AHB3Periph: specifies the AHB3 peripheral to reset.
   1717            *          This parameter must be: RCC_AHB3Periph_FSMC
   1718            *                                  or RCC_AHB3Periph_FMC (STM32F42xxx/43xxx devices)  
   1719            * @param  NewState: new state of the specified peripheral reset.
   1720            *          This parameter can be: ENABLE or DISABLE.
   1721            * @retval None
   1722            */

   \                                 In section .text, align 2, keep-with-next
   1723          void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1724          {
   \                     RCC_AHB3PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1725            /* Check the parameters */
   1726            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   \   00000006   0x0860             LSRS     R0,R4,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0xD101             BNE.N    ??RCC_AHB3PeriphResetCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_AHB3PeriphResetCmd_1
   \                     ??RCC_AHB3PeriphResetCmd_0: (+1)
   \   00000010   0xF240 0x61BE      MOVW     R1,#+1726
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1727            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB3PeriphResetCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_AHB3PeriphResetCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_AHB3PeriphResetCmd_2
   \   00000024   0xF240 0x61BF      MOVW     R1,#+1727
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1728          
   1729            if (NewState != DISABLE)
   \                     ??RCC_AHB3PeriphResetCmd_2: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable51_56  ;; 0x40023818
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0xD002             BEQ.N    ??RCC_AHB3PeriphResetCmd_3
   1730            {
   1731              RCC->AHB3RSTR |= RCC_AHB3Periph;
   \   0000003A   0x4321             ORRS     R1,R4,R1
   \   0000003C   0x6001             STR      R1,[R0, #+0]
   \   0000003E   0xBD31             POP      {R0,R4,R5,PC}
   1732            }
   1733            else
   1734            {
   1735              RCC->AHB3RSTR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphResetCmd_3: (+1)
   \   00000040   0x43A1             BICS     R1,R1,R4
   \   00000042   0x6001             STR      R1,[R0, #+0]
   1736            }
   1737          }
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1738          
   1739          /**
   1740            * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
   1741            * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
   1742            *          This parameter can be any combination of the following values:
   1743            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1744            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1745            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1746            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1747            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1748            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1749            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1750            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1751            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1752            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1753            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1754            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1755            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1756            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1757            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1758            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1759            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1760            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1761            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1762            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1763            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1764            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1765            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1766            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1767            *            @arg RCC_APB1Periph_UART8:  UART8 clock  
   1768            * @param  NewState: new state of the specified peripheral reset.
   1769            *          This parameter can be: ENABLE or DISABLE.
   1770            * @retval None
   1771            */

   \                                 In section .text, align 2, keep-with-next
   1772          void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1773          {
   \                     RCC_APB1PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1774            /* Check the parameters */
   1775            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable51_49  ;; 0x9013600
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB1PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_APB1PeriphResetCmd_1
   \                     ??RCC_APB1PeriphResetCmd_0: (+1)
   \   00000012   0xF240 0x61EF      MOVW     R1,#+1775
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1776            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphResetCmd_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB1PeriphResetCmd_2
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RCC_APB1PeriphResetCmd_2
   \   00000026   0xF44F 0x61DE      MOV      R1,#+1776
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1777            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphResetCmd_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_57  ;; 0x40023820
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xD002             BEQ.N    ??RCC_APB1PeriphResetCmd_3
   1778            {
   1779              RCC->APB1RSTR |= RCC_APB1Periph;
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
   1780            }
   1781            else
   1782            {
   1783              RCC->APB1RSTR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphResetCmd_3: (+1)
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x6001             STR      R1,[R0, #+0]
   1784            }
   1785          }
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1786          
   1787          /**
   1788            * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
   1789            * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
   1790            *          This parameter can be any combination of the following values:
   1791            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   1792            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   1793            *            @arg RCC_APB2Periph_USART1: USART1 clock
   1794            *            @arg RCC_APB2Periph_USART6: USART6 clock
   1795            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   1796            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   1797            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   1798            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   1799            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   1800            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock  
   1801            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   1802            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   1803            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   1804            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   1805            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   1806            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   1807            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   1808            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
   1809            * @param  NewState: new state of the specified peripheral reset.
   1810            *          This parameter can be: ENABLE or DISABLE.
   1811            * @retval None
   1812            */

   \                                 In section .text, align 2, keep-with-next
   1813          void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   1814          {
   \                     RCC_APB2PeriphResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1815            /* Check the parameters */
   1816            assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable51_58  ;; 0xfb8886cc
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_APB2PeriphResetCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_APB2PeriphResetCmd_1
   \                     ??RCC_APB2PeriphResetCmd_0: (+1)
   \   00000012   0xF44F 0x61E3      MOV      R1,#+1816
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1817            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphResetCmd_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_APB2PeriphResetCmd_2
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RCC_APB2PeriphResetCmd_2
   \   00000026   0xF240 0x7119      MOVW     R1,#+1817
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1818            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphResetCmd_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_59  ;; 0x40023824
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xD002             BEQ.N    ??RCC_APB2PeriphResetCmd_3
   1819            {
   1820              RCC->APB2RSTR |= RCC_APB2Periph;
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
   1821            }
   1822            else
   1823            {
   1824              RCC->APB2RSTR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphResetCmd_3: (+1)
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x6001             STR      R1,[R0, #+0]
   1825            }
   1826          }
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1827          
   1828          /**
   1829            * @brief  Enables or disables the AHB1 peripheral clock during Low Power (Sleep) mode.
   1830            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1831            *         power consumption.
   1832            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1833            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1834            * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
   1835            *          This parameter can be any combination of the following values:
   1836            *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
   1837            *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
   1838            *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
   1839            *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
   1840            *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
   1841            *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
   1842            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1843            *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
   1844            *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
   1845            *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
   1846            *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)   
   1847            *            @arg RCC_AHB1Periph_CRC:         CRC clock
   1848            *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
   1849            *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
   1850            *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
   1851            *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices) 
   1852            *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
   1853            *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
   1854            *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
   1855            *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
   1856            *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
   1857            *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
   1858            * @param  NewState: new state of the specified peripheral clock.
   1859            *          This parameter can be: ENABLE or DISABLE.
   1860            * @retval None
   1861            */

   \                                 In section .text, align 2, keep-with-next
   1862          void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
   1863          {
   \                     RCC_AHB1PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1864            /* Check the parameters */
   1865            assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable51_60  ;; 0x81106800
   \   0000000A   0x4204             TST      R4,R0
   \   0000000C   0xD101             BNE.N    ??RCC_AHB1PeriphClockLPModeCmd_0
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD105             BNE.N    ??RCC_AHB1PeriphClockLPModeCmd_1
   \                     ??RCC_AHB1PeriphClockLPModeCmd_0: (+1)
   \   00000012   0xF240 0x7149      MOVW     R1,#+1865
   \   00000016   0x.... 0x....      ADR.W    R0,?_0
   \   0000001A   0x.... 0x....      BL       assert_failed
   1866            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB1PeriphClockLPModeCmd_1: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_2
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_2
   \   00000026   0xF240 0x714A      MOVW     R1,#+1866
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   1867            if (NewState != DISABLE)
   \                     ??RCC_AHB1PeriphClockLPModeCmd_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable51_61  ;; 0x40023850
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0xD004             BEQ.N    ??RCC_AHB1PeriphClockLPModeCmd_3
   1868            {
   1869              RCC->AHB1LPENR |= RCC_AHB1Periph;
   \   0000003C   0x4321             ORRS     R1,R4,R1
   \   0000003E   0x6001             STR      R1,[R0, #+0]
   1870              __DSB();
   \   00000040   0xF3BF 0x8F4F      DSB      
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1871            }
   1872            else
   1873            {
   1874              RCC->AHB1LPENR &= ~RCC_AHB1Periph;
   \                     ??RCC_AHB1PeriphClockLPModeCmd_3: (+1)
   \   00000046   0x43A1             BICS     R1,R1,R4
   \   00000048   0x6001             STR      R1,[R0, #+0]
   1875              __DSB();
   \   0000004A   0xF3BF 0x8F4F      DSB      
   1876            }
   1877          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1878          
   1879          /**
   1880            * @brief  Enables or disables the AHB2 peripheral clock during Low Power (Sleep) mode.
   1881            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1882            *           power consumption.
   1883            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1884            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1885            * @param  RCC_AHBPeriph: specifies the AHB2 peripheral to gates its clock.
   1886            *          This parameter can be any combination of the following values:
   1887            *            @arg RCC_AHB2Periph_DCMI:   DCMI clock
   1888            *            @arg RCC_AHB2Periph_CRYP:   CRYP clock
   1889            *            @arg RCC_AHB2Periph_HASH:   HASH clock
   1890            *            @arg RCC_AHB2Periph_RNG:    RNG clock
   1891            *            @arg RCC_AHB2Periph_OTG_FS: USB OTG FS clock  
   1892            * @param  NewState: new state of the specified peripheral clock.
   1893            *          This parameter can be: ENABLE or DISABLE.
   1894            * @retval None
   1895            */

   \                                 In section .text, align 2, keep-with-next
   1896          void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
   1897          {
   \                     RCC_AHB2PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1898            /* Check the parameters */
   1899            assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
   \   00000006   0xF034 0x00F1      BICS     R0,R4,#0xF1
   \   0000000A   0xD101             BNE.N    ??RCC_AHB2PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_AHB2PeriphClockLPModeCmd_1
   \                     ??RCC_AHB2PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x716B      MOVW     R1,#+1899
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1900            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB2PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_2
   \   00000024   0xF240 0x716C      MOVW     R1,#+1900
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1901            if (NewState != DISABLE)
   \                     ??RCC_AHB2PeriphClockLPModeCmd_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable51_62  ;; 0x40023854
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xD004             BEQ.N    ??RCC_AHB2PeriphClockLPModeCmd_3
   1902            {
   1903              RCC->AHB2LPENR |= RCC_AHB2Periph;
   \   00000038   0x4321             ORRS     R1,R4,R1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   1904              __DSB();
   \   0000003C   0xF3BF 0x8F4F      DSB      
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
   1905            }
   1906            else
   1907            {
   1908              RCC->AHB2LPENR &= ~RCC_AHB2Periph;
   \                     ??RCC_AHB2PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x6001             STR      R1,[R0, #+0]
   1909              __DSB();
   \   00000046   0xF3BF 0x8F4F      DSB      
   1910            }
   1911          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1912          
   1913          /**
   1914            * @brief  Enables or disables the AHB3 peripheral clock during Low Power (Sleep) mode.
   1915            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1916            *         power consumption.
   1917            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1918            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1919            * @param  RCC_AHBPeriph: specifies the AHB3 peripheral to gates its clock.
   1920            *          This parameter must be: RCC_AHB3Periph_FSMC
   1921            *                                  or RCC_AHB3Periph_FMC (STM32F429x/439x devices) 
   1922            * @param  NewState: new state of the specified peripheral clock.
   1923            *          This parameter can be: ENABLE or DISABLE.
   1924            * @retval None
   1925            */

   \                                 In section .text, align 2, keep-with-next
   1926          void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
   1927          {
   \                     RCC_AHB3PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1928            /* Check the parameters */
   1929            assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
   \   00000006   0x0860             LSRS     R0,R4,#+1
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \   0000000A   0xD101             BNE.N    ??RCC_AHB3PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_AHB3PeriphClockLPModeCmd_1
   \                     ??RCC_AHB3PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x7189      MOVW     R1,#+1929
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1930            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_AHB3PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_2
   \   00000024   0xF240 0x718A      MOVW     R1,#+1930
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1931            if (NewState != DISABLE)
   \                     ??RCC_AHB3PeriphClockLPModeCmd_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable51_63  ;; 0x40023858
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xD004             BEQ.N    ??RCC_AHB3PeriphClockLPModeCmd_3
   1932            {
   1933              RCC->AHB3LPENR |= RCC_AHB3Periph;
   \   00000038   0x4321             ORRS     R1,R4,R1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   1934              __DSB();
   \   0000003C   0xF3BF 0x8F4F      DSB      
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
   1935            }
   1936            else
   1937            {
   1938              RCC->AHB3LPENR &= ~RCC_AHB3Periph;
   \                     ??RCC_AHB3PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x6001             STR      R1,[R0, #+0]
   1939              __DSB();
   \   00000046   0xF3BF 0x8F4F      DSB      
   1940            }
   1941          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1942          
   1943          /**
   1944            * @brief  Enables or disables the APB1 peripheral clock during Low Power (Sleep) mode.
   1945            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   1946            *         power consumption.
   1947            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   1948            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   1949            * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
   1950            *          This parameter can be any combination of the following values:
   1951            *            @arg RCC_APB1Periph_TIM2:   TIM2 clock
   1952            *            @arg RCC_APB1Periph_TIM3:   TIM3 clock
   1953            *            @arg RCC_APB1Periph_TIM4:   TIM4 clock
   1954            *            @arg RCC_APB1Periph_TIM5:   TIM5 clock
   1955            *            @arg RCC_APB1Periph_TIM6:   TIM6 clock
   1956            *            @arg RCC_APB1Periph_TIM7:   TIM7 clock
   1957            *            @arg RCC_APB1Periph_TIM12:  TIM12 clock
   1958            *            @arg RCC_APB1Periph_TIM13:  TIM13 clock
   1959            *            @arg RCC_APB1Periph_TIM14:  TIM14 clock
   1960            *            @arg RCC_APB1Periph_WWDG:   WWDG clock
   1961            *            @arg RCC_APB1Periph_SPI2:   SPI2 clock
   1962            *            @arg RCC_APB1Periph_SPI3:   SPI3 clock
   1963            *            @arg RCC_APB1Periph_USART2: USART2 clock
   1964            *            @arg RCC_APB1Periph_USART3: USART3 clock
   1965            *            @arg RCC_APB1Periph_UART4:  UART4 clock
   1966            *            @arg RCC_APB1Periph_UART5:  UART5 clock
   1967            *            @arg RCC_APB1Periph_I2C1:   I2C1 clock
   1968            *            @arg RCC_APB1Periph_I2C2:   I2C2 clock
   1969            *            @arg RCC_APB1Periph_I2C3:   I2C3 clock
   1970            *            @arg RCC_APB1Periph_CAN1:   CAN1 clock
   1971            *            @arg RCC_APB1Periph_CAN2:   CAN2 clock
   1972            *            @arg RCC_APB1Periph_PWR:    PWR clock
   1973            *            @arg RCC_APB1Periph_DAC:    DAC clock
   1974            *            @arg RCC_APB1Periph_UART7:  UART7 clock
   1975            *            @arg RCC_APB1Periph_UART8:  UART8 clock
   1976            * @param  NewState: new state of the specified peripheral clock.
   1977            *          This parameter can be: ENABLE or DISABLE.
   1978            * @retval None
   1979            */

   \                                 In section .text, align 2, keep-with-next
   1980          void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
   1981          {
   \                     RCC_APB1PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1982            /* Check the parameters */
   1983            assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
   \   00000006   0x....             LDR.N    R0,??DataTable51_49  ;; 0x9013600
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_APB1PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_APB1PeriphClockLPModeCmd_1
   \                     ??RCC_APB1PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x71BF      MOVW     R1,#+1983
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1984            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB1PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_2
   \   00000024   0xF44F 0x61F8      MOV      R1,#+1984
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1985            if (NewState != DISABLE)
   \                     ??RCC_APB1PeriphClockLPModeCmd_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable51_64  ;; 0x40023860
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xD004             BEQ.N    ??RCC_APB1PeriphClockLPModeCmd_3
   1986            {
   1987              RCC->APB1LPENR |= RCC_APB1Periph;
   \   00000038   0x4321             ORRS     R1,R4,R1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   1988              __DSB();
   \   0000003C   0xF3BF 0x8F4F      DSB      
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
   1989            }
   1990            else
   1991            {
   1992              RCC->APB1LPENR &= ~RCC_APB1Periph;
   \                     ??RCC_APB1PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x6001             STR      R1,[R0, #+0]
   1993              __DSB();
   \   00000046   0xF3BF 0x8F4F      DSB      
   1994            }
   1995          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1996          
   1997          /**
   1998            * @brief  Enables or disables the APB2 peripheral clock during Low Power (Sleep) mode.
   1999            * @note   Peripheral clock gating in SLEEP mode can be used to further reduce
   2000            *         power consumption.
   2001            * @note   After wakeup from SLEEP mode, the peripheral clock is enabled again.
   2002            * @note   By default, all peripheral clocks are enabled during SLEEP mode.
   2003            * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
   2004            *          This parameter can be any combination of the following values:
   2005            *            @arg RCC_APB2Periph_TIM1:   TIM1 clock
   2006            *            @arg RCC_APB2Periph_TIM8:   TIM8 clock
   2007            *            @arg RCC_APB2Periph_USART1: USART1 clock
   2008            *            @arg RCC_APB2Periph_USART6: USART6 clock
   2009            *            @arg RCC_APB2Periph_ADC1:   ADC1 clock
   2010            *            @arg RCC_APB2Periph_ADC2:   ADC2 clock
   2011            *            @arg RCC_APB2Periph_ADC3:   ADC3 clock
   2012            *            @arg RCC_APB2Periph_SDIO:   SDIO clock
   2013            *            @arg RCC_APB2Periph_SPI1:   SPI1 clock
   2014            *            @arg RCC_APB2Periph_SPI4:   SPI4 clock
   2015            *            @arg RCC_APB2Periph_SYSCFG: SYSCFG clock
   2016            *            @arg RCC_APB2Periph_TIM9:   TIM9 clock
   2017            *            @arg RCC_APB2Periph_TIM10:  TIM10 clock
   2018            *            @arg RCC_APB2Periph_TIM11:  TIM11 clock
   2019            *            @arg RCC_APB2Periph_SPI5:   SPI5 clock
   2020            *            @arg RCC_APB2Periph_SPI6:   SPI6 clock
   2021            *            @arg RCC_APB2Periph_SAI1:   SAI1 clock (STM32F42xxx/43xxx devices) 
   2022            *            @arg RCC_APB2Periph_LTDC:   LTDC clock (STM32F429xx/439xx devices)   
   2023            * @param  NewState: new state of the specified peripheral clock.
   2024            *          This parameter can be: ENABLE or DISABLE.
   2025            * @retval None
   2026            */

   \                                 In section .text, align 2, keep-with-next
   2027          void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
   2028          {
   \                     RCC_APB2PeriphClockLPModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2029            /* Check the parameters */
   2030            assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
   \   00000006   0x....             LDR.N    R0,??DataTable51_51  ;; 0xfb8880cc
   \   00000008   0x4204             TST      R4,R0
   \   0000000A   0xD101             BNE.N    ??RCC_APB2PeriphClockLPModeCmd_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??RCC_APB2PeriphClockLPModeCmd_1
   \                     ??RCC_APB2PeriphClockLPModeCmd_0: (+1)
   \   00000010   0xF240 0x71EE      MOVW     R1,#+2030
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   2031            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_APB2PeriphClockLPModeCmd_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_2
   \   00000024   0xF240 0x71EF      MOVW     R1,#+2031
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   2032            if (NewState != DISABLE)
   \                     ??RCC_APB2PeriphClockLPModeCmd_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable51_65  ;; 0x40023864
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xD004             BEQ.N    ??RCC_APB2PeriphClockLPModeCmd_3
   2033            {
   2034              RCC->APB2LPENR |= RCC_APB2Periph;
   \   00000038   0x4321             ORRS     R1,R4,R1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   2035              __DSB();
   \   0000003C   0xF3BF 0x8F4F      DSB      
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
   2036            }
   2037            else
   2038            {
   2039              RCC->APB2LPENR &= ~RCC_APB2Periph;
   \                     ??RCC_APB2PeriphClockLPModeCmd_3: (+1)
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x6001             STR      R1,[R0, #+0]
   2040              __DSB();
   \   00000046   0xF3BF 0x8F4F      DSB      
   2041            }
   2042          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2043          
   2044          /**
   2045            * @}
   2046            */
   2047          
   2048          /** @defgroup RCC_Group4 Interrupts and flags management functions
   2049           *  @brief   Interrupts and flags management functions 
   2050           *
   2051          @verbatim   
   2052           ===============================================================================
   2053                          ##### Interrupts and flags management functions #####
   2054           ===============================================================================  
   2055          
   2056          @endverbatim
   2057            * @{
   2058            */
   2059          
   2060          /**
   2061            * @brief  Enables or disables the specified RCC interrupts.
   2062            * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
   2063            *          This parameter can be any combination of the following values:
   2064            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2065            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2066            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2067            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2068            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2069            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt
   2070            *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)
   2071            * @param  NewState: new state of the specified RCC interrupts.
   2072            *          This parameter can be: ENABLE or DISABLE.
   2073            * @retval None
   2074            */

   \                                 In section .text, align 2, keep-with-next
   2075          void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
   2076          {
   \                     RCC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   2077            /* Check the parameters */
   2078            assert_param(IS_RCC_IT(RCC_IT));
   \   00000006   0x0620             LSLS     R0,R4,#+24
   \   00000008   0xD401             BMI.N    ??RCC_ITConfig_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??RCC_ITConfig_1
   \                     ??RCC_ITConfig_0: (+1)
   \   0000000E   0xF640 0x011E      MOVW     R1,#+2078
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       assert_failed
   2079            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??RCC_ITConfig_1: (+1)
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD007             BEQ.N    ??RCC_ITConfig_2
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD005             BEQ.N    ??RCC_ITConfig_2
   \   00000022   0xF640 0x011F      MOVW     R1,#+2079
   \   00000026   0x.... 0x....      ADR.W    R0,?_0
   \   0000002A   0x.... 0x....      BL       assert_failed
   2080            if (NewState != DISABLE)
   \                     ??RCC_ITConfig_2: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable51_66  ;; 0x4002380d
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0x7801             LDRB     R1,[R0, #+0]
   \   00000034   0xD002             BEQ.N    ??RCC_ITConfig_3
   2081            {
   2082              /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
   2083              *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
   \   00000036   0x4321             ORRS     R1,R4,R1
   \   00000038   0x7001             STRB     R1,[R0, #+0]
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}
   2084            }
   2085            else
   2086            {
   2087              /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
   2088              *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
   \                     ??RCC_ITConfig_3: (+1)
   \   0000003C   0x43A1             BICS     R1,R1,R4
   \   0000003E   0x7001             STRB     R1,[R0, #+0]
   2089            }
   2090          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2091          
   2092          /**
   2093            * @brief  Checks whether the specified RCC flag is set or not.
   2094            * @param  RCC_FLAG: specifies the flag to check.
   2095            *          This parameter can be one of the following values:
   2096            *            @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready
   2097            *            @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
   2098            *            @arg RCC_FLAG_PLLRDY: main PLL clock ready
   2099            *            @arg RCC_FLAG_PLLI2SRDY: PLLI2S clock ready
   2100            *            @arg RCC_FLAG_PLLSAIRDY: PLLSAI clock ready (only for STM32F42xxx/43xxx devices)
   2101            *            @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
   2102            *            @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
   2103            *            @arg RCC_FLAG_BORRST: POR/PDR or BOR reset
   2104            *            @arg RCC_FLAG_PINRST: Pin reset
   2105            *            @arg RCC_FLAG_PORRST: POR/PDR reset
   2106            *            @arg RCC_FLAG_SFTRST: Software reset
   2107            *            @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
   2108            *            @arg RCC_FLAG_WWDGRST: Window Watchdog reset
   2109            *            @arg RCC_FLAG_LPWRRST: Low Power reset
   2110            * @retval The new state of RCC_FLAG (SET or RESET).
   2111            */

   \                                 In section .text, align 2, keep-with-next
   2112          FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
   2113          {
   \                     RCC_GetFlagStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2114            uint32_t tmp = 0;
   2115            uint32_t statusreg = 0;
   2116            FlagStatus bitstatus = RESET;
   2117          
   2118            /* Check the parameters */
   2119            assert_param(IS_RCC_FLAG(RCC_FLAG));
   \   00000004   0x2821             CMP      R0,#+33
   \   00000006   0xD01F             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000008   0x2831             CMP      R0,#+49
   \   0000000A   0xD01D             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000000C   0x2839             CMP      R0,#+57
   \   0000000E   0xD01B             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000010   0x2841             CMP      R0,#+65
   \   00000012   0xD019             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000014   0x2861             CMP      R0,#+97
   \   00000016   0xD017             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000018   0x2879             CMP      R0,#+121
   \   0000001A   0xD015             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000001C   0x287A             CMP      R0,#+122
   \   0000001E   0xD013             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000020   0x287B             CMP      R0,#+123
   \   00000022   0xD011             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000024   0x287C             CMP      R0,#+124
   \   00000026   0xD00F             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000028   0x287D             CMP      R0,#+125
   \   0000002A   0xD00D             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000002C   0x287E             CMP      R0,#+126
   \   0000002E   0xD00B             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000030   0x287F             CMP      R0,#+127
   \   00000032   0xD009             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000034   0x283B             CMP      R0,#+59
   \   00000036   0xD007             BEQ.N    ??RCC_GetFlagStatus_0
   \   00000038   0x283D             CMP      R0,#+61
   \   0000003A   0xD005             BEQ.N    ??RCC_GetFlagStatus_0
   \   0000003C   0xF640 0x0147      MOVW     R1,#+2119
   \   00000040   0x.... 0x....      ADR.W    R0,?_0
   \   00000044   0x.... 0x....      BL       assert_failed
   2120          
   2121            /* Get the RCC register index */
   2122            tmp = RCC_FLAG >> 5;
   \                     ??RCC_GetFlagStatus_0: (+1)
   \   00000048   0x0960             LSRS     R0,R4,#+5
   2123            if (tmp == 1)               /* The flag to check is in CR register */
   \   0000004A   0x....             LDR.N    R1,??DataTable51_67  ;; 0x40023800
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD101             BNE.N    ??RCC_GetFlagStatus_1
   2124            {
   2125              statusreg = RCC->CR;
   \   00000050   0x6808             LDR      R0,[R1, #+0]
   \   00000052   0xE004             B.N      ??RCC_GetFlagStatus_2
   2126            }
   2127            else if (tmp == 2)          /* The flag to check is in BDCR register */
   \                     ??RCC_GetFlagStatus_1: (+1)
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD101             BNE.N    ??RCC_GetFlagStatus_3
   2128            {
   2129              statusreg = RCC->BDCR;
   \   00000058   0x6F08             LDR      R0,[R1, #+112]
   \   0000005A   0xE000             B.N      ??RCC_GetFlagStatus_2
   2130            }
   2131            else                       /* The flag to check is in CSR register */
   2132            {
   2133              statusreg = RCC->CSR;
   \                     ??RCC_GetFlagStatus_3: (+1)
   \   0000005C   0x6F48             LDR      R0,[R1, #+116]
   2134            }
   2135          
   2136            /* Get the flag position */
   2137            tmp = RCC_FLAG & FLAG_MASK;
   2138            if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
   2139            {
   2140              bitstatus = SET;
   2141            }
   2142            else
   2143            {
   2144              bitstatus = RESET;
   2145            }
   2146            /* Return the flag status */
   2147            return bitstatus;
   \                     ??RCC_GetFlagStatus_2: (+1)
   \   0000005E   0xF004 0x011F      AND      R1,R4,#0x1F
   \   00000062   0x4602             MOV      R2,R0
   \   00000064   0x40CA             LSRS     R2,R2,R1
   \   00000066   0xF002 0x0001      AND      R0,R2,#0x1
   \   0000006A   0xBD10             POP      {R4,PC}          ;; return
   2148          }
   2149          
   2150          /**
   2151            * @brief  Clears the RCC reset flags.
   2152            *         The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST,  RCC_FLAG_SFTRST,
   2153            *         RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
   2154            * @param  None
   2155            * @retval None
   2156            */

   \                                 In section .text, align 2, keep-with-next
   2157          void RCC_ClearFlag(void)
   2158          {
   2159            /* Set RMVF bit to clear the reset flags */
   2160            RCC->CSR |= RCC_CSR_RMVF;
   \                     RCC_ClearFlag: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable51_68  ;; 0x40023874
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xF041 0x7180      ORR      R1,R1,#0x1000000
   \   00000008   0x6001             STR      R1,[R0, #+0]
   2161          }
   \   0000000A   0x4770             BX       LR               ;; return
   2162          
   2163          /**
   2164            * @brief  Checks whether the specified RCC interrupt has occurred or not.
   2165            * @param  RCC_IT: specifies the RCC interrupt source to check.
   2166            *          This parameter can be one of the following values:
   2167            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2168            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2169            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2170            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2171            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2172            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt           
   2173            *            @arg RCC_IT_PLLSAIRDY: PLLSAI clock ready interrupt (only for STM32F42xxx/43xxx devices)    
   2174            *            @arg RCC_IT_CSS: Clock Security System interrupt
   2175            * @retval The new state of RCC_IT (SET or RESET).
   2176            */

   \                                 In section .text, align 2, keep-with-next
   2177          ITStatus RCC_GetITStatus(uint8_t RCC_IT)
   2178          {
   \                     RCC_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2179            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   2180          
   2181            /* Check the parameters */
   2182            assert_param(IS_RCC_GET_IT(RCC_IT));
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD013             BEQ.N    ??RCC_GetITStatus_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD011             BEQ.N    ??RCC_GetITStatus_0
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD00F             BEQ.N    ??RCC_GetITStatus_0
   \   00000012   0x2808             CMP      R0,#+8
   \   00000014   0xD00D             BEQ.N    ??RCC_GetITStatus_0
   \   00000016   0x2810             CMP      R0,#+16
   \   00000018   0xD00B             BEQ.N    ??RCC_GetITStatus_0
   \   0000001A   0x2880             CMP      R0,#+128
   \   0000001C   0xD009             BEQ.N    ??RCC_GetITStatus_0
   \   0000001E   0x2840             CMP      R0,#+64
   \   00000020   0xD007             BEQ.N    ??RCC_GetITStatus_0
   \   00000022   0x2820             CMP      R0,#+32
   \   00000024   0xD005             BEQ.N    ??RCC_GetITStatus_0
   \   00000026   0xF640 0x0186      MOVW     R1,#+2182
   \   0000002A   0x.... 0x....      ADR.W    R0,?_0
   \   0000002E   0x.... 0x....      BL       assert_failed
   2183          
   2184            /* Check the status of the specified RCC interrupt */
   2185            if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
   \                     ??RCC_GetITStatus_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable51_69  ;; 0x4002380c
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x4220             TST      R0,R4
   \   00000038   0xD000             BEQ.N    ??RCC_GetITStatus_1
   2186            {
   2187              bitstatus = SET;
   \   0000003A   0x2501             MOVS     R5,#+1
   2188            }
   2189            else
   2190            {
   2191              bitstatus = RESET;
   2192            }
   2193            /* Return the RCC_IT status */
   2194            return  bitstatus;
   \                     ??RCC_GetITStatus_1: (+1)
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2195          }
   2196          
   2197          /**
   2198            * @brief  Clears the RCC's interrupt pending bits.
   2199            * @param  RCC_IT: specifies the interrupt pending bit to clear.
   2200            *          This parameter can be any combination of the following values:
   2201            *            @arg RCC_IT_LSIRDY: LSI ready interrupt
   2202            *            @arg RCC_IT_LSERDY: LSE ready interrupt
   2203            *            @arg RCC_IT_HSIRDY: HSI ready interrupt
   2204            *            @arg RCC_IT_HSERDY: HSE ready interrupt
   2205            *            @arg RCC_IT_PLLRDY: main PLL ready interrupt
   2206            *            @arg RCC_IT_PLLI2SRDY: PLLI2S ready interrupt  
   2207            *            @arg RCC_IT_PLLSAIRDY: PLLSAI ready interrupt (only for STM32F42xxx/43xxx devices)   
   2208            *            @arg RCC_IT_CSS: Clock Security System interrupt
   2209            * @retval None
   2210            */

   \                                 In section .text, align 2, keep-with-next
   2211          void RCC_ClearITPendingBit(uint8_t RCC_IT)
   2212          {
   \                     RCC_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2213            /* Check the parameters */
   2214            assert_param(IS_RCC_CLEAR_IT(RCC_IT));
   \   00000004   0xD105             BNE.N    ??RCC_ClearITPendingBit_0
   \   00000006   0xF640 0x01A6      MOVW     R1,#+2214
   \   0000000A   0x.... 0x....      ADR.W    R0,?_0
   \   0000000E   0x.... 0x....      BL       assert_failed
   2215          
   2216            /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
   2217               pending bits */
   2218            *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
   \                     ??RCC_ClearITPendingBit_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable51_70  ;; 0x4002380e
   \   00000014   0x7004             STRB     R4,[R0, #+0]
   2219          }
   \   00000016   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable41_1:
   \   00000000   0xEAF6FFFF         DC32     0xeaf6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \   00000000   0x24003010         DC32     0x24003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_1:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42_2:
   \   00000000   0x20003000         DC32     0x20003000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47:
   \   00000000   0x24003000         DC32     0x24003000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable47_1:
   \   00000000   0x40023802         DC32     0x40023802

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \   00000000   0x42470000         DC32     0x42470000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \   00000000   0x40023870         DC32     0x40023870

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50_1:
   \   00000000   0x42470E80         DC32     0x42470e80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_1:
   \   00000000   0x42470060         DC32     0x42470060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_2:
   \   00000000   0x42470068         DC32     0x42470068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_3:
   \   00000000   0x40023888         DC32     0x40023888

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_4:
   \   00000000   0x42470070         DC32     0x42470070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_5:
   \   00000000   0x4247004C         DC32     0x4247004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_6:
   \   00000000   0x40023808         DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_7:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_8:
   \   00000000   0x........         DC32     APBAHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_9:
   \   00000000   0x00020300         DC32     0x20300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_10:
   \   00000000   0x00030300         DC32     0x30300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_11:
   \   00000000   0x00040300         DC32     0x40300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_12:
   \   00000000   0x00050300         DC32     0x50300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_13:
   \   00000000   0x00060300         DC32     0x60300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_14:
   \   00000000   0x00070300         DC32     0x70300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_15:
   \   00000000   0x00080300         DC32     0x80300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_16:
   \   00000000   0x00090300         DC32     0x90300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_17:
   \   00000000   0x000A0300         DC32     0xa0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_18:
   \   00000000   0x000B0300         DC32     0xb0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_19:
   \   00000000   0x000C0300         DC32     0xc0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_20:
   \   00000000   0x000D0300         DC32     0xd0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_21:
   \   00000000   0x000E0300         DC32     0xe0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_22:
   \   00000000   0x000F0300         DC32     0xf0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_23:
   \   00000000   0x00100300         DC32     0x100300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_24:
   \   00000000   0x00110300         DC32     0x110300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_25:
   \   00000000   0x00120300         DC32     0x120300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_26:
   \   00000000   0x00130300         DC32     0x130300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_27:
   \   00000000   0x00140300         DC32     0x140300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_28:
   \   00000000   0x00150300         DC32     0x150300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_29:
   \   00000000   0x00160300         DC32     0x160300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_30:
   \   00000000   0x00170300         DC32     0x170300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_31:
   \   00000000   0x00180300         DC32     0x180300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_32:
   \   00000000   0x00190300         DC32     0x190300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_33:
   \   00000000   0x001A0300         DC32     0x1a0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_34:
   \   00000000   0x001B0300         DC32     0x1b0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_35:
   \   00000000   0x001C0300         DC32     0x1c0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_36:
   \   00000000   0x001D0300         DC32     0x1d0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_37:
   \   00000000   0x001E0300         DC32     0x1e0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_38:
   \   00000000   0x001F0300         DC32     0x1f0300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_39:
   \   00000000   0x0FFFFCFF         DC32     0xffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_40:
   \   00000000   0x42470E3C         DC32     0x42470e3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_41:
   \   00000000   0x42470E40         DC32     0x42470e40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_42:
   \   00000000   0x4247015C         DC32     0x4247015c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_43:
   \   00000000   0x4002388C         DC32     0x4002388c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_44:
   \   00000000   0x424711E0         DC32     0x424711e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_45:
   \   00000000   0x810BE800         DC32     0x810be800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_46:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_47:
   \   00000000   0x40023834         DC32     0x40023834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_48:
   \   00000000   0x40023838         DC32     0x40023838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_49:
   \   00000000   0x09013600         DC32     0x9013600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_50:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_51:
   \   00000000   0xFB8880CC         DC32     0xfb8880cc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_52:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_53:
   \   00000000   0xDD1FE800         DC32     0xdd1fe800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_54:
   \   00000000   0x40023810         DC32     0x40023810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_55:
   \   00000000   0x40023814         DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_56:
   \   00000000   0x40023818         DC32     0x40023818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_57:
   \   00000000   0x40023820         DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_58:
   \   00000000   0xFB8886CC         DC32     0xfb8886cc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_59:
   \   00000000   0x40023824         DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_60:
   \   00000000   0x81106800         DC32     0x81106800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_61:
   \   00000000   0x40023850         DC32     0x40023850

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_62:
   \   00000000   0x40023854         DC32     0x40023854

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_63:
   \   00000000   0x40023858         DC32     0x40023858

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_64:
   \   00000000   0x40023860         DC32     0x40023860

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_65:
   \   00000000   0x40023864         DC32     0x40023864

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_66:
   \   00000000   0x4002380D         DC32     0x4002380d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_67:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_68:
   \   00000000   0x40023874         DC32     0x40023874

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_69:
   \   00000000   0x4002380C         DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable51_70:
   \   00000000   0x4002380E         DC32     0x4002380e

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x72 0x63          DC8 72H, 63H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   00000066   0x00 0x00          DC8 0, 0
   2220          
   2221          /**
   2222            * @}
   2223            */ 
   2224          
   2225          /**
   2226            * @}
   2227            */ 
   2228          
   2229          /**
   2230            * @}
   2231            */ 
   2232          
   2233          /**
   2234            * @}
   2235            */ 
   2236          
   2237          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   RCC_AHB1PeriphClockCmd
        16   -> assert_failed
      16   RCC_AHB1PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_AHB1PeriphResetCmd
        16   -> assert_failed
      16   RCC_AHB2PeriphClockCmd
        16   -> assert_failed
      16   RCC_AHB2PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_AHB2PeriphResetCmd
        16   -> assert_failed
      16   RCC_AHB3PeriphClockCmd
        16   -> assert_failed
      16   RCC_AHB3PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_AHB3PeriphResetCmd
        16   -> assert_failed
      16   RCC_APB1PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB1PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_APB1PeriphResetCmd
        16   -> assert_failed
      16   RCC_APB2PeriphClockCmd
        16   -> assert_failed
      16   RCC_APB2PeriphClockLPModeCmd
        16   -> assert_failed
      16   RCC_APB2PeriphResetCmd
        16   -> assert_failed
       8   RCC_AdjustHSICalibrationValue
         8   -> assert_failed
       8   RCC_BackupResetCmd
         8   -> assert_failed
       0   RCC_ClearFlag
       8   RCC_ClearITPendingBit
         8   -> assert_failed
       8   RCC_ClockSecuritySystemCmd
         8   -> assert_failed
       0   RCC_DeInit
       8   RCC_GetClocksFreq
       8   RCC_GetFlagStatus
         8   -> assert_failed
      16   RCC_GetITStatus
        16   -> assert_failed
       0   RCC_GetSYSCLKSource
       8   RCC_HCLKConfig
         8   -> assert_failed
       8   RCC_HSEConfig
         8   -> assert_failed
       8   RCC_HSICmd
         8   -> assert_failed
       8   RCC_I2SCLKConfig
         8   -> assert_failed
      16   RCC_ITConfig
        16   -> assert_failed
       8   RCC_LSEConfig
         8   -> assert_failed
       8   RCC_LSICmd
         8   -> assert_failed
       8   RCC_LTDCCLKDivConfig
         8   -> assert_failed
      16   RCC_MCO1Config
        16   -> assert_failed
      16   RCC_MCO2Config
        16   -> assert_failed
       8   RCC_PCLK1Config
         8   -> assert_failed
       8   RCC_PCLK2Config
         8   -> assert_failed
       8   RCC_PLLCmd
         8   -> assert_failed
      24   RCC_PLLConfig
        24   -> assert_failed
       8   RCC_PLLI2SCmd
         8   -> assert_failed
      16   RCC_PLLI2SConfig
        16   -> assert_failed
       8   RCC_PLLSAICmd
         8   -> assert_failed
      16   RCC_PLLSAIConfig
        16   -> assert_failed
       8   RCC_RTCCLKCmd
         8   -> assert_failed
       8   RCC_RTCCLKConfig
         8   -> assert_failed
       8   RCC_SAIBlockACLKConfig
         8   -> assert_failed
       8   RCC_SAIBlockBCLKConfig
         8   -> assert_failed
       8   RCC_SAIPLLI2SClkDivConfig
         8   -> assert_failed
       8   RCC_SAIPLLSAIClkDivConfig
         8   -> assert_failed
       8   RCC_SYSCLKConfig
         8   -> assert_failed
       8   RCC_TIMCLKPresConfig
         8   -> assert_failed
      16   RCC_WaitForHSEStartUp
        16   -> RCC_GetFlagStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable41
       4  ??DataTable41_1
       4  ??DataTable42
       4  ??DataTable42_1
       4  ??DataTable42_2
       4  ??DataTable43
       4  ??DataTable47
       4  ??DataTable47_1
       4  ??DataTable49
       4  ??DataTable50
       4  ??DataTable50_1
       4  ??DataTable51
       4  ??DataTable51_1
       4  ??DataTable51_10
       4  ??DataTable51_11
       4  ??DataTable51_12
       4  ??DataTable51_13
       4  ??DataTable51_14
       4  ??DataTable51_15
       4  ??DataTable51_16
       4  ??DataTable51_17
       4  ??DataTable51_18
       4  ??DataTable51_19
       4  ??DataTable51_2
       4  ??DataTable51_20
       4  ??DataTable51_21
       4  ??DataTable51_22
       4  ??DataTable51_23
       4  ??DataTable51_24
       4  ??DataTable51_25
       4  ??DataTable51_26
       4  ??DataTable51_27
       4  ??DataTable51_28
       4  ??DataTable51_29
       4  ??DataTable51_3
       4  ??DataTable51_30
       4  ??DataTable51_31
       4  ??DataTable51_32
       4  ??DataTable51_33
       4  ??DataTable51_34
       4  ??DataTable51_35
       4  ??DataTable51_36
       4  ??DataTable51_37
       4  ??DataTable51_38
       4  ??DataTable51_39
       4  ??DataTable51_4
       4  ??DataTable51_40
       4  ??DataTable51_41
       4  ??DataTable51_42
       4  ??DataTable51_43
       4  ??DataTable51_44
       4  ??DataTable51_45
       4  ??DataTable51_46
       4  ??DataTable51_47
       4  ??DataTable51_48
       4  ??DataTable51_49
       4  ??DataTable51_5
       4  ??DataTable51_50
       4  ??DataTable51_51
       4  ??DataTable51_52
       4  ??DataTable51_53
       4  ??DataTable51_54
       4  ??DataTable51_55
       4  ??DataTable51_56
       4  ??DataTable51_57
       4  ??DataTable51_58
       4  ??DataTable51_59
       4  ??DataTable51_6
       4  ??DataTable51_60
       4  ??DataTable51_61
       4  ??DataTable51_62
       4  ??DataTable51_63
       4  ??DataTable51_64
       4  ??DataTable51_65
       4  ??DataTable51_66
       4  ??DataTable51_67
       4  ??DataTable51_68
       4  ??DataTable51_69
       4  ??DataTable51_7
       4  ??DataTable51_70
       4  ??DataTable51_8
       4  ??DataTable51_9
     104  ?_0
      16  APBAHBPrescTable
      80  RCC_AHB1PeriphClockCmd
      80  RCC_AHB1PeriphClockLPModeCmd
      72  RCC_AHB1PeriphResetCmd
      78  RCC_AHB2PeriphClockCmd
      76  RCC_AHB2PeriphClockLPModeCmd
      70  RCC_AHB2PeriphResetCmd
      78  RCC_AHB3PeriphClockCmd
      76  RCC_AHB3PeriphClockLPModeCmd
      70  RCC_AHB3PeriphResetCmd
      80  RCC_APB1PeriphClockCmd
      76  RCC_APB1PeriphClockLPModeCmd
      72  RCC_APB1PeriphResetCmd
      80  RCC_APB2PeriphClockCmd
      76  RCC_APB2PeriphClockLPModeCmd
      72  RCC_APB2PeriphResetCmd
      38  RCC_AdjustHSICalibrationValue
      30  RCC_BackupResetCmd
      12  RCC_ClearFlag
      24  RCC_ClearITPendingBit
      30  RCC_ClockSecuritySystemCmd
      66  RCC_DeInit
     164  RCC_GetClocksFreq
     108  RCC_GetFlagStatus
      64  RCC_GetITStatus
      12  RCC_GetSYSCLKSource
      66  RCC_HCLKConfig
      38  RCC_HSEConfig
      30  RCC_HSICmd
      30  RCC_I2SCLKConfig
      66  RCC_ITConfig
      58  RCC_LSEConfig
      30  RCC_LSICmd
      52  RCC_LTDCCLKDivConfig
      98  RCC_MCO1Config
      98  RCC_MCO2Config
      58  RCC_PCLK1Config
      60  RCC_PCLK2Config
      30  RCC_PLLCmd
     158  RCC_PLLConfig
      30  RCC_PLLI2SCmd
      58  RCC_PLLI2SConfig
      30  RCC_PLLSAICmd
      64  RCC_PLLSAIConfig
      30  RCC_RTCCLKCmd
     312  RCC_RTCCLKConfig
      48  RCC_SAIBlockACLKConfig
      48  RCC_SAIBlockBCLKConfig
      40  RCC_SAIPLLI2SClkDivConfig
      42  RCC_SAIPLLSAIClkDivConfig
      42  RCC_SYSCLKConfig
      30  RCC_TIMCLKPresConfig
      50  RCC_WaitForHSEStartUp

 
    16 bytes in section .data
 3 812 bytes in section .text
 
 3 812 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
