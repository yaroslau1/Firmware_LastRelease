###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2018  15:54:08
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ff.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ff.c -D IAR_ARM_CM4
#        -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D HAVE_CONFIG_H -D
#        SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D STENDBUY_NOT_USE
#        -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO -D
#        BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ff.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\ff.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.09a                 (C)ChaN, 2012
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a generic FAT file system module for small embedded systems.
      5          / This is a free software that opened for education, research and commercial
      6          / developments under license policy of following terms.
      7          /
      8          /  Copyright (C) 2012, ChaN, all right reserved.
      9          /
     10          / * The FatFs module is a free software and there is NO WARRANTY.
     11          / * No restriction on use. You can use, modify and redistribute it for
     12          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     13          / * Redistributions of source code must retain the above copyright notice.
     14          /
     15          /-----------------------------------------------------------------------------/
     16          / Feb 26,'06 R0.00  Prototype.
     17          /
     18          / Apr 29,'06 R0.01  First stable version.
     19          /
     20          / Jun 01,'06 R0.02  Added FAT12 support.
     21          /                   Removed unbuffered mode.
     22          /                   Fixed a problem on small (<32M) partition.
     23          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     24          /
     25          / Sep 22,'06 R0.03  Added f_rename().
     26          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     27          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     28          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     29          /
     30          / Feb 04,'07 R0.04  Supported multiple drive system.
     31          /                   Changed some interfaces for multiple drive system.
     32          /                   Changed f_mountdrv() to f_mount().
     33          /                   Added f_mkfs().
     34          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     35          /                   Added a capability of extending file size to f_lseek().
     36          /                   Added minimization level 3.
     37          /                   Fixed an endian sensitive code in f_mkfs().
     38          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     39          /                   Added FSInfo support.
     40          /                   Fixed DBCS name can result FR_INVALID_NAME.
     41          /                   Fixed short seek (<= csize) collapses the file object.
     42          /
     43          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     44          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     45          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     46          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     47          /                   Fixed off by one error at FAT sub-type determination.
     48          /                   Fixed btr in f_read() can be mistruncated.
     49          /                   Fixed cached sector is not flushed when create and close without write.
     50          /
     51          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     52          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     53          /
     54          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     55          /                   Added long file name feature.
     56          /                   Added multiple code page feature.
     57          /                   Added re-entrancy for multitask operation.
     58          /                   Added auto cluster size selection to f_mkfs().
     59          /                   Added rewind option to f_readdir().
     60          /                   Changed result code of critical errors.
     61          /                   Renamed string functions to avoid name collision.
     62          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     63          /                   Added multiple sector size feature.
     64          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     65          /                   Fixed wrong cache control in f_lseek().
     66          /                   Added relative path feature.
     67          /                   Added f_chdir() and f_chdrive().
     68          /                   Added proper case conversion to extended char.
     69          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
     70          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
     71          /                   Fixed name matching error on the 13 char boundary.
     72          /                   Added a configuration option, _LFN_UNICODE.
     73          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
     74          /
     75          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
     76          /                   Added file lock feature. (_FS_SHARE)
     77          /                   Added fast seek feature. (_USE_FASTSEEK)
     78          /                   Changed some types on the API, XCHAR->TCHAR.
     79          /                   Changed fname member in the FILINFO structure on Unicode cfg.
     80          /                   String functions support UTF-8 encoding files on Unicode cfg.
     81          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
     82          /                   Added sector erase feature. (_USE_ERASE)
     83          /                   Moved file lock semaphore table from fs object to the bss.
     84          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
     85          /                   Fixed f_mkfs() creates wrong FAT32 volume.
     86          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
     87          /                   f_lseek() reports required table size on creating CLMP.
     88          /                   Extended format syntax of f_printf function.
     89          /                   Ignores duplicated directory separators in given path name.
     90          /
     91          / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
     92          /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
     93          / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
     94          /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
     95          /                   Changed option name _FS_SHARE to _FS_LOCK.
     96          /---------------------------------------------------------------------------*/
     97          
     98          #include "ff.h"			/* FatFs configurations and declarations */
     99          #include "diskio.h"		/* Declarations of low level disk I/O functions */
    100          #include "TLcdTrace.h"
    101          
    102          
    103          /*--------------------------------------------------------------------------
    104          
    105             Module Private Definitions
    106          
    107          ---------------------------------------------------------------------------*/
    108          
    109          #if _FATFS != 4004	/* Revision ID */
    110          #error Wrong include file (ff.h).
    111          #endif
    112          
    113          
    114          /* Definitions on sector size */
    115          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    116          #error Wrong sector size.
    117          #endif
    118          #if _MAX_SS != 512
    119          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
    120          #else
    121          #define	SS(fs)	512U			/* Fixed sector size */
    122          #endif
    123          
    124          
    125          /* Reentrancy related */
    126          #if _FS_REENTRANT
    127          #if _USE_LFN == 1
    128          #error Static LFN work area must not be used in re-entrant configuration.
    129          #endif
    130          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    131          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    132          #else
    133          #define	ENTER_FF(fs)
    134          #define LEAVE_FF(fs, res)	return res
    135          #endif
    136          
    137          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    138          
    139          
    140          /* File access control feature */
    141          #if _FS_LOCK
    142          #if _FS_READONLY
    143          #error _FS_LOCK must be 0 on read-only cfg.
    144          #endif
    145          typedef struct {
    146          	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
    147          	DWORD clu;				/* File ID 2, directory */
    148          	WORD idx;				/* File ID 3, directory index */
    149          	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    150          } FILESEM;
    151          #endif
    152          
    153          
    154          
    155          /* DBCS code ranges and SBCS extend char conversion table */
    156          
    157          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    158          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    159          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    160          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    161          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    162          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    163          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    164          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    165          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    166          
    167          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    168          #define _DF1S	0x81
    169          #define _DF1E	0xFE
    170          #define _DS1S	0x40
    171          #define _DS1E	0x7E
    172          #define _DS2S	0x80
    173          #define _DS2E	0xFE
    174          
    175          #elif _CODE_PAGE == 949	/* Korean */
    176          #define _DF1S	0x81
    177          #define _DF1E	0xFE
    178          #define _DS1S	0x41
    179          #define _DS1E	0x5A
    180          #define _DS2S	0x61
    181          #define _DS2E	0x7A
    182          #define _DS3S	0x81
    183          #define _DS3E	0xFE
    184          
    185          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    186          #define _DF1S	0x81
    187          #define _DF1E	0xFE
    188          #define _DS1S	0x40
    189          #define _DS1E	0x7E
    190          #define _DS2S	0xA1
    191          #define _DS2E	0xFE
    192          
    193          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    194          #define _DF1S	0
    195          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    196          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    197          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    198          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    199          
    200          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    201          #define _DF1S	0
    202          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    203          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    204          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    205          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    206          
    207          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    208          #define _DF1S	0
    209          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    210          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    211          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    212          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    213          
    214          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    215          #define _DF1S	0
    216          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    217          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    218          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    219          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    220          
    221          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    222          #define _DF1S	0
    223          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    224          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    225          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    226          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    227          
    228          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    229          #define _DF1S	0
    230          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    231          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    232          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    233          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    234          
    235          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    236          #define _DF1S	0
    237          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    238          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    239          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    240          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    241          
    242          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    243          #define _DF1S	0
    244          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    245          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    246          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    247          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    248          
    249          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    250          #define _DF1S	0
    251          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    252          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    253          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    254          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    255          
    256          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    257          #define _DF1S	0
    258          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    259          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    260          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    261          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    262          
    263          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    264          #define _DF1S	0
    265          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    266          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    267          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    268          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    269          
    270          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    271          #define _DF1S	0
    272          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    273          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    274          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    275          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    276          
    277          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    278          #define _DF1S	0
    279          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    280          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    281          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    282          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    283          
    284          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    285          #define _DF1S	0
    286          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    287          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    288          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    289          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    290          
    291          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    292          #define _DF1S	0
    293          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    294          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    295          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    296          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    297          
    298          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    299          #define _DF1S	0
    300          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    301          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    302          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    303          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    304          
    305          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    306          #define _DF1S	0
    307          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    308          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    309          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    310          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    311          
    312          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    313          #define _DF1S	0
    314          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    315          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    316          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    317          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    318          
    319          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    320          #define _DF1S	0
    321          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    322          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    323          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    324          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    325          
    326          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    327          #define _DF1S	0
    328          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    329          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    330          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    331          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    332          
    333          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    334          #define _DF1S	0
    335          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    336          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    337          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    338          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    339          
    340          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    341          #if _USE_LFN
    342          #error Cannot use LFN feature without valid code page.
    343          #endif
    344          #define _DF1S	0
    345          
    346          #else
    347          #error Unknown code page
    348          
    349          #endif
    350          
    351          
    352          /* Character code support macros */
    353          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    354          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    355          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    356          
    357          #if _DF1S		/* Code page is DBCS */
    358          
    359          #ifdef _DF2S	/* Two 1st byte areas */
    360          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    361          #else			/* One 1st byte area */
    362          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    363          #endif
    364          
    365          #ifdef _DS3S	/* Three 2nd byte areas */
    366          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    367          #else			/* Two 2nd byte areas */
    368          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    369          #endif
    370          
    371          #else			/* Code page is SBCS */
    372          
    373          #define IsDBCS1(c)	0
    374          #define IsDBCS2(c)	0
    375          
    376          #endif /* _DF1S */
    377          
    378          
    379          /* Name status flags */
    380          #define NS			11		/* Index of name status byte in fn[] */
    381          #define NS_LOSS		0x01	/* Out of 8.3 format */
    382          #define NS_LFN		0x02	/* Force to create LFN entry */
    383          #define NS_LAST		0x04	/* Last segment */
    384          #define NS_BODY		0x08	/* Lower case flag (body) */
    385          #define NS_EXT		0x10	/* Lower case flag (ext) */
    386          #define NS_DOT		0x20	/* Dot entry */
    387          
    388          
    389          /* FAT sub-type boundaries */
    390          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    391          #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
    392          #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
    393          
    394          
    395          /* FatFs refers the members in the FAT structures as byte array instead of
    396          / structure member because the structure is not binary compatible between
    397          / different platforms */
    398          
    399          #define BS_jmpBoot			0	/* Jump instruction (3) */
    400          #define BS_OEMName			3	/* OEM name (8) */
    401          #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
    402          #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
    403          #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
    404          #define BPB_NumFATs			16	/* Number of FAT copies (1) */
    405          #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
    406          #define BPB_TotSec16		19	/* Volume size [sector] (2) */
    407          #define BPB_Media			21	/* Media descriptor (1) */
    408          #define BPB_FATSz16			22	/* FAT size [sector] (2) */
    409          #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
    410          #define BPB_NumHeads		26	/* Number of heads (2) */
    411          #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
    412          #define BPB_TotSec32		32	/* Volume size [sector] (4) */
    413          #define BS_DrvNum			36	/* Physical drive number (2) */
    414          #define BS_BootSig			38	/* Extended boot signature (1) */
    415          #define BS_VolID			39	/* Volume serial number (4) */
    416          #define BS_VolLab			43	/* Volume label (8) */
    417          #define BS_FilSysType		54	/* File system type (1) */
    418          #define BPB_FATSz32			36	/* FAT size [sector] (4) */
    419          #define BPB_ExtFlags		40	/* Extended flags (2) */
    420          #define BPB_FSVer			42	/* File system version (2) */
    421          #define BPB_RootClus		44	/* Root dir first cluster (4) */
    422          #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
    423          #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
    424          #define BS_DrvNum32			64	/* Physical drive number (2) */
    425          #define BS_BootSig32		66	/* Extended boot signature (1) */
    426          #define BS_VolID32			67	/* Volume serial number (4) */
    427          #define BS_VolLab32			71	/* Volume label (8) */
    428          #define BS_FilSysType32		82	/* File system type (1) */
    429          #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
    430          #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
    431          #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
    432          #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
    433          #define MBR_Table			446	/* MBR: Partition table offset (2) */
    434          #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
    435          #define BS_55AA				510	/* Boot sector signature (2) */
    436          
    437          #define	DIR_Name			0	/* Short file name (11) */
    438          #define	DIR_Attr			11	/* Attribute (1) */
    439          #define	DIR_NTres			12	/* NT flag (1) */
    440          #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
    441          #define	DIR_CrtTime			14	/* Created time (2) */
    442          #define	DIR_CrtDate			16	/* Created date (2) */
    443          #define DIR_LstAccDate		18	/* Last accessed date (2) */
    444          #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
    445          #define	DIR_WrtTime			22	/* Modified time (2) */
    446          #define	DIR_WrtDate			24	/* Modified date (2) */
    447          #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
    448          #define	DIR_FileSize		28	/* File size (4) */
    449          #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
    450          #define	LDIR_Attr			11	/* LFN attribute (1) */
    451          #define	LDIR_Type			12	/* LFN type (1) */
    452          #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
    453          #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
    454          #define	SZ_DIR				32		/* Size of a directory entry */
    455          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    456          #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
    457          #define	NDDE				0x05	/* Replacement of the character collides with DDE */
    458          
    459          
    460          /*------------------------------------------------------------*/
    461          /* Module private work area                                   */
    462          /*------------------------------------------------------------*/
    463          /* Note that uninitialized variables with static duration are
    464          /  zeroed/nulled at start-up. If not, the compiler or start-up
    465          /  routine is out of ANSI-C standard.
    466          */
    467          
    468          #if _VOLUMES
    469          static

   \                                 In section .bss, align 4
    470          FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
    471          #else
    472          #error Number of volumes must not be 0.
    473          #endif
    474          
    475          static
    476          WORD Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 4
    477          
    478          #if _FS_RPATH
    479          static
    480          BYTE CurrVol;			/* Current drive */
    481          #endif
    482          
    483          #if _FS_LOCK
    484          static

   \                                 In section .bss, align 4
    485          FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
   \                     Files:
   \   00000000                      DS8 24
    486          #endif
    487          
    488          #if _USE_LFN == 0			/* No LFN feature */
    489          #define	DEF_NAMEBUF			BYTE sfn[12]
    490          #define INIT_BUF(dobj)		(dobj).fn = sfn
    491          #define	FREE_BUF()
    492          
    493          #elif _USE_LFN == 1			/* LFN feature with static working buffer */
    494          static WCHAR LfnBuf[_MAX_LFN+1];
    495          #define	DEF_NAMEBUF			BYTE sfn[12]
    496          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    497          #define	FREE_BUF()
    498          
    499          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    500          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    501          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    502          #define	FREE_BUF()
    503          
    504          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    505          #define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
    506          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    507          							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    508          							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
    509          #define	FREE_BUF()			ff_memfree(lfn)
    510          
    511          #else
    512          #error Wrong LFN configuration.
    513          #endif
    514          
    515          
    516          
    517          
    518          /*--------------------------------------------------------------------------
    519          
    520             Module Private Functions
    521          
    522          ---------------------------------------------------------------------------*/
    523          
    524          
    525          /*-----------------------------------------------------------------------*/
    526          /* String functions                                                      */
    527          /*-----------------------------------------------------------------------*/
    528          
    529          /* Copy memory to memory */

   \                                 In section .text, align 2, keep-with-next
    530          static
    531          void mem_cpy (void* dst, const void* src, UINT cnt) {
    532          	BYTE *d = (BYTE*)dst;
    533          	const BYTE *s = (const BYTE*)src;
   \                     _Z7mem_cpyPvPKvj: (+1)
   \   00000000   0xE003             B.N      ??mem_cpy_0
    534          
    535          #if _WORD_ACCESS == 1
    536          	while (cnt >= sizeof (int)) {
    537          		*(int*)d = *(int*)s;
    538          		d += sizeof (int); s += sizeof (int);
    539          		cnt -= sizeof (int);
    540          	}
    541          #endif
    542          	while (cnt--)
    543          		*d++ = *s++;
   \                     ??mem_cpy_1: (+1)
   \   00000002   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000006   0xF800 0x3B01      STRB     R3,[R0], #+1
   \                     ??mem_cpy_0: (+1)
   \   0000000A   0x4613             MOV      R3,R2
   \   0000000C   0x1E5A             SUBS     R2,R3,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD1F7             BNE.N    ??mem_cpy_1
    544          }
   \   00000012   0x4770             BX       LR               ;; return
    545          
    546          /* Fill memory */

   \                                 In section .text, align 2, keep-with-next
    547          static
    548          void mem_set (void* dst, int val, UINT cnt) {
    549          	BYTE *d = (BYTE*)dst;
   \                     _Z7mem_setPvij: (+1)
   \   00000000   0xE001             B.N      ??mem_set_0
    550          
    551          	while (cnt--)
    552          		*d++ = (BYTE)val;
   \                     ??mem_set_1: (+1)
   \   00000002   0xF800 0x1B01      STRB     R1,[R0], #+1
   \                     ??mem_set_0: (+1)
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0x1E5A             SUBS     R2,R3,#+1
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD1F9             BNE.N    ??mem_set_1
    553          }
   \   0000000E   0x4770             BX       LR               ;; return
    554          
    555          /* Compare memory to memory */

   \                                 In section .text, align 2, keep-with-next
    556          static
    557          int mem_cmp (const void* dst, const void* src, UINT cnt) {
   \                     _Z7mem_cmpPKvS0_j: (+1)
   \   00000000   0xB410             PUSH     {R4}
    558          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    559          	int r = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    560          
    561          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0: (+1)
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x1E62             SUBS     R2,R4,#+1
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD005             BEQ.N    ??mem_cmp_1
   \   0000000C   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   00000010   0xF811 0x4B01      LDRB     R4,[R1], #+1
   \   00000014   0x1B1B             SUBS     R3,R3,R4
   \   00000016   0xD0F5             BEQ.N    ??mem_cmp_0
    562          	return r;
   \                     ??mem_cmp_1: (+1)
   \   00000018   0x4618             MOV      R0,R3
   \   0000001A   0xBC10             POP      {R4}
   \   0000001C   0x4770             BX       LR               ;; return
    563          }
    564          
    565          /* Check if chr is contained in the string */

   \                                 In section .text, align 2, keep-with-next
    566          static
    567          int chk_chr (const char* str, int chr) {
   \                     _Z7chk_chrPKci: (+1)
   \   00000000   0xE000             B.N      ??chk_chr_0
    568          	while (*str && *str != chr) str++;
   \                     ??chk_chr_1: (+1)
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \                     ??chk_chr_0: (+1)
   \   00000004   0x7803             LDRB     R3,[R0, #+0]
   \   00000006   0x001A             MOVS     R2,R3
   \   00000008   0xD001             BEQ.N    ??chk_chr_2
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD1F9             BNE.N    ??chk_chr_1
    569          	return *str;
   \                     ??chk_chr_2: (+1)
   \   0000000E   0x4610             MOV      R0,R2
   \   00000010   0x4770             BX       LR               ;; return
    570          }
    571          
    572          
    573          
    574          /*-----------------------------------------------------------------------*/
    575          /* Request/Release grant to access the volume                            */
    576          /*-----------------------------------------------------------------------*/
    577          #if _FS_REENTRANT
    578          
    579          static
    580          int lock_fs (
    581          	FATFS *fs		/* File system object */
    582          )
    583          {
    584          	return ff_req_grant(fs->sobj);
    585          }
    586          
    587          
    588          static
    589          void unlock_fs (
    590          	FATFS *fs,		/* File system object */
    591          	FRESULT res		/* Result code to be returned */
    592          )
    593          {
    594          	if (fs &&
    595          		res != FR_NOT_ENABLED &&
    596          		res != FR_INVALID_DRIVE &&
    597          		res != FR_INVALID_OBJECT &&
    598          		res != FR_TIMEOUT) {
    599          		ff_rel_grant(fs->sobj);
    600          	}
    601          }
    602          #endif
    603          
    604          
    605          
    606          /*-----------------------------------------------------------------------*/
    607          /* File lock control functions                                           */
    608          /*-----------------------------------------------------------------------*/
    609          #if _FS_LOCK
    610          

   \                                 In section .text, align 2, keep-with-next
    611          static
    612          FRESULT chk_lock (	/* Check if the file can be accessed */
    613          	DIR* dj,		/* Directory object pointing the file to be checked */
    614          	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    615          )
    616          {
   \                     _Z8chk_lockP3DIRi: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    617          	UINT i, be;
    618          
    619          	/* Search file semaphore table */
    620          	for (i = be = 0; i < _FS_LOCK; i++) {
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x461A             MOV      R2,R3
   \   00000006   0xE001             B.N      ??chk_lock_0
    621          		if (Files[i].fs) {	/* Existing entry */
    622          			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
    623          				Files[i].clu == dj->sclust &&
    624          				Files[i].idx == dj->index) break;
    625          		} else {			/* Blank entry */
    626          			be++;
   \                     ??chk_lock_1: (+1)
   \   00000008   0x1C5B             ADDS     R3,R3,#+1
    627          		}
   \                     ??chk_lock_2: (+1)
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \                     ??chk_lock_0: (+1)
   \   0000000C   0x2A02             CMP      R2,#+2
   \   0000000E   0xD213             BCS.N    ??chk_lock_3
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable9
   \   00000014   0xEB02 0x0542      ADD      R5,R2,R2, LSL #+1
   \   00000018   0xEB04 0x0485      ADD      R4,R4,R5, LSL #+2
   \   0000001C   0x6825             LDR      R5,[R4, #+0]
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD0F2             BEQ.N    ??chk_lock_1
   \   00000022   0x6806             LDR      R6,[R0, #+0]
   \   00000024   0x42B5             CMP      R5,R6
   \   00000026   0xD1F0             BNE.N    ??chk_lock_2
   \   00000028   0x6865             LDR      R5,[R4, #+4]
   \   0000002A   0x6886             LDR      R6,[R0, #+8]
   \   0000002C   0x42B5             CMP      R5,R6
   \   0000002E   0xD1EC             BNE.N    ??chk_lock_2
   \   00000030   0x8924             LDRH     R4,[R4, #+8]
   \   00000032   0x88C5             LDRH     R5,[R0, #+6]
   \   00000034   0x42AC             CMP      R4,R5
   \   00000036   0xD1E8             BNE.N    ??chk_lock_2
    628          	}
    629          	if (i == _FS_LOCK)	/* The file is not opened */
   \                     ??chk_lock_3: (+1)
   \   00000038   0x2A02             CMP      R2,#+2
   \   0000003A   0xD107             BNE.N    ??chk_lock_4
    630          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD101             BNE.N    ??chk_lock_5
   \   00000040   0x2902             CMP      R1,#+2
   \   00000042   0xD101             BNE.N    ??chk_lock_6
   \                     ??chk_lock_5: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE010             B.N      ??chk_lock_7
   \                     ??chk_lock_6: (+1)
   \   00000048   0x2012             MOVS     R0,#+18
   \   0000004A   0xE00E             B.N      ??chk_lock_7
    631          
    632          	/* The file has been opened. Reject any open against writing file and all write mode open */
    633          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
   \                     ??chk_lock_4: (+1)
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD109             BNE.N    ??chk_lock_8
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable9
   \   00000054   0xEB02 0x0142      ADD      R1,R2,R2, LSL #+1
   \   00000058   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   0000005C   0x8940             LDRH     R0,[R0, #+10]
   \   0000005E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000062   0xD101             BNE.N    ??chk_lock_9
   \                     ??chk_lock_8: (+1)
   \   00000064   0x2010             MOVS     R0,#+16
   \   00000066   0xE000             B.N      ??chk_lock_7
   \                     ??chk_lock_9: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \                     ??chk_lock_7: (+1)
   \   0000006A   0xBC70             POP      {R4-R6}
   \   0000006C   0x4770             BX       LR               ;; return
    634          }
    635          
    636          

   \                                 In section .text, align 2, keep-with-next
    637          static
    638          int enq_lock (void)	/* Check if an entry is available for a new file */
    639          {
    640          	UINT i;
    641          
    642          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
   \                     _Z8enq_lockv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??enq_lock_0
   \                     ??enq_lock_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??enq_lock_0: (+1)
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD207             BCS.N    ??enq_lock_2
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable9
   \   0000000E   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   00000012   0x0092             LSLS     R2,R2,#+2
   \   00000014   0x5851             LDR      R1,[R2, R1]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD1F4             BNE.N    ??enq_lock_1
    643          	return (i == _FS_LOCK) ? 0 : 1;
   \                     ??enq_lock_2: (+1)
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD101             BNE.N    ??enq_lock_3
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4770             BX       LR
   \                     ??enq_lock_3: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x4770             BX       LR               ;; return
    644          }
    645          
    646          

   \                                 In section .text, align 2, keep-with-next
    647          static
    648          UINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
    649          	DIR* dj,	/* Directory object pointing the file to register or increment */
    650          	int acc		/* Desired access mode (0:Read, !0:Write) */
    651          )
    652          {
   \                     _Z8inc_lockP3DIRi: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    653          	UINT i;
    654          
    655          
    656          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x230C             MOVS     R3,#+12
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable9
   \   0000000A   0xE000             B.N      ??inc_lock_0
   \                     ??inc_lock_1: (+1)
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \                     ??inc_lock_0: (+1)
   \   0000000E   0x2A02             CMP      R2,#+2
   \   00000010   0xD20D             BCS.N    ??inc_lock_2
    657          		if (Files[i].fs == dj->fs &&
    658          			Files[i].clu == dj->sclust &&
    659          			Files[i].idx == dj->index) break;
   \   00000012   0xFB03 0x4502      MLA      R5,R3,R2,R4
   \   00000016   0x682E             LDR      R6,[R5, #+0]
   \   00000018   0x6807             LDR      R7,[R0, #+0]
   \   0000001A   0x42BE             CMP      R6,R7
   \   0000001C   0xD1F6             BNE.N    ??inc_lock_1
   \   0000001E   0x686E             LDR      R6,[R5, #+4]
   \   00000020   0x6887             LDR      R7,[R0, #+8]
   \   00000022   0x42BE             CMP      R6,R7
   \   00000024   0xD1F2             BNE.N    ??inc_lock_1
   \   00000026   0x892D             LDRH     R5,[R5, #+8]
   \   00000028   0x88C6             LDRH     R6,[R0, #+6]
   \   0000002A   0x42B5             CMP      R5,R6
   \   0000002C   0xD1EE             BNE.N    ??inc_lock_1
    660          	}
    661          
    662          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
   \                     ??inc_lock_2: (+1)
   \   0000002E   0x2A02             CMP      R2,#+2
   \   00000030   0xD115             BNE.N    ??inc_lock_3
    663          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0xE000             B.N      ??inc_lock_4
   \                     ??inc_lock_5: (+1)
   \   00000036   0x1C52             ADDS     R2,R2,#+1
   \                     ??inc_lock_4: (+1)
   \   00000038   0x2A02             CMP      R2,#+2
   \   0000003A   0xD204             BCS.N    ??inc_lock_6
   \   0000003C   0xFB03 0x4502      MLA      R5,R3,R2,R4
   \   00000040   0x682D             LDR      R5,[R5, #+0]
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD1F7             BNE.N    ??inc_lock_5
    664          		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
   \                     ??inc_lock_6: (+1)
   \   00000046   0x2A02             CMP      R2,#+2
   \   00000048   0xD010             BEQ.N    ??inc_lock_7
    665          		Files[i].fs = dj->fs;
   \   0000004A   0xFB03 0x4502      MLA      R5,R3,R2,R4
   \   0000004E   0x6806             LDR      R6,[R0, #+0]
   \   00000050   0x602E             STR      R6,[R5, #+0]
    666          		Files[i].clu = dj->sclust;
   \   00000052   0x6886             LDR      R6,[R0, #+8]
   \   00000054   0x606E             STR      R6,[R5, #+4]
    667          		Files[i].idx = dj->index;
   \   00000056   0x88C0             LDRH     R0,[R0, #+6]
   \   00000058   0x8128             STRH     R0,[R5, #+8]
    668          		Files[i].ctr = 0;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x8168             STRH     R0,[R5, #+10]
    669          	}
    670          
    671          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
   \                     ??inc_lock_3: (+1)
   \   0000005E   0xFB03 0x4002      MLA      R0,R3,R2,R4
   \   00000062   0x2900             CMP      R1,#+0
   \   00000064   0xD004             BEQ.N    ??inc_lock_8
   \   00000066   0x8943             LDRH     R3,[R0, #+10]
   \   00000068   0x2B00             CMP      R3,#+0
   \   0000006A   0xD001             BEQ.N    ??inc_lock_8
   \                     ??inc_lock_7: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE008             B.N      ??inc_lock_9
    672          
    673          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
   \                     ??inc_lock_8: (+1)
   \   00000070   0x2900             CMP      R1,#+0
   \   00000072   0xD002             BEQ.N    ??inc_lock_10
   \   00000074   0xF44F 0x7180      MOV      R1,#+256
   \   00000078   0xE001             B.N      ??inc_lock_11
   \                     ??inc_lock_10: (+1)
   \   0000007A   0x8941             LDRH     R1,[R0, #+10]
   \   0000007C   0x1C49             ADDS     R1,R1,#+1
   \                     ??inc_lock_11: (+1)
   \   0000007E   0x8141             STRH     R1,[R0, #+10]
    674          
    675          	return i + 1;
   \   00000080   0x1C50             ADDS     R0,R2,#+1
   \                     ??inc_lock_9: (+1)
   \   00000082   0xBCF0             POP      {R4-R7}
   \   00000084   0x4770             BX       LR               ;; return
    676          }
    677          
    678          

   \                                 In section .text, align 2, keep-with-next
    679          static
    680          FRESULT dec_lock (	/* Decrement file open counter */
    681          	UINT i			/* Semaphore index */
    682          )
    683          {
    684          	WORD n;
    685          	FRESULT res;
    686          
    687          
    688          	if (--i < _FS_LOCK) {
   \                     _Z8dec_lockj: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
   \   00000002   0x2802             CMP      R0,#+2
   \   00000004   0xD215             BCS.N    ??dec_lock_0
    689          		n = Files[i].ctr;
   \   00000006   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000000A   0x0088             LSLS     R0,R1,#+2
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable9
   \   00000010   0x1842             ADDS     R2,R0,R1
   \   00000012   0x8953             LDRH     R3,[R2, #+10]
    690          		if (n == 0x100) n = 0;
   \   00000014   0xF5B3 0x7F80      CMP      R3,#+256
   \   00000018   0xD100             BNE.N    ??dec_lock_1
   \   0000001A   0x2300             MOVS     R3,#+0
    691          		if (n) n--;
   \                     ??dec_lock_1: (+1)
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD000             BEQ.N    ??dec_lock_2
   \   00000020   0x1E5B             SUBS     R3,R3,#+1
    692          		Files[i].ctr = n;
   \                     ??dec_lock_2: (+1)
   \   00000022   0x8153             STRH     R3,[R2, #+10]
    693          		if (!n) Files[i].fs = 0;
   \   00000024   0xB29B             UXTH     R3,R3
   \   00000026   0x2B00             CMP      R3,#+0
   \   00000028   0xD101             BNE.N    ??dec_lock_3
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x5042             STR      R2,[R0, R1]
    694          		res = FR_OK;
   \                     ??dec_lock_3: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4770             BX       LR
    695          	} else {
    696          		res = FR_INT_ERR;
   \                     ??dec_lock_0: (+1)
   \   00000032   0x2002             MOVS     R0,#+2
    697          	}
    698          	return res;
   \   00000034   0x4770             BX       LR               ;; return
    699          }
    700          
    701          

   \                                 In section .text, align 2, keep-with-next
    702          static
    703          void clear_lock (	/* Clear lock entries of the volume */
    704          	FATFS *fs
    705          )
    706          {
   \                     _Z10clear_lockP5FATFS: (+1)
   \   00000000   0xB410             PUSH     {R4}
    707          	UINT i;
    708          
    709          	for (i = 0; i < _FS_LOCK; i++) {
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      LDR.W    R3,??DataTable9
   \   00000008   0xE008             B.N      ??clear_lock_0
    710          		if (Files[i].fs == fs) Files[i].fs = 0;
   \                     ??clear_lock_1: (+1)
   \   0000000A   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   0000000E   0x0092             LSLS     R2,R2,#+2
   \   00000010   0x58D4             LDR      R4,[R2, R3]
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD101             BNE.N    ??clear_lock_2
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0x50D4             STR      R4,[R2, R3]
    711          	}
   \                     ??clear_lock_2: (+1)
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \                     ??clear_lock_0: (+1)
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD3F4             BCC.N    ??clear_lock_1
    712          }
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    713          #endif
    714          
    715          
    716          
    717          /*-----------------------------------------------------------------------*/
    718          /* Change window offset                                                  */
    719          /*-----------------------------------------------------------------------*/
    720          

   \                                 In section .text, align 2, keep-with-next
    721          static
    722          FRESULT move_window (
    723          	FATFS *fs,		/* File system object */
    724          	DWORD sector	/* Sector number to make appearance in the fs->win[] */
    725          )					/* Move to zero only writes back dirty window */
    726          {
   \                     _Z11move_windowP5FATFSm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    727          	DWORD wsect;
    728          
    729          
    730          	wsect = fs->winsect;
   \   00000006   0x6AE6             LDR      R6,[R4, #+44]
    731          	if (wsect != sector) {	/* Changed current window */
   \   00000008   0x42AE             CMP      R6,R5
   \   0000000A   0xD02F             BEQ.N    ??move_window_0
    732          #if !_FS_READONLY
    733          		if (fs->wflag) {	/* Write back dirty window if needed */
   \   0000000C   0x7920             LDRB     R0,[R4, #+4]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD01E             BEQ.N    ??move_window_1
    734          			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
   \   00000012   0x2301             MOVS     R3,#+1
   \   00000014   0x4632             MOV      R2,R6
   \   00000016   0xF104 0x0130      ADD      R1,R4,#+48
   \   0000001A   0x7860             LDRB     R0,[R4, #+1]
   \   0000001C   0x.... 0x....      BL       disk_write
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD120             BNE.N    ??move_window_2
    735          				return FR_DISK_ERR;
    736          			fs->wflag = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7120             STRB     R0,[R4, #+4]
    737          			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
   \   00000028   0x6A20             LDR      R0,[R4, #+32]
   \   0000002A   0x69E1             LDR      R1,[R4, #+28]
   \   0000002C   0x1808             ADDS     R0,R1,R0
   \   0000002E   0x4286             CMP      R6,R0
   \   00000030   0xD20E             BCS.N    ??move_window_1
    738          				BYTE nf;
    739          				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
   \   00000032   0x78E7             LDRB     R7,[R4, #+3]
   \   00000034   0xE009             B.N      ??move_window_3
    740          					wsect += fs->fsize;
   \                     ??move_window_4: (+1)
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x1986             ADDS     R6,R0,R6
    741          					disk_write(fs->drv, fs->win, wsect, 1);
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0x4632             MOV      R2,R6
   \   0000003E   0xF104 0x0130      ADD      R1,R4,#+48
   \   00000042   0x7860             LDRB     R0,[R4, #+1]
   \   00000044   0x.... 0x....      BL       disk_write
    742          				}
   \   00000048   0x1E7F             SUBS     R7,R7,#+1
   \                     ??move_window_3: (+1)
   \   0000004A   0xB2FF             UXTB     R7,R7
   \   0000004C   0x2F02             CMP      R7,#+2
   \   0000004E   0xDAF2             BGE.N    ??move_window_4
    743          			}
    744          		}
    745          #endif
    746          		if (sector) {
   \                     ??move_window_1: (+1)
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD00B             BEQ.N    ??move_window_0
    747          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   \   00000054   0x2301             MOVS     R3,#+1
   \   00000056   0x462A             MOV      R2,R5
   \   00000058   0xF104 0x0130      ADD      R1,R4,#+48
   \   0000005C   0x7860             LDRB     R0,[R4, #+1]
   \   0000005E   0x.... 0x....      BL       disk_read
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD001             BEQ.N    ??move_window_5
    748          				return FR_DISK_ERR;
   \                     ??move_window_2: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}
    749          			fs->winsect = sector;
   \                     ??move_window_5: (+1)
   \   0000006A   0x62E5             STR      R5,[R4, #+44]
    750          		}
    751          	}
    752          
    753          	return FR_OK;
   \                     ??move_window_0: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    754          }
    755          
    756          
    757          
    758          
    759          /*-----------------------------------------------------------------------*/
    760          /* Clean-up cached data                                                  */
    761          /*-----------------------------------------------------------------------*/
    762          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    763          static
    764          FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
    765          	FATFS *fs	/* File system object */
    766          )
    767          {
   \                     _Z4syncP5FATFS: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    768          	FRESULT res;
    769          
    770          
    771          	res = move_window(fs, 0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000000A   0x0005             MOVS     R5,R0
    772          	if (res == FR_OK) {
   \   0000000C   0xD14B             BNE.N    ??sync_0
    773          		/* Update FSInfo sector if needed */
    774          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD140             BNE.N    ??sync_1
   \   00000014   0x7960             LDRB     R0,[R4, #+5]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD03D             BEQ.N    ??sync_1
    775          			fs->winsect = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x62E0             STR      R0,[R4, #+44]
    776          			/* Create FSInfo structure */
    777          			mem_set(fs->win, 0, 512);
   \   0000001E   0xF104 0x0630      ADD      R6,R4,#+48
   \   00000022   0xF44F 0x7200      MOV      R2,#+512
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       _Z7mem_setPvij
    778          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   0000002E   0xF504 0x7005      ADD      R0,R4,#+532
   \   00000032   0x2155             MOVS     R1,#+85
   \   00000034   0x7681             STRB     R1,[R0, #+26]
   \   00000036   0x21AA             MOVS     R1,#+170
   \   00000038   0x76C1             STRB     R1,[R0, #+27]
    779          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   0000003A   0x2152             MOVS     R1,#+82
   \   0000003C   0x7031             STRB     R1,[R6, #+0]
   \   0000003E   0x7071             STRB     R1,[R6, #+1]
   \   00000040   0x2161             MOVS     R1,#+97
   \   00000042   0x70B1             STRB     R1,[R6, #+2]
   \   00000044   0x2141             MOVS     R1,#+65
   \   00000046   0x70F1             STRB     R1,[R6, #+3]
    780          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   00000048   0x2172             MOVS     R1,#+114
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
   \   0000004C   0x7041             STRB     R1,[R0, #+1]
   \   0000004E   0x2141             MOVS     R1,#+65
   \   00000050   0x7081             STRB     R1,[R0, #+2]
   \   00000052   0x2161             MOVS     R1,#+97
   \   00000054   0x70C1             STRB     R1,[R0, #+3]
    781          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   00000056   0x6921             LDR      R1,[R4, #+16]
   \   00000058   0x7101             STRB     R1,[R0, #+4]
   \   0000005A   0x6921             LDR      R1,[R4, #+16]
   \   0000005C   0xB289             UXTH     R1,R1
   \   0000005E   0x0A09             LSRS     R1,R1,#+8
   \   00000060   0x7141             STRB     R1,[R0, #+5]
   \   00000062   0x6921             LDR      R1,[R4, #+16]
   \   00000064   0x0C09             LSRS     R1,R1,#+16
   \   00000066   0x7181             STRB     R1,[R0, #+6]
   \   00000068   0x6921             LDR      R1,[R4, #+16]
   \   0000006A   0x0E09             LSRS     R1,R1,#+24
   \   0000006C   0x71C1             STRB     R1,[R0, #+7]
    782          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   0000006E   0x68E1             LDR      R1,[R4, #+12]
   \   00000070   0x7201             STRB     R1,[R0, #+8]
   \   00000072   0x68E1             LDR      R1,[R4, #+12]
   \   00000074   0xB289             UXTH     R1,R1
   \   00000076   0x0A09             LSRS     R1,R1,#+8
   \   00000078   0x7241             STRB     R1,[R0, #+9]
   \   0000007A   0x68E1             LDR      R1,[R4, #+12]
   \   0000007C   0x0C09             LSRS     R1,R1,#+16
   \   0000007E   0x7281             STRB     R1,[R0, #+10]
   \   00000080   0x68E1             LDR      R1,[R4, #+12]
   \   00000082   0x0E09             LSRS     R1,R1,#+24
   \   00000084   0x72C1             STRB     R1,[R0, #+11]
    783          			/* Write it into the FSInfo sector */
    784          			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   00000086   0x2301             MOVS     R3,#+1
   \   00000088   0x6962             LDR      R2,[R4, #+20]
   \   0000008A   0x4631             MOV      R1,R6
   \   0000008C   0x7860             LDRB     R0,[R4, #+1]
   \   0000008E   0x.... 0x....      BL       disk_write
    785          			fs->fsi_flag = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x7160             STRB     R0,[R4, #+5]
    786          		}
    787          		/* Make sure that no pending write process in the physical drive */
    788          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_1: (+1)
   \   00000096   0x2200             MOVS     R2,#+0
   \   00000098   0x4611             MOV      R1,R2
   \   0000009A   0x7860             LDRB     R0,[R4, #+1]
   \   0000009C   0x.... 0x....      BL       disk_ioctl
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD000             BEQ.N    ??sync_0
    789          			res = FR_DISK_ERR;
   \   000000A4   0x2501             MOVS     R5,#+1
    790          	}
    791          
    792          	return res;
   \                     ??sync_0: (+1)
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0xBD70             POP      {R4-R6,PC}       ;; return
    793          }
    794          #endif
    795          
    796          
    797          
    798          
    799          /*-----------------------------------------------------------------------*/
    800          /* Get sector# from cluster#                                             */
    801          /*-----------------------------------------------------------------------*/
    802          
    803          

   \                                 In section .text, align 2, keep-with-next
    804          DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
    805          	FATFS *fs,		/* File system object */
    806          	DWORD clst		/* Cluster# to be converted */
    807          )
    808          {
    809          	clst -= 2;
   \                     clust2sect: (+1)
   \   00000000   0x1E89             SUBS     R1,R1,#+2
    810          	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   \   00000002   0x6982             LDR      R2,[R0, #+24]
   \   00000004   0x1E92             SUBS     R2,R2,#+2
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD301             BCC.N    ??clust2sect_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    811          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0: (+1)
   \   0000000E   0x7882             LDRB     R2,[R0, #+2]
   \   00000010   0x6A80             LDR      R0,[R0, #+40]
   \   00000012   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000016   0x4770             BX       LR               ;; return
    812          }
    813          
    814          
    815          
    816          
    817          /*-----------------------------------------------------------------------*/
    818          /* FAT access - Read value of a FAT entry                                */
    819          /*-----------------------------------------------------------------------*/
    820          
    821          

   \                                 In section .text, align 2, keep-with-next
    822          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
    823          	FATFS *fs,	/* File system object */
    824          	DWORD clst	/* Cluster# to get the link information */
    825          )
    826          {
   \                     _Z7get_fatP5FATFSm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    827          	UINT wc, bc;
    828          	BYTE *p;
    829          
    830          
    831          	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD302             BCC.N    ??get_fat_0
   \   0000000A   0x69A0             LDR      R0,[R4, #+24]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD301             BCC.N    ??get_fat_1
    832          		return 1;
   \                     ??get_fat_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xBDF2             POP      {R1,R4-R7,PC}
    833          
    834          	switch (fs->fs_type) {
   \                     ??get_fat_1: (+1)
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ.N    ??get_fat_2
   \   0000001A   0xD355             BCC.N    ??get_fat_3
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD039             BEQ.N    ??get_fat_4
   \   00000020   0xD326             BCC.N    ??get_fat_5
   \   00000022   0xE051             B.N      ??get_fat_3
    835          	case FS_FAT12 :
    836          		bc = (UINT)clst; bc += bc / 2;
   \                     ??get_fat_2: (+1)
   \   00000024   0xEB05 0x0755      ADD      R7,R5,R5, LSR #+1
    837          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   00000028   0x6A20             LDR      R0,[R4, #+32]
   \   0000002A   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD147             BNE.N    ??get_fat_3
    838          		wc = fs->win[bc % SS(fs)]; bc++;
   \   00000038   0x05F8             LSLS     R0,R7,#+23
   \   0000003A   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   0000003E   0xF890 0x6030      LDRB     R6,[R0, #+48]
   \   00000042   0x1C7F             ADDS     R7,R7,#+1
    839          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   00000044   0x6A20             LDR      R0,[R4, #+32]
   \   00000046   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD139             BNE.N    ??get_fat_3
    840          		wc |= fs->win[bc % SS(fs)] << 8;
   \   00000054   0x05F8             LSLS     R0,R7,#+23
   \   00000056   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   0000005A   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   0000005E   0xEA46 0x2600      ORR      R6,R6,R0, LSL #+8
    841          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   \   00000062   0x07E8             LSLS     R0,R5,#+31
   \   00000064   0xD501             BPL.N    ??get_fat_6
   \   00000066   0x0930             LSRS     R0,R6,#+4
   \   00000068   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??get_fat_6: (+1)
   \   0000006A   0x0530             LSLS     R0,R6,#+20
   \   0000006C   0x0D00             LSRS     R0,R0,#+20
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}
    842          
    843          	case FS_FAT16 :
    844          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   \                     ??get_fat_5: (+1)
   \   00000070   0x6A20             LDR      R0,[R4, #+32]
   \   00000072   0xEB00 0x2115      ADD      R1,R0,R5, LSR #+8
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD123             BNE.N    ??get_fat_3
    845          		p = &fs->win[clst * 2 % SS(fs)];
   \   00000080   0x0068             LSLS     R0,R5,#+1
   \   00000082   0x05C0             LSLS     R0,R0,#+23
   \   00000084   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   00000088   0x3030             ADDS     R0,R0,#+48
    846          		return LD_WORD(p);
   \   0000008A   0x7841             LDRB     R1,[R0, #+1]
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000092   0xBDF2             POP      {R1,R4-R7,PC}
    847          
    848          	case FS_FAT32 :
    849          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   \                     ??get_fat_4: (+1)
   \   00000094   0x6A20             LDR      R0,[R4, #+32]
   \   00000096   0xEB00 0x11D5      ADD      R1,R0,R5, LSR #+7
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD111             BNE.N    ??get_fat_3
    850          		p = &fs->win[clst * 4 % SS(fs)];
   \   000000A4   0x00A8             LSLS     R0,R5,#+2
   \   000000A6   0x05C0             LSLS     R0,R0,#+23
   \   000000A8   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   000000AC   0x3030             ADDS     R0,R0,#+48
    851          		return LD_DWORD(p) & 0x0FFFFFFF;
   \   000000AE   0x78C1             LDRB     R1,[R0, #+3]
   \   000000B0   0x7882             LDRB     R2,[R0, #+2]
   \   000000B2   0x0412             LSLS     R2,R2,#+16
   \   000000B4   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   000000B8   0x7842             LDRB     R2,[R0, #+1]
   \   000000BA   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x4308             ORRS     R0,R0,R1
   \   000000C2   0x0100             LSLS     R0,R0,#+4
   \   000000C4   0x0900             LSRS     R0,R0,#+4
   \   000000C6   0xBDF2             POP      {R1,R4-R7,PC}
    852          	}
    853          
    854          	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   \                     ??get_fat_3: (+1)
   \   000000C8   0xF04F 0x30FF      MOV      R0,#-1
   \   000000CC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    855          }
    856          
    857          
    858          
    859          
    860          /*-----------------------------------------------------------------------*/
    861          /* FAT access - Change value of a FAT entry                              */
    862          /*-----------------------------------------------------------------------*/
    863          #if !_FS_READONLY
    864          

   \                                 In section .text, align 2, keep-with-next
    865          FRESULT put_fat (
    866          	FATFS *fs,	/* File system object */
    867          	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
    868          	DWORD val	/* New value to mark the cluster */
    869          )
    870          {
   \                     _Z7put_fatP5FATFSmm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
    871          	UINT bc;
    872          	BYTE *p;
    873          	FRESULT res;
    874          
    875          
    876          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2E02             CMP      R6,#+2
   \   0000000A   0xD302             BCC.N    ??put_fat_0
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD301             BCC.N    ??put_fat_1
    877          		res = FR_INT_ERR;
   \                     ??put_fat_0: (+1)
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0xBDF2             POP      {R1,R4-R7,PC}
    878          
    879          	} else {
    880          		switch (fs->fs_type) {
   \                     ??put_fat_1: (+1)
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ.N    ??put_fat_2
   \   0000001C   0xD367             BCC.N    ??put_fat_3
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD049             BEQ.N    ??put_fat_4
   \   00000022   0xD336             BCC.N    ??put_fat_5
   \   00000024   0xE063             B.N      ??put_fat_3
    881          		case FS_FAT12 :
    882          			bc = (UINT)clst; bc += bc / 2;
   \                     ??put_fat_2: (+1)
   \   00000026   0xEB06 0x0756      ADD      R7,R6,R6, LSR #+1
    883          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000002A   0x6A20             LDR      R0,[R4, #+32]
   \   0000002C   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       _Z11move_windowP5FATFSm
    884          			if (res != FR_OK) break;
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD15A             BNE.N    ??put_fat_6
    885          			p = &fs->win[bc % SS(fs)];
   \   0000003A   0x05F8             LSLS     R0,R7,#+23
   \   0000003C   0xEB14 0x50D0      ADDS     R0,R4,R0, LSR #+23
   \   00000040   0xF100 0x0130      ADD      R1,R0,#+48
    886          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   \   00000044   0xF016 0x0601      ANDS     R6,R6,#0x1
   \   00000048   0xD005             BEQ.N    ??put_fat_7
   \   0000004A   0x7808             LDRB     R0,[R1, #+0]
   \   0000004C   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000050   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \   00000054   0xE000             B.N      ??put_fat_8
   \                     ??put_fat_7: (+1)
   \   00000056   0x4628             MOV      R0,R5
   \                     ??put_fat_8: (+1)
   \   00000058   0x7008             STRB     R0,[R1, #+0]
    887          			bc++;
   \   0000005A   0x1C7F             ADDS     R7,R7,#+1
    888          			fs->wflag = 1;
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x7120             STRB     R0,[R4, #+4]
    889          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00000060   0x6A20             LDR      R0,[R4, #+32]
   \   00000062   0xEB00 0x2157      ADD      R1,R0,R7, LSR #+9
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       _Z11move_windowP5FATFSm
    890          			if (res != FR_OK) break;
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD13F             BNE.N    ??put_fat_6
    891          			p = &fs->win[bc % SS(fs)];
   \   00000070   0x05F9             LSLS     R1,R7,#+23
   \   00000072   0xEB14 0x51D1      ADDS     R1,R4,R1, LSR #+23
   \   00000076   0x3130             ADDS     R1,R1,#+48
    892          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD001             BEQ.N    ??put_fat_9
   \   0000007C   0x092A             LSRS     R2,R5,#+4
   \   0000007E   0xE006             B.N      ??put_fat_10
   \                     ??put_fat_9: (+1)
   \   00000080   0x780A             LDRB     R2,[R1, #+0]
   \   00000082   0xF002 0x02F0      AND      R2,R2,#0xF0
   \   00000086   0x0A2B             LSRS     R3,R5,#+8
   \   00000088   0xF003 0x030F      AND      R3,R3,#0xF
   \   0000008C   0x431A             ORRS     R2,R3,R2
   \                     ??put_fat_10: (+1)
   \   0000008E   0x700A             STRB     R2,[R1, #+0]
    893          			break;
   \   00000090   0xE02E             B.N      ??put_fat_6
    894          
    895          		case FS_FAT16 :
    896          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_5: (+1)
   \   00000092   0x6A20             LDR      R0,[R4, #+32]
   \   00000094   0xEB00 0x2116      ADD      R1,R0,R6, LSR #+8
   \   00000098   0x4620             MOV      R0,R4
   \   0000009A   0x.... 0x....      BL       _Z11move_windowP5FATFSm
    897          			if (res != FR_OK) break;
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD126             BNE.N    ??put_fat_6
    898          			p = &fs->win[clst * 2 % SS(fs)];
   \   000000A2   0x0071             LSLS     R1,R6,#+1
   \   000000A4   0x05C9             LSLS     R1,R1,#+23
   \   000000A6   0xEB14 0x51D1      ADDS     R1,R4,R1, LSR #+23
   \   000000AA   0x3130             ADDS     R1,R1,#+48
    899          			ST_WORD(p, (WORD)val);
   \   000000AC   0x700D             STRB     R5,[R1, #+0]
   \   000000AE   0xB2AD             UXTH     R5,R5
   \   000000B0   0x0A2A             LSRS     R2,R5,#+8
   \   000000B2   0x704A             STRB     R2,[R1, #+1]
    900          			break;
   \   000000B4   0xE01C             B.N      ??put_fat_6
    901          
    902          		case FS_FAT32 :
    903          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_4: (+1)
   \   000000B6   0x6A20             LDR      R0,[R4, #+32]
   \   000000B8   0xEB00 0x11D6      ADD      R1,R0,R6, LSR #+7
   \   000000BC   0x4620             MOV      R0,R4
   \   000000BE   0x.... 0x....      BL       _Z11move_windowP5FATFSm
    904          			if (res != FR_OK) break;
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD114             BNE.N    ??put_fat_6
    905          			p = &fs->win[clst * 4 % SS(fs)];
   \   000000C6   0x00B1             LSLS     R1,R6,#+2
   \   000000C8   0x05C9             LSLS     R1,R1,#+23
   \   000000CA   0xEB14 0x51D1      ADDS     R1,R4,R1, LSR #+23
   \   000000CE   0x3130             ADDS     R1,R1,#+48
    906          			val |= LD_DWORD(p) & 0xF0000000;
   \   000000D0   0x78CA             LDRB     R2,[R1, #+3]
   \   000000D2   0x0612             LSLS     R2,R2,#+24
   \   000000D4   0xF002 0x4270      AND      R2,R2,#0xF0000000
   \   000000D8   0x4315             ORRS     R5,R2,R5
    907          			ST_DWORD(p, val);
   \   000000DA   0x700D             STRB     R5,[R1, #+0]
   \   000000DC   0x462A             MOV      R2,R5
   \   000000DE   0xB292             UXTH     R2,R2
   \   000000E0   0x0A12             LSRS     R2,R2,#+8
   \   000000E2   0x704A             STRB     R2,[R1, #+1]
   \   000000E4   0x0C2A             LSRS     R2,R5,#+16
   \   000000E6   0x708A             STRB     R2,[R1, #+2]
   \   000000E8   0x0E2A             LSRS     R2,R5,#+24
   \   000000EA   0x70CA             STRB     R2,[R1, #+3]
    908          			break;
   \   000000EC   0xE000             B.N      ??put_fat_6
    909          
    910          		default :
    911          			res = FR_INT_ERR;
   \                     ??put_fat_3: (+1)
   \   000000EE   0x2002             MOVS     R0,#+2
    912          		}
    913          		fs->wflag = 1;
   \                     ??put_fat_6: (+1)
   \   000000F0   0x2101             MOVS     R1,#+1
   \   000000F2   0x7121             STRB     R1,[R4, #+4]
    914          	}
    915          
    916          	return res;
   \   000000F4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    917          }
    918          #endif /* !_FS_READONLY */
    919          
    920          
    921          
    922          
    923          /*-----------------------------------------------------------------------*/
    924          /* FAT handling - Remove a cluster chain                                 */
    925          /*-----------------------------------------------------------------------*/
    926          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    927          static
    928          FRESULT remove_chain (
    929          	FATFS *fs,			/* File system object */
    930          	DWORD clst			/* Cluster# to remove a chain from */
    931          )
    932          {
   \                     _Z12remove_chainP5FATFSm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    933          	FRESULT res;
    934          	DWORD nxt;
    935          #if _USE_ERASE
    936          	DWORD scl = clst, ecl = clst, rt[2];
    937          #endif
    938          
    939          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD318             BCC.N    ??remove_chain_0
   \   0000000A   0x69A0             LDR      R0,[R4, #+24]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD215             BCS.N    ??remove_chain_0
    940          		res = FR_INT_ERR;
    941          
    942          	} else {
    943          		res = FR_OK;
   \   00000010   0x2600             MOVS     R6,#+0
   \   00000012   0xE008             B.N      ??remove_chain_1
    944          		while (clst < fs->n_fatent) {			/* Not a last link? */
    945          			nxt = get_fat(fs, clst);			/* Get cluster status */
    946          			if (nxt == 0) break;				/* Empty cluster? */
    947          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
    948          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
    949          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
    950          			if (res != FR_OK) break;
    951          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \                     ??remove_chain_2: (+1)
   \   00000014   0x6920             LDR      R0,[R4, #+16]
   \   00000016   0xF110 0x0F01      CMN      R0,#+1
   \   0000001A   0xD003             BEQ.N    ??remove_chain_3
    952          				fs->free_clust++;
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x6120             STR      R0,[R4, #+16]
    953          				fs->fsi_flag = 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7160             STRB     R0,[R4, #+5]
    954          			}
    955          #if _USE_ERASE
    956          			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
    957          				ecl = nxt;
    958          			} else {				/* End of contiguous clusters */
    959          				rt[0] = clust2sect(fs, scl);					/* Start sector */
    960          				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
    961          				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
    962          				scl = ecl = nxt;
    963          			}
    964          #endif
    965          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_3: (+1)
   \   00000024   0x463D             MOV      R5,R7
   \                     ??remove_chain_1: (+1)
   \   00000026   0x69A0             LDR      R0,[R4, #+24]
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD215             BCS.N    ??remove_chain_4
   \   0000002C   0x4629             MOV      R1,R5
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   00000034   0x0007             MOVS     R7,R0
   \   00000036   0xD00F             BEQ.N    ??remove_chain_4
   \   00000038   0x2F01             CMP      R7,#+1
   \   0000003A   0xD101             BNE.N    ??remove_chain_5
   \                     ??remove_chain_0: (+1)
   \   0000003C   0x2602             MOVS     R6,#+2
   \   0000003E   0xE00B             B.N      ??remove_chain_4
   \                     ??remove_chain_5: (+1)
   \   00000040   0xF117 0x0F01      CMN      R7,#+1
   \   00000044   0xD101             BNE.N    ??remove_chain_6
   \   00000046   0x2601             MOVS     R6,#+1
   \   00000048   0xE006             B.N      ??remove_chain_4
   \                     ??remove_chain_6: (+1)
   \   0000004A   0x2200             MOVS     R2,#+0
   \   0000004C   0x4629             MOV      R1,R5
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   \   00000054   0x0006             MOVS     R6,R0
   \   00000056   0xD0DD             BEQ.N    ??remove_chain_2
    966          		}
    967          	}
    968          
    969          	return res;
   \                     ??remove_chain_4: (+1)
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    970          }
    971          #endif
    972          
    973          
    974          
    975          
    976          /*-----------------------------------------------------------------------*/
    977          /* FAT handling - Stretch or Create a cluster chain                      */
    978          /*-----------------------------------------------------------------------*/
    979          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
    980          static
    981          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
    982          	FATFS *fs,			/* File system object */
    983          	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
    984          )
    985          {
   \                     _Z12create_chainP5FATFSm: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    986          	DWORD cs, ncl, scl;
    987          	FRESULT res;
    988          
    989          
    990          	if (clst == 0) {		/* Create a new chain */
   \   00000006   0xD107             BNE.N    ??create_chain_0
    991          		scl = fs->last_clust;			/* Get suggested start point */
   \   00000008   0x68E7             LDR      R7,[R4, #+12]
    992          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000A   0x2F00             CMP      R7,#+0
   \   0000000C   0xD002             BEQ.N    ??create_chain_1
   \   0000000E   0x69A0             LDR      R0,[R4, #+24]
   \   00000010   0x4287             CMP      R7,R0
   \   00000012   0xD30B             BCC.N    ??create_chain_2
   \                     ??create_chain_1: (+1)
   \   00000014   0x2701             MOVS     R7,#+1
   \   00000016   0xE009             B.N      ??create_chain_2
    993          	}
    994          	else {					/* Stretch the current chain */
    995          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0: (+1)
   \   00000018   0x.... 0x....      BL       _Z7get_fatP5FATFSm
    996          		if (cs < 2) return 1;			/* It is an invalid cluster */
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD201             BCS.N    ??create_chain_3
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBDF2             POP      {R1,R4-R7,PC}
    997          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_3: (+1)
   \   00000024   0x69A1             LDR      R1,[R4, #+24]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD339             BCC.N    ??create_chain_4
    998          		scl = clst;
   \   0000002A   0x4637             MOV      R7,R6
    999          	}
   1000          
   1001          	ncl = scl;				/* Start cluster */
   \                     ??create_chain_2: (+1)
   \   0000002C   0x463D             MOV      R5,R7
   1002          	for (;;) {
   1003          		ncl++;							/* Next cluster */
   \                     ??create_chain_5: (+1)
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   1004          		if (ncl >= fs->n_fatent) {		/* Wrap around */
   \   00000030   0x69A0             LDR      R0,[R4, #+24]
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD302             BCC.N    ??create_chain_6
   1005          			ncl = 2;
   \   00000036   0x2502             MOVS     R5,#+2
   1006          			if (ncl > scl) return 0;	/* No free cluster */
   \   00000038   0x2F02             CMP      R7,#+2
   \   0000003A   0xD327             BCC.N    ??create_chain_7
   1007          		}
   1008          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_6: (+1)
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   1009          		if (cs == 0) break;				/* Found a free cluster */
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD11A             BNE.N    ??create_chain_8
   1010          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1011          			return cs;
   1012          		if (ncl == scl) return 0;		/* No free cluster */
   1013          	}
   1014          
   1015          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   00000048   0xF06F 0x4270      MVN      R2,#-268435456
   \   0000004C   0x4629             MOV      R1,R5
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   1016          	if (res == FR_OK && clst != 0) {
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD106             BNE.N    ??create_chain_9
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD004             BEQ.N    ??create_chain_9
   1017          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   0000005C   0x462A             MOV      R2,R5
   \   0000005E   0x4631             MOV      R1,R6
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   1018          	}
   1019          	if (res == FR_OK) {
   \                     ??create_chain_9: (+1)
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD112             BNE.N    ??create_chain_10
   1020          		fs->last_clust = ncl;			/* Update FSINFO */
   \   0000006A   0x60E5             STR      R5,[R4, #+12]
   1021          		if (fs->free_clust != 0xFFFFFFFF) {
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0xF110 0x0F01      CMN      R0,#+1
   \   00000072   0xD013             BEQ.N    ??create_chain_11
   1022          			fs->free_clust--;
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x6120             STR      R0,[R4, #+16]
   1023          			fs->fsi_flag = 1;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7160             STRB     R0,[R4, #+5]
   \   0000007C   0xE00E             B.N      ??create_chain_11
   1024          		}
   1025          	} else {
   \                     ??create_chain_8: (+1)
   \   0000007E   0xF110 0x0F01      CMN      R0,#+1
   \   00000082   0xD00C             BEQ.N    ??create_chain_4
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD00A             BEQ.N    ??create_chain_4
   \   00000088   0x42BD             CMP      R5,R7
   \   0000008A   0xD1D0             BNE.N    ??create_chain_5
   \                     ??create_chain_7: (+1)
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xBDF2             POP      {R1,R4-R7,PC}
   1026          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_10: (+1)
   \   00000090   0x2801             CMP      R0,#+1
   \   00000092   0xD102             BNE.N    ??create_chain_12
   \   00000094   0xF04F 0x35FF      MOV      R5,#-1
   \   00000098   0xE000             B.N      ??create_chain_11
   \                     ??create_chain_12: (+1)
   \   0000009A   0x2501             MOVS     R5,#+1
   1027          	}
   1028          
   1029          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_11: (+1)
   \   0000009C   0x4628             MOV      R0,R5
   \                     ??create_chain_4: (+1)
   \   0000009E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1030          }
   1031          #endif /* !_FS_READONLY */
   1032          
   1033          
   1034          
   1035          /*-----------------------------------------------------------------------*/
   1036          /* FAT handling - Convert offset into cluster with link map table        */
   1037          /*-----------------------------------------------------------------------*/
   1038          
   1039          #if _USE_FASTSEEK
   1040          static
   1041          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1042          	FIL* fp,		/* Pointer to the file object */
   1043          	DWORD ofs		/* File offset to be converted to cluster# */
   1044          )
   1045          {
   1046          	DWORD cl, ncl, *tbl;
   1047          
   1048          
   1049          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1050          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   1051          	for (;;) {
   1052          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1053          		if (!ncl) return 0;		/* End of table? (error) */
   1054          		if (cl < ncl) break;	/* In this fragment? */
   1055          		cl -= ncl; tbl++;		/* Next fragment */
   1056          	}
   1057          	return cl + *tbl;	/* Return the cluster number */
   1058          }
   1059          #endif	/* _USE_FASTSEEK */
   1060          
   1061          
   1062          
   1063          /*-----------------------------------------------------------------------*/
   1064          /* Directory handling - Set directory index                              */
   1065          /*-----------------------------------------------------------------------*/
   1066          

   \                                 In section .text, align 2, keep-with-next
   1067          static
   1068          FRESULT dir_sdi (
   1069          	DIR *dj,		/* Pointer to directory object */
   1070          	WORD idx		/* Index of directory table */
   1071          )
   1072          {
   \                     _Z7dir_sdiP3DIRt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1073          	DWORD clst;
   1074          	WORD ic;
   1075          
   1076          
   1077          	dj->index = idx;
   \   00000006   0x80E5             STRH     R5,[R4, #+6]
   1078          	clst = dj->sclust;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   1079          	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD02C             BEQ.N    ??dir_sdi_0
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x698A             LDR      R2,[R1, #+24]
   \   00000012   0x4290             CMP      R0,R2
   \   00000014   0xD228             BCS.N    ??dir_sdi_0
   1080          		return FR_INT_ERR;
   1081          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD103             BNE.N    ??dir_sdi_1
   \   0000001A   0x780A             LDRB     R2,[R1, #+0]
   \   0000001C   0x2A03             CMP      R2,#+3
   \   0000001E   0xD100             BNE.N    ??dir_sdi_1
   1082          		clst = dj->fs->dirbase;
   \   00000020   0x6A48             LDR      R0,[R1, #+36]
   1083          
   1084          	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_1: (+1)
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD10A             BNE.N    ??dir_sdi_2
   1085          		dj->clust = clst;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x60E0             STR      R0,[R4, #+12]
   1086          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x8901             LDRH     R1,[R0, #+8]
   \   0000002E   0x428D             CMP      R5,R1
   \   00000030   0xD21A             BCS.N    ??dir_sdi_0
   1087          			return FR_INT_ERR;
   1088          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   00000032   0x6A40             LDR      R0,[R0, #+36]
   \   00000034   0xEB00 0x1015      ADD      R0,R0,R5, LSR #+4
   \   00000038   0x6120             STR      R0,[R4, #+16]
   \   0000003A   0xE01F             B.N      ??dir_sdi_3
   1089          	}
   1090          	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
   1091          		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_2: (+1)
   \   0000003C   0x7889             LDRB     R1,[R1, #+2]
   \   0000003E   0x010E             LSLS     R6,R1,#+4
   \   00000040   0xE000             B.N      ??dir_sdi_4
   1092          		while (idx >= ic) {	/* Follow cluster chain */
   1093          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   1094          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1095          			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   1096          				return FR_INT_ERR;
   1097          			idx -= ic;
   \                     ??dir_sdi_5: (+1)
   \   00000042   0x1BAD             SUBS     R5,R5,R6
   \                     ??dir_sdi_4: (+1)
   \   00000044   0xB2AD             UXTH     R5,R5
   \   00000046   0x42B5             CMP      R5,R6
   \   00000048   0xDB10             BLT.N    ??dir_sdi_6
   \   0000004A   0x4601             MOV      R1,R0
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   00000052   0xF110 0x0F01      CMN      R0,#+1
   \   00000056   0xD101             BNE.N    ??dir_sdi_7
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xBD70             POP      {R4-R6,PC}
   \                     ??dir_sdi_7: (+1)
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD303             BCC.N    ??dir_sdi_0
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6989             LDR      R1,[R1, #+24]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD3EC             BCC.N    ??dir_sdi_5
   \                     ??dir_sdi_0: (+1)
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0xBD70             POP      {R4-R6,PC}
   1098          		}
   1099          		dj->clust = clst;
   \                     ??dir_sdi_6: (+1)
   \   0000006C   0x60E0             STR      R0,[R4, #+12]
   1100          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   0000006E   0x4601             MOV      R1,R0
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x.... 0x....      BL       clust2sect
   \   00000076   0xEB00 0x1015      ADD      R0,R0,R5, LSR #+4
   \   0000007A   0x6120             STR      R0,[R4, #+16]
   1101          	}
   1102          
   1103          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \                     ??dir_sdi_3: (+1)
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0xF005 0x010F      AND      R1,R5,#0xF
   \   00000082   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   00000086   0x3030             ADDS     R0,R0,#+48
   \   00000088   0x6160             STR      R0,[R4, #+20]
   1104          
   1105          	return FR_OK;	/* Seek succeeded */
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
   1106          }
   1107          
   1108          
   1109          
   1110          
   1111          /*-----------------------------------------------------------------------*/
   1112          /* Directory handling - Move directory table index next                  */
   1113          /*-----------------------------------------------------------------------*/
   1114          

   \                                 In section .text, align 2, keep-with-next
   1115          static
   1116          FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
   1117          	DIR *dj,		/* Pointer to directory object */
   1118          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1119          )
   1120          {
   \                     _Z8dir_nextP3DIRi: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   1121          	DWORD clst;
   1122          	WORD i;
   1123          
   1124          
   1125          	stretch = stretch;		/* To suppress warning on read-only cfg. */
   1126          	i = dj->index + 1;
   \   00000006   0x88E0             LDRH     R0,[R4, #+6]
   \   00000008   0x1C45             ADDS     R5,R0,#+1
   \   0000000A   0xB2AD             UXTH     R5,R5
   1127          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD022             BEQ.N    ??dir_next_0
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD01F             BEQ.N    ??dir_next_0
   1128          		return FR_NO_FILE;
   1129          
   1130          	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   \   00000016   0xF015 0x0F0F      TST      R5,#0xF
   \   0000001A   0xD15E             BNE.N    ??dir_next_1
   1131          		dj->sect++;					/* Next sector */
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x6120             STR      R0,[R4, #+16]
   1132          
   1133          		if (dj->clust == 0) {	/* Static table */
   \   00000020   0x68E1             LDR      R1,[R4, #+12]
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD103             BNE.N    ??dir_next_2
   1134          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   00000028   0x8900             LDRH     R0,[R0, #+8]
   \   0000002A   0x4285             CMP      R5,R0
   \   0000002C   0xDB55             BLT.N    ??dir_next_1
   \   0000002E   0xE012             B.N      ??dir_next_0
   1135          				return FR_NO_FILE;
   1136          		}
   1137          		else {					/* Dynamic table */
   1138          			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_2: (+1)
   \   00000030   0x7882             LDRB     R2,[R0, #+2]
   \   00000032   0x1E52             SUBS     R2,R2,#+1
   \   00000034   0xEA12 0x1F15      TST      R2,R5, LSR #+4
   \   00000038   0xD14F             BNE.N    ??dir_next_1
   1139          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   0000003A   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   0000003E   0x4606             MOV      R6,R0
   1140          				if (clst <= 1) return FR_INT_ERR;
   \   00000040   0x2E02             CMP      R6,#+2
   \   00000042   0xD313             BCC.N    ??dir_next_3
   1141          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \   00000044   0xF116 0x0F01      CMN      R6,#+1
   \   00000048   0xD03C             BEQ.N    ??dir_next_4
   1142          				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6981             LDR      R1,[R0, #+24]
   \   0000004E   0x428E             CMP      R6,R1
   \   00000050   0xD33D             BCC.N    ??dir_next_5
   1143          #if !_FS_READONLY
   1144          					BYTE c;
   1145          					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   \   00000052   0x2F00             CMP      R7,#+0
   \   00000054   0xD101             BNE.N    ??dir_next_6
   \                     ??dir_next_0: (+1)
   \   00000056   0x2004             MOVS     R0,#+4
   \   00000058   0xBDF2             POP      {R1,R4-R7,PC}
   1146          					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   \                     ??dir_next_6: (+1)
   \   0000005A   0x68E1             LDR      R1,[R4, #+12]
   \   0000005C   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   00000060   0x0006             MOVS     R6,R0
   1147          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000062   0xD101             BNE.N    ??dir_next_7
   \   00000064   0x2007             MOVS     R0,#+7
   \   00000066   0xBDF2             POP      {R1,R4-R7,PC}
   1148          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_7: (+1)
   \   00000068   0x2E01             CMP      R6,#+1
   \   0000006A   0xD101             BNE.N    ??dir_next_8
   \                     ??dir_next_3: (+1)
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0xBDF2             POP      {R1,R4-R7,PC}
   1149          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_8: (+1)
   \   00000070   0xF116 0x0F01      CMN      R6,#+1
   \   00000074   0xD026             BEQ.N    ??dir_next_4
   1150          					/* Clean-up stretched table */
   1151          					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD120             BNE.N    ??dir_next_4
   1152          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \   00000082   0xF44F 0x7200      MOV      R2,#+512
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x3030             ADDS     R0,R0,#+48
   \   0000008C   0x.... 0x....      BL       _Z7mem_setPvij
   1153          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \   00000090   0x4631             MOV      R1,R6
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       clust2sect
   \   00000098   0x6821             LDR      R1,[R4, #+0]
   \   0000009A   0x62C8             STR      R0,[R1, #+44]
   1154          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   0000009C   0x2700             MOVS     R7,#+0
   \   0000009E   0xE004             B.N      ??dir_next_9
   1155          						dj->fs->wflag = 1;
   1156          						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
   1157          						dj->fs->winsect++;
   \                     ??dir_next_10: (+1)
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6AC1             LDR      R1,[R0, #+44]
   \   000000A4   0x1C49             ADDS     R1,R1,#+1
   \   000000A6   0x62C1             STR      R1,[R0, #+44]
   \   000000A8   0x1C7F             ADDS     R7,R7,#+1
   \                     ??dir_next_9: (+1)
   \   000000AA   0x6820             LDR      R0,[R4, #+0]
   \   000000AC   0x7881             LDRB     R1,[R0, #+2]
   \   000000AE   0xB2FF             UXTB     R7,R7
   \   000000B0   0x428F             CMP      R7,R1
   \   000000B2   0xD209             BCS.N    ??dir_next_11
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0x7101             STRB     R1,[R0, #+4]
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD0ED             BEQ.N    ??dir_next_10
   \                     ??dir_next_4: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xBDF2             POP      {R1,R4-R7,PC}
   1158          					}
   1159          					dj->fs->winsect -= c;						/* Rewind window address */
   \                     ??dir_next_11: (+1)
   \   000000C8   0x6AC1             LDR      R1,[R0, #+44]
   \   000000CA   0x1BC9             SUBS     R1,R1,R7
   \   000000CC   0x62C1             STR      R1,[R0, #+44]
   1160          #else
   1161          					return FR_NO_FILE;			/* Report EOT */
   1162          #endif
   1163          				}
   1164          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_5: (+1)
   \   000000CE   0x60E6             STR      R6,[R4, #+12]
   1165          				dj->sect = clust2sect(dj->fs, clst);
   \   000000D0   0x4631             MOV      R1,R6
   \   000000D2   0x6820             LDR      R0,[R4, #+0]
   \   000000D4   0x.... 0x....      BL       clust2sect
   \   000000D8   0x6120             STR      R0,[R4, #+16]
   1166          			}
   1167          		}
   1168          	}
   1169          
   1170          	dj->index = i;
   \                     ??dir_next_1: (+1)
   \   000000DA   0x80E5             STRH     R5,[R4, #+6]
   1171          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   000000DC   0x6820             LDR      R0,[R4, #+0]
   \   000000DE   0xF005 0x010F      AND      R1,R5,#0xF
   \   000000E2   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000000E6   0x3030             ADDS     R0,R0,#+48
   \   000000E8   0x6160             STR      R0,[R4, #+20]
   1172          
   1173          	return FR_OK;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1174          }
   1175          
   1176          
   1177          
   1178          
   1179          /*-----------------------------------------------------------------------*/
   1180          /* Directory handling - Load/Store start cluster number                  */
   1181          /*-----------------------------------------------------------------------*/
   1182          

   \                                 In section .text, align 2, keep-with-next
   1183          static
   1184          DWORD ld_clust (
   1185          	FATFS *fs,	/* Pointer to the fs object */
   1186          	BYTE *dir	/* Pointer to the directory entry */
   1187          )
   1188          {
   1189          	DWORD cl;
   1190          
   1191          	cl = LD_WORD(dir+DIR_FstClusLO);
   \                     _Z8ld_clustP5FATFSPh: (+1)
   \   00000000   0x7ECA             LDRB     R2,[R1, #+27]
   \   00000002   0x7E8B             LDRB     R3,[R1, #+26]
   \   00000004   0xEA43 0x2202      ORR      R2,R3,R2, LSL #+8
   1192          	if (fs->fs_type == FS_FAT32)
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD105             BNE.N    ??ld_clust_0
   1193          		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
   \   0000000E   0x7D48             LDRB     R0,[R1, #+21]
   \   00000010   0x7D09             LDRB     R1,[R1, #+20]
   \   00000012   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000016   0xEA42 0x4200      ORR      R2,R2,R0, LSL #+16
   1194          
   1195          	return cl;
   \                     ??ld_clust_0: (+1)
   \   0000001A   0x4610             MOV      R0,R2
   \   0000001C   0x4770             BX       LR               ;; return
   1196          }
   1197          
   1198          
   1199          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1200          static
   1201          void st_clust (
   1202          	BYTE *dir,	/* Pointer to the directory entry */
   1203          	DWORD cl	/* Value to be set */
   1204          )
   1205          {
   1206          	ST_WORD(dir+DIR_FstClusLO, cl);
   \                     _Z8st_clustPhm: (+1)
   \   00000000   0x7681             STRB     R1,[R0, #+26]
   \   00000002   0x460A             MOV      R2,R1
   \   00000004   0xB292             UXTH     R2,R2
   \   00000006   0x0A12             LSRS     R2,R2,#+8
   \   00000008   0x76C2             STRB     R2,[R0, #+27]
   1207          	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   \   0000000A   0x0C09             LSRS     R1,R1,#+16
   \   0000000C   0x7501             STRB     R1,[R0, #+20]
   \   0000000E   0x0A09             LSRS     R1,R1,#+8
   \   00000010   0x7541             STRB     R1,[R0, #+21]
   1208          }
   \   00000012   0x4770             BX       LR               ;; return
   1209          #endif
   1210          
   1211          
   1212          
   1213          /*-----------------------------------------------------------------------*/
   1214          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1215          /*-----------------------------------------------------------------------*/
   1216          #if _USE_LFN
   1217          static
   1218          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
   1219          
   1220          
   1221          static
   1222          int cmp_lfn (			/* 1:Matched, 0:Not matched */
   1223          	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
   1224          	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
   1225          )
   1226          {
   1227          	UINT i, s;
   1228          	WCHAR wc, uc;
   1229          
   1230          
   1231          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   1232          	s = 0; wc = 1;
   1233          	do {
   1234          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   1235          		if (wc) {	/* Last char has not been processed */
   1236          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   1237          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   1238          				return 0;				/* Not matched */
   1239          		} else {
   1240          			if (uc != 0xFFFF) return 0;	/* Check filler */
   1241          		}
   1242          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   1243          
   1244          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   1245          		return 0;
   1246          
   1247          	return 1;						/* The part of LFN matched */
   1248          }
   1249          
   1250          
   1251          
   1252          static
   1253          int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
   1254          	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
   1255          	BYTE *dir			/* Pointer to the directory entry */
   1256          )
   1257          {
   1258          	UINT i, s;
   1259          	WCHAR wc, uc;
   1260          
   1261          
   1262          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1263          
   1264          	s = 0; wc = 1;
   1265          	do {
   1266          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   1267          		if (wc) {	/* Last char has not been processed */
   1268          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   1269          			lfnbuf[i++] = wc = uc;			/* Store it */
   1270          		} else {
   1271          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1272          		}
   1273          	} while (++s < 13);						/* Read all character in the entry */
   1274          
   1275          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   1276          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   1277          		lfnbuf[i] = 0;
   1278          	}
   1279          
   1280          	return 1;
   1281          }
   1282          
   1283          
   1284          #if !_FS_READONLY
   1285          static
   1286          void fit_lfn (
   1287          	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
   1288          	BYTE *dir,				/* Pointer to the directory entry */
   1289          	BYTE ord,				/* LFN order (1-20) */
   1290          	BYTE sum				/* SFN sum */
   1291          )
   1292          {
   1293          	UINT i, s;
   1294          	WCHAR wc;
   1295          
   1296          
   1297          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   1298          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1299          	dir[LDIR_Type] = 0;
   1300          	ST_WORD(dir+LDIR_FstClusLO, 0);
   1301          
   1302          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   1303          	s = wc = 0;
   1304          	do {
   1305          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   1306          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   1307          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   1308          	} while (++s < 13);
   1309          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   1310          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   1311          }
   1312          
   1313          #endif
   1314          #endif
   1315          
   1316          
   1317          
   1318          /*-----------------------------------------------------------------------*/
   1319          /* Create numbered name                                                  */
   1320          /*-----------------------------------------------------------------------*/
   1321          #if _USE_LFN
   1322          void gen_numname (
   1323          	BYTE *dst,			/* Pointer to generated SFN */
   1324          	const BYTE *src,	/* Pointer to source SFN to be modified */
   1325          	const WCHAR *lfn,	/* Pointer to LFN */
   1326          	WORD seq			/* Sequence number */
   1327          )
   1328          {
   1329          	BYTE ns[8], c;
   1330          	UINT i, j;
   1331          
   1332          
   1333          	mem_cpy(dst, src, 11);
   1334          
   1335          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   1336          		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
   1337          	}
   1338          
   1339          	/* itoa (hexdecimal) */
   1340          	i = 7;
   1341          	do {
   1342          		c = (seq % 16) + '0';
   1343          		if (c > '9') c += 7;
   1344          		ns[i--] = c;
   1345          		seq /= 16;
   1346          	} while (seq);
   1347          	ns[i] = '~';
   1348          
   1349          	/* Append the number */
   1350          	for (j = 0; j < i && dst[j] != ' '; j++) {
   1351          		if (IsDBCS1(dst[j])) {
   1352          			if (j == i - 1) break;
   1353          			j++;
   1354          		}
   1355          	}
   1356          	do {
   1357          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   1358          	} while (j < 8);
   1359          }
   1360          #endif
   1361          
   1362          
   1363          
   1364          
   1365          /*-----------------------------------------------------------------------*/
   1366          /* Calculate sum of an SFN                                               */
   1367          /*-----------------------------------------------------------------------*/
   1368          #if _USE_LFN
   1369          static
   1370          BYTE sum_sfn (
   1371          	const BYTE *dir		/* Ptr to directory entry */
   1372          )
   1373          {
   1374          	BYTE sum = 0;
   1375          	UINT n = 11;
   1376          
   1377          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   1378          	return sum;
   1379          }
   1380          #endif
   1381          
   1382          
   1383          
   1384          
   1385          /*-----------------------------------------------------------------------*/
   1386          /* Directory handling - Find an object in the directory                  */
   1387          /*-----------------------------------------------------------------------*/
   1388          

   \                                 In section .text, align 2, keep-with-next
   1389          static
   1390          FRESULT dir_find (
   1391          	DIR *dj			/* Pointer to the directory object linked to the file name */
   1392          )
   1393          {
   \                     _Z8dir_findP3DIR: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1394          	FRESULT res;
   1395          	BYTE c, *dir;
   1396          #if _USE_LFN
   1397          	BYTE a, ord, sum;
   1398          #endif
   1399          
   1400          	res = dir_sdi(dj, 0);			/* Rewind directory object */
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       _Z7dir_sdiP3DIRt
   \   0000000A   0x0005             MOVS     R5,R0
   1401          	if (res != FR_OK) return res;
   \   0000000C   0xD11A             BNE.N    ??dir_find_0
   1402          
   1403          #if _USE_LFN
   1404          	ord = sum = 0xFF;
   1405          #endif
   1406          	do {
   1407          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_1: (+1)
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000016   0x0005             MOVS     R5,R0
   1408          		if (res != FR_OK) break;
   \   00000018   0xD114             BNE.N    ??dir_find_0
   1409          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \   0000001A   0x6960             LDR      R0,[R4, #+20]
   1410          		c = dir[DIR_Name];
   1411          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   0000001C   0x7801             LDRB     R1,[R0, #+0]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD101             BNE.N    ??dir_find_2
   \   00000022   0x2504             MOVS     R5,#+4
   \   00000024   0xE00E             B.N      ??dir_find_0
   1412          #if _USE_LFN	/* LFN configuration */
   1413          		a = dir[DIR_Attr] & AM_MASK;
   1414          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   1415          			ord = 0xFF;
   1416          		} else {
   1417          			if (a == AM_LFN) {			/* An LFN entry is found */
   1418          				if (dj->lfn) {
   1419          					if (c & LLE) {		/* Is it start of LFN sequence? */
   1420          						sum = dir[LDIR_Chksum];
   1421          						c &= ~LLE; ord = c;	/* LFN start order */
   1422          						dj->lfn_idx = dj->index;
   1423          					}
   1424          					/* Check validity of the LFN entry and compare it with given name */
   1425          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1426          				}
   1427          			} else {					/* An SFN entry is found */
   1428          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   1429          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   1430          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
   1431          			}
   1432          		}
   1433          #else		/* Non LFN configuration */
   1434          		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   \                     ??dir_find_2: (+1)
   \   00000026   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000028   0x0709             LSLS     R1,R1,#+28
   \   0000002A   0xD405             BMI.N    ??dir_find_3
   \   0000002C   0x220B             MOVS     R2,#+11
   \   0000002E   0x69A1             LDR      R1,[R4, #+24]
   \   00000030   0x.... 0x....      BL       _Z7mem_cmpPKvS0_j
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD005             BEQ.N    ??dir_find_0
   1435          			break;
   1436          #endif
   1437          		res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_find_3: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _Z8dir_nextP3DIRi
   \   00000040   0x0005             MOVS     R5,R0
   1438          	} while (res == FR_OK);
   \   00000042   0xD0E4             BEQ.N    ??dir_find_1
   1439          
   1440          	return res;
   \                     ??dir_find_0: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1441          }
   1442          
   1443          
   1444          
   1445          
   1446          /*-----------------------------------------------------------------------*/
   1447          /* Read an object from the directory                                     */
   1448          /*-----------------------------------------------------------------------*/
   1449          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1450          static
   1451          FRESULT dir_read (
   1452          	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
   1453          )
   1454          {
   \                     _Z8dir_readP3DIR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1455          	FRESULT res;
   1456          	BYTE c, *dir;
   1457          #if _USE_LFN
   1458          	BYTE a, ord = 0xFF, sum = 0xFF;
   1459          #endif
   1460          
   1461          	res = FR_NO_FILE;
   \   00000004   0x2004             MOVS     R0,#+4
   1462          	while (dj->sect) {
   \                     ??dir_read_0: (+1)
   \   00000006   0x6921             LDR      R1,[R4, #+16]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD017             BEQ.N    ??dir_read_1
   1463          		res = move_window(dj->fs, dj->sect);
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   1464          		if (res != FR_OK) break;
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD112             BNE.N    ??dir_read_1
   1465          		dir = dj->dir;					/* Ptr to the directory entry of current index */
   \   00000016   0x6961             LDR      R1,[R4, #+20]
   1466          		c = dir[DIR_Name];
   \   00000018   0x780A             LDRB     R2,[R1, #+0]
   1467          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??dir_read_2
   \   0000001E   0x2004             MOVS     R0,#+4
   \   00000020   0xE00C             B.N      ??dir_read_1
   1468          #if _USE_LFN	/* LFN configuration */
   1469          		a = dir[DIR_Attr] & AM_MASK;
   1470          		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   1471          			ord = 0xFF;
   1472          		} else {
   1473          			if (a == AM_LFN) {			/* An LFN entry is found */
   1474          				if (c & LLE) {			/* Is it start of LFN sequence? */
   1475          					sum = dir[LDIR_Chksum];
   1476          					c &= ~LLE; ord = c;
   1477          					dj->lfn_idx = dj->index;
   1478          				}
   1479          				/* Check LFN validity and capture it */
   1480          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   1481          			} else {					/* An SFN entry is found */
   1482          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   1483          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   1484          				break;
   1485          			}
   1486          		}
   1487          #else		/* Non LFN configuration */
   1488          		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
   \                     ??dir_read_2: (+1)
   \   00000022   0x2AE5             CMP      R2,#+229
   \   00000024   0xD004             BEQ.N    ??dir_read_3
   \   00000026   0x2A2E             CMP      R2,#+46
   \   00000028   0xD002             BEQ.N    ??dir_read_3
   \   0000002A   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000002C   0x0709             LSLS     R1,R1,#+28
   \   0000002E   0xD505             BPL.N    ??dir_read_1
   1489          			break;
   1490          #endif
   1491          		res = dir_next(dj, 0);				/* Next entry */
   \                     ??dir_read_3: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       _Z8dir_nextP3DIRi
   1492          		if (res != FR_OK) break;
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD0E4             BEQ.N    ??dir_read_0
   1493          	}
   1494          
   1495          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1: (+1)
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??dir_read_4
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6121             STR      R1,[R4, #+16]
   1496          
   1497          	return res;
   \                     ??dir_read_4: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
   1498          }
   1499          #endif
   1500          
   1501          
   1502          
   1503          /*-----------------------------------------------------------------------*/
   1504          /* Register an object to the directory                                   */
   1505          /*-----------------------------------------------------------------------*/
   1506          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1507          static
   1508          FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
   1509          	DIR *dj				/* Target directory with object name to be created */
   1510          )
   1511          {
   \                     _Z12dir_registerP3DIR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1512          	FRESULT res;
   1513          	BYTE c, *dir;
   1514          #if _USE_LFN	/* LFN configuration */
   1515          	WORD n, ne, is;
   1516          	BYTE sn[12], *fn, sum;
   1517          	WCHAR *lfn;
   1518          
   1519          
   1520          	fn = dj->fn; lfn = dj->lfn;
   1521          	mem_cpy(sn, fn, 12);
   1522          
   1523          	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
   1524          		return FR_INVALID_NAME;
   1525          
   1526          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   1527          		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   1528          		for (n = 1; n < 100; n++) {
   1529          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   1530          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   1531          			if (res != FR_OK) break;
   1532          		}
   1533          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   1534          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   1535          		fn[NS] = sn[NS]; dj->lfn = lfn;
   1536          	}
   1537          
   1538          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
   1539          		for (ne = 0; lfn[ne]; ne++) ;
   1540          		ne = (ne + 25) / 13;
   1541          	} else {						/* Otherwise reserve only an SFN entry. */
   1542          		ne = 1;
   1543          	}
   1544          
   1545          	/* Reserve contiguous entries */
   1546          	res = dir_sdi(dj, 0);
   1547          	if (res != FR_OK) return res;
   1548          	n = is = 0;
   1549          	do {
   1550          		res = move_window(dj->fs, dj->sect);
   1551          		if (res != FR_OK) break;
   1552          		c = *dj->dir;				/* Check the entry status */
   1553          		if (c == DDE || c == 0) {	/* Is it a blank entry? */
   1554          			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
   1555          			if (++n == ne) break;	/* A contiguous entry that required count is found */
   1556          		} else {
   1557          			n = 0;					/* Not a blank entry. Restart to search */
   1558          		}
   1559          		res = dir_next(dj, 1);		/* Next entry with table stretch */
   1560          	} while (res == FR_OK);
   1561          
   1562          	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
   1563          		res = dir_sdi(dj, is);
   1564          		if (res == FR_OK) {
   1565          			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
   1566          			ne--;
   1567          			do {					/* Store LFN entries in bottom first */
   1568          				res = move_window(dj->fs, dj->sect);
   1569          				if (res != FR_OK) break;
   1570          				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
   1571          				dj->fs->wflag = 1;
   1572          				res = dir_next(dj, 0);	/* Next entry */
   1573          			} while (res == FR_OK && --ne);
   1574          		}
   1575          	}
   1576          
   1577          #else	/* Non LFN configuration */
   1578          	res = dir_sdi(dj, 0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       _Z7dir_sdiP3DIRt
   \   0000000A   0x0005             MOVS     R5,R0
   1579          	if (res == FR_OK) {
   \   0000000C   0xD111             BNE.N    ??dir_register_0
   1580          		do {	/* Find a blank entry for the SFN */
   1581          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_1: (+1)
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000016   0x0005             MOVS     R5,R0
   1582          			if (res != FR_OK) break;
   \   00000018   0xD10B             BNE.N    ??dir_register_0
   1583          			c = *dj->dir;
   \   0000001A   0x6960             LDR      R0,[R4, #+20]
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   1584          			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
   \   0000001E   0x28E5             CMP      R0,#+229
   \   00000020   0xD007             BEQ.N    ??dir_register_0
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD005             BEQ.N    ??dir_register_0
   1585          			res = dir_next(dj, 1);			/* Next entry with table stretch */
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _Z8dir_nextP3DIRi
   \   0000002E   0x0005             MOVS     R5,R0
   1586          		} while (res == FR_OK);
   \   00000030   0xD0ED             BEQ.N    ??dir_register_1
   1587          	}
   1588          #endif
   1589          
   1590          	if (res == FR_OK) {		/* Initialize the SFN entry */
   \                     ??dir_register_0: (+1)
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD113             BNE.N    ??dir_register_2
   1591          		res = move_window(dj->fs, dj->sect);
   \   00000036   0x6921             LDR      R1,[R4, #+16]
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000003E   0x0005             MOVS     R5,R0
   1592          		if (res == FR_OK) {
   \   00000040   0xD10D             BNE.N    ??dir_register_2
   1593          			dir = dj->dir;
   \   00000042   0x6966             LDR      R6,[R4, #+20]
   1594          			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
   \   00000044   0x2220             MOVS     R2,#+32
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       _Z7mem_setPvij
   1595          			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
   \   0000004E   0x220B             MOVS     R2,#+11
   \   00000050   0x69A1             LDR      R1,[R4, #+24]
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   1596          #if _USE_LFN
   1597          			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   1598          #endif
   1599          			dj->fs->wflag = 1;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x7108             STRB     R0,[R1, #+4]
   1600          		}
   1601          	}
   1602          
   1603          	return res;
   \                     ??dir_register_2: (+1)
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
   1604          }
   1605          #endif /* !_FS_READONLY */
   1606          
   1607          
   1608          
   1609          
   1610          /*-----------------------------------------------------------------------*/
   1611          /* Remove an object from the directory                                   */
   1612          /*-----------------------------------------------------------------------*/
   1613          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   1614          static
   1615          FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
   1616          	DIR *dj				/* Directory object pointing the entry to be removed */
   1617          )
   1618          {
   \                     _Z10dir_removeP3DIR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1619          	FRESULT res;
   1620          #if _USE_LFN	/* LFN configuration */
   1621          	WORD i;
   1622          
   1623          	i = dj->index;	/* SFN index */
   1624          	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   1625          	if (res == FR_OK) {
   1626          		do {
   1627          			res = move_window(dj->fs, dj->sect);
   1628          			if (res != FR_OK) break;
   1629          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   1630          			dj->fs->wflag = 1;
   1631          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   1632          			res = dir_next(dj, 0);		/* Next entry */
   1633          		} while (res == FR_OK);
   1634          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   1635          	}
   1636          
   1637          #else			/* Non LFN configuration */
   1638          	res = dir_sdi(dj, dj->index);
   \   00000004   0x88E1             LDRH     R1,[R4, #+6]
   \   00000006   0x.... 0x....      BL       _Z7dir_sdiP3DIRt
   1639          	if (res == FR_OK) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD10B             BNE.N    ??dir_remove_0
   1640          		res = move_window(dj->fs, dj->sect);
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   1641          		if (res == FR_OK) {
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD105             BNE.N    ??dir_remove_0
   1642          			*dj->dir = DDE;			/* Mark the entry "deleted" */
   \   0000001A   0x21E5             MOVS     R1,#+229
   \   0000001C   0x6962             LDR      R2,[R4, #+20]
   \   0000001E   0x7011             STRB     R1,[R2, #+0]
   1643          			dj->fs->wflag = 1;
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x6822             LDR      R2,[R4, #+0]
   \   00000024   0x7111             STRB     R1,[R2, #+4]
   1644          		}
   1645          	}
   1646          #endif
   1647          
   1648          	return res;
   \                     ??dir_remove_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1649          }
   1650          #endif /* !_FS_READONLY */
   1651          
   1652          
   1653          
   1654          
   1655          /*-----------------------------------------------------------------------*/
   1656          /* Pick a segment and create the object name in directory form           */
   1657          /*-----------------------------------------------------------------------*/
   1658          

   \                                 In section .text, align 2, keep-with-next
   1659          static
   1660          FRESULT create_name (
   1661          	DIR *dj,			/* Pointer to the directory object */
   1662          	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
   1663          )
   1664          {
   \                     _Z11create_nameP3DIRPPKc: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x460C             MOV      R4,R1
   1665          #ifdef _EXCVT
   1666          	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
   1667          #endif
   1668          
   1669          #if _USE_LFN	/* LFN configuration */
   1670          	BYTE b, cf;
   1671          	WCHAR w, *lfn;
   1672          	UINT i, ni, si, di;
   1673          	const TCHAR *p;
   1674          
   1675          	/* Create LFN in Unicode */
   1676          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   1677          	lfn = dj->lfn;
   1678          	si = di = 0;
   1679          	for (;;) {
   1680          		w = p[si++];					/* Get a character */
   1681          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   1682          		if (di >= _MAX_LFN)				/* Reject too long name */
   1683          			return FR_INVALID_NAME;
   1684          #if !_LFN_UNICODE
   1685          		w &= 0xFF;
   1686          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1687          			b = (BYTE)p[si++];			/* Get 2nd byte */
   1688          			if (!IsDBCS2(b))
   1689          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   1690          			w = (w << 8) + b;			/* Create a DBC */
   1691          		}
   1692          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   1693          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   1694          #endif
   1695          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   1696          			return FR_INVALID_NAME;
   1697          		lfn[di++] = w;					/* Store the Unicode char */
   1698          	}
   1699          	*path = &p[si];						/* Return pointer to the next segment */
   1700          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   1701          #if _FS_RPATH
   1702          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   1703          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   1704          		lfn[di] = 0;
   1705          		for (i = 0; i < 11; i++)
   1706          			dj->fn[i] = (i < di) ? '.' : ' ';
   1707          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   1708          		return FR_OK;
   1709          	}
   1710          #endif
   1711          	while (di) {						/* Strip trailing spaces and dots */
   1712          		w = lfn[di-1];
   1713          		if (w != ' ' && w != '.') break;
   1714          		di--;
   1715          	}
   1716          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   1717          
   1718          	lfn[di] = 0;						/* LFN is created */
   1719          
   1720          	/* Create SFN in directory form */
   1721          	mem_set(dj->fn, ' ', 11);
   1722          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   1723          	if (si) cf |= NS_LOSS | NS_LFN;
   1724          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   1725          
   1726          	b = i = 0; ni = 8;
   1727          	for (;;) {
   1728          		w = lfn[si++];					/* Get an LFN char */
   1729          		if (!w) break;					/* Break on end of the LFN */
   1730          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   1731          			cf |= NS_LOSS | NS_LFN; continue;
   1732          		}
   1733          
   1734          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   1735          			if (ni == 11) {				/* Long extension */
   1736          				cf |= NS_LOSS | NS_LFN; break;
   1737          			}
   1738          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   1739          			if (si > di) break;			/* No extension */
   1740          			si = di; i = 8; ni = 11;	/* Enter extension section */
   1741          			b <<= 2; continue;
   1742          		}
   1743          
   1744          		if (w >= 0x80) {				/* Non ASCII char */
   1745          #ifdef _EXCVT
   1746          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   1747          			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   1748          #else
   1749          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   1750          #endif
   1751          			cf |= NS_LFN;				/* Force create LFN entry */
   1752          		}
   1753          
   1754          		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
   1755          			if (i >= ni - 1) {
   1756          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   1757          			}
   1758          			dj->fn[i++] = (BYTE)(w >> 8);
   1759          		} else {						/* Single byte char */
   1760          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   1761          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   1762          			} else {
   1763          				if (IsUpper(w)) {		/* ASCII large capital */
   1764          					b |= 2;
   1765          				} else {
   1766          					if (IsLower(w)) {	/* ASCII small capital */
   1767          						b |= 1; w -= 0x20;
   1768          					}
   1769          				}
   1770          			}
   1771          		}
   1772          		dj->fn[i++] = (BYTE)w;
   1773          	}
   1774          
   1775          	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   1776          
   1777          	if (ni == 8) b <<= 2;
   1778          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   1779          		cf |= NS_LFN;
   1780          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   1781          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   1782          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   1783          	}
   1784          
   1785          	dj->fn[NS] = cf;	/* SFN is created */
   1786          
   1787          	return FR_OK;
   1788          
   1789          
   1790          #else	/* Non-LFN configuration */
   1791          	BYTE b, c, d, *sfn;
   1792          	UINT ni, si, i;
   1793          	const char *p;
   1794          
   1795          	/* Create file name in directory form */
   1796          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000006   0x6825             LDR      R5,[R4, #+0]
   \   00000008   0xE000             B.N      ??create_name_0
   \                     ??create_name_1: (+1)
   \   0000000A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??create_name_0: (+1)
   \   0000000C   0x7829             LDRB     R1,[R5, #+0]
   \   0000000E   0x292F             CMP      R1,#+47
   \   00000010   0xD0FB             BEQ.N    ??create_name_1
   \   00000012   0x295C             CMP      R1,#+92
   \   00000014   0xD0F9             BEQ.N    ??create_name_1
   1797          	sfn = dj->fn;
   \   00000016   0x6986             LDR      R6,[R0, #+24]
   1798          	mem_set(sfn, ' ', 11);
   \   00000018   0x220B             MOVS     R2,#+11
   \   0000001A   0x2120             MOVS     R1,#+32
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0x.... 0x....      BL       _Z7mem_setPvij
   1799          	si = i = b = 0; ni = 8;
   \   00000022   0xF04F 0x0900      MOV      R9,#+0
   \   00000026   0x464F             MOV      R7,R9
   \   00000028   0x46BB             MOV      R11,R7
   \   0000002A   0xF04F 0x0808      MOV      R8,#+8
   \   0000002E   0xE00C             B.N      ??create_name_2
   1800          #if _FS_RPATH
   1801          	if (p[si] == '.') { /* Is this a dot entry? */
   1802          		for (;;) {
   1803          			c = (BYTE)p[si++];
   1804          			if (c != '.' || si >= 3) break;
   1805          			sfn[i++] = c;
   1806          		}
   1807          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   1808          		*path = &p[si];									/* Return pointer to the next segment */
   1809          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   1810          		return FR_OK;
   1811          	}
   1812          #endif
   1813          	for (;;) {
   1814          		c = (BYTE)p[si++];
   1815          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   1816          		if (c == '.' || i >= ni) {
   1817          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   \                     ??create_name_3: (+1)
   \   00000030   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000034   0xD152             BNE.N    ??create_name_4
   \   00000036   0xF1BA 0x0F2E      CMP      R10,#+46
   \   0000003A   0xD14F             BNE.N    ??create_name_4
   1818          			i = 8; ni = 11;
   \   0000003C   0x2708             MOVS     R7,#+8
   \   0000003E   0xF04F 0x080B      MOV      R8,#+11
   1819          			b <<= 2; continue;
   \   00000042   0xEA4F 0x0989      LSL      R9,R9,#+2
   \   00000046   0xFA5F 0xF989      UXTB     R9,R9
   1820          		}
   \                     ??create_name_2: (+1)
   \   0000004A   0xF81B 0xA005      LDRB     R10,[R11, R5]
   \   0000004E   0xF10B 0x0B01      ADD      R11,R11,#+1
   \   00000052   0xF1BA 0x0F21      CMP      R10,#+33
   \   00000056   0xDB05             BLT.N    ??create_name_5
   \   00000058   0xF1BA 0x0F2F      CMP      R10,#+47
   \   0000005C   0xD002             BEQ.N    ??create_name_5
   \   0000005E   0xF1BA 0x0F5C      CMP      R10,#+92
   \   00000062   0xD108             BNE.N    ??create_name_6
   1821          		if (c >= 0x80) {				/* Extended char? */
   1822          			b |= 3;						/* Eliminate NT flag */
   1823          #ifdef _EXCVT
   1824          			c = excvt[c - 0x80];		/* Upper conversion (SBCS) */
   1825          #else
   1826          #if !_DF1S	/* ASCII only cfg */
   1827          			return FR_INVALID_NAME;
   1828          #endif
   1829          #endif
   1830          		}
   1831          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   1832          			d = (BYTE)p[si++];			/* Get 2nd byte */
   1833          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   1834          				return FR_INVALID_NAME;
   1835          			sfn[i++] = c;
   1836          			sfn[i++] = d;
   1837          		} else {						/* Single byte code */
   1838          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   1839          				return FR_INVALID_NAME;
   1840          			if (IsUpper(c)) {			/* ASCII large capital? */
   1841          				b |= 2;
   1842          			} else {
   1843          				if (IsLower(c)) {		/* ASCII small capital? */
   1844          					b |= 1; c -= 0x20;
   1845          				}
   1846          			}
   1847          			sfn[i++] = c;
   1848          		}
   1849          	}
   1850          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_5: (+1)
   \   00000064   0xEB0B 0x0005      ADD      R0,R11,R5
   \   00000068   0x6020             STR      R0,[R4, #+0]
   1851          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   0000006A   0xF1BA 0x0F21      CMP      R10,#+33
   \   0000006E   0xDA31             BGE.N    ??create_name_7
   \   00000070   0xF04F 0x0A04      MOV      R10,#+4
   \   00000074   0xE030             B.N      ??create_name_8
   \                     ??create_name_6: (+1)
   \   00000076   0xF1BA 0x0F2E      CMP      R10,#+46
   \   0000007A   0xD0D9             BEQ.N    ??create_name_3
   \   0000007C   0x4547             CMP      R7,R8
   \   0000007E   0xD2D7             BCS.N    ??create_name_3
   \   00000080   0xF1BA 0x0F80      CMP      R10,#+128
   \   00000084   0xDB06             BLT.N    ??create_name_9
   \   00000086   0xF049 0x0903      ORR      R9,R9,#0x3
   \   0000008A   0x.... 0x....      ADR.W    R0,??excvt
   \   0000008E   0x4450             ADD      R0,R10,R0
   \   00000090   0xF810 0xAC80      LDRB     R10,[R0, #-128]
   \                     ??create_name_9: (+1)
   \   00000094   0x4651             MOV      R1,R10
   \   00000096   0x.... 0x....      ADR.W    R0,?_0
   \   0000009A   0x.... 0x....      BL       _Z7chk_chrPKci
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD11C             BNE.N    ??create_name_4
   \   000000A2   0xF1AA 0x0041      SUB      R0,R10,#+65
   \   000000A6   0x281A             CMP      R0,#+26
   \   000000A8   0xD204             BCS.N    ??create_name_10
   \   000000AA   0xF049 0x0902      ORR      R9,R9,#0x2
   \   000000AE   0xFA5F 0xF989      UXTB     R9,R9
   \   000000B2   0xE00B             B.N      ??create_name_11
   \                     ??create_name_10: (+1)
   \   000000B4   0xF1AA 0x0061      SUB      R0,R10,#+97
   \   000000B8   0x281A             CMP      R0,#+26
   \   000000BA   0xD207             BCS.N    ??create_name_11
   \   000000BC   0xF049 0x0901      ORR      R9,R9,#0x1
   \   000000C0   0xFA5F 0xF989      UXTB     R9,R9
   \   000000C4   0xF1AA 0x0A20      SUB      R10,R10,#+32
   \   000000C8   0xFA5F 0xFA8A      UXTB     R10,R10
   \                     ??create_name_11: (+1)
   \   000000CC   0xF807 0xA006      STRB     R10,[R7, R6]
   \   000000D0   0x1C7F             ADDS     R7,R7,#+1
   \   000000D2   0xE7BA             B.N      ??create_name_2
   \                     ??create_name_7: (+1)
   \   000000D4   0xF04F 0x0A00      MOV      R10,#+0
   1852          
   1853          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   \                     ??create_name_8: (+1)
   \   000000D8   0x2F00             CMP      R7,#+0
   \   000000DA   0xD101             BNE.N    ??create_name_12
   \                     ??create_name_4: (+1)
   \   000000DC   0x2006             MOVS     R0,#+6
   \   000000DE   0xE01A             B.N      ??create_name_13
   1854          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   \                     ??create_name_12: (+1)
   \   000000E0   0x7830             LDRB     R0,[R6, #+0]
   \   000000E2   0x28E5             CMP      R0,#+229
   \   000000E4   0xD101             BNE.N    ??create_name_14
   \   000000E6   0x2005             MOVS     R0,#+5
   \   000000E8   0x7030             STRB     R0,[R6, #+0]
   1855          
   1856          	if (ni == 8) b <<= 2;
   \                     ??create_name_14: (+1)
   \   000000EA   0xF1B8 0x0F08      CMP      R8,#+8
   \   000000EE   0xD103             BNE.N    ??create_name_15
   \   000000F0   0xEA4F 0x0989      LSL      R9,R9,#+2
   \   000000F4   0xFA5F 0xF989      UXTB     R9,R9
   1857          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   \                     ??create_name_15: (+1)
   \   000000F8   0xF009 0x0003      AND      R0,R9,#0x3
   \   000000FC   0x2801             CMP      R0,#+1
   \   000000FE   0xD101             BNE.N    ??create_name_16
   \   00000100   0xF04A 0x0A10      ORR      R10,R10,#0x10
   1858          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   \                     ??create_name_16: (+1)
   \   00000104   0xF009 0x000C      AND      R0,R9,#0xC
   \   00000108   0x2804             CMP      R0,#+4
   \   0000010A   0xD101             BNE.N    ??create_name_17
   \   0000010C   0xF04A 0x0A08      ORR      R10,R10,#0x8
   1859          
   1860          	sfn[NS] = c;		/* Store NT flag, File name is created */
   \                     ??create_name_17: (+1)
   \   00000110   0xF886 0xA00B      STRB     R10,[R6, #+11]
   1861          
   1862          	return FR_OK;
   \   00000114   0x2000             MOVS     R0,#+0
   \                     ??create_name_13: (+1)
   \   00000116   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1863          #endif
   1864          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??excvt:
   \   00000000   0x80 0x81          DC8 128, 129, 130, 130, 132, 133, 134, 135, 136, 137, 138, 139, 140
   \              0x82 0x82    
   \              0x84 0x85    
   \              0x86 0x87    
   \              0x88 0x89    
   \              0x8A 0x8B    
   \              0x8C         
   \   0000000D   0x8D 0x8E          DC8 141, 142, 143, 128, 145, 146, 147, 148, 149, 150, 151, 152, 153
   \              0x8F 0x80    
   \              0x91 0x92    
   \              0x93 0x94    
   \              0x95 0x96    
   \              0x97 0x98    
   \              0x99         
   \   0000001A   0x8A 0x9B          DC8 138, 155, 140, 141, 142, 143, 160, 162, 162, 163, 164, 165, 166
   \              0x8C 0x8D    
   \              0x8E 0x8F    
   \              0xA0 0xA2    
   \              0xA2 0xA3    
   \              0xA4 0xA5    
   \              0xA6         
   \   00000027   0xA7 0xA8          DC8 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 178
   \              0xA9 0xAA    
   \              0xAB 0xAC    
   \              0xAD 0xAE    
   \              0xAF 0xB0    
   \              0xB1 0xB2    
   \              0xB2         
   \   00000034   0xA5 0xB5          DC8 165, 181, 182, 183, 168, 185, 170, 187, 163, 189, 189, 175, 192
   \              0xB6 0xB7    
   \              0xA8 0xB9    
   \              0xAA 0xBB    
   \              0xA3 0xBD    
   \              0xBD 0xAF    
   \              0xC0         
   \   00000041   0xC1 0xC2          DC8 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205
   \              0xC3 0xC4    
   \              0xC5 0xC6    
   \              0xC7 0xC8    
   \              0xC9 0xCA    
   \              0xCB 0xCC    
   \              0xCD         
   \   0000004E   0xCE 0xCF          DC8 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218
   \              0xD0 0xD1    
   \              0xD2 0xD3    
   \              0xD4 0xD5    
   \              0xD6 0xD7    
   \              0xD8 0xD9    
   \              0xDA         
   \   0000005B   0xDB 0xDC          DC8 219, 220, 221, 222, 223, 192, 193, 194, 195, 196, 197, 198, 199
   \              0xDD 0xDE    
   \              0xDF 0xC0    
   \              0xC1 0xC2    
   \              0xC3 0xC4    
   \              0xC5 0xC6    
   \              0xC7         
   \   00000068   0xC8 0xC9          DC8 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212
   \              0xCA 0xCB    
   \              0xCC 0xCD    
   \              0xCE 0xCF    
   \              0xD0 0xD1    
   \              0xD2 0xD3    
   \              0xD4         
   \   00000075   0xD5 0xD6          DC8 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223
   \              0xD7 0xD8    
   \              0xD9 0xDA    
   \              0xDB 0xDC    
   \              0xDD 0xDE    
   \              0xDF         
   1865          
   1866          
   1867          
   1868          
   1869          /*-----------------------------------------------------------------------*/
   1870          /* Get file information from directory entry                             */
   1871          /*-----------------------------------------------------------------------*/
   1872          #if _FS_MINIMIZE <= 1

   \                                 In section .text, align 2, keep-with-next
   1873          static
   1874          void get_fileinfo (		/* No return code */
   1875          	DIR *dj,			/* Pointer to the directory object */
   1876          	FILINFO *fno	 	/* Pointer to the file information to be filled */
   1877          )
   1878          {
   \                     _Z12get_fileinfoP3DIRP7FILINFO: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1879          	UINT i;
   1880          	BYTE nt, *dir;
   1881          	TCHAR *p, c;
   1882          
   1883          
   1884          	p = fno->fname;
   \   00000002   0xF101 0x0209      ADD      R2,R1,#+9
   1885          	if (dj->sect) {
   \   00000006   0x6903             LDR      R3,[R0, #+16]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD035             BEQ.N    ??get_fileinfo_0
   1886          		dir = dj->dir;
   \   0000000C   0x6940             LDR      R0,[R0, #+20]
   1887          		nt = dir[DIR_NTres];		/* NT flag */
   1888          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0xE005             B.N      ??get_fileinfo_1
   1889          			c = dir[i];
   1890          			if (c == ' ') break;
   1891          			if (c == NDDE) c = (TCHAR)DDE;
   \                     ??get_fileinfo_2: (+1)
   \   00000012   0x2C05             CMP      R4,#+5
   \   00000014   0xD100             BNE.N    ??get_fileinfo_3
   \   00000016   0x25E5             MOVS     R5,#+229
   1892          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
   1893          #if _LFN_UNICODE
   1894          			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   1895          				c = (c << 8) | dir[++i];
   1896          			c = ff_convert(c, 1);
   1897          			if (!c) c = '?';
   1898          #endif
   1899          			*p++ = c;
   \                     ??get_fileinfo_3: (+1)
   \   00000018   0xF802 0x5B01      STRB     R5,[R2], #+1
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??get_fileinfo_1: (+1)
   \   0000001E   0x2B08             CMP      R3,#+8
   \   00000020   0xD203             BCS.N    ??get_fileinfo_4
   \   00000022   0x5C1D             LDRB     R5,[R3, R0]
   \   00000024   0x462C             MOV      R4,R5
   \   00000026   0x2C20             CMP      R4,#+32
   \   00000028   0xD1F3             BNE.N    ??get_fileinfo_2
   1900          		}
   1901          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_4: (+1)
   \   0000002A   0x7A03             LDRB     R3,[R0, #+8]
   \   0000002C   0x2B20             CMP      R3,#+32
   \   0000002E   0xD00C             BEQ.N    ??get_fileinfo_5
   1902          			*p++ = '.';
   \   00000030   0x232E             MOVS     R3,#+46
   \   00000032   0xF802 0x3B01      STRB     R3,[R2], #+1
   1903          			for (i = 8; i < 11; i++) {
   \   00000036   0x2308             MOVS     R3,#+8
   \   00000038   0xE002             B.N      ??get_fileinfo_6
   1904          				c = dir[i];
   1905          				if (c == ' ') break;
   1906          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   1907          #if _LFN_UNICODE
   1908          				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   1909          					c = (c << 8) | dir[++i];
   1910          				c = ff_convert(c, 1);
   1911          				if (!c) c = '?';
   1912          #endif
   1913          				*p++ = c;
   \                     ??get_fileinfo_7: (+1)
   \   0000003A   0xF802 0x5B01      STRB     R5,[R2], #+1
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??get_fileinfo_6: (+1)
   \   00000040   0x2B0B             CMP      R3,#+11
   \   00000042   0xD202             BCS.N    ??get_fileinfo_5
   \   00000044   0x5C1D             LDRB     R5,[R3, R0]
   \   00000046   0x2D20             CMP      R5,#+32
   \   00000048   0xD1F7             BNE.N    ??get_fileinfo_7
   1914          			}
   1915          		}
   1916          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_5: (+1)
   \   0000004A   0x7AC3             LDRB     R3,[R0, #+11]
   \   0000004C   0x720B             STRB     R3,[R1, #+8]
   1917          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   0000004E   0x7FC3             LDRB     R3,[R0, #+31]
   \   00000050   0x7F84             LDRB     R4,[R0, #+30]
   \   00000052   0x0424             LSLS     R4,R4,#+16
   \   00000054   0xEA44 0x6303      ORR      R3,R4,R3, LSL #+24
   \   00000058   0x7F44             LDRB     R4,[R0, #+29]
   \   0000005A   0xEA43 0x2304      ORR      R3,R3,R4, LSL #+8
   \   0000005E   0x7F04             LDRB     R4,[R0, #+28]
   \   00000060   0x4323             ORRS     R3,R4,R3
   \   00000062   0x600B             STR      R3,[R1, #+0]
   1918          		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   00000064   0x7E43             LDRB     R3,[R0, #+25]
   \   00000066   0x7E04             LDRB     R4,[R0, #+24]
   \   00000068   0xEA44 0x2303      ORR      R3,R4,R3, LSL #+8
   \   0000006C   0x808B             STRH     R3,[R1, #+4]
   1919          		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   0000006E   0x7DC3             LDRB     R3,[R0, #+23]
   \   00000070   0x7D80             LDRB     R0,[R0, #+22]
   \   00000072   0xEA40 0x2003      ORR      R0,R0,R3, LSL #+8
   \   00000076   0x80C8             STRH     R0,[R1, #+6]
   1920          	}
   1921          	*p = 0;		/* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_0: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x7010             STRB     R0,[R2, #+0]
   1922          
   1923          #if _USE_LFN
   1924          	if (fno->lfname && fno->lfsize) {
   1925          		TCHAR *tp = fno->lfname;
   1926          		WCHAR w, *lfn;
   1927          
   1928          		i = 0;
   1929          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   1930          			lfn = dj->lfn;
   1931          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   1932          #if !_LFN_UNICODE
   1933          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   1934          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   1935          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   1936          					tp[i++] = (TCHAR)(w >> 8);
   1937          #endif
   1938          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   1939          				tp[i++] = (TCHAR)w;
   1940          			}
   1941          		}
   1942          		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   1943          	}
   1944          #endif
   1945          }
   \   0000007C   0xBC30             POP      {R4,R5}
   \   0000007E   0x4770             BX       LR               ;; return
   1946          #endif /* _FS_MINIMIZE <= 1 */
   1947          
   1948          
   1949          
   1950          
   1951          /*-----------------------------------------------------------------------*/
   1952          /* Follow a file path                                                    */
   1953          /*-----------------------------------------------------------------------*/
   1954          

   \                                 In section .text, align 2, keep-with-next
   1955          static
   1956          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   1957          	DIR *dj,			/* Directory object to return last directory and found object */
   1958          	const TCHAR *path	/* Full-path string to find a file or directory */
   1959          )
   1960          {
   \                     _Z11follow_pathP3DIRPKc: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1961          	FRESULT res;
   1962          	BYTE *dir, ns;
   1963          
   1964          
   1965          #if _FS_RPATH
   1966          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   1967          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   1968          	} else {							/* No heading separator */
   1969          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   1970          	}
   1971          #else
   1972          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   \   00000004   0x4608             MOV      R0,R1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xD001             BEQ.N    ??follow_path_0
   \   0000000C   0x285C             CMP      R0,#+92
   \   0000000E   0xD102             BNE.N    ??follow_path_1
   1973          		path++;
   \                     ??follow_path_0: (+1)
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x9001             STR      R0,[SP, #+4]
   1974          	dj->sclust = 0;						/* Start from the root dir */
   \                     ??follow_path_1: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x60A0             STR      R0,[R4, #+8]
   1975          #endif
   1976          
   1977          	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
   \   0000001A   0x9801             LDR      R0,[SP, #+4]
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2820             CMP      R0,#+32
   \   00000020   0xD20A             BCS.N    ??follow_path_2
   1978          		res = dir_sdi(dj, 0);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _Z7dir_sdiP3DIRt
   1979          		dj->dir = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x6161             STR      R1,[R4, #+20]
   \   0000002E   0xBD16             POP      {R1,R2,R4,PC}
   1980          	} else {							/* Follow path */
   1981          		for (;;) {
   1982          			res = create_name(dj, &path);	/* Get a segment */
   1983          			if (res != FR_OK) break;
   1984          			res = dir_find(dj);				/* Find it */
   1985          			ns = *(dj->fn+NS);
   1986          			if (res != FR_OK) {				/* Failed to find the object */
   1987          				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
   1988          				/* Object not found */
   1989          				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
   1990          					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
   1991          					res = FR_OK;
   1992          					if (!(ns & NS_LAST)) continue;
   1993          				} else {							/* Could not find the object */
   1994          					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   1995          				}
   1996          				break;
   1997          			}
   1998          			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
   1999          			dir = dj->dir;						/* There is next segment. Follow the sub directory */
   2000          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   2001          				res = FR_NO_PATH; break;
   2002          			}
   2003          			dj->sclust = ld_clust(dj->fs, dir);
   \                     ??follow_path_3: (+1)
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x.... 0x....      BL       _Z8ld_clustP5FATFSPh
   \   00000036   0x60A0             STR      R0,[R4, #+8]
   \                     ??follow_path_2: (+1)
   \   00000038   0xA901             ADD      R1,SP,#+4
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _Z11create_nameP3DIRPPKc
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD113             BNE.N    ??follow_path_4
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       _Z8dir_findP3DIR
   \   0000004A   0x69A1             LDR      R1,[R4, #+24]
   \   0000004C   0x7AC9             LDRB     R1,[R1, #+11]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD005             BEQ.N    ??follow_path_5
   \   00000052   0x2804             CMP      R0,#+4
   \   00000054   0xD10A             BNE.N    ??follow_path_4
   \   00000056   0x0749             LSLS     R1,R1,#+29
   \   00000058   0xD408             BMI.N    ??follow_path_4
   \   0000005A   0x2005             MOVS     R0,#+5
   \   0000005C   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??follow_path_5: (+1)
   \   0000005E   0x0749             LSLS     R1,R1,#+29
   \   00000060   0xD404             BMI.N    ??follow_path_4
   \   00000062   0x6961             LDR      R1,[R4, #+20]
   \   00000064   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000066   0x06C0             LSLS     R0,R0,#+27
   \   00000068   0xD4E2             BMI.N    ??follow_path_3
   \   0000006A   0x2005             MOVS     R0,#+5
   2004          		}
   2005          	}
   2006          
   2007          	return res;
   \                     ??follow_path_4: (+1)
   \   0000006C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   2008          }
   2009          
   2010          
   2011          
   2012          
   2013          /*-----------------------------------------------------------------------*/
   2014          /* Load a sector and check if it is an FAT Volume Boot Record            */
   2015          /*-----------------------------------------------------------------------*/
   2016          

   \                                 In section .text, align 2, keep-with-next
   2017          static
   2018          BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
   2019          	FATFS *fs,	/* File system object */
   2020          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2021          )
   2022          {
   \                     _Z8check_fsP5FATFSm: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2023          	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x460A             MOV      R2,R1
   \   00000008   0xF104 0x0130      ADD      R1,R4,#+48
   \   0000000C   0x7860             LDRB     R0,[R4, #+1]
   \   0000000E   0x.... 0x....      BL       disk_read
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??check_fs_0
   2024          		return 3;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xBD10             POP      {R4,PC}
   2025          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0: (+1)
   \   0000001A   0xF204 0x202E      ADDW     R0,R4,#+558
   \   0000001E   0x7841             LDRB     R1,[R0, #+1]
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000026   0xF64A 0x2155      MOVW     R1,#+43605
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD001             BEQ.N    ??check_fs_1
   2026          		return 2;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xBD10             POP      {R4,PC}
   2027          
   2028          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_1: (+1)
   \   00000032   0xF104 0x0066      ADD      R0,R4,#+102
   \   00000036   0x....             LDR.N    R1,??DataTable11  ;; 0x544146
   \   00000038   0x7882             LDRB     R2,[R0, #+2]
   \   0000003A   0x7843             LDRB     R3,[R0, #+1]
   \   0000003C   0x021B             LSLS     R3,R3,#+8
   \   0000003E   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   00000042   0x7803             LDRB     R3,[R0, #+0]
   \   00000044   0x431A             ORRS     R2,R3,R2
   \   00000046   0x428A             CMP      R2,R1
   \   00000048   0xD101             BNE.N    ??check_fs_2
   2029          		return 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD10             POP      {R4,PC}
   2030          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_2: (+1)
   \   0000004E   0x7F82             LDRB     R2,[R0, #+30]
   \   00000050   0x7F43             LDRB     R3,[R0, #+29]
   \   00000052   0x021B             LSLS     R3,R3,#+8
   \   00000054   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   00000058   0x7F00             LDRB     R0,[R0, #+28]
   \   0000005A   0x4310             ORRS     R0,R0,R2
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD101             BNE.N    ??check_fs_3
   2031          		return 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xBD10             POP      {R4,PC}
   2032          
   2033          	return 1;
   \                     ??check_fs_3: (+1)
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xBD10             POP      {R4,PC}          ;; return
   2034          }
   2035          
   2036          
   2037          
   2038          
   2039          /*-----------------------------------------------------------------------*/
   2040          /* Check if the file system object is valid or not                       */
   2041          /*-----------------------------------------------------------------------*/
   2042          

   \                                 In section .text, align 2, keep-with-next
   2043          static
   2044          FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
   2045          	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
   2046          	FATFS **rfs,		/* Pointer to pointer to the found file system object */
   2047          	BYTE wmode			/* !=0: Check write protection for write access */
   2048          )
   2049          {
   \                     _Z11chk_mountedPPKcPP5FATFSh: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4616             MOV      R6,R2
   2050          	BYTE fmt, b, pi, *tbl;
   2051          	UINT vol;
   2052          	DSTATUS stat;
   2053          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
   2054          	WORD nrsv;
   2055          	const TCHAR *p = *path;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   2056          	FATFS *fs;
   2057          
   2058          
   2059          	/* Get logical drive number from the path name */
   2060          	vol = p[0] - '0';					/* Is there a drive number? */
   \   00000008   0x7813             LDRB     R3,[R2, #+0]
   \   0000000A   0x3B30             SUBS     R3,R3,#+48
   2061          	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   \   0000000C   0x2B0A             CMP      R3,#+10
   \   0000000E   0xD205             BCS.N    ??chk_mounted_0
   \   00000010   0x7854             LDRB     R4,[R2, #+1]
   \   00000012   0x2C3A             CMP      R4,#+58
   \   00000014   0xD102             BNE.N    ??chk_mounted_0
   2062          		p += 2; *path = p;				/* Return pointer to the path name */
   \   00000016   0x1C92             ADDS     R2,R2,#+2
   \   00000018   0x6002             STR      R2,[R0, #+0]
   \   0000001A   0xE000             B.N      ??chk_mounted_1
   2063          	} else {							/* No drive number is given */
   2064          #if _FS_RPATH
   2065          		vol = CurrVol;					/* Use current drive */
   2066          #else
   2067          		vol = 0;						/* Use drive 0 */
   \                     ??chk_mounted_0: (+1)
   \   0000001C   0x2300             MOVS     R3,#+0
   2068          #endif
   2069          	}
   2070          
   2071          	/* Check if the file system object is valid or not */
   2072          	*rfs = 0;
   \                     ??chk_mounted_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6008             STR      R0,[R1, #+0]
   2073          	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD001             BEQ.N    ??chk_mounted_2
   2074          		return FR_INVALID_DRIVE;
   \   00000026   0x200B             MOVS     R0,#+11
   \   00000028   0xE145             B.N      ??chk_mounted_3
   2075          	fs = FatFs[vol];					/* Get corresponding file system object */
   \                     ??chk_mounted_2: (+1)
   \   0000002A   0x....             LDR.N    R4,??DataTable11_1
   \   0000002C   0x6865             LDR      R5,[R4, #+4]
   2076          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD101             BNE.N    ??chk_mounted_4
   \   00000032   0x200C             MOVS     R0,#+12
   \   00000034   0xE13F             B.N      ??chk_mounted_3
   2077          
   2078          	ENTER_FF(fs);						/* Lock file system */
   2079          
   2080          	*rfs = fs;							/* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_4: (+1)
   \   00000036   0x600D             STR      R5,[R1, #+0]
   2081          	if (fs->fs_type) {					/* If the volume has been mounted */
   \   00000038   0x7828             LDRB     R0,[R5, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD00B             BEQ.N    ??chk_mounted_5
   2082          		stat = disk_status(fs->drv);
   \   0000003E   0x7868             LDRB     R0,[R5, #+1]
   \   00000040   0x.... 0x....      BL       disk_status
   2083          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x07C9             LSLS     R1,R1,#+31
   \   00000048   0xD405             BMI.N    ??chk_mounted_5
   2084          			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   0000004A   0x2E00             CMP      R6,#+0
   \   0000004C   0xD001             BEQ.N    ??chk_mounted_6
   \   0000004E   0x0740             LSLS     R0,R0,#+29
   \   00000050   0xD40F             BMI.N    ??chk_mounted_7
   2085          				return FR_WRITE_PROTECTED;
   2086          			return FR_OK;				/* The file system object is valid */
   \                     ??chk_mounted_6: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE12F             B.N      ??chk_mounted_3
   2087          		}
   2088          	}
   2089          
   2090          	/* The file system object is not valid. */
   2091          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2092          
   2093          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_5: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x7028             STRB     R0,[R5, #+0]
   2094          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   0000005A   0x7068             STRB     R0,[R5, #+1]
   2095          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   \   0000005C   0x.... 0x....      BL       disk_initialize
   2096          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   00000060   0x4601             MOV      R1,R0
   \   00000062   0x07C9             LSLS     R1,R1,#+31
   \   00000064   0xD501             BPL.N    ??chk_mounted_8
   2097          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0xE125             B.N      ??chk_mounted_3
   2098          	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_8: (+1)
   \   0000006A   0x2E00             CMP      R6,#+0
   \   0000006C   0xD003             BEQ.N    ??chk_mounted_9
   \   0000006E   0x0740             LSLS     R0,R0,#+29
   \   00000070   0xD501             BPL.N    ??chk_mounted_9
   2099          		return FR_WRITE_PROTECTED;
   \                     ??chk_mounted_7: (+1)
   \   00000072   0x200A             MOVS     R0,#+10
   \   00000074   0xE11F             B.N      ??chk_mounted_3
   2100          #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
   2101          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2102          		return FR_DISK_ERR;
   2103          #endif
   2104          	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
   2105          	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   \                     ??chk_mounted_9: (+1)
   \   00000076   0x2600             MOVS     R6,#+0
   \   00000078   0x4631             MOV      R1,R6
   \   0000007A   0x4628             MOV      R0,R5
   \   0000007C   0x.... 0x....      BL       _Z8check_fsP5FATFSm
   \   00000080   0x4680             MOV      R8,R0
   2106          	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
   2107          	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   \   00000082   0xF1B8 0x0F01      CMP      R8,#+1
   \   00000086   0xD114             BNE.N    ??chk_mounted_10
   2108          		/* Check the partition listed in the partition table */
   2109          		pi = LD2PT(vol);
   2110          		if (pi) pi--;
   2111          		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
   \   00000088   0xF505 0x70F7      ADD      R0,R5,#+494
   2112          		if (tbl[4]) {						/* Is the partition existing? */
   \   0000008C   0x7901             LDRB     R1,[R0, #+4]
   \   0000008E   0x2900             CMP      R1,#+0
   \   00000090   0xD00F             BEQ.N    ??chk_mounted_10
   2113          			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   \   00000092   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000094   0x7A82             LDRB     R2,[R0, #+10]
   \   00000096   0x0412             LSLS     R2,R2,#+16
   \   00000098   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   0000009C   0x7A42             LDRB     R2,[R0, #+9]
   \   0000009E   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   000000A2   0x7A00             LDRB     R0,[R0, #+8]
   \   000000A4   0xEA40 0x0601      ORR      R6,R0,R1
   2114          			fmt = check_fs(fs, bsect);		/* Check the partition */
   \   000000A8   0x4631             MOV      R1,R6
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       _Z8check_fsP5FATFSm
   \   000000B0   0x4680             MOV      R8,R0
   2115          		}
   2116          	}
   2117          	if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_10: (+1)
   \   000000B2   0xF1B8 0x0F03      CMP      R8,#+3
   \   000000B6   0xD101             BNE.N    ??chk_mounted_11
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xE0FC             B.N      ??chk_mounted_3
   2118          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??chk_mounted_11: (+1)
   \   000000BC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C0   0xF040 0x8098      BNE.W    ??chk_mounted_12
   2119          
   2120          	/* An FAT volume is found. Following code initializes the file system object */
   2121          
   2122          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \   000000C4   0xF105 0x0730      ADD      R7,R5,#+48
   \   000000C8   0x7B38             LDRB     R0,[R7, #+12]
   \   000000CA   0x7AF9             LDRB     R1,[R7, #+11]
   \   000000CC   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   000000D0   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000D4   0xF040 0x808E      BNE.W    ??chk_mounted_12
   2123          		return FR_NO_FILESYSTEM;
   2124          
   2125          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \   000000D8   0x7DF8             LDRB     R0,[R7, #+23]
   \   000000DA   0x7DB9             LDRB     R1,[R7, #+22]
   \   000000DC   0xEA51 0x2000      ORRS     R0,R1,R0, LSL #+8
   2126          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   000000E0   0xD10B             BNE.N    ??chk_mounted_13
   \   000000E2   0xF105 0x0150      ADD      R1,R5,#+80
   \   000000E6   0x79C8             LDRB     R0,[R1, #+7]
   \   000000E8   0x798A             LDRB     R2,[R1, #+6]
   \   000000EA   0x0412             LSLS     R2,R2,#+16
   \   000000EC   0xEA42 0x6000      ORR      R0,R2,R0, LSL #+24
   \   000000F0   0x794A             LDRB     R2,[R1, #+5]
   \   000000F2   0xEA40 0x2002      ORR      R0,R0,R2, LSL #+8
   \   000000F6   0x7909             LDRB     R1,[R1, #+4]
   \   000000F8   0x4308             ORRS     R0,R1,R0
   2127          	fs->fsize = fasize;
   \                     ??chk_mounted_13: (+1)
   \   000000FA   0x61E8             STR      R0,[R5, #+28]
   2128          
   2129          	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   \   000000FC   0x7C39             LDRB     R1,[R7, #+16]
   \   000000FE   0x70E9             STRB     R1,[R5, #+3]
   2130          	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   \   00000100   0x2901             CMP      R1,#+1
   \   00000102   0xD001             BEQ.N    ??chk_mounted_14
   \   00000104   0x2902             CMP      R1,#+2
   \   00000106   0xD175             BNE.N    ??chk_mounted_12
   2131          	fasize *= b;										/* Number of sectors for FAT area */
   \                     ??chk_mounted_14: (+1)
   \   00000108   0x4348             MULS     R0,R1,R0
   2132          
   2133          	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   \   0000010A   0x7B79             LDRB     R1,[R7, #+13]
   \   0000010C   0x70A9             STRB     R1,[R5, #+2]
   2134          	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   \   0000010E   0x2900             CMP      R1,#+0
   \   00000110   0xD070             BEQ.N    ??chk_mounted_12
   \   00000112   0x1E4A             SUBS     R2,R1,#+1
   \   00000114   0x4211             TST      R1,R2
   \   00000116   0xD16D             BNE.N    ??chk_mounted_12
   2135          
   2136          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   \   00000118   0x7CB9             LDRB     R1,[R7, #+18]
   \   0000011A   0x7C7A             LDRB     R2,[R7, #+17]
   \   0000011C   0xEA42 0x2201      ORR      R2,R2,R1, LSL #+8
   \   00000120   0x812A             STRH     R2,[R5, #+8]
   2137          	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   \   00000122   0x210F             MOVS     R1,#+15
   \   00000124   0x420A             TST      R2,R1
   \   00000126   0xD165             BNE.N    ??chk_mounted_12
   2138          
   2139          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \   00000128   0x7D39             LDRB     R1,[R7, #+20]
   \   0000012A   0x7CFB             LDRB     R3,[R7, #+19]
   \   0000012C   0xEA53 0x2301      ORRS     R3,R3,R1, LSL #+8
   2140          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   00000130   0xD10E             BNE.N    ??chk_mounted_15
   \   00000132   0xF105 0x0150      ADD      R1,R5,#+80
   \   00000136   0x78CB             LDRB     R3,[R1, #+3]
   \   00000138   0xF891 0xC002      LDRB     R12,[R1, #+2]
   \   0000013C   0xEA4F 0x4C0C      LSL      R12,R12,#+16
   \   00000140   0xEA4C 0x6303      ORR      R3,R12,R3, LSL #+24
   \   00000144   0xF891 0xC001      LDRB     R12,[R1, #+1]
   \   00000148   0xEA43 0x230C      ORR      R3,R3,R12, LSL #+8
   \   0000014C   0x7809             LDRB     R1,[R1, #+0]
   \   0000014E   0x430B             ORRS     R3,R1,R3
   2141          
   2142          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??chk_mounted_15: (+1)
   \   00000150   0x7BF9             LDRB     R1,[R7, #+15]
   \   00000152   0xF897 0xC00E      LDRB     R12,[R7, #+14]
   \   00000156   0xEA5C 0x2101      ORRS     R1,R12,R1, LSL #+8
   2143          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   \   0000015A   0xD04B             BEQ.N    ??chk_mounted_12
   2144          
   2145          	/* Determine the FAT sub type */
   2146          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   \   0000015C   0xEB00 0x0C01      ADD      R12,R0,R1
   \   00000160   0xEB0C 0x1212      ADD      R2,R12,R2, LSR #+4
   2147          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   00000164   0x4293             CMP      R3,R2
   \   00000166   0xD345             BCC.N    ??chk_mounted_12
   2148          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \   00000168   0x1A9B             SUBS     R3,R3,R2
   \   0000016A   0xF895 0xC002      LDRB     R12,[R5, #+2]
   \   0000016E   0xFBB3 0xF3FC      UDIV     R3,R3,R12
   2149          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   00000172   0x2B00             CMP      R3,#+0
   \   00000174   0xD03E             BEQ.N    ??chk_mounted_12
   2150          	fmt = FS_FAT12;
   \   00000176   0xF04F 0x0801      MOV      R8,#+1
   2151          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   0000017A   0xF640 0x7CF6      MOVW     R12,#+4086
   \   0000017E   0x4563             CMP      R3,R12
   \   00000180   0xD301             BCC.N    ??chk_mounted_16
   \   00000182   0xF04F 0x0802      MOV      R8,#+2
   2152          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??chk_mounted_16: (+1)
   \   00000186   0xF64F 0x7CF6      MOVW     R12,#+65526
   \   0000018A   0x4563             CMP      R3,R12
   \   0000018C   0xD301             BCC.N    ??chk_mounted_17
   \   0000018E   0xF04F 0x0803      MOV      R8,#+3
   2153          
   2154          	/* Boundaries and Limits */
   2155          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??chk_mounted_17: (+1)
   \   00000192   0x1C9B             ADDS     R3,R3,#+2
   \   00000194   0x61AB             STR      R3,[R5, #+24]
   2156          	fs->database = bsect + sysect;						/* Data start sector */
   \   00000196   0x1992             ADDS     R2,R2,R6
   \   00000198   0x62AA             STR      R2,[R5, #+40]
   2157          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   0000019A   0x1989             ADDS     R1,R1,R6
   \   0000019C   0x6229             STR      R1,[R5, #+32]
   2158          	if (fmt == FS_FAT32) {
   \   0000019E   0x892B             LDRH     R3,[R5, #+8]
   \   000001A0   0x4642             MOV      R2,R8
   \   000001A2   0x2A03             CMP      R2,#+3
   \   000001A4   0xD111             BNE.N    ??chk_mounted_18
   2159          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   000001A6   0x2B00             CMP      R3,#+0
   \   000001A8   0xD124             BNE.N    ??chk_mounted_12
   2160          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \   000001AA   0xF105 0x0150      ADD      R1,R5,#+80
   \   000001AE   0x7BC8             LDRB     R0,[R1, #+15]
   \   000001B0   0x7B8B             LDRB     R3,[R1, #+14]
   \   000001B2   0x041B             LSLS     R3,R3,#+16
   \   000001B4   0xEA43 0x6000      ORR      R0,R3,R0, LSL #+24
   \   000001B8   0x7B4B             LDRB     R3,[R1, #+13]
   \   000001BA   0xEA40 0x2003      ORR      R0,R0,R3, LSL #+8
   \   000001BE   0x7B09             LDRB     R1,[R1, #+12]
   \   000001C0   0x4308             ORRS     R0,R1,R0
   \   000001C2   0x6268             STR      R0,[R5, #+36]
   2161          		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   \   000001C4   0x69A8             LDR      R0,[R5, #+24]
   \   000001C6   0x0080             LSLS     R0,R0,#+2
   \   000001C8   0xE00E             B.N      ??chk_mounted_19
   2162          	} else {
   2163          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_18: (+1)
   \   000001CA   0x2B00             CMP      R3,#+0
   \   000001CC   0xD012             BEQ.N    ??chk_mounted_12
   2164          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \   000001CE   0x1840             ADDS     R0,R0,R1
   \   000001D0   0x6268             STR      R0,[R5, #+36]
   2165          		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
   2166          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   000001D2   0x69A8             LDR      R0,[R5, #+24]
   \   000001D4   0x2A02             CMP      R2,#+2
   \   000001D6   0xD101             BNE.N    ??chk_mounted_20
   \   000001D8   0x0040             LSLS     R0,R0,#+1
   \   000001DA   0xE005             B.N      ??chk_mounted_19
   \                     ??chk_mounted_20: (+1)
   \   000001DC   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   000001E0   0xF000 0x0001      AND      R0,R0,#0x1
   \   000001E4   0xEB00 0x0051      ADD      R0,R0,R1, LSR #+1
   2167          	}
   2168          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   \                     ??chk_mounted_19: (+1)
   \   000001E8   0x69E9             LDR      R1,[R5, #+28]
   \   000001EA   0xF200 0x10FF      ADDW     R0,R0,#+511
   \   000001EE   0xEBB1 0x2F50      CMP      R1,R0, LSR #+9
   \   000001F2   0xD201             BCS.N    ??chk_mounted_21
   2169          		return FR_NO_FILESYSTEM;
   \                     ??chk_mounted_12: (+1)
   \   000001F4   0x200D             MOVS     R0,#+13
   \   000001F6   0xE05E             B.N      ??chk_mounted_3
   2170          
   2171          #if !_FS_READONLY
   2172          	/* Initialize cluster allocation information */
   2173          	fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_21: (+1)
   \   000001F8   0xF04F 0x30FF      MOV      R0,#-1
   \   000001FC   0x6128             STR      R0,[R5, #+16]
   2174          	fs->last_clust = 0;
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x60E8             STR      R0,[R5, #+12]
   2175          
   2176          	/* Get fsinfo if available */
   2177          	if (fmt == FS_FAT32) {
   \   00000202   0x2A03             CMP      R2,#+3
   \   00000204   0xD14A             BNE.N    ??chk_mounted_22
   2178          	 	fs->fsi_flag = 0;
   \   00000206   0x7168             STRB     R0,[R5, #+5]
   2179          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   00000208   0xF105 0x0150      ADD      R1,R5,#+80
   \   0000020C   0x7C48             LDRB     R0,[R1, #+17]
   \   0000020E   0x7C09             LDRB     R1,[R1, #+16]
   \   00000210   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000214   0xFA16 0xF280      UXTAH    R2,R6,R0
   \   00000218   0x616A             STR      R2,[R5, #+20]
   2180          		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2181          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2182          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2183          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   0000021A   0x2301             MOVS     R3,#+1
   \   0000021C   0x4639             MOV      R1,R7
   \   0000021E   0x7868             LDRB     R0,[R5, #+1]
   \   00000220   0x.... 0x....      BL       disk_read
   \   00000224   0x2800             CMP      R0,#+0
   \   00000226   0xD139             BNE.N    ??chk_mounted_22
   \   00000228   0xF505 0x7005      ADD      R0,R5,#+532
   \   0000022C   0x7EC1             LDRB     R1,[R0, #+27]
   \   0000022E   0x7E82             LDRB     R2,[R0, #+26]
   \   00000230   0xEA42 0x2101      ORR      R1,R2,R1, LSL #+8
   \   00000234   0xF64A 0x2255      MOVW     R2,#+43605
   \   00000238   0x4291             CMP      R1,R2
   \   0000023A   0xD12F             BNE.N    ??chk_mounted_22
   \   0000023C   0x78F9             LDRB     R1,[R7, #+3]
   \   0000023E   0x78BA             LDRB     R2,[R7, #+2]
   \   00000240   0x0412             LSLS     R2,R2,#+16
   \   00000242   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000246   0x787A             LDRB     R2,[R7, #+1]
   \   00000248   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   0000024C   0x783A             LDRB     R2,[R7, #+0]
   \   0000024E   0x4311             ORRS     R1,R2,R1
   \   00000250   0x....             LDR.N    R2,??DataTable11_2  ;; 0x41615252
   \   00000252   0x4291             CMP      R1,R2
   \   00000254   0xD122             BNE.N    ??chk_mounted_22
   \   00000256   0x78C1             LDRB     R1,[R0, #+3]
   \   00000258   0x7882             LDRB     R2,[R0, #+2]
   \   0000025A   0x0412             LSLS     R2,R2,#+16
   \   0000025C   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000260   0x7842             LDRB     R2,[R0, #+1]
   \   00000262   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000266   0x7802             LDRB     R2,[R0, #+0]
   \   00000268   0x4311             ORRS     R1,R2,R1
   \   0000026A   0x....             LDR.N    R2,??DataTable11_3  ;; 0x61417272
   \   0000026C   0x4291             CMP      R1,R2
   \   0000026E   0xD115             BNE.N    ??chk_mounted_22
   2184          				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   00000270   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000272   0x7A82             LDRB     R2,[R0, #+10]
   \   00000274   0x0412             LSLS     R2,R2,#+16
   \   00000276   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   0000027A   0x7A42             LDRB     R2,[R0, #+9]
   \   0000027C   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000280   0x7A02             LDRB     R2,[R0, #+8]
   \   00000282   0x4311             ORRS     R1,R2,R1
   \   00000284   0x60E9             STR      R1,[R5, #+12]
   2185          				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   00000286   0x79C1             LDRB     R1,[R0, #+7]
   \   00000288   0x7982             LDRB     R2,[R0, #+6]
   \   0000028A   0x0412             LSLS     R2,R2,#+16
   \   0000028C   0xEA42 0x6101      ORR      R1,R2,R1, LSL #+24
   \   00000290   0x7942             LDRB     R2,[R0, #+5]
   \   00000292   0xEA41 0x2102      ORR      R1,R1,R2, LSL #+8
   \   00000296   0x7900             LDRB     R0,[R0, #+4]
   \   00000298   0x4308             ORRS     R0,R0,R1
   \   0000029A   0x6128             STR      R0,[R5, #+16]
   2186          		}
   2187          	}
   2188          #endif
   2189          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_22: (+1)
   \   0000029C   0xF885 0x8000      STRB     R8,[R5, #+0]
   2190          	fs->id = ++Fsid;		/* File system mount ID */
   \   000002A0   0x8820             LDRH     R0,[R4, #+0]
   \   000002A2   0x1C40             ADDS     R0,R0,#+1
   \   000002A4   0x8020             STRH     R0,[R4, #+0]
   \   000002A6   0x80E8             STRH     R0,[R5, #+6]
   2191          	fs->winsect = 0;		/* Invalidate sector cache */
   \   000002A8   0x2000             MOVS     R0,#+0
   \   000002AA   0x62E8             STR      R0,[R5, #+44]
   2192          	fs->wflag = 0;
   \   000002AC   0x7128             STRB     R0,[R5, #+4]
   2193          #if _FS_RPATH
   2194          	fs->cdir = 0;			/* Current directory (root dir) */
   2195          #endif
   2196          #if _FS_LOCK				/* Clear file lock semaphores */
   2197          	clear_lock(fs);
   \   000002AE   0x4628             MOV      R0,R5
   \   000002B0   0x.... 0x....      BL       _Z10clear_lockP5FATFS
   2198          #endif
   2199          
   2200          	return FR_OK;
   \   000002B4   0x2000             MOVS     R0,#+0
   \                     ??chk_mounted_3: (+1)
   \   000002B6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2201          }
   2202          
   2203          
   2204          
   2205          
   2206          /*-----------------------------------------------------------------------*/
   2207          /* Check if the file/dir object is valid or not                          */
   2208          /*-----------------------------------------------------------------------*/
   2209          

   \                                 In section .text, align 2, keep-with-next
   2210          static
   2211          FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
   2212          	void* obj		/* Pointer to the object FIL/DIR to check validity */
   2213          )
   2214          {
   \                     _Z8validatePv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2215          	FIL *fil;
   2216          
   2217          
   2218          	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
   2219          	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD006             BEQ.N    ??validate_0
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD003             BEQ.N    ??validate_0
   \   0000000E   0x88CA             LDRH     R2,[R1, #+6]
   \   00000010   0x8880             LDRH     R0,[R0, #+4]
   \   00000012   0x4282             CMP      R2,R0
   \   00000014   0xD001             BEQ.N    ??validate_1
   2220          		return FR_INVALID_OBJECT;
   \                     ??validate_0: (+1)
   \   00000016   0x2009             MOVS     R0,#+9
   \   00000018   0xBD02             POP      {R1,PC}
   2221          
   2222          	ENTER_FF(fil->fs);		/* Lock file system */
   2223          
   2224          	if (disk_status(fil->fs->drv) & STA_NOINIT)
   \                     ??validate_1: (+1)
   \   0000001A   0x7848             LDRB     R0,[R1, #+1]
   \   0000001C   0x.... 0x....      BL       disk_status
   \   00000020   0x07C0             LSLS     R0,R0,#+31
   \   00000022   0xD501             BPL.N    ??validate_2
   2225          		return FR_NOT_READY;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xBD02             POP      {R1,PC}
   2226          
   2227          	return FR_OK;
   \                     ??validate_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD02             POP      {R1,PC}          ;; return
   2228          }
   2229          
   2230          
   2231          
   2232          
   2233          /*--------------------------------------------------------------------------
   2234          
   2235             Public Functions
   2236          
   2237          --------------------------------------------------------------------------*/
   2238          
   2239          
   2240          
   2241          /*-----------------------------------------------------------------------*/
   2242          /* Mount/Unmount a Logical Drive                                         */
   2243          /*-----------------------------------------------------------------------*/
   2244          

   \                                 In section .text, align 2, keep-with-next
   2245          FRESULT f_mount (
   2246          	BYTE vol,		/* Logical drive number to be mounted/unmounted */
   2247          	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
   2248          )
   2249          {
   \                     f_mount: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   2250          	FATFS *rfs;
   2251          
   2252          
   2253          	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??f_mount_0
   2254          		return FR_INVALID_DRIVE;
   \   00000008   0x200B             MOVS     R0,#+11
   \   0000000A   0xBD70             POP      {R4-R6,PC}
   2255          	rfs = FatFs[vol];			/* Get current fs object */
   \                     ??f_mount_0: (+1)
   \   0000000C   0x....             LDR.N    R5,??DataTable11_1
   \   0000000E   0x686E             LDR      R6,[R5, #+4]
   2256          
   2257          	if (rfs) {
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD004             BEQ.N    ??f_mount_1
   2258          #if _FS_LOCK
   2259          		clear_lock(rfs);
   \   00000014   0x4630             MOV      R0,R6
   \   00000016   0x.... 0x....      BL       _Z10clear_lockP5FATFS
   2260          #endif
   2261          #if _FS_REENTRANT				/* Discard sync object of the current volume */
   2262          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   2263          #endif
   2264          		rfs->fs_type = 0;		/* Clear old fs object */
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7030             STRB     R0,[R6, #+0]
   2265          	}
   2266          
   2267          	if (fs) {
   \                     ??f_mount_1: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD001             BEQ.N    ??f_mount_2
   2268          		fs->fs_type = 0;		/* Clear new fs object */
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x7020             STRB     R0,[R4, #+0]
   2269          #if _FS_REENTRANT				/* Create sync object for the new volume */
   2270          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   2271          #endif
   2272          	}
   2273          	FatFs[vol] = fs;			/* Register new fs object */
   \                     ??f_mount_2: (+1)
   \   00000026   0x606C             STR      R4,[R5, #+4]
   2274          
   2275          	return FR_OK;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
   2276          }
   2277          
   2278          
   2279          
   2280          
   2281          /*-----------------------------------------------------------------------*/
   2282          /* Open or Create a File                                                 */
   2283          /*-----------------------------------------------------------------------*/
   2284          

   \                                 In section .text, align 2, keep-with-next
   2285          FRESULT f_open (
   2286          	FIL *fp,			/* Pointer to the blank file object */
   2287          	const TCHAR *path,	/* Pointer to the file name */
   2288          	BYTE mode			/* Access mode and file open mode flags */
   2289          )
   2290          {
   \                     f_open: (+1)
   \   00000000   0xE92D 0x43F2      PUSH     {R1,R4-R9,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4615             MOV      R5,R2
   2291          	FRESULT res;
   2292          	DIR dj;
   2293          	BYTE *dir;
   2294          	DEF_NAMEBUF;
   2295                  TLcdTrace::AddLine("INSIDE f_open");
   \   0000000A   0x.... 0x....      ADR.W    R0,?_1
   \   0000000E   0x.... 0x....      BL       _ZN9TLcdTrace7AddLineEPKc
   2296          
   2297          
   2298          	if (!fp){ TLcdTrace::AddLine("Pointer error"); return FR_INVALID_OBJECT; }
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD105             BNE.N    ??f_open_0
   \   00000016   0x.... 0x....      ADR.W    R0,?_2
   \   0000001A   0x.... 0x....      BL       _ZN9TLcdTrace7AddLineEPKc
   \   0000001E   0x2009             MOVS     R0,#+9
   \   00000020   0xE0B9             B.N      ??f_open_1
   2299          	fp->fs = 0;			/* Clear file object */
   \                     ??f_open_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6020             STR      R0,[R4, #+0]
   2300          
   2301          #if !_FS_READONLY
   2302          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   00000026   0xF005 0x051F      AND      R5,R5,#0x1F
   2303          	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
   \   0000002A   0xF005 0x02FE      AND      R2,R5,#0xFE
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0xA80A             ADD      R0,SP,#+40
   \   00000032   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   \   00000036   0x0007             MOVS     R7,R0
   2304          #else
   2305          	mode &= FA_READ;
   2306          	res = chk_mounted(&path, &dj.fs, 0);
   2307          #endif
   2308          	if (res == FR_OK) {
   \   00000038   0xF040 0x80AC      BNE.W    ??f_open_2
   2309          		INIT_BUF(dj);
   \   0000003C   0xA807             ADD      R0,SP,#+28
   \   0000003E   0x9006             STR      R0,[SP, #+24]
   2310          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000040   0x990A             LDR      R1,[SP, #+40]
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   \   00000048   0x0007             MOVS     R7,R0
   2311          		dir = dj.dir;
   \   0000004A   0x9E05             LDR      R6,[SP, #+20]
   2312          #if !_FS_READONLY	/* R/W configuration */
   2313          		if (res == FR_OK) {
   \   0000004C   0xD10D             BNE.N    ??f_open_3
   2314          			if (!dir)	/* Current dir itself */
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD101             BNE.N    ??f_open_4
   2315          				res = FR_INVALID_NAME;
   \   00000052   0x2706             MOVS     R7,#+6
   \   00000054   0xE009             B.N      ??f_open_3
   2316          #if _FS_LOCK
   2317          			else
   2318          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   \                     ??f_open_4: (+1)
   \   00000056   0xF005 0x00FE      AND      R0,R5,#0xFE
   \   0000005A   0x1E41             SUBS     R1,R0,#+1
   \   0000005C   0x4189             SBCS     R1,R1,R1
   \   0000005E   0x43C9             MVNS     R1,R1
   \   00000060   0x0FC9             LSRS     R1,R1,#+31
   \   00000062   0xA800             ADD      R0,SP,#+0
   \   00000064   0x.... 0x....      BL       _Z8chk_lockP3DIRi
   \   00000068   0x4607             MOV      R7,R0
   2319          #endif
   2320          		}
   2321          		/* Create or Open a file */
   2322          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_3: (+1)
   \   0000006A   0x201C             MOVS     R0,#+28
   \   0000006C   0x4205             TST      R5,R0
   \   0000006E   0xD053             BEQ.N    ??f_open_5
   2323          			DWORD dw, cl;
   2324          
   2325          			if (res != FR_OK) {					/* No file, create new */
   \   00000070   0x2F00             CMP      R7,#+0
   \   00000072   0xD00F             BEQ.N    ??f_open_6
   2326          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   00000074   0x2F04             CMP      R7,#+4
   \   00000076   0xD109             BNE.N    ??f_open_7
   2327          #if _FS_LOCK
   2328          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   \   00000078   0x.... 0x....      BL       _Z8enq_lockv
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD004             BEQ.N    ??f_open_8
   \   00000080   0xA800             ADD      R0,SP,#+0
   \   00000082   0x.... 0x....      BL       _Z12dir_registerP3DIR
   \   00000086   0x4607             MOV      R7,R0
   \   00000088   0xE000             B.N      ??f_open_7
   \                     ??f_open_8: (+1)
   \   0000008A   0x2712             MOVS     R7,#+18
   2329          #else
   2330          					res = dir_register(&dj);
   2331          #endif
   2332          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_7: (+1)
   \   0000008C   0xF045 0x0508      ORR      R5,R5,#0x8
   2333          				dir = dj.dir;					/* New entry */
   \   00000090   0x9E05             LDR      R6,[SP, #+20]
   \   00000092   0xE008             B.N      ??f_open_9
   2334          			}
   2335          			else {								/* Any object is already existing */
   2336          				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_6: (+1)
   \   00000094   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000096   0x2111             MOVS     R1,#+17
   \   00000098   0x4208             TST      R0,R1
   \   0000009A   0xD001             BEQ.N    ??f_open_10
   2337          					res = FR_DENIED;
   \   0000009C   0x2707             MOVS     R7,#+7
   \   0000009E   0xE002             B.N      ??f_open_9
   2338          				} else {
   2339          					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_10: (+1)
   \   000000A0   0x0768             LSLS     R0,R5,#+29
   \   000000A2   0xD500             BPL.N    ??f_open_9
   2340          						res = FR_EXIST;
   \   000000A4   0x2708             MOVS     R7,#+8
   2341          				}
   2342          			}
   2343          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_9: (+1)
   \   000000A6   0x2F00             CMP      R7,#+0
   \   000000A8   0xD142             BNE.N    ??f_open_11
   \   000000AA   0x0728             LSLS     R0,R5,#+28
   \   000000AC   0xD540             BPL.N    ??f_open_11
   2344          				dw = get_fattime();					/* Created time */
   \   000000AE   0x.... 0x....      BL       get_fattime
   \   000000B2   0x4680             MOV      R8,R0
   2345          				ST_DWORD(dir+DIR_CrtTime, dw);
   \   000000B4   0xF886 0x800E      STRB     R8,[R6, #+14]
   \   000000B8   0xB280             UXTH     R0,R0
   \   000000BA   0x0A00             LSRS     R0,R0,#+8
   \   000000BC   0x73F0             STRB     R0,[R6, #+15]
   \   000000BE   0xEA4F 0x4018      LSR      R0,R8,#+16
   \   000000C2   0x7430             STRB     R0,[R6, #+16]
   \   000000C4   0xEA4F 0x6018      LSR      R0,R8,#+24
   \   000000C8   0x7470             STRB     R0,[R6, #+17]
   2346          				dir[DIR_Attr] = 0;					/* Reset attribute */
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x72F0             STRB     R0,[R6, #+11]
   2347          				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   \   000000CE   0x7730             STRB     R0,[R6, #+28]
   \   000000D0   0x7770             STRB     R0,[R6, #+29]
   \   000000D2   0x77B0             STRB     R0,[R6, #+30]
   \   000000D4   0x77F0             STRB     R0,[R6, #+31]
   2348          				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
   \   000000D6   0x4631             MOV      R1,R6
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   \   000000DA   0x.... 0x....      BL       _Z8ld_clustP5FATFSPh
   \   000000DE   0x4681             MOV      R9,R0
   2349          				st_clust(dir, 0);					/* cluster = 0 */
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x4630             MOV      R0,R6
   \   000000E4   0x.... 0x....      BL       _Z8st_clustPhm
   2350          				dj.fs->wflag = 1;
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0x9900             LDR      R1,[SP, #+0]
   \   000000EC   0x7108             STRB     R0,[R1, #+4]
   2351          				if (cl) {							/* Remove the cluster chain if exist */
   \   000000EE   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000F2   0xD01D             BEQ.N    ??f_open_11
   2352          					dw = dj.fs->winsect;
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0xF8D0 0x802C      LDR      R8,[R0, #+44]
   2353          					res = remove_chain(dj.fs, cl);
   \   000000FA   0x4649             MOV      R1,R9
   \   000000FC   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   00000100   0x0007             MOVS     R7,R0
   2354          					if (res == FR_OK) {
   \   00000102   0xD115             BNE.N    ??f_open_11
   2355          						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   00000104   0xF1A9 0x0001      SUB      R0,R9,#+1
   \   00000108   0x9900             LDR      R1,[SP, #+0]
   \   0000010A   0x60C8             STR      R0,[R1, #+12]
   2356          						res = move_window(dj.fs, dw);
   \   0000010C   0x4641             MOV      R1,R8
   \   0000010E   0x9800             LDR      R0,[SP, #+0]
   \   00000110   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000114   0x4607             MOV      R7,R0
   \   00000116   0xE00B             B.N      ??f_open_11
   2357          					}
   2358          				}
   2359          			}
   2360          		}
   2361          		else {	/* Open an existing file */
   2362          			if (res == FR_OK) {						/* Follow succeeded */
   \                     ??f_open_5: (+1)
   \   00000118   0x2F00             CMP      R7,#+0
   \   0000011A   0xD109             BNE.N    ??f_open_11
   2363          				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   \   0000011C   0x7AF0             LDRB     R0,[R6, #+11]
   \   0000011E   0x06C1             LSLS     R1,R0,#+27
   \   00000120   0xD501             BPL.N    ??f_open_12
   2364          					res = FR_NO_FILE;
   \   00000122   0x2704             MOVS     R7,#+4
   \   00000124   0xE004             B.N      ??f_open_11
   2365          				} else {
   2366          					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_12: (+1)
   \   00000126   0x07A9             LSLS     R1,R5,#+30
   \   00000128   0xD502             BPL.N    ??f_open_11
   \   0000012A   0x07C0             LSLS     R0,R0,#+31
   \   0000012C   0xD500             BPL.N    ??f_open_11
   2367          						res = FR_DENIED;
   \   0000012E   0x2707             MOVS     R7,#+7
   2368          				}
   2369          			}
   2370          		}
   2371          		if (res == FR_OK) {
   \                     ??f_open_11: (+1)
   \   00000130   0x2F00             CMP      R7,#+0
   \   00000132   0xD114             BNE.N    ??f_open_13
   2372          			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   \   00000134   0x0728             LSLS     R0,R5,#+28
   \   00000136   0xD501             BPL.N    ??f_open_14
   2373          				mode |= FA__WRITTEN;
   \   00000138   0xF045 0x0520      ORR      R5,R5,#0x20
   2374          			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   \                     ??f_open_14: (+1)
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000140   0x61E0             STR      R0,[R4, #+28]
   2375          			fp->dir_ptr = dir;
   \   00000142   0x6226             STR      R6,[R4, #+32]
   2376          #if _FS_LOCK
   2377          			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   \   00000144   0xF005 0x00FE      AND      R0,R5,#0xFE
   \   00000148   0x1E41             SUBS     R1,R0,#+1
   \   0000014A   0x4189             SBCS     R1,R1,R1
   \   0000014C   0x43C9             MVNS     R1,R1
   \   0000014E   0x0FC9             LSRS     R1,R1,#+31
   \   00000150   0xA800             ADD      R0,SP,#+0
   \   00000152   0x.... 0x....      BL       _Z8inc_lockP3DIRi
   \   00000156   0x6260             STR      R0,[R4, #+36]
   2378          			if (!fp->lockid) res = FR_INT_ERR;
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD100             BNE.N    ??f_open_13
   \   0000015C   0x2702             MOVS     R7,#+2
   2379          #endif
   2380          		}
   2381          
   2382          #else				/* R/O configuration */
   2383          		if (res == FR_OK) {					/* Follow succeeded */
   2384          			dir = dj.dir;
   2385          			if (!dir) {						/* Current dir itself */
   2386          				res = FR_INVALID_NAME;
   2387          			} else {
   2388          				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   2389          					res = FR_NO_FILE;
   2390          			}
   2391          		}
   2392          #endif
   2393          		FREE_BUF();
   2394          
   2395          		if (res == FR_OK) {
   \                     ??f_open_13: (+1)
   \   0000015E   0x2F00             CMP      R7,#+0
   \   00000160   0xD118             BNE.N    ??f_open_2
   2396          			fp->flag = mode;					/* File access mode */
   \   00000162   0x71A5             STRB     R5,[R4, #+6]
   2397          			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   \   00000164   0x4631             MOV      R1,R6
   \   00000166   0x9800             LDR      R0,[SP, #+0]
   \   00000168   0x.... 0x....      BL       _Z8ld_clustP5FATFSPh
   \   0000016C   0x6120             STR      R0,[R4, #+16]
   2398          			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   0000016E   0x7FF0             LDRB     R0,[R6, #+31]
   \   00000170   0x7FB1             LDRB     R1,[R6, #+30]
   \   00000172   0x0409             LSLS     R1,R1,#+16
   \   00000174   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000178   0x7F71             LDRB     R1,[R6, #+29]
   \   0000017A   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000017E   0x7F31             LDRB     R1,[R6, #+28]
   \   00000180   0x4308             ORRS     R0,R1,R0
   \   00000182   0x60E0             STR      R0,[R4, #+12]
   2399          			fp->fptr = 0;						/* File pointer */
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x60A0             STR      R0,[R4, #+8]
   2400          			fp->dsect = 0;
   \   00000188   0x61A0             STR      R0,[R4, #+24]
   2401          #if _USE_FASTSEEK
   2402          			fp->cltbl = 0;						/* Normal seek mode */
   2403          #endif
   2404          			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   \   0000018A   0x9800             LDR      R0,[SP, #+0]
   \   0000018C   0x6020             STR      R0,[R4, #+0]
   \   0000018E   0x9800             LDR      R0,[SP, #+0]
   \   00000190   0x88C0             LDRH     R0,[R0, #+6]
   \   00000192   0x80A0             STRH     R0,[R4, #+4]
   2405          		}
   2406          	}
   2407          
   2408          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_2: (+1)
   \   00000194   0x4638             MOV      R0,R7
   \                     ??f_open_1: (+1)
   \   00000196   0xB00B             ADD      SP,SP,#+44
   \   00000198   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   2409          }
   2410          
   2411          
   2412          
   2413          
   2414          /*-----------------------------------------------------------------------*/
   2415          /* Read File                                                             */
   2416          /*-----------------------------------------------------------------------*/
   2417          

   \                                 In section .text, align 2, keep-with-next
   2418          FRESULT f_read (
   2419          	FIL *fp, 		/* Pointer to the file object */
   2420          	void *buff,		/* Pointer to data buffer */
   2421          	UINT btr,		/* Number of bytes to read */
   2422          	UINT *br		/* Pointer to number of bytes read */
   2423          )
   2424          {
   \                     f_read: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
   2425          	FRESULT res;
   2426          	DWORD clst, sect, remain;
   2427          	UINT rcnt, cc;
   2428          	BYTE csect, *rbuff = (BYTE*)buff;
   \   0000000A   0x460C             MOV      R4,R1
   2429          
   2430          
   2431          	*br = 0;	/* Clear read byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6038             STR      R0,[R7, #+0]
   2432          
   2433          	res = validate(fp);							/* Check validity */
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       _Z8validatePv
   2434          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xF040 0x808F      BNE.W    ??f_read_0
   2435          	if (fp->flag & FA__ERROR)					/* Aborted file? */
   \   0000001C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000001E   0x0601             LSLS     R1,R0,#+24
   \   00000020   0xD501             BPL.N    ??f_read_1
   2436          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE089             B.N      ??f_read_0
   2437          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \                     ??f_read_1: (+1)
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD401             BMI.N    ??f_read_2
   2438          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE085             B.N      ??f_read_0
   2439          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_2: (+1)
   \   0000002E   0x68E8             LDR      R0,[R5, #+12]
   \   00000030   0x68A9             LDR      R1,[R5, #+8]
   \   00000032   0x1A40             SUBS     R0,R0,R1
   2440          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   \   00000034   0x42B0             CMP      R0,R6
   \   00000036   0xD815             BHI.N    ??f_read_3
   \   00000038   0x4606             MOV      R6,R0
   \   0000003A   0xE013             B.N      ??f_read_3
   2441          
   2442          	for ( ;  btr;								/* Repeat until all data read */
   2443          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   2444          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   2445          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2446          			if (!csect) {						/* On the cluster boundary? */
   2447          				if (fp->fptr == 0) {			/* On the top of the file? */
   2448          					clst = fp->sclust;			/* Follow from the origin */
   2449          				} else {						/* Middle or end of the file */
   2450          #if _USE_FASTSEEK
   2451          					if (fp->cltbl)
   2452          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2453          					else
   2454          #endif
   2455          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   2456          				}
   2457          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   2458          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2459          				fp->clust = clst;				/* Update current cluster */
   2460          			}
   2461          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2462          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2463          			sect += csect;
   2464          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   2465          			if (cc) {							/* Read maximum contiguous sectors directly */
   2466          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2467          					cc = fp->fs->csize - csect;
   2468          				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
   2469          					ABORT(fp->fs, FR_DISK_ERR);
   2470          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   2471          #if _FS_TINY
   2472          				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
   2473          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   2474          #else
   2475          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   2476          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   2477          #endif
   2478          #endif
   2479          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   2480          				continue;
   2481          			}
   2482          #if !_FS_TINY
   2483          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   2484          #if !_FS_READONLY
   2485          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2486          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2487          						ABORT(fp->fs, FR_DISK_ERR);
   2488          					fp->flag &= ~FA__DIRTY;
   2489          				}
   2490          #endif
   2491          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   2492          					ABORT(fp->fs, FR_DISK_ERR);
   2493          			}
   2494          #endif
   2495          			fp->dsect = sect;
   2496          		}
   2497          		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   2498          		if (rcnt > btr) rcnt = btr;
   2499          #if _FS_TINY
   2500          		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
   2501          			ABORT(fp->fs, FR_DISK_ERR);
   2502          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_4: (+1)
   \   0000003C   0x4642             MOV      R2,R8
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x68A9             LDR      R1,[R5, #+8]
   \   00000042   0x05C9             LSLS     R1,R1,#+23
   \   00000044   0xEB10 0x50D1      ADDS     R0,R0,R1, LSR #+23
   \   00000048   0xF100 0x0130      ADD      R1,R0,#+48
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   \                     ??f_read_5: (+1)
   \   00000052   0x4444             ADD      R4,R8,R4
   \   00000054   0x68A8             LDR      R0,[R5, #+8]
   \   00000056   0x4440             ADD      R0,R8,R0
   \   00000058   0x60A8             STR      R0,[R5, #+8]
   \   0000005A   0x6838             LDR      R0,[R7, #+0]
   \   0000005C   0x4440             ADD      R0,R8,R0
   \   0000005E   0x6038             STR      R0,[R7, #+0]
   \   00000060   0xEBA6 0x0608      SUB      R6,R6,R8
   \                     ??f_read_3: (+1)
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD067             BEQ.N    ??f_read_6
   \   00000068   0x68A9             LDR      R1,[R5, #+8]
   \   0000006A   0x05C8             LSLS     R0,R1,#+23
   \   0000006C   0xD14F             BNE.N    ??f_read_7
   \   0000006E   0x6828             LDR      R0,[R5, #+0]
   \   00000070   0x7883             LDRB     R3,[R0, #+2]
   \   00000072   0x1E5B             SUBS     R3,R3,#+1
   \   00000074   0xEA03 0x2851      AND      R8,R3,R1, LSR #+9
   \   00000078   0xFA5F 0xF888      UXTB     R8,R8
   \   0000007C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000080   0xD10C             BNE.N    ??f_read_8
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD101             BNE.N    ??f_read_9
   \   00000086   0x6928             LDR      R0,[R5, #+16]
   \   00000088   0xE002             B.N      ??f_read_10
   \                     ??f_read_9: (+1)
   \   0000008A   0x6969             LDR      R1,[R5, #+20]
   \   0000008C   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \                     ??f_read_10: (+1)
   \   00000090   0x2802             CMP      R0,#+2
   \   00000092   0xD30B             BCC.N    ??f_read_11
   \   00000094   0xF110 0x0F01      CMN      R0,#+1
   \   00000098   0xD048             BEQ.N    ??f_read_12
   \   0000009A   0x6168             STR      R0,[R5, #+20]
   \                     ??f_read_8: (+1)
   \   0000009C   0x6969             LDR      R1,[R5, #+20]
   \   0000009E   0x6828             LDR      R0,[R5, #+0]
   \   000000A0   0x.... 0x....      BL       clust2sect
   \   000000A4   0x4681             MOV      R9,R0
   \   000000A6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000AA   0xD105             BNE.N    ??f_read_13
   \                     ??f_read_11: (+1)
   \   000000AC   0x79A8             LDRB     R0,[R5, #+6]
   \   000000AE   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000B2   0x71A8             STRB     R0,[R5, #+6]
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0xE040             B.N      ??f_read_0
   \                     ??f_read_13: (+1)
   \   000000B8   0x44C1             ADD      R9,R8,R9
   \   000000BA   0xEA5F 0x2A56      LSRS     R10,R6,#+9
   \   000000BE   0xD024             BEQ.N    ??f_read_14
   \   000000C0   0x6828             LDR      R0,[R5, #+0]
   \   000000C2   0x7881             LDRB     R1,[R0, #+2]
   \   000000C4   0xEB0A 0x0208      ADD      R2,R10,R8
   \   000000C8   0x4291             CMP      R1,R2
   \   000000CA   0xD201             BCS.N    ??f_read_15
   \   000000CC   0xEBA1 0x0A08      SUB      R10,R1,R8
   \                     ??f_read_15: (+1)
   \   000000D0   0x4653             MOV      R3,R10
   \   000000D2   0xB2DB             UXTB     R3,R3
   \   000000D4   0x464A             MOV      R2,R9
   \   000000D6   0x4621             MOV      R1,R4
   \   000000D8   0x7840             LDRB     R0,[R0, #+1]
   \   000000DA   0x.... 0x....      BL       disk_read
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD124             BNE.N    ??f_read_12
   \   000000E2   0x6828             LDR      R0,[R5, #+0]
   \   000000E4   0x7901             LDRB     R1,[R0, #+4]
   \   000000E6   0x2900             CMP      R1,#+0
   \   000000E8   0xD00C             BEQ.N    ??f_read_16
   \   000000EA   0x6AC1             LDR      R1,[R0, #+44]
   \   000000EC   0xEBA1 0x0309      SUB      R3,R1,R9
   \   000000F0   0x4553             CMP      R3,R10
   \   000000F2   0xD207             BCS.N    ??f_read_16
   \   000000F4   0xF44F 0x7200      MOV      R2,#+512
   \   000000F8   0xF100 0x0130      ADD      R1,R0,#+48
   \   000000FC   0xEB04 0x2043      ADD      R0,R4,R3, LSL #+9
   \   00000100   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   \                     ??f_read_16: (+1)
   \   00000104   0xEA4F 0x284A      LSL      R8,R10,#+9
   \   00000108   0xE7A3             B.N      ??f_read_5
   \                     ??f_read_14: (+1)
   \   0000010A   0xF8C5 0x9018      STR      R9,[R5, #+24]
   \                     ??f_read_7: (+1)
   \   0000010E   0x68A8             LDR      R0,[R5, #+8]
   \   00000110   0x05C0             LSLS     R0,R0,#+23
   \   00000112   0x0DC0             LSRS     R0,R0,#+23
   \   00000114   0xF5C0 0x7000      RSB      R0,R0,#+512
   \   00000118   0x46B0             MOV      R8,R6
   \   0000011A   0x4286             CMP      R6,R0
   \   0000011C   0xD900             BLS.N    ??f_read_17
   \   0000011E   0x4680             MOV      R8,R0
   \                     ??f_read_17: (+1)
   \   00000120   0x69A9             LDR      R1,[R5, #+24]
   \   00000122   0x6828             LDR      R0,[R5, #+0]
   \   00000124   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD087             BEQ.N    ??f_read_4
   \                     ??f_read_12: (+1)
   \   0000012C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000012E   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000132   0x71A8             STRB     R0,[R5, #+6]
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0xE000             B.N      ??f_read_0
   2503          #else
   2504          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   2505          #endif
   2506          	}
   2507          
   2508          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_6: (+1)
   \   00000138   0x2000             MOVS     R0,#+0
   \                     ??f_read_0: (+1)
   \   0000013A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2509          }
   2510          
   2511          
   2512          
   2513          
   2514          #if !_FS_READONLY
   2515          /*-----------------------------------------------------------------------*/
   2516          /* Write File                                                            */
   2517          /*-----------------------------------------------------------------------*/
   2518          

   \                                 In section .text, align 2, keep-with-next
   2519          FRESULT f_write (
   2520          	FIL *fp,			/* Pointer to the file object */
   2521          	const void *buff,	/* Pointer to the data to be written */
   2522          	UINT btw,			/* Number of bytes to write */
   2523          	UINT *bw			/* Pointer to number of bytes written */
   2524          )
   2525          {
   \                     f_write: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4617             MOV      R7,R2
   \   00000008   0x461E             MOV      R6,R3
   2526          	FRESULT res;
   2527          	DWORD clst, sect;
   2528          	UINT wcnt, cc;
   2529          	const BYTE *wbuff = (BYTE*)buff;
   \   0000000A   0x460C             MOV      R4,R1
   2530          	BYTE csect;
   2531          
   2532          
   2533          	*bw = 0;	/* Clear write byte counter */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6030             STR      R0,[R6, #+0]
   2534          
   2535          	res = validate(fp);						/* Check validity */
   \   00000010   0x4628             MOV      R0,R5
   \   00000012   0x.... 0x....      BL       _Z8validatePv
   2536          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xF040 0x80BC      BNE.W    ??f_write_0
   2537          	if (fp->flag & FA__ERROR)				/* Aborted file? */
   \   0000001C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000001E   0x0601             LSLS     R1,R0,#+24
   \   00000020   0xD501             BPL.N    ??f_write_1
   2538          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE0B6             B.N      ??f_write_0
   2539          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_1: (+1)
   \   00000026   0x0780             LSLS     R0,R0,#+30
   \   00000028   0xD401             BMI.N    ??f_write_2
   2540          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE0B2             B.N      ??f_write_0
   2541          	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
   \                     ??f_write_2: (+1)
   \   0000002E   0x68E8             LDR      R0,[R5, #+12]
   \   00000030   0x1839             ADDS     R1,R7,R0
   \   00000032   0x4281             CMP      R1,R0
   \   00000034   0xD217             BCS.N    ??f_write_3
   \   00000036   0x2700             MOVS     R7,#+0
   \   00000038   0xE015             B.N      ??f_write_3
   2542          
   2543          	for ( ;  btw;							/* Repeat until all data written */
   2544          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   2545          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   2546          			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   2547          			if (!csect) {					/* On the cluster boundary? */
   2548          				if (fp->fptr == 0) {		/* On the top of the file? */
   2549          					clst = fp->sclust;		/* Follow from the origin */
   2550          					if (clst == 0)			/* When no cluster is allocated, */
   2551          						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   2552          				} else {					/* Middle or end of the file */
   2553          #if _USE_FASTSEEK
   2554          					if (fp->cltbl)
   2555          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   2556          					else
   2557          #endif
   2558          						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   2559          				}
   2560          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   2561          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   2562          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2563          				fp->clust = clst;			/* Update current cluster */
   2564          			}
   2565          #if _FS_TINY
   2566          			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
   2567          				ABORT(fp->fs, FR_DISK_ERR);
   2568          #else
   2569          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   2570          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2571          					ABORT(fp->fs, FR_DISK_ERR);
   2572          				fp->flag &= ~FA__DIRTY;
   2573          			}
   2574          #endif
   2575          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   2576          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   2577          			sect += csect;
   2578          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   2579          			if (cc) {						/* Write maximum contiguous sectors directly */
   2580          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   2581          					cc = fp->fs->csize - csect;
   2582          				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
   2583          					ABORT(fp->fs, FR_DISK_ERR);
   2584          #if _FS_TINY
   2585          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   2586          					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   2587          					fp->fs->wflag = 0;
   2588          				}
   2589          #else
   2590          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   2591          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   2592          					fp->flag &= ~FA__DIRTY;
   2593          				}
   2594          #endif
   2595          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   2596          				continue;
   2597          			}
   2598          #if _FS_TINY
   2599          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   2600          				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
   2601          				fp->fs->winsect = sect;
   2602          			}
   2603          #else
   2604          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   2605          				if (fp->fptr < fp->fsize &&
   2606          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   2607          						ABORT(fp->fs, FR_DISK_ERR);
   2608          			}
   2609          #endif
   2610          			fp->dsect = sect;
   2611          		}
   2612          		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   2613          		if (wcnt > btw) wcnt = btw;
   2614          #if _FS_TINY
   2615          		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   2616          			ABORT(fp->fs, FR_DISK_ERR);
   2617          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_4: (+1)
   \   0000003A   0x4642             MOV      R2,R8
   \   0000003C   0x4621             MOV      R1,R4
   \   0000003E   0x6828             LDR      R0,[R5, #+0]
   \   00000040   0x68AB             LDR      R3,[R5, #+8]
   \   00000042   0x05DB             LSLS     R3,R3,#+23
   \   00000044   0xEB10 0x50D3      ADDS     R0,R0,R3, LSR #+23
   \   00000048   0x3030             ADDS     R0,R0,#+48
   \   0000004A   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   2618          		fp->fs->wflag = 1;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x6829             LDR      R1,[R5, #+0]
   \   00000052   0x7108             STRB     R0,[R1, #+4]
   \                     ??f_write_5: (+1)
   \   00000054   0x4444             ADD      R4,R8,R4
   \   00000056   0x68A8             LDR      R0,[R5, #+8]
   \   00000058   0x4440             ADD      R0,R8,R0
   \   0000005A   0x60A8             STR      R0,[R5, #+8]
   \   0000005C   0x6830             LDR      R0,[R6, #+0]
   \   0000005E   0x4440             ADD      R0,R8,R0
   \   00000060   0x6030             STR      R0,[R6, #+0]
   \   00000062   0xEBA7 0x0708      SUB      R7,R7,R8
   \                     ??f_write_3: (+1)
   \   00000066   0x2F00             CMP      R7,#+0
   \   00000068   0xF000 0x8089      BEQ.W    ??f_write_6
   \   0000006C   0x68A9             LDR      R1,[R5, #+8]
   \   0000006E   0x05C8             LSLS     R0,R1,#+23
   \   00000070   0xD16F             BNE.N    ??f_write_7
   \   00000072   0x6828             LDR      R0,[R5, #+0]
   \   00000074   0x7883             LDRB     R3,[R0, #+2]
   \   00000076   0x1E5B             SUBS     R3,R3,#+1
   \   00000078   0xEA03 0x2851      AND      R8,R3,R1, LSR #+9
   \   0000007C   0xFA5F 0xF888      UXTB     R8,R8
   \   00000080   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000084   0xD116             BNE.N    ??f_write_8
   \   00000086   0x2900             CMP      R1,#+0
   \   00000088   0xD108             BNE.N    ??f_write_9
   \   0000008A   0x6929             LDR      R1,[R5, #+16]
   \   0000008C   0x2900             CMP      R1,#+0
   \   0000008E   0xD109             BNE.N    ??f_write_10
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   00000096   0x4601             MOV      R1,R0
   \   00000098   0x6129             STR      R1,[R5, #+16]
   \   0000009A   0xE003             B.N      ??f_write_10
   \                     ??f_write_9: (+1)
   \   0000009C   0x6969             LDR      R1,[R5, #+20]
   \   0000009E   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   000000A2   0x4601             MOV      R1,R0
   \                     ??f_write_10: (+1)
   \   000000A4   0x2900             CMP      R1,#+0
   \   000000A6   0xD06A             BEQ.N    ??f_write_6
   \   000000A8   0x2901             CMP      R1,#+1
   \   000000AA   0xD015             BEQ.N    ??f_write_11
   \   000000AC   0xF111 0x0F01      CMN      R1,#+1
   \   000000B0   0xD05F             BEQ.N    ??f_write_12
   \   000000B2   0x6169             STR      R1,[R5, #+20]
   \                     ??f_write_8: (+1)
   \   000000B4   0x6828             LDR      R0,[R5, #+0]
   \   000000B6   0x6AC1             LDR      R1,[R0, #+44]
   \   000000B8   0x69AA             LDR      R2,[R5, #+24]
   \   000000BA   0x4291             CMP      R1,R2
   \   000000BC   0xD104             BNE.N    ??f_write_13
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD154             BNE.N    ??f_write_12
   \                     ??f_write_13: (+1)
   \   000000C8   0x6969             LDR      R1,[R5, #+20]
   \   000000CA   0x6828             LDR      R0,[R5, #+0]
   \   000000CC   0x.... 0x....      BL       clust2sect
   \   000000D0   0x4681             MOV      R9,R0
   \   000000D2   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D6   0xD105             BNE.N    ??f_write_14
   \                     ??f_write_11: (+1)
   \   000000D8   0x79A8             LDRB     R0,[R5, #+6]
   \   000000DA   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000DE   0x71A8             STRB     R0,[R5, #+6]
   \   000000E0   0x2002             MOVS     R0,#+2
   \   000000E2   0xE057             B.N      ??f_write_0
   \                     ??f_write_14: (+1)
   \   000000E4   0x44C1             ADD      R9,R8,R9
   \   000000E6   0xEA5F 0x2A57      LSRS     R10,R7,#+9
   \   000000EA   0xD023             BEQ.N    ??f_write_15
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0x7881             LDRB     R1,[R0, #+2]
   \   000000F0   0xEB0A 0x0208      ADD      R2,R10,R8
   \   000000F4   0x4291             CMP      R1,R2
   \   000000F6   0xD201             BCS.N    ??f_write_16
   \   000000F8   0xEBA1 0x0A08      SUB      R10,R1,R8
   \                     ??f_write_16: (+1)
   \   000000FC   0x4653             MOV      R3,R10
   \   000000FE   0xB2DB             UXTB     R3,R3
   \   00000100   0x464A             MOV      R2,R9
   \   00000102   0x4621             MOV      R1,R4
   \   00000104   0x7840             LDRB     R0,[R0, #+1]
   \   00000106   0x.... 0x....      BL       disk_write
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD131             BNE.N    ??f_write_12
   \   0000010E   0x6828             LDR      R0,[R5, #+0]
   \   00000110   0x6AC1             LDR      R1,[R0, #+44]
   \   00000112   0xEBA1 0x0109      SUB      R1,R1,R9
   \   00000116   0x4551             CMP      R1,R10
   \   00000118   0xD209             BCS.N    ??f_write_17
   \   0000011A   0xF44F 0x7200      MOV      R2,#+512
   \   0000011E   0xEB04 0x2141      ADD      R1,R4,R1, LSL #+9
   \   00000122   0x3030             ADDS     R0,R0,#+48
   \   00000124   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x6829             LDR      R1,[R5, #+0]
   \   0000012C   0x7108             STRB     R0,[R1, #+4]
   \                     ??f_write_17: (+1)
   \   0000012E   0xEA4F 0x284A      LSL      R8,R10,#+9
   \   00000132   0xE78F             B.N      ??f_write_5
   \                     ??f_write_15: (+1)
   \   00000134   0x68A8             LDR      R0,[R5, #+8]
   \   00000136   0x68E9             LDR      R1,[R5, #+12]
   \   00000138   0x4288             CMP      R0,R1
   \   0000013A   0xD308             BCC.N    ??f_write_18
   \   0000013C   0x2100             MOVS     R1,#+0
   \   0000013E   0x6828             LDR      R0,[R5, #+0]
   \   00000140   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000144   0x2800             CMP      R0,#+0
   \   00000146   0xD114             BNE.N    ??f_write_12
   \   00000148   0x6828             LDR      R0,[R5, #+0]
   \   0000014A   0xF8C0 0x902C      STR      R9,[R0, #+44]
   \                     ??f_write_18: (+1)
   \   0000014E   0xF8C5 0x9018      STR      R9,[R5, #+24]
   \                     ??f_write_7: (+1)
   \   00000152   0x68A8             LDR      R0,[R5, #+8]
   \   00000154   0x05C0             LSLS     R0,R0,#+23
   \   00000156   0x0DC0             LSRS     R0,R0,#+23
   \   00000158   0xF5C0 0x7000      RSB      R0,R0,#+512
   \   0000015C   0x46B8             MOV      R8,R7
   \   0000015E   0x4287             CMP      R7,R0
   \   00000160   0xD900             BLS.N    ??f_write_19
   \   00000162   0x4680             MOV      R8,R0
   \                     ??f_write_19: (+1)
   \   00000164   0x69A9             LDR      R1,[R5, #+24]
   \   00000166   0x6828             LDR      R0,[R5, #+0]
   \   00000168   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000016C   0x2800             CMP      R0,#+0
   \   0000016E   0xF43F 0xAF64      BEQ.W    ??f_write_4
   \                     ??f_write_12: (+1)
   \   00000172   0x79A8             LDRB     R0,[R5, #+6]
   \   00000174   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000178   0x71A8             STRB     R0,[R5, #+6]
   \   0000017A   0x2001             MOVS     R0,#+1
   \   0000017C   0xE00A             B.N      ??f_write_0
   2619          #else
   2620          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   2621          		fp->flag |= FA__DIRTY;
   2622          #endif
   2623          	}
   2624          
   2625          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_6: (+1)
   \   0000017E   0x68E8             LDR      R0,[R5, #+12]
   \   00000180   0x68A9             LDR      R1,[R5, #+8]
   \   00000182   0x4288             CMP      R0,R1
   \   00000184   0xD200             BCS.N    ??f_write_20
   \   00000186   0x4608             MOV      R0,R1
   \                     ??f_write_20: (+1)
   \   00000188   0x60E8             STR      R0,[R5, #+12]
   2626          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \   0000018A   0x79A8             LDRB     R0,[R5, #+6]
   \   0000018C   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000190   0x71A8             STRB     R0,[R5, #+6]
   2627          
   2628          	LEAVE_FF(fp->fs, FR_OK);
   \   00000192   0x2000             MOVS     R0,#+0
   \                     ??f_write_0: (+1)
   \   00000194   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   2629          }
   2630          
   2631          
   2632          
   2633          
   2634          /*-----------------------------------------------------------------------*/
   2635          /* Synchronize the File Object                                           */
   2636          /*-----------------------------------------------------------------------*/
   2637          

   \                                 In section .text, align 2, keep-with-next
   2638          FRESULT f_sync (
   2639          	FIL *fp		/* Pointer to the file object */
   2640          )
   2641          {
   \                     f_sync: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   2642          	FRESULT res;
   2643          	DWORD tim;
   2644          	BYTE *dir;
   2645          
   2646          
   2647          	res = validate(fp);					/* Check validity of the object */
   \   00000004   0x.... 0x....      BL       _Z8validatePv
   2648          	if (res == FR_OK) {
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD137             BNE.N    ??f_sync_0
   2649          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   0000000C   0x79A1             LDRB     R1,[R4, #+6]
   \   0000000E   0x0689             LSLS     R1,R1,#+26
   \   00000010   0xD534             BPL.N    ??f_sync_0
   2650          #if !_FS_TINY	/* Write-back dirty buffer */
   2651          			if (fp->flag & FA__DIRTY) {
   2652          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2653          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   2654          				fp->flag &= ~FA__DIRTY;
   2655          			}
   2656          #endif
   2657          			/* Update the directory entry */
   2658          			res = move_window(fp->fs, fp->dir_sect);
   \   00000012   0x69E1             LDR      R1,[R4, #+28]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   2659          			if (res == FR_OK) {
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD12E             BNE.N    ??f_sync_0
   2660          				dir = fp->dir_ptr;
   \   0000001E   0x6A25             LDR      R5,[R4, #+32]
   2661          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   00000020   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000022   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000026   0x72E8             STRB     R0,[R5, #+11]
   2662          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \   0000002A   0x7728             STRB     R0,[R5, #+28]
   \   0000002C   0x68E0             LDR      R0,[R4, #+12]
   \   0000002E   0xB280             UXTH     R0,R0
   \   00000030   0x0A00             LSRS     R0,R0,#+8
   \   00000032   0x7768             STRB     R0,[R5, #+29]
   \   00000034   0x68E0             LDR      R0,[R4, #+12]
   \   00000036   0x0C00             LSRS     R0,R0,#+16
   \   00000038   0x77A8             STRB     R0,[R5, #+30]
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x0E00             LSRS     R0,R0,#+24
   \   0000003E   0x77E8             STRB     R0,[R5, #+31]
   2663          				st_clust(dir, fp->sclust);					/* Update start cluster */
   \   00000040   0x6921             LDR      R1,[R4, #+16]
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       _Z8st_clustPhm
   2664          				tim = get_fattime();						/* Update updated time */
   \   00000048   0x.... 0x....      BL       get_fattime
   2665          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   0000004C   0x75A8             STRB     R0,[R5, #+22]
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0xB289             UXTH     R1,R1
   \   00000052   0x0A09             LSRS     R1,R1,#+8
   \   00000054   0x75E9             STRB     R1,[R5, #+23]
   \   00000056   0x0C01             LSRS     R1,R0,#+16
   \   00000058   0x7629             STRB     R1,[R5, #+24]
   \   0000005A   0x0E00             LSRS     R0,R0,#+24
   \   0000005C   0x7668             STRB     R0,[R5, #+25]
   2666          				ST_WORD(dir+DIR_LstAccDate, 0);
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x74A8             STRB     R0,[R5, #+18]
   \   00000062   0x74E8             STRB     R0,[R5, #+19]
   2667          				fp->flag &= ~FA__WRITTEN;
   \   00000064   0x79A0             LDRB     R0,[R4, #+6]
   \   00000066   0xF000 0x00DF      AND      R0,R0,#0xDF
   \   0000006A   0x71A0             STRB     R0,[R4, #+6]
   2668          				fp->fs->wflag = 1;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x7108             STRB     R0,[R1, #+4]
   2669          				res = sync(fp->fs);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000078   0x.... 0x....      B.W      _Z4syncP5FATFS
   2670          			}
   2671          		}
   2672          	}
   2673          
   2674          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0: (+1)
   \   0000007C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2675          }
   2676          
   2677          #endif /* !_FS_READONLY */
   2678          
   2679          
   2680          
   2681          
   2682          /*-----------------------------------------------------------------------*/
   2683          /* Close File                                                            */
   2684          /*-----------------------------------------------------------------------*/
   2685          

   \                                 In section .text, align 2, keep-with-next
   2686          FRESULT f_close (
   2687          	FIL *fp		/* Pointer to the file object to be closed */
   2688          )
   2689          {
   \                     f_close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   2690          	FRESULT res;
   2691          
   2692          
   2693          #if _FS_READONLY
   2694          	res = validate(fp);
   2695          	{
   2696          #if _FS_REENTRANT
   2697          		FATFS *fs = fp->fs;
   2698          #endif
   2699          		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   2700          		LEAVE_FF(fs, res);
   2701          	}
   2702          #else
   2703          	res = f_sync(fp);		/* Flush cached data */
   \   00000004   0x.... 0x....      BL       f_sync
   2704          #if _FS_LOCK
   2705          	if (res == FR_OK) {		/* Decrement open counter */
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD102             BNE.N    ??f_close_0
   2706          #if _FS_REENTRANT
   2707          		FATFS *fs = fp->fs;;
   2708          		res = validate(fp);
   2709          		if (res == FR_OK) {
   2710          			res = dec_lock(fp->lockid);
   2711          			unlock_fs(fs, FR_OK);
   2712          		}
   2713          #else
   2714          		res = dec_lock(fp->lockid);
   \   0000000C   0x6A60             LDR      R0,[R4, #+36]
   \   0000000E   0x.... 0x....      BL       _Z8dec_lockj
   2715          #endif
   2716          	}
   2717          #endif
   2718          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   \                     ??f_close_0: (+1)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??f_close_1
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6021             STR      R1,[R4, #+0]
   2719          	return res;
   \                     ??f_close_1: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   2720          #endif
   2721          }
   2722          
   2723          
   2724          
   2725          
   2726          /*-----------------------------------------------------------------------*/
   2727          /* Current Drive/Directory Handlings                                     */
   2728          /*-----------------------------------------------------------------------*/
   2729          
   2730          #if _FS_RPATH >= 1
   2731          
   2732          FRESULT f_chdrive (
   2733          	BYTE drv		/* Drive number */
   2734          )
   2735          {
   2736          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   2737          
   2738          	CurrVol = drv;
   2739          
   2740          	return FR_OK;
   2741          }
   2742          
   2743          
   2744          
   2745          FRESULT f_chdir (
   2746          	const TCHAR *path	/* Pointer to the directory path */
   2747          )
   2748          {
   2749          	FRESULT res;
   2750          	DIR dj;
   2751          	DEF_NAMEBUF;
   2752          
   2753          
   2754          	res = chk_mounted(&path, &dj.fs, 0);
   2755          	if (res == FR_OK) {
   2756          		INIT_BUF(dj);
   2757          		res = follow_path(&dj, path);		/* Follow the path */
   2758          		FREE_BUF();
   2759          		if (res == FR_OK) {					/* Follow completed */
   2760          			if (!dj.dir) {
   2761          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   2762          			} else {
   2763          				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   2764          					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
   2765          				else
   2766          					res = FR_NO_PATH;		/* Reached but a file */
   2767          			}
   2768          		}
   2769          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   2770          	}
   2771          
   2772          	LEAVE_FF(dj.fs, res);
   2773          }
   2774          
   2775          
   2776          #if _FS_RPATH >= 2
   2777          FRESULT f_getcwd (
   2778          	TCHAR *path,	/* Pointer to the directory path */
   2779          	UINT sz_path	/* Size of path */
   2780          )
   2781          {
   2782          	FRESULT res;
   2783          	DIR dj;
   2784          	UINT i, n;
   2785          	DWORD ccl;
   2786          	TCHAR *tp;
   2787          	FILINFO fno;
   2788          	DEF_NAMEBUF;
   2789          
   2790          
   2791          	*path = 0;
   2792          	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
   2793          	if (res == FR_OK) {
   2794          		INIT_BUF(dj);
   2795          		i = sz_path;		/* Bottom of buffer (dir stack base) */
   2796          		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
   2797          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
   2798          			res = dir_sdi(&dj, 1);			/* Get parent dir */
   2799          			if (res != FR_OK) break;
   2800          			res = dir_read(&dj);
   2801          			if (res != FR_OK) break;
   2802          			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
   2803          			res = dir_sdi(&dj, 0);
   2804          			if (res != FR_OK) break;
   2805          			do {							/* Find the entry links to the child dir */
   2806          				res = dir_read(&dj);
   2807          				if (res != FR_OK) break;
   2808          				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
   2809          				res = dir_next(&dj, 0);
   2810          			} while (res == FR_OK);
   2811          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   2812          			if (res != FR_OK) break;
   2813          #if _USE_LFN
   2814          			fno.lfname = path;
   2815          			fno.lfsize = i;
   2816          #endif
   2817          			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
   2818          			tp = fno.fname;
   2819          			if (_USE_LFN && *path) tp = path;
   2820          			for (n = 0; tp[n]; n++) ;
   2821          			if (i < n + 3) {
   2822          				res = FR_NOT_ENOUGH_CORE; break;
   2823          			}
   2824          			while (n) path[--i] = tp[--n];
   2825          			path[--i] = '/';
   2826          		}
   2827          		tp = path;
   2828          		if (res == FR_OK) {
   2829          			*tp++ = '0' + CurrVol;			/* Put drive number */
   2830          			*tp++ = ':';
   2831          			if (i == sz_path) {				/* Root-dir */
   2832          				*tp++ = '/';
   2833          			} else {						/* Sub-dir */
   2834          				do		/* Add stacked path str */
   2835          					*tp++ = path[i++];
   2836          				while (i < sz_path);
   2837          			}
   2838          		}
   2839          		*tp = 0;
   2840          		FREE_BUF();
   2841          	}
   2842          
   2843          	LEAVE_FF(dj.fs, res);
   2844          }
   2845          #endif /* _FS_RPATH >= 2 */
   2846          #endif /* _FS_RPATH >= 1 */
   2847          
   2848          
   2849          
   2850          #if _FS_MINIMIZE <= 2
   2851          /*-----------------------------------------------------------------------*/
   2852          /* Seek File R/W Pointer                                                 */
   2853          /*-----------------------------------------------------------------------*/
   2854          

   \                                 In section .text, align 2, keep-with-next
   2855          FRESULT f_lseek (
   2856          	FIL *fp,		/* Pointer to the file object */
   2857          	DWORD ofs		/* File pointer from top of file */
   2858          )
   2859          {
   \                     f_lseek: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   2860          	FRESULT res;
   2861          
   2862          
   2863          	res = validate(fp);					/* Check validity of the object */
   \   00000008   0x.... 0x....      BL       _Z8validatePv
   \   0000000C   0x0006             MOVS     R6,R0
   2864          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   0000000E   0xD17C             BNE.N    ??f_lseek_0
   2865          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \   00000010   0x79A0             LDRB     R0,[R4, #+6]
   \   00000012   0x0601             LSLS     R1,R0,#+24
   \   00000014   0xD501             BPL.N    ??f_lseek_1
   2866          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE078             B.N      ??f_lseek_2
   2867          
   2868          #if _USE_FASTSEEK
   2869          	if (fp->cltbl) {	/* Fast seek */
   2870          		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   2871          
   2872          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   2873          			tbl = fp->cltbl;
   2874          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   2875          			cl = fp->sclust;			/* Top of the chain */
   2876          			if (cl) {
   2877          				do {
   2878          					/* Get a fragment */
   2879          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   2880          					do {
   2881          						pcl = cl; ncl++;
   2882          						cl = get_fat(fp->fs, cl);
   2883          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   2884          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2885          					} while (cl == pcl + 1);
   2886          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   2887          						*tbl++ = ncl; *tbl++ = tcl;
   2888          					}
   2889          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   2890          			}
   2891          			*fp->cltbl = ulen;	/* Number of items used */
   2892          			if (ulen <= tlen)
   2893          				*tbl = 0;		/* Terminate table */
   2894          			else
   2895          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   2896          
   2897          		} else {						/* Fast seek */
   2898          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   2899          				ofs = fp->fsize;
   2900          			fp->fptr = ofs;				/* Set file pointer */
   2901          			if (ofs) {
   2902          				fp->clust = clmt_clust(fp, ofs - 1);
   2903          				dsc = clust2sect(fp->fs, fp->clust);
   2904          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   2905          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   2906          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   2907          #if !_FS_TINY
   2908          #if !_FS_READONLY
   2909          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   2910          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2911          							ABORT(fp->fs, FR_DISK_ERR);
   2912          						fp->flag &= ~FA__DIRTY;
   2913          					}
   2914          #endif
   2915          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   2916          						ABORT(fp->fs, FR_DISK_ERR);
   2917          #endif
   2918          					fp->dsect = dsc;
   2919          				}
   2920          			}
   2921          		}
   2922          	} else
   2923          #endif
   2924          
   2925          	/* Normal Seek */
   2926          	{
   2927          		DWORD clst, bcs, nsect, ifptr;
   2928          
   2929          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   2930          #if !_FS_READONLY
   2931          			 && !(fp->flag & FA_WRITE)
   2932          #endif
   2933          			) ofs = fp->fsize;
   \                     ??f_lseek_1: (+1)
   \   0000001A   0x68E1             LDR      R1,[R4, #+12]
   \   0000001C   0x42A9             CMP      R1,R5
   \   0000001E   0xD202             BCS.N    ??f_lseek_3
   \   00000020   0x0780             LSLS     R0,R0,#+30
   \   00000022   0xD400             BMI.N    ??f_lseek_3
   \   00000024   0x460D             MOV      R5,R1
   2934          
   2935          		ifptr = fp->fptr;
   \                     ??f_lseek_3: (+1)
   \   00000026   0x68A1             LDR      R1,[R4, #+8]
   2936          		fp->fptr = nsect = 0;
   \   00000028   0x2700             MOVS     R7,#+0
   \   0000002A   0x4638             MOV      R0,R7
   \   0000002C   0x60A0             STR      R0,[R4, #+8]
   2937          		if (ofs) {
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD05B             BEQ.N    ??f_lseek_4
   2938          			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x7882             LDRB     R2,[R0, #+2]
   \   00000036   0xEA4F 0x2842      LSL      R8,R2,#+9
   2939          			if (ifptr > 0 &&
   2940          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD00F             BEQ.N    ??f_lseek_5
   \   0000003E   0x1E49             SUBS     R1,R1,#+1
   \   00000040   0xFBB1 0xF2F8      UDIV     R2,R1,R8
   \   00000044   0x1E6B             SUBS     R3,R5,#+1
   \   00000046   0xFBB3 0xF3F8      UDIV     R3,R3,R8
   \   0000004A   0x4293             CMP      R3,R2
   \   0000004C   0xD307             BCC.N    ??f_lseek_5
   2941          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   0000004E   0xF1A8 0x0001      SUB      R0,R8,#+1
   \   00000052   0xEA21 0x0000      BIC      R0,R1,R0
   \   00000056   0x60A0             STR      R0,[R4, #+8]
   2942          				ofs -= fp->fptr;
   \   00000058   0x1A2D             SUBS     R5,R5,R0
   2943          				clst = fp->clust;
   \   0000005A   0x6961             LDR      R1,[R4, #+20]
   \   0000005C   0xE00D             B.N      ??f_lseek_6
   2944          			} else {									/* When seek to back cluster, */
   2945          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_5: (+1)
   \   0000005E   0x6921             LDR      R1,[R4, #+16]
   2946          #if !_FS_READONLY
   2947          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   00000060   0x2900             CMP      R1,#+0
   \   00000062   0xD109             BNE.N    ??f_lseek_7
   2948          					clst = create_chain(fp->fs, 0);
   \   00000064   0x4639             MOV      R1,R7
   \   00000066   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   0000006A   0x4601             MOV      R1,R0
   2949          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   0000006C   0x2901             CMP      R1,#+1
   \   0000006E   0xD028             BEQ.N    ??f_lseek_8
   2950          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \   00000070   0xF111 0x0F01      CMN      R1,#+1
   \   00000074   0xD031             BEQ.N    ??f_lseek_9
   2951          					fp->sclust = clst;
   \   00000076   0x6121             STR      R1,[R4, #+16]
   2952          				}
   2953          #endif
   2954          				fp->clust = clst;
   \                     ??f_lseek_7: (+1)
   \   00000078   0x6161             STR      R1,[R4, #+20]
   2955          			}
   2956          			if (clst != 0) {
   \                     ??f_lseek_6: (+1)
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xD10C             BNE.N    ??f_lseek_10
   \   0000007E   0xE034             B.N      ??f_lseek_4
   2957          				while (ofs > bcs) {						/* Cluster following loop */
   2958          #if !_FS_READONLY
   2959          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   2960          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   2961          						if (clst == 0) {				/* When disk gets full, clip file size */
   2962          							ofs = bcs; break;
   2963          						}
   2964          					} else
   2965          #endif
   2966          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   2967          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   2968          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_lseek_11: (+1)
   \   00000080   0x2902             CMP      R1,#+2
   \   00000082   0xD31E             BCC.N    ??f_lseek_8
   \   00000084   0x6820             LDR      R0,[R4, #+0]
   \   00000086   0x6980             LDR      R0,[R0, #+24]
   \   00000088   0x4281             CMP      R1,R0
   \   0000008A   0xD21A             BCS.N    ??f_lseek_8
   2969          					fp->clust = clst;
   \   0000008C   0x6161             STR      R1,[R4, #+20]
   2970          					fp->fptr += bcs;
   \   0000008E   0x68A0             LDR      R0,[R4, #+8]
   \   00000090   0x4440             ADD      R0,R8,R0
   \   00000092   0x60A0             STR      R0,[R4, #+8]
   2971          					ofs -= bcs;
   \   00000094   0xEBA5 0x0508      SUB      R5,R5,R8
   \                     ??f_lseek_10: (+1)
   \   00000098   0x45A8             CMP      R8,R5
   \   0000009A   0xD208             BCS.N    ??f_lseek_12
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x79A2             LDRB     R2,[R4, #+6]
   \   000000A0   0x0792             LSLS     R2,R2,#+30
   \   000000A2   0xD514             BPL.N    ??f_lseek_13
   \   000000A4   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   000000A8   0x0001             MOVS     R1,R0
   \   000000AA   0xD113             BNE.N    ??f_lseek_14
   \   000000AC   0x4645             MOV      R5,R8
   2972          				}
   2973          				fp->fptr += ofs;
   \                     ??f_lseek_12: (+1)
   \   000000AE   0x68A0             LDR      R0,[R4, #+8]
   \   000000B0   0x1828             ADDS     R0,R5,R0
   \   000000B2   0x60A0             STR      R0,[R4, #+8]
   2974          				if (ofs % SS(fp->fs)) {
   \   000000B4   0x05E8             LSLS     R0,R5,#+23
   \   000000B6   0xD018             BEQ.N    ??f_lseek_4
   2975          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   000000B8   0x6820             LDR      R0,[R4, #+0]
   \   000000BA   0x.... 0x....      BL       clust2sect
   \   000000BE   0x0007             MOVS     R7,R0
   2976          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   000000C0   0xD111             BNE.N    ??f_lseek_15
   \                     ??f_lseek_8: (+1)
   \   000000C2   0x79A0             LDRB     R0,[R4, #+6]
   \   000000C4   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000C8   0x71A0             STRB     R0,[R4, #+6]
   \   000000CA   0x2002             MOVS     R0,#+2
   \   000000CC   0xE01E             B.N      ??f_lseek_2
   \                     ??f_lseek_13: (+1)
   \   000000CE   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   000000D2   0x4601             MOV      R1,R0
   \                     ??f_lseek_14: (+1)
   \   000000D4   0xF111 0x0F01      CMN      R1,#+1
   \   000000D8   0xD1D2             BNE.N    ??f_lseek_11
   \                     ??f_lseek_9: (+1)
   \   000000DA   0x79A0             LDRB     R0,[R4, #+6]
   \   000000DC   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000000E0   0x71A0             STRB     R0,[R4, #+6]
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xE012             B.N      ??f_lseek_2
   2977          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_15: (+1)
   \   000000E6   0xEB07 0x2755      ADD      R7,R7,R5, LSR #+9
   2978          				}
   2979          			}
   2980          		}
   2981          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_4: (+1)
   \   000000EA   0x68A0             LDR      R0,[R4, #+8]
   \   000000EC   0x05C0             LSLS     R0,R0,#+23
   \   000000EE   0xD003             BEQ.N    ??f_lseek_16
   \   000000F0   0x69A0             LDR      R0,[R4, #+24]
   \   000000F2   0x4287             CMP      R7,R0
   \   000000F4   0xD000             BEQ.N    ??f_lseek_16
   2982          #if !_FS_TINY
   2983          #if !_FS_READONLY
   2984          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   2985          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   2986          					ABORT(fp->fs, FR_DISK_ERR);
   2987          				fp->flag &= ~FA__DIRTY;
   2988          			}
   2989          #endif
   2990          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   2991          				ABORT(fp->fs, FR_DISK_ERR);
   2992          #endif
   2993          			fp->dsect = nsect;
   \   000000F6   0x61A7             STR      R7,[R4, #+24]
   2994          		}
   2995          #if !_FS_READONLY
   2996          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_16: (+1)
   \   000000F8   0x68A0             LDR      R0,[R4, #+8]
   \   000000FA   0x68E1             LDR      R1,[R4, #+12]
   \   000000FC   0x4281             CMP      R1,R0
   \   000000FE   0xD204             BCS.N    ??f_lseek_0
   2997          			fp->fsize = fp->fptr;
   \   00000100   0x60E0             STR      R0,[R4, #+12]
   2998          			fp->flag |= FA__WRITTEN;
   \   00000102   0x79A0             LDRB     R0,[R4, #+6]
   \   00000104   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000108   0x71A0             STRB     R0,[R4, #+6]
   2999          		}
   3000          #endif
   3001          	}
   3002          
   3003          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_0: (+1)
   \   0000010A   0x4630             MOV      R0,R6
   \                     ??f_lseek_2: (+1)
   \   0000010C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   3004          }
   3005          
   3006          
   3007          
   3008          #if _FS_MINIMIZE <= 1
   3009          /*-----------------------------------------------------------------------*/
   3010          /* Create a Directory Object                                             */
   3011          /*-----------------------------------------------------------------------*/
   3012          

   \                                 In section .text, align 2, keep-with-next
   3013          FRESULT f_opendir (
   3014          	DIR *dj,			/* Pointer to directory object to create */
   3015          	const TCHAR *path	/* Pointer to the directory path */
   3016          )
   3017          {
   \                     f_opendir: (+1)
   \   00000000   0xB572             PUSH     {R1,R4-R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   3018          	FRESULT res;
   3019          	FATFS *fs;
   3020          	DEF_NAMEBUF;
   3021          
   3022          
   3023          	if (!dj) return FR_INVALID_OBJECT;
   \   00000006   0xD101             BNE.N    ??f_opendir_0
   \   00000008   0x2009             MOVS     R0,#+9
   \   0000000A   0xE02F             B.N      ??f_opendir_1
   3024          
   3025          	res = chk_mounted(&path, &dj->fs, 0);
   \                     ??f_opendir_0: (+1)
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x4621             MOV      R1,R4
   \   00000010   0xA803             ADD      R0,SP,#+12
   \   00000012   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   \   00000016   0x0005             MOVS     R5,R0
   3026          	fs = dj->fs;
   \   00000018   0x6826             LDR      R6,[R4, #+0]
   3027          	if (res == FR_OK) {
   \   0000001A   0xD124             BNE.N    ??f_opendir_2
   3028          		INIT_BUF(*dj);
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x61A0             STR      R0,[R4, #+24]
   3029          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \   00000020   0x9903             LDR      R1,[SP, #+12]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   \   00000028   0x0005             MOVS     R5,R0
   3030          		FREE_BUF();
   3031          		if (res == FR_OK) {						/* Follow completed */
   \   0000002A   0xD114             BNE.N    ??f_opendir_3
   3032          			if (dj->dir) {						/* It is not the root dir */
   \   0000002C   0x6961             LDR      R1,[R4, #+20]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD008             BEQ.N    ??f_opendir_4
   3033          				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   00000032   0x7AC8             LDRB     R0,[R1, #+11]
   \   00000034   0x06C0             LSLS     R0,R0,#+27
   \   00000036   0xD504             BPL.N    ??f_opendir_5
   3034          					dj->sclust = ld_clust(fs, dj->dir);
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x.... 0x....      BL       _Z8ld_clustP5FATFSPh
   \   0000003E   0x60A0             STR      R0,[R4, #+8]
   \   00000040   0xE000             B.N      ??f_opendir_4
   3035          				} else {						/* The object is not a directory */
   3036          					res = FR_NO_PATH;
   \                     ??f_opendir_5: (+1)
   \   00000042   0x2505             MOVS     R5,#+5
   3037          				}
   3038          			}
   3039          			if (res == FR_OK) {
   \                     ??f_opendir_4: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD106             BNE.N    ??f_opendir_3
   3040          				dj->id = fs->id;
   \   00000048   0x88F0             LDRH     R0,[R6, #+6]
   \   0000004A   0x80A0             STRH     R0,[R4, #+4]
   3041          				res = dir_sdi(dj, 0);			/* Rewind dir */
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _Z7dir_sdiP3DIRt
   \   00000054   0x4605             MOV      R5,R0
   3042          			}
   3043          		}
   3044          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_3: (+1)
   \   00000056   0x2D04             CMP      R5,#+4
   \   00000058   0xD100             BNE.N    ??f_opendir_6
   \   0000005A   0x2505             MOVS     R5,#+5
   3045          		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
   \                     ??f_opendir_6: (+1)
   \   0000005C   0x2D00             CMP      R5,#+0
   \   0000005E   0xD004             BEQ.N    ??f_opendir_7
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6020             STR      R0,[R4, #+0]
   \   00000064   0xE001             B.N      ??f_opendir_7
   3046          	} else {
   3047          		dj->fs = 0;
   \                     ??f_opendir_2: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6020             STR      R0,[R4, #+0]
   3048          	}
   3049          
   3050          	LEAVE_FF(fs, res);
   \                     ??f_opendir_7: (+1)
   \   0000006A   0x4628             MOV      R0,R5
   \                     ??f_opendir_1: (+1)
   \   0000006C   0xB004             ADD      SP,SP,#+16
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
   3051          }
   3052          
   3053          
   3054          
   3055          
   3056          /*-----------------------------------------------------------------------*/
   3057          /* Read Directory Entry in Sequence                                      */
   3058          /*-----------------------------------------------------------------------*/
   3059          

   \                                 In section .text, align 2, keep-with-next
   3060          FRESULT f_readdir (
   3061          	DIR *dj,			/* Pointer to the open directory object */
   3062          	FILINFO *fno		/* Pointer to file information to return */
   3063          )
   3064          {
   \                     f_readdir: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   3065          	FRESULT res;
   3066          	DEF_NAMEBUF;
   3067          
   3068          
   3069          	res = validate(dj);						/* Check validity of the object */
   \   00000006   0x.... 0x....      BL       _Z8validatePv
   3070          	if (res == FR_OK) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11D             BNE.N    ??f_readdir_0
   3071          		if (!fno) {
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD104             BNE.N    ??f_readdir_1
   3072          			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _Z7dir_sdiP3DIRt
   \   0000001A   0xBD3E             POP      {R1-R5,PC}
   3073          		} else {
   3074          			INIT_BUF(*dj);
   \                     ??f_readdir_1: (+1)
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x61A0             STR      R0,[R4, #+24]
   3075          			res = dir_read(dj);				/* Read an directory item */
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _Z8dir_readP3DIR
   3076          			if (res == FR_NO_FILE) {		/* Reached end of dir */
   \   00000026   0x2804             CMP      R0,#+4
   \   00000028   0xD101             BNE.N    ??f_readdir_2
   3077          				dj->sect = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6120             STR      R0,[R4, #+16]
   3078          				res = FR_OK;
   3079          			}
   3080          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_2: (+1)
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD10B             BNE.N    ??f_readdir_0
   3081          				get_fileinfo(dj, fno);		/* Get the object information */
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x.... 0x....      BL       _Z12get_fileinfoP3DIRP7FILINFO
   3082          				res = dir_next(dj, 0);		/* Increment index for next */
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       _Z8dir_nextP3DIRi
   3083          				if (res == FR_NO_FILE) {
   \   00000042   0x2804             CMP      R0,#+4
   \   00000044   0xD101             BNE.N    ??f_readdir_0
   3084          					dj->sect = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6120             STR      R0,[R4, #+16]
   3085          					res = FR_OK;
   3086          				}
   3087          			}
   3088          			FREE_BUF();
   3089          		}
   3090          	}
   3091          
   3092          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0: (+1)
   \   0000004A   0xBD3E             POP      {R1-R5,PC}       ;; return
   3093          }
   3094          
   3095          
   3096          
   3097          #if _FS_MINIMIZE == 0
   3098          /*-----------------------------------------------------------------------*/
   3099          /* Get File Status                                                       */
   3100          /*-----------------------------------------------------------------------*/
   3101          

   \                                 In section .text, align 2, keep-with-next
   3102          FRESULT f_stat (
   3103          	const TCHAR *path,	/* Pointer to the file path */
   3104          	FILINFO *fno		/* Pointer to file information to return */
   3105          )
   3106          {
   \                     f_stat: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x460C             MOV      R4,R1
   3107          	FRESULT res;
   3108          	DIR dj;
   3109          	DEF_NAMEBUF;
   3110          
   3111          
   3112          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA903             ADD      R1,SP,#+12
   \   0000000A   0xA80A             ADD      R0,SP,#+40
   \   0000000C   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   \   00000010   0x0005             MOVS     R5,R0
   3113          	if (res == FR_OK) {
   \   00000012   0xD110             BNE.N    ??f_stat_0
   3114          		INIT_BUF(dj);
   \   00000014   0xA800             ADD      R0,SP,#+0
   \   00000016   0x9009             STR      R0,[SP, #+36]
   3115          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000018   0x990A             LDR      R1,[SP, #+40]
   \   0000001A   0xA803             ADD      R0,SP,#+12
   \   0000001C   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   \   00000020   0x0005             MOVS     R5,R0
   3116          		if (res == FR_OK) {				/* Follow completed */
   \   00000022   0xD108             BNE.N    ??f_stat_0
   3117          			if (dj.dir)		/* Found an object */
   \   00000024   0x9808             LDR      R0,[SP, #+32]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD004             BEQ.N    ??f_stat_1
   3118          				get_fileinfo(&dj, fno);
   \   0000002A   0x4621             MOV      R1,R4
   \   0000002C   0xA803             ADD      R0,SP,#+12
   \   0000002E   0x.... 0x....      BL       _Z12get_fileinfoP3DIRP7FILINFO
   \   00000032   0xE000             B.N      ??f_stat_0
   3119          			else			/* It is root dir */
   3120          				res = FR_INVALID_NAME;
   \                     ??f_stat_1: (+1)
   \   00000034   0x2506             MOVS     R5,#+6
   3121          		}
   3122          		FREE_BUF();
   3123          	}
   3124          
   3125          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0: (+1)
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0xB00B             ADD      SP,SP,#+44
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return
   3126          }
   3127          
   3128          
   3129          
   3130          #if !_FS_READONLY
   3131          /*-----------------------------------------------------------------------*/
   3132          /* Get Number of Free Clusters                                           */
   3133          /*-----------------------------------------------------------------------*/
   3134          

   \                                 In section .text, align 2, keep-with-next
   3135          FRESULT f_getfree (
   3136          	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
   3137          	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
   3138          	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
   3139          )
   3140          {
   \                     f_getfree: (+1)
   \   00000000   0xE92D 0x47F1      PUSH     {R0,R4-R10,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4614             MOV      R4,R2
   3141          	FRESULT res;
   3142          	FATFS *fs;
   3143          	DWORD n, clst, sect, stat;
   3144          	UINT i;
   3145          	BYTE fat, *p;
   3146          
   3147          
   3148          	/* Get drive number */
   3149          	res = chk_mounted(&path, fatfs, 0);
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   \   00000014   0x4680             MOV      R8,R0
   3150          	fs = *fatfs;
   \   00000016   0x6826             LDR      R6,[R4, #+0]
   3151          	if (res == FR_OK) {
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD15F             BNE.N    ??f_getfree_0
   3152          		/* If free_clust is valid, return it without full cluster scan */
   3153          		if (fs->free_clust <= fs->n_fatent - 2) {
   \   0000001E   0x6930             LDR      R0,[R6, #+16]
   \   00000020   0x69B4             LDR      R4,[R6, #+24]
   \   00000022   0x1EA1             SUBS     R1,R4,#+2
   \   00000024   0x4281             CMP      R1,R0
   \   00000026   0xD301             BCC.N    ??f_getfree_1
   3154          			*nclst = fs->free_clust;
   \   00000028   0x6028             STR      R0,[R5, #+0]
   \   0000002A   0xE058             B.N      ??f_getfree_0
   3155          		} else {
   3156          			/* Get number of free clusters */
   3157          			fat = fs->fs_type;
   \                     ??f_getfree_1: (+1)
   \   0000002C   0x7837             LDRB     R7,[R6, #+0]
   3158          			n = 0;
   \   0000002E   0xF04F 0x0900      MOV      R9,#+0
   3159          			if (fat == FS_FAT12) {
   \   00000032   0x2F01             CMP      R7,#+1
   \   00000034   0xD118             BNE.N    ??f_getfree_2
   3160          				clst = 2;
   \   00000036   0x2402             MOVS     R4,#+2
   3161          				do {
   3162          					stat = get_fat(fs, clst);
   \                     ??f_getfree_3: (+1)
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   3163          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   00000040   0xF110 0x0F01      CMN      R0,#+1
   \   00000044   0xD102             BNE.N    ??f_getfree_4
   \   00000046   0xF04F 0x0801      MOV      R8,#+1
   \   0000004A   0xE040             B.N      ??f_getfree_5
   3164          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4: (+1)
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD102             BNE.N    ??f_getfree_6
   \   00000050   0xF04F 0x0802      MOV      R8,#+2
   \   00000054   0xE03B             B.N      ??f_getfree_5
   3165          					if (stat == 0) n++;
   \                     ??f_getfree_6: (+1)
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD101             BNE.N    ??f_getfree_7
   \   0000005A   0xF109 0x0901      ADD      R9,R9,#+1
   3166          				} while (++clst < fs->n_fatent);
   \                     ??f_getfree_7: (+1)
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
   \   00000060   0x69B0             LDR      R0,[R6, #+24]
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD3E8             BCC.N    ??f_getfree_3
   \   00000066   0xE032             B.N      ??f_getfree_5
   3167          			} else {
   3168          				clst = fs->n_fatent;
   3169          				sect = fs->fatbase;
   \                     ??f_getfree_2: (+1)
   \   00000068   0xF8D6 0xA020      LDR      R10,[R6, #+32]
   3170          				i = 0; p = 0;
   \   0000006C   0x4649             MOV      R1,R9
   \   0000006E   0x4608             MOV      R0,R1
   3171          				do {
   3172          					if (!i) {
   \                     ??f_getfree_8: (+1)
   \   00000070   0x2900             CMP      R1,#+0
   \   00000072   0xD10D             BNE.N    ??f_getfree_9
   3173          						res = move_window(fs, sect++);
   \   00000074   0x4651             MOV      R1,R10
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000007C   0x4680             MOV      R8,R0
   \   0000007E   0xF10A 0x0A01      ADD      R10,R10,#+1
   3174          						if (res != FR_OK) break;
   \   00000082   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000086   0xD122             BNE.N    ??f_getfree_5
   3175          						p = fs->win;
   \   00000088   0xF106 0x0030      ADD      R0,R6,#+48
   3176          						i = SS(fs);
   \   0000008C   0xF44F 0x7100      MOV      R1,#+512
   3177          					}
   3178          					if (fat == FS_FAT16) {
   \                     ??f_getfree_9: (+1)
   \   00000090   0x7842             LDRB     R2,[R0, #+1]
   \   00000092   0x7803             LDRB     R3,[R0, #+0]
   \   00000094   0x2F02             CMP      R7,#+2
   \   00000096   0xD107             BNE.N    ??f_getfree_10
   3179          						if (LD_WORD(p) == 0) n++;
   \   00000098   0xEA53 0x2202      ORRS     R2,R3,R2, LSL #+8
   \   0000009C   0xD101             BNE.N    ??f_getfree_11
   \   0000009E   0xF109 0x0901      ADD      R9,R9,#+1
   3180          						p += 2; i -= 2;
   \                     ??f_getfree_11: (+1)
   \   000000A2   0x1C80             ADDS     R0,R0,#+2
   \   000000A4   0x1E89             SUBS     R1,R1,#+2
   \   000000A6   0xE010             B.N      ??f_getfree_12
   3181          					} else {
   3182          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_10: (+1)
   \   000000A8   0xF890 0xC003      LDRB     R12,[R0, #+3]
   \   000000AC   0xF890 0xE002      LDRB     LR,[R0, #+2]
   \   000000B0   0xEA4F 0x4E0E      LSL      LR,LR,#+16
   \   000000B4   0xEA4E 0x6C0C      ORR      R12,LR,R12, LSL #+24
   \   000000B8   0xEA4C 0x2202      ORR      R2,R12,R2, LSL #+8
   \   000000BC   0x431A             ORRS     R2,R3,R2
   \   000000BE   0x0112             LSLS     R2,R2,#+4
   \   000000C0   0xD101             BNE.N    ??f_getfree_13
   \   000000C2   0xF109 0x0901      ADD      R9,R9,#+1
   3183          						p += 4; i -= 4;
   \                     ??f_getfree_13: (+1)
   \   000000C6   0x1D00             ADDS     R0,R0,#+4
   \   000000C8   0x1F09             SUBS     R1,R1,#+4
   3184          					}
   3185          				} while (--clst);
   \                     ??f_getfree_12: (+1)
   \   000000CA   0x1E64             SUBS     R4,R4,#+1
   \   000000CC   0xD1D0             BNE.N    ??f_getfree_8
   3186          			}
   3187          			fs->free_clust = n;
   \                     ??f_getfree_5: (+1)
   \   000000CE   0xF8C6 0x9010      STR      R9,[R6, #+16]
   3188          			if (fat == FS_FAT32) fs->fsi_flag = 1;
   \   000000D2   0x2F03             CMP      R7,#+3
   \   000000D4   0xD101             BNE.N    ??f_getfree_14
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x7170             STRB     R0,[R6, #+5]
   3189          			*nclst = n;
   \                     ??f_getfree_14: (+1)
   \   000000DA   0xF8C5 0x9000      STR      R9,[R5, #+0]
   3190          		}
   3191          	}
   3192          	LEAVE_FF(fs, res);
   \                     ??f_getfree_0: (+1)
   \   000000DE   0x4640             MOV      R0,R8
   \   000000E0   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   3193          }
   3194          
   3195          
   3196          
   3197          
   3198          /*-----------------------------------------------------------------------*/
   3199          /* Truncate File                                                         */
   3200          /*-----------------------------------------------------------------------*/
   3201          

   \                                 In section .text, align 2, keep-with-next
   3202          FRESULT f_truncate (
   3203          	FIL *fp		/* Pointer to the file object */
   3204          )
   3205          {
   \                     f_truncate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3206          	FRESULT res;
   3207          	DWORD ncl;
   3208          
   3209          
   3210          	if (!fp) return FR_INVALID_OBJECT;
   \   00000004   0xD101             BNE.N    ??f_truncate_0
   \   00000006   0x2009             MOVS     R0,#+9
   \   00000008   0xBD70             POP      {R4-R6,PC}
   3211          
   3212          	res = validate(fp);						/* Check validity of the object */
   \                     ??f_truncate_0: (+1)
   \   0000000A   0x.... 0x....      BL       _Z8validatePv
   \   0000000E   0x0005             MOVS     R5,R0
   3213          	if (res == FR_OK) {
   \   00000010   0xD107             BNE.N    ??f_truncate_1
   3214          		if (fp->flag & FA__ERROR) {			/* Check abort flag */
   \   00000012   0x79A0             LDRB     R0,[R4, #+6]
   \   00000014   0x0601             LSLS     R1,R0,#+24
   \   00000016   0xD501             BPL.N    ??f_truncate_2
   3215          			res = FR_INT_ERR;
   \   00000018   0x2502             MOVS     R5,#+2
   \   0000001A   0xE002             B.N      ??f_truncate_1
   3216          		} else {
   3217          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_2: (+1)
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD400             BMI.N    ??f_truncate_1
   3218          				res = FR_DENIED;
   \   00000020   0x2507             MOVS     R5,#+7
   3219          		}
   3220          	}
   3221          	if (res == FR_OK) {
   \                     ??f_truncate_1: (+1)
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD136             BNE.N    ??f_truncate_3
   3222          		if (fp->fsize > fp->fptr) {
   \   00000026   0x68A0             LDR      R0,[R4, #+8]
   \   00000028   0x68E1             LDR      R1,[R4, #+12]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD22C             BCS.N    ??f_truncate_4
   3223          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   0000002E   0x60E0             STR      R0,[R4, #+12]
   3224          			fp->flag |= FA__WRITTEN;
   \   00000030   0x79A0             LDRB     R0,[R4, #+6]
   \   00000032   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000036   0x71A0             STRB     R0,[R4, #+6]
   3225          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x68A1             LDR      R1,[R4, #+8]
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD106             BNE.N    ??f_truncate_5
   3226          				res = remove_chain(fp->fs, fp->sclust);
   \   00000040   0x6921             LDR      R1,[R4, #+16]
   \   00000042   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   00000046   0x4605             MOV      R5,R0
   3227          				fp->sclust = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x6120             STR      R0,[R4, #+16]
   \   0000004C   0xE01C             B.N      ??f_truncate_4
   3228          			} else {				/* When truncate a part of the file, remove remaining clusters */
   3229          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_5: (+1)
   \   0000004E   0x6961             LDR      R1,[R4, #+20]
   \   00000050   0x.... 0x....      BL       _Z7get_fatP5FATFSm
   \   00000054   0x4606             MOV      R6,R0
   3230          				res = FR_OK;
   3231          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   00000056   0xF116 0x0F01      CMN      R6,#+1
   \   0000005A   0xD100             BNE.N    ??f_truncate_6
   \   0000005C   0x2501             MOVS     R5,#+1
   3232          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_6: (+1)
   \   0000005E   0x2E01             CMP      R6,#+1
   \   00000060   0xD100             BNE.N    ??f_truncate_7
   \   00000062   0x2502             MOVS     R5,#+2
   3233          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_7: (+1)
   \   00000064   0x2D00             CMP      R5,#+0
   \   00000066   0xD10F             BNE.N    ??f_truncate_4
   \   00000068   0x6820             LDR      R0,[R4, #+0]
   \   0000006A   0x6981             LDR      R1,[R0, #+24]
   \   0000006C   0x428E             CMP      R6,R1
   \   0000006E   0xD20B             BCS.N    ??f_truncate_4
   3234          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   00000070   0xF06F 0x4270      MVN      R2,#-268435456
   \   00000074   0x6961             LDR      R1,[R4, #+20]
   \   00000076   0x.... 0x....      BL       _Z7put_fatP5FATFSmm
   \   0000007A   0x0005             MOVS     R5,R0
   3235          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   0000007C   0xD104             BNE.N    ??f_truncate_4
   \   0000007E   0x4631             MOV      R1,R6
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   00000086   0x4605             MOV      R5,R0
   3236          				}
   3237          			}
   3238          		}
   3239          		if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_4: (+1)
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD003             BEQ.N    ??f_truncate_3
   \   0000008C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000008E   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000092   0x71A0             STRB     R0,[R4, #+6]
   3240          	}
   3241          
   3242          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_3: (+1)
   \   00000094   0x4628             MOV      R0,R5
   \   00000096   0xBD70             POP      {R4-R6,PC}       ;; return
   3243          }
   3244          
   3245          
   3246          
   3247          
   3248          /*-----------------------------------------------------------------------*/
   3249          /* Delete a File or Directory                                            */
   3250          /*-----------------------------------------------------------------------*/
   3251          

   \                                 In section .text, align 2, keep-with-next
   3252          FRESULT f_unlink (
   3253          	const TCHAR *path		/* Pointer to the file or directory path */
   3254          )
   3255          {
   \                     f_unlink: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB091             SUB      SP,SP,#+68
   3256          	FRESULT res;
   3257          	DIR dj, sdj;
   3258          	BYTE *dir;
   3259          	DWORD dclst;
   3260          	DEF_NAMEBUF;
   3261          
   3262          
   3263          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xA900             ADD      R1,SP,#+0
   \   00000008   0xA811             ADD      R0,SP,#+68
   \   0000000A   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   \   0000000E   0x0004             MOVS     R4,R0
   3264          	if (res == FR_OK) {
   \   00000010   0xD14E             BNE.N    ??f_unlink_0
   3265          		INIT_BUF(dj);
   \   00000012   0xA807             ADD      R0,SP,#+28
   \   00000014   0x9006             STR      R0,[SP, #+24]
   3266          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000016   0x9911             LDR      R1,[SP, #+68]
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   \   0000001E   0x0004             MOVS     R4,R0
   3267          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   3268          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   3269          #if _FS_LOCK
   3270          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
   \   00000020   0xD104             BNE.N    ??f_unlink_1
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       _Z8chk_lockP3DIRi
   \   0000002A   0x4604             MOV      R4,R0
   3271          #endif
   3272          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_1: (+1)
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD13F             BNE.N    ??f_unlink_0
   3273          			dir = dj.dir;
   \   00000030   0x9D05             LDR      R5,[SP, #+20]
   3274          			if (!dir) {
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD101             BNE.N    ??f_unlink_2
   3275          				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
   \   00000036   0x2406             MOVS     R4,#+6
   \   00000038   0xE003             B.N      ??f_unlink_3
   3276          			} else {
   3277          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_2: (+1)
   \   0000003A   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000003C   0x07C0             LSLS     R0,R0,#+31
   \   0000003E   0xD500             BPL.N    ??f_unlink_3
   3278          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   00000040   0x2407             MOVS     R4,#+7
   3279          			}
   3280          			dclst = ld_clust(dj.fs, dir);
   \                     ??f_unlink_3: (+1)
   \   00000042   0x4629             MOV      R1,R5
   \   00000044   0x9800             LDR      R0,[SP, #+0]
   \   00000046   0x.... 0x....      BL       _Z8ld_clustP5FATFSPh
   \   0000004A   0x4606             MOV      R6,R0
   3281          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \   0000004C   0x2C00             CMP      R4,#+0
   \   0000004E   0xD11B             BNE.N    ??f_unlink_4
   \   00000050   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000052   0x06C0             LSLS     R0,R0,#+27
   \   00000054   0xD518             BPL.N    ??f_unlink_4
   3282          				if (dclst < 2) {
   \   00000056   0x2E02             CMP      R6,#+2
   \   00000058   0xD201             BCS.N    ??f_unlink_5
   3283          					res = FR_INT_ERR;
   \   0000005A   0x2402             MOVS     R4,#+2
   \   0000005C   0xE014             B.N      ??f_unlink_4
   3284          				} else {
   3285          					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
   \                     ??f_unlink_5: (+1)
   \   0000005E   0x221C             MOVS     R2,#+28
   \   00000060   0xA900             ADD      R1,SP,#+0
   \   00000062   0xA80A             ADD      R0,SP,#+40
   \   00000064   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   3286          					sdj.sclust = dclst;
   \   00000068   0x960C             STR      R6,[SP, #+48]
   3287          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   0000006A   0x2102             MOVS     R1,#+2
   \   0000006C   0xA80A             ADD      R0,SP,#+40
   \   0000006E   0x.... 0x....      BL       _Z7dir_sdiP3DIRt
   \   00000072   0x0004             MOVS     R4,R0
   3288          					if (res == FR_OK) {
   \   00000074   0xD108             BNE.N    ??f_unlink_4
   3289          						res = dir_read(&sdj);
   \   00000076   0xA80A             ADD      R0,SP,#+40
   \   00000078   0x.... 0x....      BL       _Z8dir_readP3DIR
   \   0000007C   0x0004             MOVS     R4,R0
   3290          						if (res == FR_OK		/* Not empty dir */
   3291          #if _FS_RPATH
   3292          						|| dclst == dj.fs->cdir	/* Current dir */
   3293          #endif
   3294          						) res = FR_DENIED;
   \   0000007E   0xD100             BNE.N    ??f_unlink_6
   \   00000080   0x2407             MOVS     R4,#+7
   3295          						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
   \                     ??f_unlink_6: (+1)
   \   00000082   0x2C04             CMP      R4,#+4
   \   00000084   0xD100             BNE.N    ??f_unlink_4
   \   00000086   0x2400             MOVS     R4,#+0
   3296          					}
   3297          				}
   3298          			}
   3299          			if (res == FR_OK) {
   \                     ??f_unlink_4: (+1)
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD111             BNE.N    ??f_unlink_0
   3300          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       _Z10dir_removeP3DIR
   \   00000092   0x0004             MOVS     R4,R0
   3301          				if (res == FR_OK) {
   \   00000094   0xD10C             BNE.N    ??f_unlink_0
   3302          					if (dclst)				/* Remove the cluster chain if exist */
   \   00000096   0x2E00             CMP      R6,#+0
   \   00000098   0xD004             BEQ.N    ??f_unlink_7
   3303          						res = remove_chain(dj.fs, dclst);
   \   0000009A   0x4631             MOV      R1,R6
   \   0000009C   0x9800             LDR      R0,[SP, #+0]
   \   0000009E   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   000000A2   0x4604             MOV      R4,R0
   3304          					if (res == FR_OK) res = sync(dj.fs);
   \                     ??f_unlink_7: (+1)
   \   000000A4   0x2C00             CMP      R4,#+0
   \   000000A6   0xD103             BNE.N    ??f_unlink_0
   \   000000A8   0x9800             LDR      R0,[SP, #+0]
   \   000000AA   0x.... 0x....      BL       _Z4syncP5FATFS
   \   000000AE   0x4604             MOV      R4,R0
   3305          				}
   3306          			}
   3307          		}
   3308          		FREE_BUF();
   3309          	}
   3310          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0: (+1)
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0xB012             ADD      SP,SP,#+72
   \   000000B4   0xBD70             POP      {R4-R6,PC}       ;; return
   3311          }
   3312          
   3313          
   3314          
   3315          
   3316          /*-----------------------------------------------------------------------*/
   3317          /* Create a Directory                                                    */
   3318          /*-----------------------------------------------------------------------*/
   3319          

   \                                 In section .text, align 2, keep-with-next
   3320          FRESULT f_mkdir (
   3321          	const TCHAR *path		/* Pointer to the directory path */
   3322          )
   3323          {
   \                     f_mkdir: (+1)
   \   00000000   0xE92D 0x43F1      PUSH     {R0,R4-R9,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   3324          	FRESULT res;
   3325          	DIR dj;
   3326          	BYTE *dir, n;
   3327          	DWORD dsc, dcl, pcl, tim = get_fattime();
   \   00000006   0x.... 0x....      BL       get_fattime
   \   0000000A   0x4604             MOV      R4,R0
   3328          	DEF_NAMEBUF;
   3329          
   3330          
   3331          	res = chk_mounted(&path, &dj.fs, 1);
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xA900             ADD      R1,SP,#+0
   \   00000010   0xA80A             ADD      R0,SP,#+40
   \   00000012   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   \   00000016   0x0006             MOVS     R6,R0
   3332          	if (res == FR_OK) {
   \   00000018   0xF040 0x80AD      BNE.W    ??f_mkdir_0
   3333          		INIT_BUF(dj);
   \   0000001C   0xA807             ADD      R0,SP,#+28
   \   0000001E   0x9006             STR      R0,[SP, #+24]
   3334          		res = follow_path(&dj, path);			/* Follow the file path */
   \   00000020   0x990A             LDR      R1,[SP, #+40]
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   \   00000028   0x0006             MOVS     R6,R0
   3335          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   0000002A   0xD100             BNE.N    ??f_mkdir_1
   \   0000002C   0x2608             MOVS     R6,#+8
   3336          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   3337          			res = FR_INVALID_NAME;
   3338          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_1: (+1)
   \   0000002E   0x2E04             CMP      R6,#+4
   \   00000030   0xF040 0x80A1      BNE.W    ??f_mkdir_0
   3339          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x.... 0x....      BL       _Z12create_chainP5FATFSm
   \   0000003C   0x4605             MOV      R5,R0
   3340          			res = FR_OK;
   \   0000003E   0x2600             MOVS     R6,#+0
   3341          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD100             BNE.N    ??f_mkdir_2
   \   00000044   0x2607             MOVS     R6,#+7
   3342          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_2: (+1)
   \   00000046   0x2D01             CMP      R5,#+1
   \   00000048   0xD100             BNE.N    ??f_mkdir_3
   \   0000004A   0x2602             MOVS     R6,#+2
   3343          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_3: (+1)
   \   0000004C   0xF115 0x0F01      CMN      R5,#+1
   \   00000050   0xD100             BNE.N    ??f_mkdir_4
   \   00000052   0x2601             MOVS     R6,#+1
   3344          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_4: (+1)
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD104             BNE.N    ??f_mkdir_5
   3345          				res = move_window(dj.fs, 0);
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   00000060   0x4606             MOV      R6,R0
   3346          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_5: (+1)
   \   00000062   0x2E00             CMP      R6,#+0
   \   00000064   0xD15D             BNE.N    ??f_mkdir_6
   3347          				dsc = clust2sect(dj.fs, dcl);
   \   00000066   0x4629             MOV      R1,R5
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x.... 0x....      BL       clust2sect
   \   0000006E   0x4607             MOV      R7,R0
   3348          				dir = dj.fs->win;
   \   00000070   0x9800             LDR      R0,[SP, #+0]
   \   00000072   0xF100 0x0830      ADD      R8,R0,#+48
   3349          				mem_set(dir, 0, SS(dj.fs));
   \   00000076   0xF44F 0x7200      MOV      R2,#+512
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0x.... 0x....      BL       _Z7mem_setPvij
   3350          				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
   \   00000082   0x220B             MOVS     R2,#+11
   \   00000084   0x2120             MOVS     R1,#+32
   \   00000086   0x4640             MOV      R0,R8
   \   00000088   0x.... 0x....      BL       _Z7mem_setPvij
   3351          				dir[DIR_Name] = '.';
   \   0000008C   0x202E             MOVS     R0,#+46
   \   0000008E   0xF888 0x0000      STRB     R0,[R8, #+0]
   3352          				dir[DIR_Attr] = AM_DIR;
   \   00000092   0x2010             MOVS     R0,#+16
   \   00000094   0xF888 0x000B      STRB     R0,[R8, #+11]
   3353          				ST_DWORD(dir+DIR_WrtTime, tim);
   \   00000098   0xF888 0x4016      STRB     R4,[R8, #+22]
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0xB280             UXTH     R0,R0
   \   000000A0   0x0A00             LSRS     R0,R0,#+8
   \   000000A2   0xF888 0x0017      STRB     R0,[R8, #+23]
   \   000000A6   0x0C20             LSRS     R0,R4,#+16
   \   000000A8   0xF888 0x0018      STRB     R0,[R8, #+24]
   \   000000AC   0x0E20             LSRS     R0,R4,#+24
   \   000000AE   0xF888 0x0019      STRB     R0,[R8, #+25]
   3354          				st_clust(dir, dcl);
   \   000000B2   0x4629             MOV      R1,R5
   \   000000B4   0x4640             MOV      R0,R8
   \   000000B6   0x.... 0x....      BL       _Z8st_clustPhm
   3355          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   000000BA   0x2220             MOVS     R2,#+32
   \   000000BC   0x4641             MOV      R1,R8
   \   000000BE   0xF108 0x0020      ADD      R0,R8,#+32
   \   000000C2   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   3356          				dir[33] = '.'; pcl = dj.sclust;
   \   000000C6   0x202E             MOVS     R0,#+46
   \   000000C8   0xF888 0x0021      STRB     R0,[R8, #+33]
   \   000000CC   0x9902             LDR      R1,[SP, #+8]
   3357          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   000000CE   0x9800             LDR      R0,[SP, #+0]
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x2803             CMP      R0,#+3
   \   000000D4   0xD104             BNE.N    ??f_mkdir_7
   \   000000D6   0x9800             LDR      R0,[SP, #+0]
   \   000000D8   0x6A40             LDR      R0,[R0, #+36]
   \   000000DA   0x4281             CMP      R1,R0
   \   000000DC   0xD100             BNE.N    ??f_mkdir_7
   3358          					pcl = 0;
   \   000000DE   0x2100             MOVS     R1,#+0
   3359          				st_clust(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_7: (+1)
   \   000000E0   0xF108 0x0020      ADD      R0,R8,#+32
   \   000000E4   0x.... 0x....      BL       _Z8st_clustPhm
   3360          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   000000E8   0x9800             LDR      R0,[SP, #+0]
   \   000000EA   0xF890 0x9002      LDRB     R9,[R0, #+2]
   \   000000EE   0xE007             B.N      ??f_mkdir_8
   3361          					dj.fs->winsect = dsc++;
   3362          					dj.fs->wflag = 1;
   3363          					res = move_window(dj.fs, 0);
   3364          					if (res != FR_OK) break;
   3365          					mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_9: (+1)
   \   000000F0   0xF44F 0x7200      MOV      R2,#+512
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x4640             MOV      R0,R8
   \   000000F8   0x.... 0x....      BL       _Z7mem_setPvij
   \   000000FC   0xF1A9 0x0901      SUB      R9,R9,#+1
   \                     ??f_mkdir_8: (+1)
   \   00000100   0xFA5F 0xF989      UXTB     R9,R9
   \   00000104   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000108   0xD00B             BEQ.N    ??f_mkdir_6
   \   0000010A   0x9800             LDR      R0,[SP, #+0]
   \   0000010C   0x62C7             STR      R7,[R0, #+44]
   \   0000010E   0x1C7F             ADDS     R7,R7,#+1
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0x9900             LDR      R1,[SP, #+0]
   \   00000114   0x7108             STRB     R0,[R1, #+4]
   \   00000116   0x2100             MOVS     R1,#+0
   \   00000118   0x9800             LDR      R0,[SP, #+0]
   \   0000011A   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   0000011E   0x0006             MOVS     R6,R0
   \   00000120   0xD0E6             BEQ.N    ??f_mkdir_9
   3366          				}
   3367          			}
   3368          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_6: (+1)
   \   00000122   0x2E00             CMP      R6,#+0
   \   00000124   0xD103             BNE.N    ??f_mkdir_10
   \   00000126   0xA800             ADD      R0,SP,#+0
   \   00000128   0x.... 0x....      BL       _Z12dir_registerP3DIR
   \   0000012C   0x4606             MOV      R6,R0
   3369          			if (res != FR_OK) {
   \                     ??f_mkdir_10: (+1)
   \   0000012E   0x2E00             CMP      R6,#+0
   \   00000130   0xD004             BEQ.N    ??f_mkdir_11
   3370          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   00000132   0x4629             MOV      R1,R5
   \   00000134   0x9800             LDR      R0,[SP, #+0]
   \   00000136   0x.... 0x....      BL       _Z12remove_chainP5FATFSm
   \   0000013A   0xE01C             B.N      ??f_mkdir_0
   3371          			} else {
   3372          				dir = dj.dir;
   \                     ??f_mkdir_11: (+1)
   \   0000013C   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   3373          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   00000140   0x2010             MOVS     R0,#+16
   \   00000142   0xF888 0x000B      STRB     R0,[R8, #+11]
   3374          				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
   \   00000146   0xF888 0x4016      STRB     R4,[R8, #+22]
   \   0000014A   0x4620             MOV      R0,R4
   \   0000014C   0xB280             UXTH     R0,R0
   \   0000014E   0x0A00             LSRS     R0,R0,#+8
   \   00000150   0xF888 0x0017      STRB     R0,[R8, #+23]
   \   00000154   0x0C20             LSRS     R0,R4,#+16
   \   00000156   0xF888 0x0018      STRB     R0,[R8, #+24]
   \   0000015A   0x0E20             LSRS     R0,R4,#+24
   \   0000015C   0xF888 0x0019      STRB     R0,[R8, #+25]
   3375          				st_clust(dir, dcl);					/* Table start cluster */
   \   00000160   0x4629             MOV      R1,R5
   \   00000162   0x4640             MOV      R0,R8
   \   00000164   0x.... 0x....      BL       _Z8st_clustPhm
   3376          				dj.fs->wflag = 1;
   \   00000168   0x2001             MOVS     R0,#+1
   \   0000016A   0x9900             LDR      R1,[SP, #+0]
   \   0000016C   0x7108             STRB     R0,[R1, #+4]
   3377          				res = sync(dj.fs);
   \   0000016E   0x9800             LDR      R0,[SP, #+0]
   \   00000170   0x.... 0x....      BL       _Z4syncP5FATFS
   \   00000174   0x4606             MOV      R6,R0
   3378          			}
   3379          		}
   3380          		FREE_BUF();
   3381          	}
   3382          
   3383          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0: (+1)
   \   00000176   0x4630             MOV      R0,R6
   \   00000178   0xB00B             ADD      SP,SP,#+44
   \   0000017A   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   3384          }
   3385          
   3386          
   3387          
   3388          
   3389          /*-----------------------------------------------------------------------*/
   3390          /* Change Attribute                                                      */
   3391          /*-----------------------------------------------------------------------*/
   3392          

   \                                 In section .text, align 2, keep-with-next
   3393          FRESULT f_chmod (
   3394          	const TCHAR *path,	/* Pointer to the file path */
   3395          	BYTE value,			/* Attribute bits */
   3396          	BYTE mask			/* Attribute mask to change */
   3397          )
   3398          {
   \                     f_chmod: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08A             SUB      SP,SP,#+40
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0x4615             MOV      R5,R2
   3399          	FRESULT res;
   3400          	DIR dj;
   3401          	BYTE *dir;
   3402          	DEF_NAMEBUF;
   3403          
   3404          
   3405          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0xA80A             ADD      R0,SP,#+40
   \   0000000E   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   3406          	if (res == FR_OK) {
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD11A             BNE.N    ??f_chmod_0
   3407          		INIT_BUF(dj);
   \   00000016   0xA807             ADD      R0,SP,#+28
   \   00000018   0x9006             STR      R0,[SP, #+24]
   3408          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000001A   0x990A             LDR      R1,[SP, #+40]
   \   0000001C   0xA800             ADD      R0,SP,#+0
   \   0000001E   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   3409          		FREE_BUF();
   3410          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   3411          			res = FR_INVALID_NAME;
   3412          		if (res == FR_OK) {
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD112             BNE.N    ??f_chmod_0
   3413          			dir = dj.dir;
   \   00000026   0x9805             LDR      R0,[SP, #+20]
   3414          			if (!dir) {						/* Is it a root directory? */
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD101             BNE.N    ??f_chmod_1
   3415          				res = FR_INVALID_NAME;
   \   0000002C   0x2006             MOVS     R0,#+6
   \   0000002E   0xE00D             B.N      ??f_chmod_0
   3416          			} else {						/* File or sub directory */
   3417          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_1: (+1)
   \   00000030   0xF005 0x0527      AND      R5,R5,#0x27
   3418          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   \   00000034   0xEA05 0x0104      AND      R1,R5,R4
   \   00000038   0x7AC2             LDRB     R2,[R0, #+11]
   \   0000003A   0x43AA             BICS     R2,R2,R5
   \   0000003C   0x4311             ORRS     R1,R2,R1
   \   0000003E   0x72C1             STRB     R1,[R0, #+11]
   3419          				dj.fs->wflag = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0x7108             STRB     R0,[R1, #+4]
   3420          				res = sync(dj.fs);
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x.... 0x....      BL       _Z4syncP5FATFS
   3421          			}
   3422          		}
   3423          	}
   3424          
   3425          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0: (+1)
   \   0000004C   0xB00B             ADD      SP,SP,#+44
   \   0000004E   0xBD30             POP      {R4,R5,PC}       ;; return
   3426          }
   3427          
   3428          
   3429          
   3430          
   3431          /*-----------------------------------------------------------------------*/
   3432          /* Change Timestamp                                                      */
   3433          /*-----------------------------------------------------------------------*/
   3434          

   \                                 In section .text, align 2, keep-with-next
   3435          FRESULT f_utime (
   3436          	const TCHAR *path,	/* Pointer to the file/directory name */
   3437          	const FILINFO *fno	/* Pointer to the time stamp to be set */
   3438          )
   3439          {
   \                     f_utime: (+1)
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
   \   00000004   0x460C             MOV      R4,R1
   3440          	FRESULT res;
   3441          	DIR dj;
   3442          	BYTE *dir;
   3443          	DEF_NAMEBUF;
   3444          
   3445          
   3446          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xA80B             ADD      R0,SP,#+44
   \   0000000C   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   3447          	if (res == FR_OK) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD11C             BNE.N    ??f_utime_0
   3448          		INIT_BUF(dj);
   \   00000014   0xA807             ADD      R0,SP,#+28
   \   00000016   0x9006             STR      R0,[SP, #+24]
   3449          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000018   0x990B             LDR      R1,[SP, #+44]
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   3450          		FREE_BUF();
   3451          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   3452          			res = FR_INVALID_NAME;
   3453          		if (res == FR_OK) {
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD114             BNE.N    ??f_utime_0
   3454          			dir = dj.dir;
   \   00000024   0x9805             LDR      R0,[SP, #+20]
   3455          			if (!dir) {					/* Root directory */
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD101             BNE.N    ??f_utime_1
   3456          				res = FR_INVALID_NAME;
   \   0000002A   0x2006             MOVS     R0,#+6
   \   0000002C   0xE00F             B.N      ??f_utime_0
   3457          			} else {					/* File or sub-directory */
   3458          				ST_WORD(dir+DIR_WrtTime, fno->ftime);
   \                     ??f_utime_1: (+1)
   \   0000002E   0x88E1             LDRH     R1,[R4, #+6]
   \   00000030   0x7581             STRB     R1,[R0, #+22]
   \   00000032   0x88E1             LDRH     R1,[R4, #+6]
   \   00000034   0x0A09             LSRS     R1,R1,#+8
   \   00000036   0x75C1             STRB     R1,[R0, #+23]
   3459          				ST_WORD(dir+DIR_WrtDate, fno->fdate);
   \   00000038   0x88A1             LDRH     R1,[R4, #+4]
   \   0000003A   0x7601             STRB     R1,[R0, #+24]
   \   0000003C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000003E   0x0A09             LSRS     R1,R1,#+8
   \   00000040   0x7641             STRB     R1,[R0, #+25]
   3460          				dj.fs->wflag = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x9900             LDR      R1,[SP, #+0]
   \   00000046   0x7108             STRB     R0,[R1, #+4]
   3461          				res = sync(dj.fs);
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x.... 0x....      BL       _Z4syncP5FATFS
   3462          			}
   3463          		}
   3464          	}
   3465          
   3466          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0: (+1)
   \   0000004E   0xB00C             ADD      SP,SP,#+48
   \   00000050   0xBD10             POP      {R4,PC}          ;; return
   3467          }
   3468          
   3469          
   3470          
   3471          
   3472          /*-----------------------------------------------------------------------*/
   3473          /* Rename File/Directory                                                 */
   3474          /*-----------------------------------------------------------------------*/
   3475          

   \                                 In section .text, align 2, keep-with-next
   3476          FRESULT f_rename (
   3477          	const TCHAR *path_old,	/* Pointer to the old name */
   3478          	const TCHAR *path_new	/* Pointer to the new name */
   3479          )
   3480          {
   \                     f_rename: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB098             SUB      SP,SP,#+96
   \   00000004   0x460D             MOV      R5,R1
   3481          	FRESULT res;
   3482          	DIR djo, djn;
   3483          	BYTE buf[21], *dir;
   3484          	DWORD dw;
   3485          	DEF_NAMEBUF;
   3486          
   3487          
   3488          	res = chk_mounted(&path_old, &djo.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0xA818             ADD      R0,SP,#+96
   \   0000000C   0x.... 0x....      BL       _Z11chk_mountedPPKcPP5FATFSh
   \   00000010   0x0004             MOVS     R4,R0
   3489          	if (res == FR_OK) {
   \   00000012   0xD178             BNE.N    ??f_rename_0
   3490          		djn.fs = djo.fs;
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x9007             STR      R0,[SP, #+28]
   3491          		INIT_BUF(djo);
   \   00000018   0xA80E             ADD      R0,SP,#+56
   \   0000001A   0x9006             STR      R0,[SP, #+24]
   3492          		res = follow_path(&djo, path_old);		/* Check old object */
   \   0000001C   0x9918             LDR      R1,[SP, #+96]
   \   0000001E   0xA800             ADD      R0,SP,#+0
   \   00000020   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   \   00000024   0x0004             MOVS     R4,R0
   3493          		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   3494          			res = FR_INVALID_NAME;
   3495          #if _FS_LOCK
   3496          		if (res == FR_OK) res = chk_lock(&djo, 2);
   \   00000026   0xD104             BNE.N    ??f_rename_1
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       _Z8chk_lockP3DIRi
   \   00000030   0x4604             MOV      R4,R0
   3497          #endif
   3498          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_1: (+1)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD167             BNE.N    ??f_rename_0
   3499          			if (!djo.dir) {						/* Is root dir? */
   \   00000036   0x9805             LDR      R0,[SP, #+20]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD101             BNE.N    ??f_rename_2
   3500          				res = FR_NO_FILE;
   \   0000003C   0x2404             MOVS     R4,#+4
   \   0000003E   0xE062             B.N      ??f_rename_0
   3501          			} else {
   3502          				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
   \                     ??f_rename_2: (+1)
   \   00000040   0x2215             MOVS     R2,#+21
   \   00000042   0xF100 0x010B      ADD      R1,R0,#+11
   \   00000046   0xA811             ADD      R0,SP,#+68
   \   00000048   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   3503          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
   \   0000004C   0x221C             MOVS     R2,#+28
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0xA807             ADD      R0,SP,#+28
   \   00000052   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   3504          				res = follow_path(&djn, path_new);
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0xA807             ADD      R0,SP,#+28
   \   0000005A   0x.... 0x....      BL       _Z11follow_pathP3DIRPKc
   \   0000005E   0x0004             MOVS     R4,R0
   3505          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \   00000060   0xD100             BNE.N    ??f_rename_3
   \   00000062   0x2408             MOVS     R4,#+8
   3506          				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
   \                     ??f_rename_3: (+1)
   \   00000064   0x2C04             CMP      R4,#+4
   \   00000066   0xD14E             BNE.N    ??f_rename_0
   3507          /* Start critical section that an interruption or error can cause cross-link */
   3508          					res = dir_register(&djn);			/* Register the new entry */
   \   00000068   0xA807             ADD      R0,SP,#+28
   \   0000006A   0x.... 0x....      BL       _Z12dir_registerP3DIR
   \   0000006E   0x0004             MOVS     R4,R0
   3509          					if (res == FR_OK) {
   \   00000070   0xD149             BNE.N    ??f_rename_0
   3510          						dir = djn.dir;					/* Copy object information except for name */
   \   00000072   0x9D0C             LDR      R5,[SP, #+48]
   3511          						mem_cpy(dir+13, buf+2, 19);
   \   00000074   0x2213             MOVS     R2,#+19
   \   00000076   0xF10D 0x0146      ADD      R1,SP,#+70
   \   0000007A   0xF105 0x000D      ADD      R0,R5,#+13
   \   0000007E   0x.... 0x....      BL       _Z7mem_cpyPvPKvj
   3512          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   00000082   0xF89D 0x0044      LDRB     R0,[SP, #+68]
   \   00000086   0xF040 0x0020      ORR      R0,R0,#0x20
   \   0000008A   0x72E8             STRB     R0,[R5, #+11]
   3513          						djo.fs->wflag = 1;
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x9900             LDR      R1,[SP, #+0]
   \   00000090   0x7108             STRB     R0,[R1, #+4]
   3514          						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
   \   00000092   0x9802             LDR      R0,[SP, #+8]
   \   00000094   0x9909             LDR      R1,[SP, #+36]
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD02A             BEQ.N    ??f_rename_4
   \   0000009A   0x7AE8             LDRB     R0,[R5, #+11]
   \   0000009C   0x06C0             LSLS     R0,R0,#+27
   \   0000009E   0xD527             BPL.N    ??f_rename_4
   3515          							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
   \   000000A0   0x4629             MOV      R1,R5
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x.... 0x....      BL       _Z8ld_clustP5FATFSPh
   \   000000A8   0x4601             MOV      R1,R0
   \   000000AA   0x9800             LDR      R0,[SP, #+0]
   \   000000AC   0x.... 0x....      BL       clust2sect
   \   000000B0   0x0001             MOVS     R1,R0
   3516          							if (!dw) {
   \   000000B2   0xD101             BNE.N    ??f_rename_5
   3517          								res = FR_INT_ERR;
   \   000000B4   0x2402             MOVS     R4,#+2
   \   000000B6   0xE01B             B.N      ??f_rename_4
   3518          							} else {
   3519          								res = move_window(djo.fs, dw);
   \                     ??f_rename_5: (+1)
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0x.... 0x....      BL       _Z11move_windowP5FATFSm
   \   000000BE   0x4604             MOV      R4,R0
   3520          								dir = djo.fs->win+SZ_DIR;	/* .. entry */
   \   000000C0   0x9800             LDR      R0,[SP, #+0]
   \   000000C2   0xF100 0x0550      ADD      R5,R0,#+80
   3521          								if (res == FR_OK && dir[1] == '.') {
   \   000000C6   0x2C00             CMP      R4,#+0
   \   000000C8   0xD112             BNE.N    ??f_rename_4
   \   000000CA   0x7868             LDRB     R0,[R5, #+1]
   \   000000CC   0x282E             CMP      R0,#+46
   \   000000CE   0xD10F             BNE.N    ??f_rename_4
   3522          									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
   \   000000D0   0x9909             LDR      R1,[SP, #+36]
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x7800             LDRB     R0,[R0, #+0]
   \   000000D6   0x2803             CMP      R0,#+3
   \   000000D8   0xD104             BNE.N    ??f_rename_6
   \   000000DA   0x9800             LDR      R0,[SP, #+0]
   \   000000DC   0x6A40             LDR      R0,[R0, #+36]
   \   000000DE   0x4281             CMP      R1,R0
   \   000000E0   0xD100             BNE.N    ??f_rename_6
   \   000000E2   0x2100             MOVS     R1,#+0
   3523          									st_clust(dir, dw);
   \                     ??f_rename_6: (+1)
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0x.... 0x....      BL       _Z8st_clustPhm
   3524          									djo.fs->wflag = 1;
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0x9900             LDR      R1,[SP, #+0]
   \   000000EE   0x7108             STRB     R0,[R1, #+4]
   3525          								}
   3526          							}
   3527          						}
   3528          						if (res == FR_OK) {
   \                     ??f_rename_4: (+1)
   \   000000F0   0x2C00             CMP      R4,#+0
   \   000000F2   0xD108             BNE.N    ??f_rename_0
   3529          							res = dir_remove(&djo);		/* Remove old entry */
   \   000000F4   0xA800             ADD      R0,SP,#+0
   \   000000F6   0x.... 0x....      BL       _Z10dir_removeP3DIR
   \   000000FA   0x0004             MOVS     R4,R0
   3530          							if (res == FR_OK)
   \   000000FC   0xD103             BNE.N    ??f_rename_0
   3531          								res = sync(djo.fs);
   \   000000FE   0x9800             LDR      R0,[SP, #+0]
   \   00000100   0x.... 0x....      BL       _Z4syncP5FATFS
   \   00000104   0x4604             MOV      R4,R0
   3532          						}
   3533          					}
   3534          /* End critical section */
   3535          				}
   3536          			}
   3537          		}
   3538          		FREE_BUF();
   3539          	}
   3540          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0: (+1)
   \   00000106   0x4620             MOV      R0,R4
   \   00000108   0xB019             ADD      SP,SP,#+100
   \   0000010A   0xBD30             POP      {R4,R5,PC}       ;; return
   3541          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x22 0x2A          DC8 "\"*+,:;<=>?[]|\177"
   \              0x2B 0x2C    
   \              0x3A 0x3B    
   \              0x3C 0x3D    
   \              0x3E 0x3F    
   \              0x5B 0x5D    
   \              0x7C 0x7F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     Files

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     Fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x49 0x4E          DC8 "INSIDE f_open"
   \              0x53 0x49    
   \              0x44 0x45    
   \              0x20 0x66    
   \              0x5F 0x6F    
   \              0x70 0x65    
   \              0x6E 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x50 0x6F          DC8 "Pointer error"
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0
   3542          
   3543          #endif /* !_FS_READONLY */
   3544          #endif /* _FS_MINIMIZE == 0 */
   3545          #endif /* _FS_MINIMIZE <= 1 */
   3546          #endif /* _FS_MINIMIZE <= 2 */
   3547          
   3548          
   3549          
   3550          /*-----------------------------------------------------------------------*/
   3551          /* Forward data to the stream directly (available on only tiny cfg)      */
   3552          /*-----------------------------------------------------------------------*/
   3553          #if _USE_FORWARD && _FS_TINY
   3554          
   3555          FRESULT f_forward (
   3556          	FIL *fp, 						/* Pointer to the file object */
   3557          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   3558          	UINT btr,						/* Number of bytes to forward */
   3559          	UINT *bf						/* Pointer to number of bytes forwarded */
   3560          )
   3561          {
   3562          	FRESULT res;
   3563          	DWORD remain, clst, sect;
   3564          	UINT rcnt;
   3565          	BYTE csect;
   3566          
   3567          
   3568          	*bf = 0;	/* Clear transfer byte counter */
   3569          
   3570          	if (!fp) return FR_INVALID_OBJECT;
   3571          
   3572          	res = validate(fp);								/* Check validity of the object */
   3573          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   3574          	if (fp->flag & FA__ERROR)						/* Check error flag */
   3575          		LEAVE_FF(fp->fs, FR_INT_ERR);
   3576          	if (!(fp->flag & FA_READ))						/* Check access mode */
   3577          		LEAVE_FF(fp->fs, FR_DENIED);
   3578          
   3579          	remain = fp->fsize - fp->fptr;
   3580          	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
   3581          
   3582          	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   3583          		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
   3584          		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3585          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   3586          			if (!csect) {							/* On the cluster boundary? */
   3587          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   3588          					fp->sclust : get_fat(fp->fs, fp->clust);
   3589          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   3590          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3591          				fp->clust = clst;					/* Update current cluster */
   3592          			}
   3593          		}
   3594          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   3595          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3596          		sect += csect;
   3597          		if (move_window(fp->fs, sect))				/* Move sector window */
   3598          			ABORT(fp->fs, FR_DISK_ERR);
   3599          		fp->dsect = sect;
   3600          		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   3601          		if (rcnt > btr) rcnt = btr;
   3602          		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
   3603          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   3604          	}
   3605          
   3606          	LEAVE_FF(fp->fs, FR_OK);
   3607          }
   3608          #endif /* _USE_FORWARD */
   3609          
   3610          
   3611          
   3612          #if _USE_MKFS && !_FS_READONLY
   3613          /*-----------------------------------------------------------------------*/
   3614          /* Create File System on the Drive                                       */
   3615          /*-----------------------------------------------------------------------*/
   3616          #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
   3617          #define N_FATS		1		/* Number of FAT copies (1 or 2) */
   3618          
   3619          
   3620          FRESULT f_mkfs (
   3621          	BYTE drv,		/* Logical drive number */
   3622          	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
   3623          	UINT au			/* Allocation unit size [bytes] */
   3624          )
   3625          {
   3626          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   3627          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   3628          	BYTE fmt, md, sys, *tbl, pdrv, part;
   3629          	DWORD n_clst, vs, n, wsect;
   3630          	UINT i;
   3631          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   3632          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   3633          	FATFS *fs;
   3634          	DSTATUS stat;
   3635          
   3636          
   3637          	/* Check mounted drive and clear work area */
   3638          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   3639          	if (sfd > 1) return FR_INVALID_PARAMETER;
   3640          	if (au & (au - 1)) return FR_INVALID_PARAMETER;
   3641          	fs = FatFs[drv];
   3642          	if (!fs) return FR_NOT_ENABLED;
   3643          	fs->fs_type = 0;
   3644          	pdrv = LD2PD(drv);	/* Physical drive */
   3645          	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   3646          
   3647          	/* Get disk statics */
   3648          	stat = disk_initialize(pdrv);
   3649          	if (stat & STA_NOINIT) return FR_NOT_READY;
   3650          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3651          #if _MAX_SS != 512					/* Get disk sector size */
   3652          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   3653          		return FR_DISK_ERR;
   3654          #endif
   3655          	if (_MULTI_PARTITION && part) {
   3656          		/* Get partition information from partition table in the MBR */
   3657          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3658          		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   3659          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3660          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   3661          		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
   3662          		n_vol = LD_DWORD(tbl+12);	/* Volume size */
   3663          	} else {
   3664          		/* Create a partition in this function */
   3665          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   3666          			return FR_DISK_ERR;
   3667          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   3668          		n_vol -= b_vol;				/* Volume size */
   3669          	}
   3670          
   3671          	if (!au) {				/* AU auto selection */
   3672          		vs = n_vol / (2000 / (SS(fs) / 512));
   3673          		for (i = 0; vs < vst[i]; i++) ;
   3674          		au = cst[i];
   3675          	}
   3676          	au /= SS(fs);		/* Number of sectors per cluster */
   3677          	if (au == 0) au = 1;
   3678          	if (au > 128) au = 128;
   3679          
   3680          	/* Pre-compute number of clusters and FAT sub-type */
   3681          	n_clst = n_vol / au;
   3682          	fmt = FS_FAT12;
   3683          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   3684          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   3685          
   3686          	/* Determine offset and size of FAT structure */
   3687          	if (fmt == FS_FAT32) {
   3688          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   3689          		n_rsv = 32;
   3690          		n_dir = 0;
   3691          	} else {
   3692          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   3693          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   3694          		n_rsv = 1;
   3695          		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
   3696          	}
   3697          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   3698          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   3699          	b_data = b_dir + n_dir;				/* Data area start sector */
   3700          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   3701          
   3702          	/* Align data start sector to erase block boundary (for flash memory media) */
   3703          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   3704          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   3705          	n = (n - b_data) / N_FATS;
   3706          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   3707          		n_rsv += n;
   3708          		b_fat += n;
   3709          	} else {					/* FAT12/16: Expand FAT size */
   3710          		n_fat += n;
   3711          	}
   3712          
   3713          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   3714          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   3715          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   3716          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   3717          		return FR_MKFS_ABORTED;
   3718          
   3719          	switch (fmt) {	/* Determine system ID for partition table */
   3720          	case FS_FAT12:	sys = 0x01; break;
   3721          	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
   3722          	default: 		sys = 0x0C;
   3723          	}
   3724          
   3725          	if (_MULTI_PARTITION && part) {
   3726          		/* Update system ID in the partition table */
   3727          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   3728          		tbl[4] = sys;
   3729          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   3730          		md = 0xF8;
   3731          	} else {
   3732          		if (sfd) {	/* No partition table (SFD) */
   3733          			md = 0xF0;
   3734          		} else {	/* Create partition table (FDISK) */
   3735          			mem_set(fs->win, 0, SS(fs));
   3736          			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
   3737          			tbl[1] = 1;						/* Partition start head */
   3738          			tbl[2] = 1;						/* Partition start sector */
   3739          			tbl[3] = 0;						/* Partition start cylinder */
   3740          			tbl[4] = sys;					/* System type */
   3741          			tbl[5] = 254;					/* Partition end head */
   3742          			n = (b_vol + n_vol) / 63 / 255;
   3743          			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
   3744          			tbl[7] = (BYTE)n;				/* End cylinder */
   3745          			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   3746          			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
   3747          			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   3748          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
   3749          				return FR_DISK_ERR;
   3750          			md = 0xF8;
   3751          		}
   3752          	}
   3753          
   3754          	/* Create BPB in the VBR */
   3755          	tbl = fs->win;							/* Clear sector */
   3756          	mem_set(tbl, 0, SS(fs));
   3757          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   3758          	i = SS(fs);								/* Sector size */
   3759          	ST_WORD(tbl+BPB_BytsPerSec, i);
   3760          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   3761          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   3762          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   3763          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
   3764          	ST_WORD(tbl+BPB_RootEntCnt, i);
   3765          	if (n_vol < 0x10000) {					/* Number of total sectors */
   3766          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   3767          	} else {
   3768          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   3769          	}
   3770          	tbl[BPB_Media] = md;					/* Media descriptor */
   3771          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   3772          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   3773          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   3774          	n = get_fattime();						/* Use current time as VSN */
   3775          	if (fmt == FS_FAT32) {
   3776          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   3777          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   3778          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   3779          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
   3780          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   3781          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   3782          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   3783          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   3784          	} else {
   3785          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   3786          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   3787          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   3788          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   3789          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   3790          	}
   3791          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   3792          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   3793          		return FR_DISK_ERR;
   3794          	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
   3795          		disk_write(pdrv, tbl, b_vol + 6, 1);
   3796          
   3797          	/* Initialize FAT area */
   3798          	wsect = b_fat;
   3799          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   3800          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   3801          		n = md;								/* Media descriptor byte */
   3802          		if (fmt != FS_FAT32) {
   3803          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   3804          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   3805          		} else {
   3806          			n |= 0xFFFFFF00;
   3807          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   3808          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   3809          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   3810          		}
   3811          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   3812          			return FR_DISK_ERR;
   3813          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   3814          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   3815          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   3816          				return FR_DISK_ERR;
   3817          		}
   3818          	}
   3819          
   3820          	/* Initialize root directory */
   3821          	i = (fmt == FS_FAT32) ? au : n_dir;
   3822          	do {
   3823          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   3824          			return FR_DISK_ERR;
   3825          	} while (--i);
   3826          
   3827          #if _USE_ERASE	/* Erase data area if needed */
   3828          	{
   3829          		DWORD eb[2];
   3830          
   3831          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   3832          		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
   3833          	}
   3834          #endif
   3835          
   3836          	/* Create FSInfo if needed */
   3837          	if (fmt == FS_FAT32) {
   3838          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   3839          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   3840          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   3841          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   3842          		ST_WORD(tbl+BS_55AA, 0xAA55);
   3843          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   3844          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   3845          	}
   3846          
   3847          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   3848          }
   3849          
   3850          
   3851          #if _MULTI_PARTITION == 2
   3852          /*-----------------------------------------------------------------------*/
   3853          /* Divide Physical Drive                                                 */
   3854          /*-----------------------------------------------------------------------*/
   3855          
   3856          FRESULT f_fdisk (
   3857          	BYTE pdrv,			/* Physical drive number */
   3858          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   3859          	void* work			/* Pointer to the working buffer */
   3860          )
   3861          {
   3862          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   3863          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   3864          	DSTATUS stat;
   3865          	DWORD sz_disk, sz_part, s_part;
   3866          
   3867          
   3868          	stat = disk_initialize(pdrv);
   3869          	if (stat & STA_NOINIT) return FR_NOT_READY;
   3870          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   3871          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   3872          
   3873          	/* Determine CHS in the table regardless of the drive geometry */
   3874          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   3875          	if (n == 256) n--;
   3876          	e_hd = n - 1;
   3877          	sz_cyl = 63 * n;
   3878          	tot_cyl = sz_disk / sz_cyl;
   3879          
   3880          	/* Create partition table */
   3881          	mem_set(buf, 0, _MAX_SS);
   3882          	p = buf + MBR_Table; b_cyl = 0;
   3883          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   3884          		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   3885          		if (!p_cyl) continue;
   3886          		s_part = (DWORD)sz_cyl * b_cyl;
   3887          		sz_part = (DWORD)sz_cyl * p_cyl;
   3888          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   3889          			s_hd = 1;
   3890          			s_part += 63; sz_part -= 63;
   3891          		} else {
   3892          			s_hd = 0;
   3893          		}
   3894          		e_cyl = b_cyl + p_cyl - 1;
   3895          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   3896          
   3897          		/* Set partition table */
   3898          		p[1] = s_hd;						/* Start head */
   3899          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   3900          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   3901          		p[4] = 0x06;						/* System type (temporary setting) */
   3902          		p[5] = e_hd;						/* End head */
   3903          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   3904          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   3905          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   3906          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   3907          
   3908          		/* Next partition */
   3909          		b_cyl += p_cyl;
   3910          	}
   3911          	ST_WORD(p, 0xAA55);
   3912          
   3913          	/* Write it to the MBR */
   3914          	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
   3915          }
   3916          
   3917          
   3918          #endif /* _MULTI_PARTITION == 2 */
   3919          #endif /* _USE_MKFS && !_FS_READONLY */
   3920          
   3921          
   3922          
   3923          
   3924          #if _USE_STRFUNC
   3925          /*-----------------------------------------------------------------------*/
   3926          /* Get a string from the file                                            */
   3927          /*-----------------------------------------------------------------------*/
   3928          TCHAR* f_gets (
   3929          	TCHAR* buff,	/* Pointer to the string buffer to read */
   3930          	int len,		/* Size of string buffer (characters) */
   3931          	FIL* fil		/* Pointer to the file object */
   3932          )
   3933          {
   3934          	int n = 0;
   3935          	TCHAR c, *p = buff;
   3936          	BYTE s[2];
   3937          	UINT rc;
   3938          
   3939          
   3940          	while (n < len - 1) {			/* Read bytes until buffer gets filled */
   3941          		f_read(fil, s, 1, &rc);
   3942          		if (rc != 1) break;			/* Break on EOF or error */
   3943          		c = s[0];
   3944          #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
   3945          		if (c >= 0x80) {
   3946          			if (c < 0xC0) continue;	/* Skip stray trailer */
   3947          			if (c < 0xE0) {			/* Two-byte sequence */
   3948          				f_read(fil, s, 1, &rc);
   3949          				if (rc != 1) break;
   3950          				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   3951          				if (c < 0x80) c = '?';
   3952          			} else {
   3953          				if (c < 0xF0) {		/* Three-byte sequence */
   3954          					f_read(fil, s, 2, &rc);
   3955          					if (rc != 2) break;
   3956          					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   3957          					if (c < 0x800) c = '?';
   3958          				} else {			/* Reject four-byte sequence */
   3959          					c = '?';
   3960          				}
   3961          			}
   3962          		}
   3963          #endif
   3964          #if _USE_STRFUNC >= 2
   3965          		if (c == '\r') continue;	/* Strip '\r' */
   3966          #endif
   3967          		*p++ = c;
   3968          		n++;
   3969          		if (c == '\n') break;		/* Break on EOL */
   3970          	}
   3971          	*p = 0;
   3972          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   3973          }
   3974          
   3975          
   3976          
   3977          #if !_FS_READONLY
   3978          #include <stdarg.h>
   3979          /*-----------------------------------------------------------------------*/
   3980          /* Put a character to the file                                           */
   3981          /*-----------------------------------------------------------------------*/
   3982          int f_putc (
   3983          	TCHAR c,	/* A character to be output */
   3984          	FIL* fil	/* Pointer to the file object */
   3985          )
   3986          {
   3987          	UINT bw, btw;
   3988          	BYTE s[3];
   3989          
   3990          
   3991          #if _USE_STRFUNC >= 2
   3992          	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
   3993          #endif
   3994          
   3995          #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
   3996          	if (c < 0x80) {			/* 7-bit */
   3997          		s[0] = (BYTE)c;
   3998          		btw = 1;
   3999          	} else {
   4000          		if (c < 0x800) {	/* 11-bit */
   4001          			s[0] = (BYTE)(0xC0 | (c >> 6));
   4002          			s[1] = (BYTE)(0x80 | (c & 0x3F));
   4003          			btw = 2;
   4004          		} else {			/* 16-bit */
   4005          			s[0] = (BYTE)(0xE0 | (c >> 12));
   4006          			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
   4007          			s[2] = (BYTE)(0x80 | (c & 0x3F));
   4008          			btw = 3;
   4009          		}
   4010          	}
   4011          #else				/* Write the character without conversion */
   4012          	s[0] = (BYTE)c;
   4013          	btw = 1;
   4014          #endif
   4015          	f_write(fil, s, btw, &bw);		/* Write the char to the file */
   4016          	return (bw == btw) ? 1 : EOF;	/* Return the result */
   4017          }
   4018          
   4019          
   4020          
   4021          
   4022          /*-----------------------------------------------------------------------*/
   4023          /* Put a string to the file                                              */
   4024          /*-----------------------------------------------------------------------*/
   4025          int f_puts (
   4026          	const TCHAR* str,	/* Pointer to the string to be output */
   4027          	FIL* fil			/* Pointer to the file object */
   4028          )
   4029          {
   4030          	int n;
   4031          
   4032          
   4033          	for (n = 0; *str; str++, n++) {
   4034          		if (f_putc(*str, fil) == EOF) return EOF;
   4035          	}
   4036          	return n;
   4037          }
   4038          
   4039          
   4040          
   4041          
   4042          /*-----------------------------------------------------------------------*/
   4043          /* Put a formatted string to the file                                    */
   4044          /*-----------------------------------------------------------------------*/
   4045          int f_printf (
   4046          	FIL* fil,			/* Pointer to the file object */
   4047          	const TCHAR* str,	/* Pointer to the format string */
   4048          	...					/* Optional arguments... */
   4049          )
   4050          {
   4051          	va_list arp;
   4052          	BYTE f, r;
   4053          	UINT i, j, w;
   4054          	ULONG v;
   4055          	TCHAR c, d, s[16], *p;
   4056          	int res, chc, cc;
   4057          
   4058          
   4059          	va_start(arp, str);
   4060          
   4061          	for (cc = res = 0; cc != EOF; res += cc) {
   4062          		c = *str++;
   4063          		if (c == 0) break;			/* End of string */
   4064          		if (c != '%') {				/* Non escape character */
   4065          			cc = f_putc(c, fil);
   4066          			if (cc != EOF) cc = 1;
   4067          			continue;
   4068          		}
   4069          		w = f = 0;
   4070          		c = *str++;
   4071          		if (c == '0') {				/* Flag: '0' padding */
   4072          			f = 1; c = *str++;
   4073          		} else {
   4074          			if (c == '-') {			/* Flag: left justified */
   4075          				f = 2; c = *str++;
   4076          			}
   4077          		}
   4078          		while (IsDigit(c)) {		/* Precision */
   4079          			w = w * 10 + c - '0';
   4080          			c = *str++;
   4081          		}
   4082          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   4083          			f |= 4; c = *str++;
   4084          		}
   4085          		if (!c) break;
   4086          		d = c;
   4087          		if (IsLower(d)) d -= 0x20;
   4088          		switch (d) {				/* Type is... */
   4089          		case 'S' :					/* String */
   4090          			p = va_arg(arp, TCHAR*);
   4091          			for (j = 0; p[j]; j++) ;
   4092          			chc = 0;
   4093          			if (!(f & 2)) {
   4094          				while (j++ < w) chc += (cc = f_putc(' ', fil));
   4095          			}
   4096          			chc += (cc = f_puts(p, fil));
   4097          			while (j++ < w) chc += (cc = f_putc(' ', fil));
   4098          			if (cc != EOF) cc = chc;
   4099          			continue;
   4100          		case 'C' :					/* Character */
   4101          			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
   4102          		case 'B' :					/* Binary */
   4103          			r = 2; break;
   4104          		case 'O' :					/* Octal */
   4105          			r = 8; break;
   4106          		case 'D' :					/* Signed decimal */
   4107          		case 'U' :					/* Unsigned decimal */
   4108          			r = 10; break;
   4109          		case 'X' :					/* Hexdecimal */
   4110          			r = 16; break;
   4111          		default:					/* Unknown type (pass-through) */
   4112          			cc = f_putc(c, fil); continue;
   4113          		}
   4114          
   4115          		/* Get an argument and put it in numeral */
   4116          		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
   4117          		if (d == 'D' && (v & 0x80000000)) {
   4118          			v = 0 - v;
   4119          			f |= 8;
   4120          		}
   4121          		i = 0;
   4122          		do {
   4123          			d = (TCHAR)(v % r); v /= r;
   4124          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   4125          			s[i++] = d + '0';
   4126          		} while (v && i < sizeof s / sizeof s[0]);
   4127          		if (f & 8) s[i++] = '-';
   4128          		j = i; d = (f & 1) ? '0' : ' ';
   4129          		res = 0;
   4130          		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
   4131          		do res += (cc = f_putc(s[--i], fil)); while(i);
   4132          		while (j++ < w) res += (cc = f_putc(' ', fil));
   4133          		if (cc != EOF) cc = res;
   4134          	}
   4135          
   4136          	va_end(arp);
   4137          	return (cc == EOF) ? cc : res;
   4138          }
   4139          
   4140          #endif /* !_FS_READONLY */
   4141          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   check_fs(FATFS *, DWORD)
         8   -> disk_read
       0   chk_chr(char const *, int)
      12   chk_lock(DIR *, int)
      24   chk_mounted(char const **, FATFS **, BYTE)
        24   -> check_fs(FATFS *, DWORD)
        24   -> clear_lock(FATFS *)
        24   -> disk_initialize
        24   -> disk_read
        24   -> disk_status
       4   clear_lock(FATFS *)
       0   clust2sect
      24   create_chain(FATFS *, DWORD)
        24   -> get_fat(FATFS *, DWORD)
        24   -> put_fat(FATFS *, DWORD, DWORD)
      40   create_name(DIR *, char const **)
        40   -> chk_chr(char const *, int)
        40   -> mem_set(void *, int, UINT)
       0   dec_lock(UINT)
      16   dir_find(DIR *)
        16   -> dir_next(DIR *, int)
        16   -> dir_sdi(DIR *, WORD)
        16   -> mem_cmp(void const *, void const *, UINT)
        16   -> move_window(FATFS *, DWORD)
      24   dir_next(DIR *, int)
        24   -> clust2sect
        24   -> create_chain(FATFS *, DWORD)
        24   -> get_fat(FATFS *, DWORD)
        24   -> mem_set(void *, int, UINT)
        24   -> move_window(FATFS *, DWORD)
       8   dir_read(DIR *)
         8   -> dir_next(DIR *, int)
         8   -> move_window(FATFS *, DWORD)
      16   dir_register(DIR *)
        16   -> dir_next(DIR *, int)
        16   -> dir_sdi(DIR *, WORD)
        16   -> mem_cpy(void *, void const *, UINT)
        16   -> mem_set(void *, int, UINT)
        16   -> move_window(FATFS *, DWORD)
       8   dir_remove(DIR *)
         8   -> dir_sdi(DIR *, WORD)
         8   -> move_window(FATFS *, DWORD)
      16   dir_sdi(DIR *, WORD)
        16   -> clust2sect
        16   -> get_fat(FATFS *, DWORD)
       0   enq_lock()
      56   f_chmod
        56   -> chk_mounted(char const **, FATFS **, BYTE)
        56   -> follow_path(DIR *, char const *)
        56   -> sync(FATFS *)
       8   f_close
         8   -> dec_lock(UINT)
         8   -> f_sync
      40   f_getfree
        40   -> chk_mounted(char const **, FATFS **, BYTE)
        40   -> get_fat(FATFS *, DWORD)
        40   -> move_window(FATFS *, DWORD)
      24   f_lseek
        24   -> clust2sect
        24   -> create_chain(FATFS *, DWORD)
        24   -> get_fat(FATFS *, DWORD)
        24   -> validate(void *)
      72   f_mkdir
        72   -> chk_mounted(char const **, FATFS **, BYTE)
        72   -> clust2sect
        72   -> create_chain(FATFS *, DWORD)
        72   -> dir_register(DIR *)
        72   -> follow_path(DIR *, char const *)
        72   -> get_fattime
        72   -> mem_cpy(void *, void const *, UINT)
        72   -> mem_set(void *, int, UINT)
        72   -> move_window(FATFS *, DWORD)
        72   -> remove_chain(FATFS *, DWORD)
        72   -> st_clust(BYTE *, DWORD)
        72   -> sync(FATFS *)
      16   f_mount
        16   -> clear_lock(FATFS *)
      72   f_open
        72   -> TLcdTrace::AddLine(char const *)
        72   -> chk_lock(DIR *, int)
        72   -> chk_mounted(char const **, FATFS **, BYTE)
        72   -> dir_register(DIR *)
        72   -> enq_lock()
        72   -> follow_path(DIR *, char const *)
        72   -> get_fattime
        72   -> inc_lock(DIR *, int)
        72   -> ld_clust(FATFS *, BYTE *)
        72   -> move_window(FATFS *, DWORD)
        72   -> remove_chain(FATFS *, DWORD)
        72   -> st_clust(BYTE *, DWORD)
      32   f_opendir
        32   -> chk_mounted(char const **, FATFS **, BYTE)
        32   -> dir_sdi(DIR *, WORD)
        32   -> follow_path(DIR *, char const *)
        32   -> ld_clust(FATFS *, BYTE *)
      32   f_read
        32   -> clust2sect
        32   -> disk_read
        32   -> get_fat(FATFS *, DWORD)
        32   -> mem_cpy(void *, void const *, UINT)
        32   -> move_window(FATFS *, DWORD)
        32   -> validate(void *)
      24   f_readdir
        24   -> dir_next(DIR *, int)
        24   -> dir_read(DIR *)
        24   -> dir_sdi(DIR *, WORD)
        24   -> get_fileinfo(DIR *, FILINFO *)
        24   -> validate(void *)
     112   f_rename
       112   -> chk_lock(DIR *, int)
       112   -> chk_mounted(char const **, FATFS **, BYTE)
       112   -> clust2sect
       112   -> dir_register(DIR *)
       112   -> dir_remove(DIR *)
       112   -> follow_path(DIR *, char const *)
       112   -> ld_clust(FATFS *, BYTE *)
       112   -> mem_cpy(void *, void const *, UINT)
       112   -> move_window(FATFS *, DWORD)
       112   -> st_clust(BYTE *, DWORD)
       112   -> sync(FATFS *)
      56   f_stat
        56   -> chk_mounted(char const **, FATFS **, BYTE)
        56   -> follow_path(DIR *, char const *)
        56   -> get_fileinfo(DIR *, FILINFO *)
      16   f_sync
        16   -> get_fattime
        16   -> move_window(FATFS *, DWORD)
        16   -> st_clust(BYTE *, DWORD)
        16   -> validate(void *)
      16   f_truncate
        16   -> get_fat(FATFS *, DWORD)
        16   -> put_fat(FATFS *, DWORD, DWORD)
        16   -> remove_chain(FATFS *, DWORD)
        16   -> validate(void *)
      88   f_unlink
        88   -> chk_lock(DIR *, int)
        88   -> chk_mounted(char const **, FATFS **, BYTE)
        88   -> dir_read(DIR *)
        88   -> dir_remove(DIR *)
        88   -> dir_sdi(DIR *, WORD)
        88   -> follow_path(DIR *, char const *)
        88   -> ld_clust(FATFS *, BYTE *)
        88   -> mem_cpy(void *, void const *, UINT)
        88   -> remove_chain(FATFS *, DWORD)
        88   -> sync(FATFS *)
      56   f_utime
        56   -> chk_mounted(char const **, FATFS **, BYTE)
        56   -> follow_path(DIR *, char const *)
        56   -> sync(FATFS *)
      32   f_write
        32   -> clust2sect
        32   -> create_chain(FATFS *, DWORD)
        32   -> disk_write
        32   -> mem_cpy(void *, void const *, UINT)
        32   -> move_window(FATFS *, DWORD)
        32   -> validate(void *)
      16   follow_path(DIR *, char const *)
        16   -> create_name(DIR *, char const **)
        16   -> dir_find(DIR *)
        16   -> dir_sdi(DIR *, WORD)
        16   -> ld_clust(FATFS *, BYTE *)
      24   get_fat(FATFS *, DWORD)
        24   -> move_window(FATFS *, DWORD)
       8   get_fileinfo(DIR *, FILINFO *)
      16   inc_lock(DIR *, int)
       0   ld_clust(FATFS *, BYTE *)
       4   mem_cmp(void const *, void const *, UINT)
       0   mem_cpy(void *, void const *, UINT)
       0   mem_set(void *, int, UINT)
      24   move_window(FATFS *, DWORD)
        24   -> disk_read
        24   -> disk_write
      24   put_fat(FATFS *, DWORD, DWORD)
        24   -> move_window(FATFS *, DWORD)
      24   remove_chain(FATFS *, DWORD)
        24   -> get_fat(FATFS *, DWORD)
        24   -> put_fat(FATFS *, DWORD, DWORD)
       0   st_clust(BYTE *, DWORD)
      16   sync(FATFS *)
        16   -> disk_ioctl
        16   -> disk_write
        16   -> mem_set(void *, int, UINT)
        16   -> move_window(FATFS *, DWORD)
       8   validate(void *)
         8   -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable9
      16  ?_0
      16  ?_1
      16  ?_2
      24  Files
       8  Fsid
          FatFs
     104  check_fs(FATFS *, DWORD)
      18  chk_chr(char const *, int)
     110  chk_lock(DIR *, int)
     698  chk_mounted(char const **, FATFS **, BYTE)
      36  clear_lock(FATFS *)
      24  clust2sect
     160  create_chain(FATFS *, DWORD)
     282  create_name(DIR *, char const **)
      54  dec_lock(UINT)
      72  dir_find(DIR *)
     238  dir_next(DIR *, int)
      70  dir_read(DIR *)
      98  dir_register(DIR *)
      40  dir_remove(DIR *)
     142  dir_sdi(DIR *, WORD)
      38  enq_lock()
     128  excvt
      80  f_chmod
      28  f_close
     228  f_getfree
     272  f_lseek
     382  f_mkdir
      44  f_mount
     412  f_open
     112  f_opendir
     318  f_read
      76  f_readdir
     268  f_rename
      60  f_stat
     126  f_sync
     152  f_truncate
     182  f_unlink
      82  f_utime
     408  f_write
     110  follow_path(DIR *, char const *)
     206  get_fat(FATFS *, DWORD)
     128  get_fileinfo(DIR *, FILINFO *)
     134  inc_lock(DIR *, int)
      30  ld_clust(FATFS *, BYTE *)
      30  mem_cmp(void const *, void const *, UINT)
      20  mem_cpy(void *, void const *, UINT)
      16  mem_set(void *, int, UINT)
     112  move_window(FATFS *, DWORD)
     246  put_fat(FATFS *, DWORD, DWORD)
      92  remove_chain(FATFS *, DWORD)
      20  st_clust(BYTE *, DWORD)
     170  sync(FATFS *)
      44  validate(void *)

 
    32 bytes in section .bss
 6 968 bytes in section .text
 
 6 968 bytes of CODE memory
    32 bytes of DATA memory

Errors: none
Warnings: none
