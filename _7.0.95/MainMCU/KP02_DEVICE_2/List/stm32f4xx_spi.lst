###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        12/Oct/2018  15:54:19
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_spi.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_spi.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):
      9            *           + Initialization and Configuration
     10            *           + Data transfers functions
     11            *           + Hardware CRC Calculation
     12            *           + DMA transfers management
     13            *           + Interrupts and flags management 
     14            *           
     15          @verbatim
     16          
     17           ===================================================================
     18                            ##### How to use this driver #####
     19           ===================================================================
     20           [..]
     21             (#) Enable peripheral clock using the following functions 
     22                 RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
     23                 RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
     24                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3
     25                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI4
     26                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI5
     27                 RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI6.
     28            
     29             (#) Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
     30                 function. In I2S mode, if an external clock source is used then the I2S 
     31                 CKIN pin GPIO clock should also be enabled.
     32            
     33             (#) Peripherals alternate function: 
     34                 (++) Connect the pin to the desired peripherals' Alternate Function (AF) 
     35                      using GPIO_PinAFConfig() function
     36                 (++) Configure the desired pin in alternate function by: 
     37                      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38                 (++) Select the type, pull-up/pull-down and output speed via GPIO_PuPd, 
     39                      GPIO_OType and GPIO_Speed members
     40                 (++) Call GPIO_Init() function In I2S mode, if an external clock source is 
     41                      used then the I2S CKIN pin should be also configured in Alternate 
     42                      function Push-pull pull-up mode. 
     43                    
     44             (#) Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     45                 Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     46                 function.
     47                 In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
     48                 frequency and Polarity using I2S_Init() function. For I2S mode, make sure 
     49                 that either:
     50                 (++) I2S PLL is configured using the functions 
     51                      RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), RCC_PLLI2SCmd(ENABLE) and 
     52                      RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY); or 
     53                 (++) External clock source is configured using the function 
     54                      RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly 
     55                      the define constant I2S_EXTERNAL_CLOCK_VAL in the stm32f4xx_conf.h file. 
     56            
     57             (#) Enable the NVIC and the corresponding interrupt using the function 
     58                 SPI_ITConfig() if you need to use interrupt mode. 
     59            
     60             (#) When using the DMA mode 
     61                 (++) Configure the DMA using DMA_Init() function
     62                 (++) Active the needed channel Request using SPI_I2S_DMACmd() function
     63             
     64             (#) Enable the SPI using the SPI_Cmd() function or enable the I2S using
     65                 I2S_Cmd().
     66             
     67             (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     68            
     69             (#) Optionally, you can enable/configure the following parameters without
     70                 re-initialization (i.e there is no need to call again SPI_Init() function):
     71                 (++) When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     72                      is programmed as Data direction parameter using the SPI_Init() function
     73                      it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     74                      using the SPI_BiDirectionalLineConfig() function.
     75                 (++) When SPI_NSS_Soft is selected as Slave Select Management parameter 
     76                      using the SPI_Init() function it can be possible to manage the 
     77                      NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     78                 (++) Reconfigure the data size using the SPI_DataSizeConfig() function  
     79                 (++) Enable or disable the SS output using the SPI_SSOutputCmd() function  
     80                      
     81              (#) To use the CRC Hardware calculation feature refer to the Peripheral 
     82                  CRC hardware Calculation subsection.
     83               
     84            
     85           [..] It is possible to use SPI in I2S full duplex mode, in this case, each SPI 
     86                peripheral is able to manage sending and receiving data simultaneously
     87                using two data lines. Each SPI peripheral has an extended block called I2Sxext
     88                (ie. I2S2ext for SPI2 and I2S3ext for SPI3).
     89                The extension block is not a full SPI IP, it is used only as I2S slave to
     90                implement full duplex mode. The extension block uses the same clock sources
     91                as its master.          
     92                To configure I2S full duplex you have to:
     93                        
     94                (#) Configure SPIx in I2S mode (I2S_Init() function) as described above. 
     95                       
     96                (#) Call the I2S_FullDuplexConfig() function using the same strucutre passed to  
     97                    I2S_Init() function.
     98                        
     99                (#) Call I2S_Cmd() for SPIx then for its extended block.
    100                      
    101                (#) To configure interrupts or DMA requests and to get/clear flag status, 
    102                    use I2Sxext instance for the extension block.
    103                         
    104           [..] Functions that can be called with I2Sxext instances are: I2S_Cmd(), 
    105                I2S_FullDuplexConfig(), SPI_I2S_ReceiveData(), SPI_I2S_SendData(), 
    106                SPI_I2S_DMACmd(), SPI_I2S_ITConfig(), SPI_I2S_GetFlagStatus(), 
    107                SPI_I2S_ClearFlag(), SPI_I2S_GetITStatus() and SPI_I2S_ClearITPendingBit().
    108                             
    109                Example: To use SPI3 in Full duplex mode (SPI3 is Master Tx, I2S3ext is Slave Rx):
    110                        
    111                RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);   
    112                I2S_StructInit(&I2SInitStruct);
    113                I2SInitStruct.Mode = I2S_Mode_MasterTx;     
    114                I2S_Init(SPI3, &I2SInitStruct);
    115                I2S_FullDuplexConfig(SPI3ext, &I2SInitStruct)
    116                I2S_Cmd(SPI3, ENABLE);
    117                I2S_Cmd(SPI3ext, ENABLE);
    118                ...
    119                while (SPI_I2S_GetFlagStatus(SPI2, SPI_FLAG_TXE) == RESET)
    120                {}
    121                SPI_I2S_SendData(SPI3, txdata[i]);
    122                ...  
    123                while (SPI_I2S_GetFlagStatus(I2S3ext, SPI_FLAG_RXNE) == RESET)
    124                {}
    125                rxdata[i] = SPI_I2S_ReceiveData(I2S3ext);
    126                ...          
    127                          
    128           [..]       
    129             (@) In I2S mode: if an external clock is used as source clock for the I2S,  
    130                 then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should 
    131                 be enabled and set to the value of the source clock frequency (in Hz).
    132             
    133             (@) In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
    134                 just after calling the function SPI_Init().
    135            
    136          @endverbatim  
    137            *                                  
    138            ******************************************************************************
    139            * @attention
    140            *
    141            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
    142            *
    143            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
    144            * You may not use this file except in compliance with the License.
    145            * You may obtain a copy of the License at:
    146            *
    147            *        http://www.st.com/software_license_agreement_liberty_v2
    148            *
    149            * Unless required by applicable law or agreed to in writing, software 
    150            * distributed under the License is distributed on an "AS IS" BASIS, 
    151            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    152            * See the License for the specific language governing permissions and
    153            * limitations under the License.
    154            *
    155            ******************************************************************************  
    156            */ 
    157          
    158          /* Includes ------------------------------------------------------------------*/
    159          #include "stm32f4xx_spi.h"
    160          #include "stm32f4xx_rcc.h"
    161          
    162          /** @addtogroup STM32F4xx_StdPeriph_Driver
    163            * @{
    164            */
    165          
    166          /** @defgroup SPI 
    167            * @brief SPI driver modules
    168            * @{
    169            */ 
    170          
    171          /* Private typedef -----------------------------------------------------------*/
    172          /* Private define ------------------------------------------------------------*/
    173          
    174          /* SPI registers Masks */
    175          #define CR1_CLEAR_MASK            ((uint16_t)0x3040)
    176          #define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)
    177          
    178          /* RCC PLLs masks */
    179          #define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
    180          #define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)
    181          
    182          #define SPI_CR2_FRF               ((uint16_t)0x0010)
    183          #define SPI_SR_TIFRFE             ((uint16_t)0x0100)
    184          
    185          /* Private macro -------------------------------------------------------------*/
    186          /* Private variables ---------------------------------------------------------*/
    187          /* Private function prototypes -----------------------------------------------*/
    188          /* Private functions ---------------------------------------------------------*/
    189          
    190          /** @defgroup SPI_Private_Functions
    191            * @{
    192            */
    193          
    194          /** @defgroup SPI_Group1 Initialization and Configuration functions
    195           *  @brief   Initialization and Configuration functions 
    196           *
    197          @verbatim   
    198           ===============================================================================
    199                       ##### Initialization and Configuration functions ##### 
    200           ===============================================================================  
    201           [..] This section provides a set of functions allowing to initialize the SPI 
    202                Direction, SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS 
    203                Management, SPI Baud Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    204            
    205           [..] The SPI_Init() function follows the SPI configuration procedures for Master 
    206                mode and Slave mode (details for these procedures are available in reference 
    207                manual (RM0090)).
    208            
    209          @endverbatim
    210            * @{
    211            */
    212          
    213          /**
    214            * @brief  De-initialize the SPIx peripheral registers to their default reset values.
    215            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
    216            *         in SPI mode or 2 or 3 in I2S mode.   
    217            *         
    218            * @note   The extended I2S blocks (ie. I2S2ext and I2S3ext blocks) are de-initialized
    219            *         when the relative I2S peripheral is de-initialized (the extended block's clock
    220            *         is managed by the I2S peripheral clock).
    221            *             
    222            * @retval None
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    225          {
   \                     SPI_I2S_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    226            /* Check the parameters */
    227            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable17  ;; 0x40013000
   \   00000008   0x42AC             CMP      R4,R5
   \   0000000A   0xD018             BEQ.N    ??SPI_I2S_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD014             BEQ.N    ??SPI_I2S_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD010             BEQ.N    ??SPI_I2S_DeInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00C             BEQ.N    ??SPI_I2S_DeInit_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD008             BEQ.N    ??SPI_I2S_DeInit_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40015400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD004             BEQ.N    ??SPI_I2S_DeInit_0
   \   00000034   0x21E3             MOVS     R1,#+227
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000003A   0x.... 0x....      BL       assert_failed
    228          
    229            if (SPIx == SPI1)
   \                     ??SPI_I2S_DeInit_0: (+1)
   \   0000003E   0x42AC             CMP      R4,R5
   \   00000040   0xD10B             BNE.N    ??SPI_I2S_DeInit_1
    230            {
    231              /* Enable SPI1 reset state */
    232              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0xF44F 0x5080      MOV      R0,#+4096
   \   00000048   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    233              /* Release SPI1 from reset state */
    234              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xF44F 0x5080      MOV      R0,#+4096
   \   00000052   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000056   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    235            }
    236            else if (SPIx == SPI2)
   \                     ??SPI_I2S_DeInit_1: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   0000005E   0x4284             CMP      R4,R0
   \   00000060   0xD10B             BNE.N    ??SPI_I2S_DeInit_2
    237            {
    238              /* Enable SPI2 reset state */
    239              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0xF44F 0x4080      MOV      R0,#+16384
   \   00000068   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    240              /* Release SPI2 from reset state */
    241              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0xF44F 0x4080      MOV      R0,#+16384
   \   00000072   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000076   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    242            }
    243            else if (SPIx == SPI3)
   \                     ??SPI_I2S_DeInit_2: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD10B             BNE.N    ??SPI_I2S_DeInit_3
    244            {
    245              /* Enable SPI3 reset state */
    246              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0xF44F 0x4000      MOV      R0,#+32768
   \   00000088   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    247              /* Release SPI3 from reset state */
    248              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0xF44F 0x4000      MOV      R0,#+32768
   \   00000092   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000096   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    249            }
    250            else if (SPIx == SPI4)
   \                     ??SPI_I2S_DeInit_3: (+1)
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   0000009E   0x4284             CMP      R4,R0
   \   000000A0   0xD10B             BNE.N    ??SPI_I2S_DeInit_4
    251            {
    252              /* Enable SPI4 reset state */
    253              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0xF44F 0x5000      MOV      R0,#+8192
   \   000000A8   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    254              /* Release SPI4 from reset state */
    255              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0xF44F 0x5000      MOV      R0,#+8192
   \   000000B2   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000B6   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    256            }
    257            else if (SPIx == SPI5)
   \                     ??SPI_I2S_DeInit_4: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   000000BE   0x4284             CMP      R4,R0
   \   000000C0   0xD10B             BNE.N    ??SPI_I2S_DeInit_5
    258            {
    259              /* Enable SPI5 reset state */
    260              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
   \   000000C2   0x2101             MOVS     R1,#+1
   \   000000C4   0xF44F 0x1080      MOV      R0,#+1048576
   \   000000C8   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    261              /* Release SPI5 from reset state */
    262              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0xF44F 0x1080      MOV      R0,#+1048576
   \   000000D2   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000D6   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    263            }
    264            else 
    265            {
    266              if (SPIx == SPI6)
   \                     ??SPI_I2S_DeInit_5: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40015400
   \   000000DE   0x4284             CMP      R4,R0
   \   000000E0   0xD10B             BNE.N    ??SPI_I2S_DeInit_6
    267              {
    268                /* Enable SPI6 reset state */
    269                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
   \   000000E2   0x2101             MOVS     R1,#+1
   \   000000E4   0xF44F 0x1000      MOV      R0,#+2097152
   \   000000E8   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    270                /* Release SPI6 from reset state */
    271                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0xF44F 0x1000      MOV      R0,#+2097152
   \   000000F2   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000F6   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    272              }
    273            }
    274          }
   \                     ??SPI_I2S_DeInit_6: (+1)
   \   000000FA   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    275          
    276          /**
    277            * @brief  Initializes the SPIx peripheral according to the specified 
    278            *         parameters in the SPI_InitStruct.
    279            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    280            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    281            *         contains the configuration information for the specified SPI peripheral.
    282            * @retval None
    283            */

   \                                 In section .text, align 2, keep-with-next
    284          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    285          {
   \                     SPI_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    286            uint16_t tmpreg = 0;
    287            
    288            /* check the parameters */
    289            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable18_1
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40013000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD018             BEQ.N    ??SPI_Init_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD014             BEQ.N    ??SPI_Init_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD010             BEQ.N    ??SPI_Init_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00C             BEQ.N    ??SPI_Init_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD008             BEQ.N    ??SPI_Init_0
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD004             BEQ.N    ??SPI_Init_0
   \   0000003A   0xF240 0x1121      MOVW     R1,#+289
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       assert_failed
    290            
    291            /* Check the SPI parameters */
    292            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
   \                     ??SPI_Init_0: (+1)
   \   00000044   0x8828             LDRH     R0,[R5, #+0]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD00D             BEQ.N    ??SPI_Init_1
   \   0000004A   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000004E   0xD00A             BEQ.N    ??SPI_Init_1
   \   00000050   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000054   0xD007             BEQ.N    ??SPI_Init_1
   \   00000056   0xF5B0 0x4F40      CMP      R0,#+49152
   \   0000005A   0xD004             BEQ.N    ??SPI_Init_1
   \   0000005C   0xF44F 0x7192      MOV      R1,#+292
   \   00000060   0x4630             MOV      R0,R6
   \   00000062   0x.... 0x....      BL       assert_failed
    293            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
   \                     ??SPI_Init_1: (+1)
   \   00000066   0x8868             LDRH     R0,[R5, #+2]
   \   00000068   0xF5B0 0x7F82      CMP      R0,#+260
   \   0000006C   0xD006             BEQ.N    ??SPI_Init_2
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD004             BEQ.N    ??SPI_Init_2
   \   00000072   0xF240 0x1125      MOVW     R1,#+293
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       assert_failed
    294            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
   \                     ??SPI_Init_2: (+1)
   \   0000007C   0x88A8             LDRH     R0,[R5, #+4]
   \   0000007E   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000082   0xD006             BEQ.N    ??SPI_Init_3
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD004             BEQ.N    ??SPI_Init_3
   \   00000088   0xF44F 0x7193      MOV      R1,#+294
   \   0000008C   0x4630             MOV      R0,R6
   \   0000008E   0x.... 0x....      BL       assert_failed
    295            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
   \                     ??SPI_Init_3: (+1)
   \   00000092   0x88E8             LDRH     R0,[R5, #+6]
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD006             BEQ.N    ??SPI_Init_4
   \   00000098   0x2802             CMP      R0,#+2
   \   0000009A   0xD004             BEQ.N    ??SPI_Init_4
   \   0000009C   0xF240 0x1127      MOVW     R1,#+295
   \   000000A0   0x4630             MOV      R0,R6
   \   000000A2   0x.... 0x....      BL       assert_failed
    296            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
   \                     ??SPI_Init_4: (+1)
   \   000000A6   0x8928             LDRH     R0,[R5, #+8]
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD006             BEQ.N    ??SPI_Init_5
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD004             BEQ.N    ??SPI_Init_5
   \   000000B0   0xF44F 0x7194      MOV      R1,#+296
   \   000000B4   0x4630             MOV      R0,R6
   \   000000B6   0x.... 0x....      BL       assert_failed
    297            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
   \                     ??SPI_Init_5: (+1)
   \   000000BA   0x8968             LDRH     R0,[R5, #+10]
   \   000000BC   0xF5B0 0x7F00      CMP      R0,#+512
   \   000000C0   0xD006             BEQ.N    ??SPI_Init_6
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD004             BEQ.N    ??SPI_Init_6
   \   000000C6   0xF240 0x1129      MOVW     R1,#+297
   \   000000CA   0x4630             MOV      R0,R6
   \   000000CC   0x.... 0x....      BL       assert_failed
    298            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
   \                     ??SPI_Init_6: (+1)
   \   000000D0   0x89A8             LDRH     R0,[R5, #+12]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD012             BEQ.N    ??SPI_Init_7
   \   000000D6   0x2808             CMP      R0,#+8
   \   000000D8   0xD010             BEQ.N    ??SPI_Init_7
   \   000000DA   0x2810             CMP      R0,#+16
   \   000000DC   0xD00E             BEQ.N    ??SPI_Init_7
   \   000000DE   0x2818             CMP      R0,#+24
   \   000000E0   0xD00C             BEQ.N    ??SPI_Init_7
   \   000000E2   0x2820             CMP      R0,#+32
   \   000000E4   0xD00A             BEQ.N    ??SPI_Init_7
   \   000000E6   0x2828             CMP      R0,#+40
   \   000000E8   0xD008             BEQ.N    ??SPI_Init_7
   \   000000EA   0x2830             CMP      R0,#+48
   \   000000EC   0xD006             BEQ.N    ??SPI_Init_7
   \   000000EE   0x2838             CMP      R0,#+56
   \   000000F0   0xD004             BEQ.N    ??SPI_Init_7
   \   000000F2   0xF44F 0x7195      MOV      R1,#+298
   \   000000F6   0x4630             MOV      R0,R6
   \   000000F8   0x.... 0x....      BL       assert_failed
    299            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
   \                     ??SPI_Init_7: (+1)
   \   000000FC   0x89E8             LDRH     R0,[R5, #+14]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD006             BEQ.N    ??SPI_Init_8
   \   00000102   0x2880             CMP      R0,#+128
   \   00000104   0xD004             BEQ.N    ??SPI_Init_8
   \   00000106   0xF240 0x112B      MOVW     R1,#+299
   \   0000010A   0x4630             MOV      R0,R6
   \   0000010C   0x.... 0x....      BL       assert_failed
    300            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
   \                     ??SPI_Init_8: (+1)
   \   00000110   0x8A28             LDRH     R0,[R5, #+16]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD104             BNE.N    ??SPI_Init_9
   \   00000116   0xF44F 0x7196      MOV      R1,#+300
   \   0000011A   0x4630             MOV      R0,R6
   \   0000011C   0x.... 0x....      BL       assert_failed
    301          
    302          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    303            /* Get the SPIx CR1 value */
    304            tmpreg = SPIx->CR1;
   \                     ??SPI_Init_9: (+1)
   \   00000120   0x8820             LDRH     R0,[R4, #+0]
    305            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    306            tmpreg &= CR1_CLEAR_MASK;
    307            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    308               master/salve mode, CPOL and CPHA */
    309            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    310            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    311            /* Set LSBFirst bit according to SPI_FirstBit value */
    312            /* Set BR bits according to SPI_BaudRatePrescaler value */
    313            /* Set CPOL bit according to SPI_CPOL value */
    314            /* Set CPHA bit according to SPI_CPHA value */
    315            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    316                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    317                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    318                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
    319            /* Write to SPIx CR1 */
    320            SPIx->CR1 = tmpreg;
   \   00000122   0xF400 0x5041      AND      R0,R0,#0x3040
   \   00000126   0x8829             LDRH     R1,[R5, #+0]
   \   00000128   0x4308             ORRS     R0,R1,R0
   \   0000012A   0x8869             LDRH     R1,[R5, #+2]
   \   0000012C   0x4308             ORRS     R0,R1,R0
   \   0000012E   0x88A9             LDRH     R1,[R5, #+4]
   \   00000130   0x4308             ORRS     R0,R1,R0
   \   00000132   0x88E9             LDRH     R1,[R5, #+6]
   \   00000134   0x4308             ORRS     R0,R1,R0
   \   00000136   0x8929             LDRH     R1,[R5, #+8]
   \   00000138   0x4308             ORRS     R0,R1,R0
   \   0000013A   0x8969             LDRH     R1,[R5, #+10]
   \   0000013C   0x4308             ORRS     R0,R1,R0
   \   0000013E   0x89A9             LDRH     R1,[R5, #+12]
   \   00000140   0x4308             ORRS     R0,R1,R0
   \   00000142   0x89E9             LDRH     R1,[R5, #+14]
   \   00000144   0x4308             ORRS     R0,R1,R0
   \   00000146   0x8020             STRH     R0,[R4, #+0]
    321          
    322            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    323            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
   \   00000148   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000014A   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000014E   0x4008             ANDS     R0,R1,R0
   \   00000150   0x83A0             STRH     R0,[R4, #+28]
    324          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    325            /* Write to SPIx CRCPOLY */
    326            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000152   0x8A28             LDRH     R0,[R5, #+16]
   \   00000154   0x8220             STRH     R0,[R4, #+16]
    327          }
   \   00000156   0xBD70             POP      {R4-R6,PC}       ;; return
    328          
    329          /**
    330            * @brief  Initializes the SPIx peripheral according to the specified 
    331            *         parameters in the I2S_InitStruct.
    332            * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
    333            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    334            *         contains the configuration information for the specified SPI peripheral
    335            *         configured in I2S mode.
    336            *           
    337            * @note   The function calculates the optimal prescaler needed to obtain the most 
    338            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    339            *         and the product configuration). But in case the prescaler value is greater 
    340            *         than 511, the default value (0x02) will be configured instead.    
    341            * 
    342            * @note   if an external clock is used as source clock for the I2S, then the define
    343            *         I2S_EXTERNAL_CLOCK_VAL in file stm32f4xx_conf.h should be enabled and set
    344            *         to the value of the the source clock frequency (in Hz).
    345            *  
    346            * @retval None
    347            */

   \                                 In section .text, align 2, keep-with-next
    348          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    349          {
   \                     I2S_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    350            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000006   0x2601             MOVS     R6,#+1
    351            uint32_t tmp = 0, i2sclk = 0;
    352          #ifndef I2S_EXTERNAL_CLOCK_VAL
    353            uint32_t pllm = 0, plln = 0, pllr = 0;
    354          #endif /* I2S_EXTERNAL_CLOCK_VAL */
    355            
    356            /* Check the I2S parameters */
    357            assert_param(IS_SPI_23_PERIPH(SPIx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??I2S_Init_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??I2S_Init_0
   \   00000018   0xF240 0x1165      MOVW     R1,#+357
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
    358            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
   \                     ??I2S_Init_0: (+1)
   \   00000024   0x8828             LDRH     R0,[R5, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD00E             BEQ.N    ??I2S_Init_1
   \   0000002A   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000002E   0xD00B             BEQ.N    ??I2S_Init_1
   \   00000030   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000034   0xD008             BEQ.N    ??I2S_Init_1
   \   00000036   0xF5B0 0x7F40      CMP      R0,#+768
   \   0000003A   0xD005             BEQ.N    ??I2S_Init_1
   \   0000003C   0xF44F 0x71B3      MOV      R1,#+358
   \   00000040   0x.... 0x....      ADR.W    R0,?_0
   \   00000044   0x.... 0x....      BL       assert_failed
    359            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
   \                     ??I2S_Init_1: (+1)
   \   00000048   0x8868             LDRH     R0,[R5, #+2]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD00D             BEQ.N    ??I2S_Init_2
   \   0000004E   0x2810             CMP      R0,#+16
   \   00000050   0xD00B             BEQ.N    ??I2S_Init_2
   \   00000052   0x2820             CMP      R0,#+32
   \   00000054   0xD009             BEQ.N    ??I2S_Init_2
   \   00000056   0x2830             CMP      R0,#+48
   \   00000058   0xD007             BEQ.N    ??I2S_Init_2
   \   0000005A   0x28B0             CMP      R0,#+176
   \   0000005C   0xD005             BEQ.N    ??I2S_Init_2
   \   0000005E   0xF240 0x1167      MOVW     R1,#+359
   \   00000062   0x.... 0x....      ADR.W    R0,?_0
   \   00000066   0x.... 0x....      BL       assert_failed
    360            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
   \                     ??I2S_Init_2: (+1)
   \   0000006A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD00B             BEQ.N    ??I2S_Init_3
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD009             BEQ.N    ??I2S_Init_3
   \   00000074   0x2803             CMP      R0,#+3
   \   00000076   0xD007             BEQ.N    ??I2S_Init_3
   \   00000078   0x2805             CMP      R0,#+5
   \   0000007A   0xD005             BEQ.N    ??I2S_Init_3
   \   0000007C   0xF44F 0x71B4      MOV      R1,#+360
   \   00000080   0x.... 0x....      ADR.W    R0,?_0
   \   00000084   0x.... 0x....      BL       assert_failed
    361            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
   \                     ??I2S_Init_3: (+1)
   \   00000088   0x88E8             LDRH     R0,[R5, #+6]
   \   0000008A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000008E   0xD007             BEQ.N    ??I2S_Init_4
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD005             BEQ.N    ??I2S_Init_4
   \   00000094   0xF240 0x1169      MOVW     R1,#+361
   \   00000098   0x.... 0x....      ADR.W    R0,?_0
   \   0000009C   0x.... 0x....      BL       assert_failed
    362            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
   \                     ??I2S_Init_4: (+1)
   \   000000A0   0x68A8             LDR      R0,[R5, #+8]
   \   000000A2   0xF5A0 0x51FA      SUB      R1,R0,#+8000
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable21  ;; 0x2cec1
   \   000000AA   0x4291             CMP      R1,R2
   \   000000AC   0xD307             BCC.N    ??I2S_Init_5
   \   000000AE   0x2802             CMP      R0,#+2
   \   000000B0   0xD005             BEQ.N    ??I2S_Init_5
   \   000000B2   0xF44F 0x71B5      MOV      R1,#+362
   \   000000B6   0x.... 0x....      ADR.W    R0,?_0
   \   000000BA   0x.... 0x....      BL       assert_failed
    363            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
   \                     ??I2S_Init_5: (+1)
   \   000000BE   0x89A8             LDRH     R0,[R5, #+12]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD007             BEQ.N    ??I2S_Init_6
   \   000000C4   0x2808             CMP      R0,#+8
   \   000000C6   0xD005             BEQ.N    ??I2S_Init_6
   \   000000C8   0xF240 0x116B      MOVW     R1,#+363
   \   000000CC   0x.... 0x....      ADR.W    R0,?_0
   \   000000D0   0x.... 0x....      BL       assert_failed
    364          
    365          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    366            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    367            SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
   \                     ??I2S_Init_6: (+1)
   \   000000D4   0x8BA0             LDRH     R0,[R4, #+28]
   \   000000D6   0xF24F 0x0140      MOVW     R1,#+61504
   \   000000DA   0x4008             ANDS     R0,R1,R0
   \   000000DC   0x83A0             STRH     R0,[R4, #+28]
    368            SPIx->I2SPR = 0x0002;
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0x8420             STRH     R0,[R4, #+32]
    369            
    370            /* Get the I2SCFGR register value */
    371            tmpreg = SPIx->I2SCFGR;
   \   000000E2   0x8BA0             LDRH     R0,[R4, #+28]
    372            
    373            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    374            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   000000E4   0x68A9             LDR      R1,[R5, #+8]
   \   000000E6   0x2902             CMP      R1,#+2
   \   000000E8   0xD102             BNE.N    ??I2S_Init_7
    375            {
    376              i2sodd = (uint16_t)0;
   \   000000EA   0x2100             MOVS     R1,#+0
    377              i2sdiv = (uint16_t)2;   
   \   000000EC   0x2202             MOVS     R2,#+2
   \   000000EE   0xE03D             B.N      ??I2S_Init_8
    378            }
    379            /* If the requested audio frequency is not the default, compute the prescaler */
    380            else
    381            {
    382              /* Check the frame length (For the Prescaler computing) *******************/
    383              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_7: (+1)
   \   000000F0   0x88A9             LDRH     R1,[R5, #+4]
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0xD000             BEQ.N    ??I2S_Init_9
    384              {
    385                /* Packet length is 16 bits */
    386                packetlength = 1;
    387              }
    388              else
    389              {
    390                /* Packet length is 32 bits */
    391                packetlength = 2;
   \   000000F6   0x2602             MOVS     R6,#+2
    392              }
    393          
    394              /* Get I2S source Clock frequency  ****************************************/
    395                
    396              /* If an external I2S clock has to be used, this define should be set  
    397                 in the project configuration or in the stm32f4xx_conf.h file */
    398            #ifdef I2S_EXTERNAL_CLOCK_VAL     
    399              /* Set external clock as I2S clock source */
    400              if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
    401              {
    402                RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
    403              }
    404              
    405              /* Set the I2S clock to the external clock  value */
    406              i2sclk = I2S_EXTERNAL_CLOCK_VAL;
    407          
    408            #else /* There is no define for External I2S clock source */
    409              /* Set PLLI2S as I2S clock source */
    410              if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
   \                     ??I2S_Init_9: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0x40023804
   \   000000FC   0x684A             LDR      R2,[R1, #+4]
   \   000000FE   0x0212             LSLS     R2,R2,#+8
   \   00000100   0xD503             BPL.N    ??I2S_Init_10
    411              {
    412                RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
   \   00000102   0x684A             LDR      R2,[R1, #+4]
   \   00000104   0xF422 0x0200      BIC      R2,R2,#0x800000
   \   00000108   0x604A             STR      R2,[R1, #+4]
    413              }    
    414              
    415              /* Get the PLLI2SN value */
    416              plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
    417                                (RCC_PLLI2SCFGR_PLLI2SN >> 6));
   \                     ??I2S_Init_10: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R2,??DataTable23_1  ;; 0x40023884
   \   0000010E   0x6813             LDR      R3,[R2, #+0]
   \   00000110   0xF3C3 0x1388      UBFX     R3,R3,#+6,#+9
    418              
    419              /* Get the PLLI2SR value */
    420              pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
    421                                (RCC_PLLI2SCFGR_PLLI2SR >> 28));
   \   00000114   0x6812             LDR      R2,[R2, #+0]
   \   00000116   0xF3C2 0x7202      UBFX     R2,R2,#+28,#+3
    422              
    423              /* Get the PLLM value */
    424              pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
   \   0000011A   0x6809             LDR      R1,[R1, #+0]
   \   0000011C   0xF001 0x013F      AND      R1,R1,#0x3F
    425          
    426              /* Get the I2S source clock value */
    427              i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
   \   00000120   0xF44F 0x17FA      MOV      R7,#+2048000
   \   00000124   0xFBB7 0xF1F1      UDIV     R1,R7,R1
   \   00000128   0x4359             MULS     R1,R3,R1
   \   0000012A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    428            #endif /* I2S_EXTERNAL_CLOCK_VAL */
    429              
    430              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    431              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   0000012E   0x68AA             LDR      R2,[R5, #+8]
   \   00000130   0x230A             MOVS     R3,#+10
   \   00000132   0x88EF             LDRH     R7,[R5, #+6]
   \   00000134   0xF5B7 0x7F00      CMP      R7,#+512
   \   00000138   0xD106             BNE.N    ??I2S_Init_11
    432              {
    433                /* MCLK output is enabled */
    434                tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   0000013A   0x0A09             LSRS     R1,R1,#+8
   \   0000013C   0x4359             MULS     R1,R3,R1
   \   0000013E   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000142   0x1D49             ADDS     R1,R1,#+5
   \   00000144   0xB289             UXTH     R1,R1
   \   00000146   0xE007             B.N      ??I2S_Init_12
    435              }
    436              else
    437              {
    438                /* MCLK output is disabled */
    439                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_11: (+1)
   \   00000148   0x0176             LSLS     R6,R6,#+5
   \   0000014A   0xFBB1 0xF1F6      UDIV     R1,R1,R6
   \   0000014E   0x4359             MULS     R1,R3,R1
   \   00000150   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000154   0x1D49             ADDS     R1,R1,#+5
   \   00000156   0xB289             UXTH     R1,R1
    440              }
    441              
    442              /* Remove the flatting point */
    443              tmp = tmp / 10;  
   \                     ??I2S_Init_12: (+1)
   \   00000158   0x461A             MOV      R2,R3
   \   0000015A   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    444                
    445              /* Check the parity of the divider */
    446              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   \   0000015E   0xF001 0x0301      AND      R3,R1,#0x1
    447             
    448              /* Compute the i2sdiv prescaler */
    449              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   \   00000162   0x461A             MOV      R2,R3
   \   00000164   0x1A89             SUBS     R1,R1,R2
   \   00000166   0x084A             LSRS     R2,R1,#+1
   \   00000168   0xB292             UXTH     R2,R2
    450             
    451              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    452              i2sodd = (uint16_t) (i2sodd << 8);
   \   0000016A   0x0219             LSLS     R1,R3,#+8
    453            }
    454          
    455            /* Test if the divider is 1 or 0 or greater than 0xFF */
    456            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_8: (+1)
   \   0000016C   0x1E93             SUBS     R3,R2,#+2
   \   0000016E   0x2BFE             CMP      R3,#+254
   \   00000170   0xD301             BCC.N    ??I2S_Init_13
    457            {
    458              /* Set the default values */
    459              i2sdiv = 2;
   \   00000172   0x2202             MOVS     R2,#+2
    460              i2sodd = 0;
   \   00000174   0x2100             MOVS     R1,#+0
    461            }
    462          
    463            /* Write to SPIx I2SPR register the computed value */
    464            SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
   \                     ??I2S_Init_13: (+1)
   \   00000176   0x4311             ORRS     R1,R1,R2
   \   00000178   0x88EA             LDRH     R2,[R5, #+6]
   \   0000017A   0x4311             ORRS     R1,R2,R1
   \   0000017C   0x8421             STRH     R1,[R4, #+32]
    465           
    466            /* Configure the I2S with the SPI_InitStruct values */
    467            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    468                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    469                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
    470           
    471            /* Write to SPIx I2SCFGR */  
    472            SPIx->I2SCFGR = tmpreg;
   \   0000017E   0x8829             LDRH     R1,[R5, #+0]
   \   00000180   0x4308             ORRS     R0,R1,R0
   \   00000182   0x8869             LDRH     R1,[R5, #+2]
   \   00000184   0x4308             ORRS     R0,R1,R0
   \   00000186   0x88A9             LDRH     R1,[R5, #+4]
   \   00000188   0x4308             ORRS     R0,R1,R0
   \   0000018A   0x89A9             LDRH     R1,[R5, #+12]
   \   0000018C   0x4308             ORRS     R0,R1,R0
   \   0000018E   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000192   0x83A0             STRH     R0,[R4, #+28]
    473          }
   \   00000194   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    474          
    475          /**
    476            * @brief  Fills each SPI_InitStruct member with its default value.
    477            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    478            * @retval None
    479            */

   \                                 In section .text, align 2, keep-with-next
    480          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    481          {
    482          /*--------------- Reset SPI init structure parameters values -----------------*/
    483            /* Initialize the SPI_Direction member */
    484            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    485            /* initialize the SPI_Mode member */
    486            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    487            /* initialize the SPI_DataSize member */
    488            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    489            /* Initialize the SPI_CPOL member */
    490            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    491            /* Initialize the SPI_CPHA member */
    492            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
    493            /* Initialize the SPI_NSS member */
    494            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   0000000C   0x8141             STRH     R1,[R0, #+10]
    495            /* Initialize the SPI_BaudRatePrescaler member */
    496            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    497            /* Initialize the SPI_FirstBit member */
    498            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000010   0x81C1             STRH     R1,[R0, #+14]
    499            /* Initialize the SPI_CRCPolynomial member */
    500            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000012   0x2107             MOVS     R1,#+7
   \   00000014   0x8201             STRH     R1,[R0, #+16]
    501          }
   \   00000016   0x4770             BX       LR               ;; return
    502          
    503          /**
    504            * @brief  Fills each I2S_InitStruct member with its default value.
    505            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    506            * @retval None
    507            */

   \                                 In section .text, align 2, keep-with-next
    508          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    509          {
    510          /*--------------- Reset I2S init structure parameters values -----------------*/
    511            /* Initialize the I2S_Mode member */
    512            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    513            
    514            /* Initialize the I2S_Standard member */
    515            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    516            
    517            /* Initialize the I2S_DataFormat member */
    518            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    519            
    520            /* Initialize the I2S_MCLKOutput member */
    521            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    522            
    523            /* Initialize the I2S_AudioFreq member */
    524            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    525            
    526            /* Initialize the I2S_CPOL member */
    527            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8181             STRH     R1,[R0, #+12]
    528          }
   \   00000012   0x4770             BX       LR               ;; return
    529          
    530          /**
    531            * @brief  Enables or disables the specified SPI peripheral.
    532            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    533            * @param  NewState: new state of the SPIx peripheral. 
    534            *          This parameter can be: ENABLE or DISABLE.
    535            * @retval None
    536            */

   \                                 In section .text, align 2, keep-with-next
    537          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    538          {
   \                     SPI_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    539            /* Check the parameters */
    540            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??SPI_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??SPI_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??SPI_Cmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??SPI_Cmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??SPI_Cmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??SPI_Cmd_0
   \   00000036   0xF44F 0x7107      MOV      R1,#+540
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
    541            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_Cmd_0: (+1)
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD007             BEQ.N    ??SPI_Cmd_1
   \   00000046   0x2D01             CMP      R5,#+1
   \   00000048   0xD005             BEQ.N    ??SPI_Cmd_1
   \   0000004A   0xF240 0x211D      MOVW     R1,#+541
   \   0000004E   0x.... 0x....      ADR.W    R0,?_0
   \   00000052   0x.... 0x....      BL       assert_failed
    542            if (NewState != DISABLE)
   \                     ??SPI_Cmd_1: (+1)
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0x8820             LDRH     R0,[R4, #+0]
   \   0000005A   0xD003             BEQ.N    ??SPI_Cmd_2
    543            {
    544              /* Enable the selected SPI peripheral */
    545              SPIx->CR1 |= SPI_CR1_SPE;
   \   0000005C   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000060   0x8020             STRH     R0,[R4, #+0]
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}
    546            }
    547            else
    548            {
    549              /* Disable the selected SPI peripheral */
    550              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
   \                     ??SPI_Cmd_2: (+1)
   \   00000064   0xF64F 0x71BF      MOVW     R1,#+65471
   \   00000068   0x4008             ANDS     R0,R1,R0
   \   0000006A   0x8020             STRH     R0,[R4, #+0]
    551            }
    552          }
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    553          
    554          /**
    555            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    556            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral (or I2Sxext 
    557            *         for full duplex mode).
    558            * @param  NewState: new state of the SPIx peripheral. 
    559            *         This parameter can be: ENABLE or DISABLE.
    560            * @retval None
    561            */

   \                                 In section .text, align 2, keep-with-next
    562          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    563          {
   \                     I2S_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    564            /* Check the parameters */
    565            assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ.N    ??I2S_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00C             BEQ.N    ??I2S_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40003400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD008             BEQ.N    ??I2S_Cmd_0
   \   0000001E   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000022   0xD005             BEQ.N    ??I2S_Cmd_0
   \   00000024   0xF240 0x2135      MOVW     R1,#+565
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
    566            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2S_Cmd_0: (+1)
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD007             BEQ.N    ??I2S_Cmd_1
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xD005             BEQ.N    ??I2S_Cmd_1
   \   00000038   0xF240 0x2136      MOVW     R1,#+566
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    567            
    568            if (NewState != DISABLE)
   \                     ??I2S_Cmd_1: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0x8BA0             LDRH     R0,[R4, #+28]
   \   00000048   0xD003             BEQ.N    ??I2S_Cmd_2
    569            {
    570              /* Enable the selected SPI peripheral (in I2S mode) */
    571              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
   \   0000004A   0xF440 0x6080      ORR      R0,R0,#0x400
   \   0000004E   0x83A0             STRH     R0,[R4, #+28]
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}
    572            }
    573            else
    574            {
    575              /* Disable the selected SPI peripheral in I2S mode */
    576              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
   \                     ??I2S_Cmd_2: (+1)
   \   00000052   0xF64F 0x31FF      MOVW     R1,#+64511
   \   00000056   0x4008             ANDS     R0,R1,R0
   \   00000058   0x83A0             STRH     R0,[R4, #+28]
    577            }
    578          }
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    579          
    580          /**
    581            * @brief  Configures the data size for the selected SPI.
    582            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    583            * @param  SPI_DataSize: specifies the SPI data size.
    584            *          This parameter can be one of the following values:
    585            *            @arg SPI_DataSize_16b: Set data frame format to 16bit
    586            *            @arg SPI_DataSize_8b: Set data frame format to 8bit
    587            * @retval None
    588            */

   \                                 In section .text, align 2, keep-with-next
    589          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    590          {
   \                     SPI_DataSizeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    591            /* Check the parameters */
    592            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??SPI_DataSizeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??SPI_DataSizeConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??SPI_DataSizeConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??SPI_DataSizeConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??SPI_DataSizeConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??SPI_DataSizeConfig_0
   \   00000036   0xF44F 0x7114      MOV      R1,#+592
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
    593            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
   \                     ??SPI_DataSizeConfig_0: (+1)
   \   00000042   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000046   0xD007             BEQ.N    ??SPI_DataSizeConfig_1
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD005             BEQ.N    ??SPI_DataSizeConfig_1
   \   0000004C   0xF240 0x2151      MOVW     R1,#+593
   \   00000050   0x.... 0x....      ADR.W    R0,?_0
   \   00000054   0x.... 0x....      BL       assert_failed
    594            /* Clear DFF bit */
    595            SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
   \                     ??SPI_DataSizeConfig_1: (+1)
   \   00000058   0x8820             LDRH     R0,[R4, #+0]
   \   0000005A   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x8020             STRH     R0,[R4, #+0]
    596            /* Set new DFF bit value */
    597            SPIx->CR1 |= SPI_DataSize;
   \   00000062   0x8820             LDRH     R0,[R4, #+0]
   \   00000064   0x4328             ORRS     R0,R5,R0
   \   00000066   0x8020             STRH     R0,[R4, #+0]
    598          }
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    599          
    600          /**
    601            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    602            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    603            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    604            *          This parameter can be one of the following values:
    605            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    606            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    607            * @retval None
    608            */

   \                                 In section .text, align 2, keep-with-next
    609          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    610          {
   \                     SPI_BiDirectionalLineConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    611            /* Check the parameters */
    612            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??SPI_BiDirectionalLineConfig_0
   \   00000036   0xF44F 0x7119      MOV      R1,#+612
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
    613            assert_param(IS_SPI_DIRECTION(SPI_Direction));
   \                     ??SPI_BiDirectionalLineConfig_0: (+1)
   \   00000042   0xF64B 0x76FF      MOVW     R6,#+49151
   \   00000046   0x42B5             CMP      R5,R6
   \   00000048   0xD008             BEQ.N    ??SPI_BiDirectionalLineConfig_1
   \   0000004A   0xF5B5 0x4F80      CMP      R5,#+16384
   \   0000004E   0xD005             BEQ.N    ??SPI_BiDirectionalLineConfig_1
   \   00000050   0xF240 0x2165      MOVW     R1,#+613
   \   00000054   0x.... 0x....      ADR.W    R0,?_0
   \   00000058   0x.... 0x....      BL       assert_failed
    614            if (SPI_Direction == SPI_Direction_Tx)
   \                     ??SPI_BiDirectionalLineConfig_1: (+1)
   \   0000005C   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000060   0x8820             LDRH     R0,[R4, #+0]
   \   00000062   0xD103             BNE.N    ??SPI_BiDirectionalLineConfig_2
    615            {
    616              /* Set the Tx only mode */
    617              SPIx->CR1 |= SPI_Direction_Tx;
   \   00000064   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   00000068   0x8020             STRH     R0,[R4, #+0]
   \   0000006A   0xBD70             POP      {R4-R6,PC}
    618            }
    619            else
    620            {
    621              /* Set the Rx only mode */
    622              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_2: (+1)
   \   0000006C   0x4030             ANDS     R0,R6,R0
   \   0000006E   0x8020             STRH     R0,[R4, #+0]
    623            }
    624          }
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    625          
    626          /**
    627            * @brief  Configures internally by software the NSS pin for the selected SPI.
    628            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    629            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    630            *          This parameter can be one of the following values:
    631            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    632            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    633            * @retval None
    634            */

   \                                 In section .text, align 2, keep-with-next
    635          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    636          {
   \                     SPI_NSSInternalSoftwareConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    637            /* Check the parameters */
    638            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
   \   00000036   0xF240 0x217E      MOVW     R1,#+638
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
    639            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
   \                     ??SPI_NSSInternalSoftwareConfig_0: (+1)
   \   00000042   0xF64F 0x66FF      MOVW     R6,#+65279
   \   00000046   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000004A   0xD007             BEQ.N    ??SPI_NSSInternalSoftwareConfig_1
   \   0000004C   0x42B5             CMP      R5,R6
   \   0000004E   0xD005             BEQ.N    ??SPI_NSSInternalSoftwareConfig_1
   \   00000050   0xF240 0x217F      MOVW     R1,#+639
   \   00000054   0x.... 0x....      ADR.W    R0,?_0
   \   00000058   0x.... 0x....      BL       assert_failed
    640            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     ??SPI_NSSInternalSoftwareConfig_1: (+1)
   \   0000005C   0x42B5             CMP      R5,R6
   \   0000005E   0x8820             LDRH     R0,[R4, #+0]
   \   00000060   0xD003             BEQ.N    ??SPI_NSSInternalSoftwareConfig_2
    641            {
    642              /* Set NSS pin internally by software */
    643              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   00000062   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000066   0x8020             STRH     R0,[R4, #+0]
   \   00000068   0xBD70             POP      {R4-R6,PC}
    644            }
    645            else
    646            {
    647              /* Reset NSS pin internally by software */
    648              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_2: (+1)
   \   0000006A   0x4030             ANDS     R0,R6,R0
   \   0000006C   0x8020             STRH     R0,[R4, #+0]
    649            }
    650          }
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    651          
    652          /**
    653            * @brief  Enables or disables the SS output for the selected SPI.
    654            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    655            * @param  NewState: new state of the SPIx SS output. 
    656            *          This parameter can be: ENABLE or DISABLE.
    657            * @retval None
    658            */

   \                                 In section .text, align 2, keep-with-next
    659          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    660          {
   \                     SPI_SSOutputCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    661            /* Check the parameters */
    662            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD019             BEQ.N    ??SPI_SSOutputCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD015             BEQ.N    ??SPI_SSOutputCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40003c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??SPI_SSOutputCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40013400
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00D             BEQ.N    ??SPI_SSOutputCmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD009             BEQ.N    ??SPI_SSOutputCmd_0
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD005             BEQ.N    ??SPI_SSOutputCmd_0
   \   00000036   0xF240 0x2196      MOVW     R1,#+662
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
    663            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_SSOutputCmd_0: (+1)
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD007             BEQ.N    ??SPI_SSOutputCmd_1
   \   00000046   0x2D01             CMP      R5,#+1
   \   00000048   0xD005             BEQ.N    ??SPI_SSOutputCmd_1
   \   0000004A   0xF240 0x2197      MOVW     R1,#+663
   \   0000004E   0x.... 0x....      ADR.W    R0,?_0
   \   00000052   0x.... 0x....      BL       assert_failed
    664            if (NewState != DISABLE)
   \                     ??SPI_SSOutputCmd_1: (+1)
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0x88A0             LDRH     R0,[R4, #+4]
   \   0000005A   0xD003             BEQ.N    ??SPI_SSOutputCmd_2
    665            {
    666              /* Enable the selected SPI SS output */
    667              SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
   \   0000005C   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000060   0x80A0             STRH     R0,[R4, #+4]
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}
    668            }
    669            else
    670            {
    671              /* Disable the selected SPI SS output */
    672              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
   \                     ??SPI_SSOutputCmd_2: (+1)
   \   00000064   0xF64F 0x71FB      MOVW     R1,#+65531
   \   00000068   0x4008             ANDS     R0,R1,R0
   \   0000006A   0x80A0             STRH     R0,[R4, #+4]
    673            }
    674          }
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    675          
    676          /**
    677            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    678            *   
    679            * @note   This function can be called only after the SPI_Init() function has 
    680            *         been called. 
    681            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    682            *         are not taken into consideration and are configured by hardware
    683            *         respectively to the TI mode requirements.  
    684            * 
    685            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 
    686            * @param  NewState: new state of the selected SPI TI communication mode.
    687            *          This parameter can be: ENABLE or DISABLE.
    688            * @retval None
    689            */

   \                                 In section .text, align 2, keep-with-next
    690          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    691          {
   \                     SPI_TIModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    692            /* Check the parameters */
    693            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable17  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD016             BEQ.N    ??SPI_TIModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD013             BEQ.N    ??SPI_TIModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD010             BEQ.N    ??SPI_TIModeCmd_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40013400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00D             BEQ.N    ??SPI_TIModeCmd_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x40015000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD009             BEQ.N    ??SPI_TIModeCmd_0
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD005             BEQ.N    ??SPI_TIModeCmd_0
   \   0000002E   0xF240 0x21B5      MOVW     R1,#+693
   \   00000032   0x.... 0x....      ADR.W    R0,?_0
   \   00000036   0x.... 0x....      BL       assert_failed
    694            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_TIModeCmd_0: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD007             BEQ.N    ??SPI_TIModeCmd_1
   \   0000003E   0x2D01             CMP      R5,#+1
   \   00000040   0xD005             BEQ.N    ??SPI_TIModeCmd_1
   \   00000042   0xF240 0x21B6      MOVW     R1,#+694
   \   00000046   0x.... 0x....      ADR.W    R0,?_0
   \   0000004A   0x.... 0x....      BL       assert_failed
    695          
    696            if (NewState != DISABLE)
   \                     ??SPI_TIModeCmd_1: (+1)
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0x88A0             LDRH     R0,[R4, #+4]
   \   00000052   0xD003             BEQ.N    ??SPI_TIModeCmd_2
    697            {
    698              /* Enable the TI mode for the selected SPI peripheral */
    699              SPIx->CR2 |= SPI_CR2_FRF;
   \   00000054   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000058   0x80A0             STRH     R0,[R4, #+4]
   \   0000005A   0xBD31             POP      {R0,R4,R5,PC}
    700            }
    701            else
    702            {
    703              /* Disable the TI mode for the selected SPI peripheral */
    704              SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
   \                     ??SPI_TIModeCmd_2: (+1)
   \   0000005C   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000060   0x4008             ANDS     R0,R1,R0
   \   00000062   0x80A0             STRH     R0,[R4, #+4]
    705            }
    706          }
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    707          
    708          /**
    709            * @brief  Configures the full duplex mode for the I2Sx peripheral using its
    710            *         extension I2Sxext according to the specified parameters in the 
    711            *         I2S_InitStruct.
    712            * @param  I2Sxext: where x can be  2 or 3 to select the I2S peripheral extension block.
    713            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    714            *         contains the configuration information for the specified I2S peripheral
    715            *         extension.
    716            * 
    717            * @note   The structure pointed by I2S_InitStruct parameter should be the same
    718            *         used for the master I2S peripheral. In this case, if the master is 
    719            *         configured as transmitter, the slave will be receiver and vice versa.
    720            *         Or you can force a different mode by modifying the field I2S_Mode to the
    721            *         value I2S_SlaveRx or I2S_SlaveTx indepedently of the master configuration.    
    722            *         
    723            * @note   The I2S full duplex extension can be configured in slave mode only.    
    724            *  
    725            * @retval None
    726            */

   \                                 In section .text, align 2, keep-with-next
    727          void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
    728          {
   \                     I2S_FullDuplexConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    729            uint16_t tmpreg = 0, tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    730            
    731            /* Check the I2S parameters */
    732            assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40003400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??I2S_FullDuplexConfig_0
   \   00000010   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000014   0xD005             BEQ.N    ??I2S_FullDuplexConfig_0
   \   00000016   0xF44F 0x7137      MOV      R1,#+732
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       assert_failed
    733            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
   \                     ??I2S_FullDuplexConfig_0: (+1)
   \   00000022   0x8828             LDRH     R0,[R5, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD00E             BEQ.N    ??I2S_FullDuplexConfig_1
   \   00000028   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000002C   0xD00B             BEQ.N    ??I2S_FullDuplexConfig_1
   \   0000002E   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000032   0xD008             BEQ.N    ??I2S_FullDuplexConfig_1
   \   00000034   0xF5B0 0x7F40      CMP      R0,#+768
   \   00000038   0xD005             BEQ.N    ??I2S_FullDuplexConfig_1
   \   0000003A   0xF240 0x21DD      MOVW     R1,#+733
   \   0000003E   0x.... 0x....      ADR.W    R0,?_0
   \   00000042   0x.... 0x....      BL       assert_failed
    734            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
   \                     ??I2S_FullDuplexConfig_1: (+1)
   \   00000046   0x8868             LDRH     R0,[R5, #+2]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD00D             BEQ.N    ??I2S_FullDuplexConfig_2
   \   0000004C   0x2810             CMP      R0,#+16
   \   0000004E   0xD00B             BEQ.N    ??I2S_FullDuplexConfig_2
   \   00000050   0x2820             CMP      R0,#+32
   \   00000052   0xD009             BEQ.N    ??I2S_FullDuplexConfig_2
   \   00000054   0x2830             CMP      R0,#+48
   \   00000056   0xD007             BEQ.N    ??I2S_FullDuplexConfig_2
   \   00000058   0x28B0             CMP      R0,#+176
   \   0000005A   0xD005             BEQ.N    ??I2S_FullDuplexConfig_2
   \   0000005C   0xF240 0x21DE      MOVW     R1,#+734
   \   00000060   0x.... 0x....      ADR.W    R0,?_0
   \   00000064   0x.... 0x....      BL       assert_failed
    735            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
   \                     ??I2S_FullDuplexConfig_2: (+1)
   \   00000068   0x88A8             LDRH     R0,[R5, #+4]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD00B             BEQ.N    ??I2S_FullDuplexConfig_3
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD009             BEQ.N    ??I2S_FullDuplexConfig_3
   \   00000072   0x2803             CMP      R0,#+3
   \   00000074   0xD007             BEQ.N    ??I2S_FullDuplexConfig_3
   \   00000076   0x2805             CMP      R0,#+5
   \   00000078   0xD005             BEQ.N    ??I2S_FullDuplexConfig_3
   \   0000007A   0xF240 0x21DF      MOVW     R1,#+735
   \   0000007E   0x.... 0x....      ADR.W    R0,?_0
   \   00000082   0x.... 0x....      BL       assert_failed
    736            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
   \                     ??I2S_FullDuplexConfig_3: (+1)
   \   00000086   0x89A8             LDRH     R0,[R5, #+12]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD007             BEQ.N    ??I2S_FullDuplexConfig_4
   \   0000008C   0x2808             CMP      R0,#+8
   \   0000008E   0xD005             BEQ.N    ??I2S_FullDuplexConfig_4
   \   00000090   0xF44F 0x7138      MOV      R1,#+736
   \   00000094   0x.... 0x....      ADR.W    R0,?_0
   \   00000098   0x.... 0x....      BL       assert_failed
    737          
    738          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    739            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    740            I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
   \                     ??I2S_FullDuplexConfig_4: (+1)
   \   0000009C   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000009E   0xF24F 0x0140      MOVW     R1,#+61504
   \   000000A2   0x4008             ANDS     R0,R1,R0
   \   000000A4   0x83A0             STRH     R0,[R4, #+28]
    741            I2Sxext->I2SPR = 0x0002;
   \   000000A6   0x2002             MOVS     R0,#+2
   \   000000A8   0x8420             STRH     R0,[R4, #+32]
    742            
    743            /* Get the I2SCFGR register value */
    744            tmpreg = I2Sxext->I2SCFGR;
   \   000000AA   0x8BA0             LDRH     R0,[R4, #+28]
    745            
    746            /* Get the mode to be configured for the extended I2S */
    747            if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
   \   000000AC   0x8829             LDRH     R1,[R5, #+0]
   \   000000AE   0xF5B1 0x7F00      CMP      R1,#+512
   \   000000B2   0xD001             BEQ.N    ??I2S_FullDuplexConfig_5
   \   000000B4   0x2900             CMP      R1,#+0
   \   000000B6   0xD101             BNE.N    ??I2S_FullDuplexConfig_6
    748            {
    749              tmp = I2S_Mode_SlaveRx;
   \                     ??I2S_FullDuplexConfig_5: (+1)
   \   000000B8   0xF44F 0x7680      MOV      R6,#+256
    750            }
    751            else
    752            {
    753              if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    754              {
    755                tmp = I2S_Mode_SlaveTx;
    756              }
    757            }
    758          
    759           
    760            /* Configure the I2S with the SPI_InitStruct values */
    761            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
    762                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    763                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
    764           
    765            /* Write to SPIx I2SCFGR */  
    766            I2Sxext->I2SCFGR = tmpreg;
   \                     ??I2S_FullDuplexConfig_6: (+1)
   \   000000BC   0x4330             ORRS     R0,R6,R0
   \   000000BE   0x8869             LDRH     R1,[R5, #+2]
   \   000000C0   0x4308             ORRS     R0,R1,R0
   \   000000C2   0x88A9             LDRH     R1,[R5, #+4]
   \   000000C4   0x4308             ORRS     R0,R1,R0
   \   000000C6   0x89A9             LDRH     R1,[R5, #+12]
   \   000000C8   0x4308             ORRS     R0,R1,R0
   \   000000CA   0xF440 0x6000      ORR      R0,R0,#0x800
   \   000000CE   0x83A0             STRH     R0,[R4, #+28]
    767          }
   \   000000D0   0xBD70             POP      {R4-R6,PC}       ;; return
    768          
    769          /**
    770            * @}
    771            */
    772          
    773          /** @defgroup SPI_Group2 Data transfers functions
    774           *  @brief   Data transfers functions
    775           *
    776          @verbatim   
    777           ===============================================================================
    778                                ##### Data transfers functions #####
    779           ===============================================================================  
    780          
    781           [..] This section provides a set of functions allowing to manage the SPI data 
    782                transfers. In reception, data are received and then stored into an internal 
    783                Rx buffer while. In transmission, data are first stored into an internal Tx 
    784                buffer before being transmitted.
    785          
    786           [..] The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
    787                function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    788                can be done using SPI_I2S_SendData() function and stores the written data into 
    789                Tx buffer.
    790          
    791          @endverbatim
    792            * @{
    793            */
    794          
    795          /**
    796            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    797            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
    798            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
    799            * @retval The value of the received data.
    800            */

   \                                 In section .text, align 2, keep-with-next
    801          uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    802          {
   \                     SPI_I2S_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    803            /* Check the parameters */
    804            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable17  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD01C             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   0000000A   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD019             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000010   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD016             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000016   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40013400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD013             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   0000001C   0x....             LDR.N    R0,??DataTable18  ;; 0x40015000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD010             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40015400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00C             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40003400
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD008             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000032   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000036   0xD005             BEQ.N    ??SPI_I2S_ReceiveData_0
   \   00000038   0xF44F 0x7149      MOV      R1,#+804
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    805            
    806            /* Return the data in the DR register */
    807            return SPIx->DR;
   \                     ??SPI_I2S_ReceiveData_0: (+1)
   \   00000044   0x89A0             LDRH     R0,[R4, #+12]
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    808          }
    809          
    810          /**
    811            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    812            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
    813            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.     
    814            * @param  Data: Data to be transmitted.
    815            * @retval None
    816            */

   \                                 In section .text, align 2, keep-with-next
    817          void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
    818          {
   \                     SPI_I2S_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    819            /* Check the parameters */
    820            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable17  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD01C             BEQ.N    ??SPI_I2S_SendData_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD019             BEQ.N    ??SPI_I2S_SendData_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD016             BEQ.N    ??SPI_I2S_SendData_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40013400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD013             BEQ.N    ??SPI_I2S_SendData_0
   \   0000001E   0x....             LDR.N    R0,??DataTable18  ;; 0x40015000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD010             BEQ.N    ??SPI_I2S_SendData_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable22  ;; 0x40015400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD00C             BEQ.N    ??SPI_I2S_SendData_0
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable23_2  ;; 0x40003400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD008             BEQ.N    ??SPI_I2S_SendData_0
   \   00000034   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000038   0xD005             BEQ.N    ??SPI_I2S_SendData_0
   \   0000003A   0xF44F 0x714D      MOV      R1,#+820
   \   0000003E   0x.... 0x....      ADR.W    R0,?_0
   \   00000042   0x.... 0x....      BL       assert_failed
    821            
    822            /* Write in the DR register the data to be sent */
    823            SPIx->DR = Data;
   \                     ??SPI_I2S_SendData_0: (+1)
   \   00000046   0x81A5             STRH     R5,[R4, #+12]
    824          }
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    825          
    826          /**
    827            * @}
    828            */
    829          
    830          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    831           *  @brief   Hardware CRC Calculation functions
    832           *
    833          @verbatim   
    834           ===============================================================================
    835                           ##### Hardware CRC Calculation functions #####
    836           ===============================================================================  
    837          
    838           [..] This section provides a set of functions allowing to manage the SPI CRC hardware 
    839                calculation
    840          
    841           [..] SPI communication using CRC is possible through the following procedure:
    842             (#) Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    843                 Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    844                 function.
    845             (#) Enable the CRC calculation using the SPI_CalculateCRC() function.
    846             (#) Enable the SPI using the SPI_Cmd() function
    847             (#) Before writing the last data to the TX buffer, set the CRCNext bit using the 
    848                 SPI_TransmitCRC() function to indicate that after transmission of the last 
    849                 data, the CRC should be transmitted.
    850             (#) After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    851                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    852                  value. 
    853                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    854                  can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    855          
    856           [..]
    857             (@) It is advised not to read the calculated CRC values during the communication.
    858          
    859             (@) When the SPI is in slave mode, be careful to enable CRC calculation only 
    860                 when the clock is stable, that is, when the clock is in the steady state. 
    861                 If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    862                 to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    863                 the value of the SPE bit.
    864          
    865             (@) With high bitrate frequencies, be careful when transmitting the CRC.
    866                 As the number of used CPU cycles has to be as low as possible in the CRC 
    867                 transfer phase, it is forbidden to call software functions in the CRC 
    868                 transmission sequence to avoid errors in the last data and CRC reception. 
    869                 In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    870                 of the last data.
    871          
    872             (@) For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    873                 degradation of the SPI speed performance due to CPU accesses impacting the 
    874                 SPI bandwidth.
    875          
    876             (@) When the STM32F4xx is configured as slave and the NSS hardware mode is 
    877                 used, the NSS pin needs to be kept low between the data phase and the CRC 
    878                 phase.
    879          
    880             (@) When the SPI is configured in slave mode with the CRC feature enabled, CRC
    881                 calculation takes place even if a high level is applied on the NSS pin. 
    882                 This may happen for example in case of a multi-slave environment where the 
    883                 communication master addresses slaves alternately.
    884          
    885             (@) Between a slave de-selection (high level on NSS) and a new slave selection 
    886                 (low level on NSS), the CRC value should be cleared on both master and slave
    887                 sides in order to resynchronize the master and slave for their respective 
    888                 CRC calculation.
    889          
    890             (@) To clear the CRC, follow the procedure below:
    891                 (#@) Disable SPI using the SPI_Cmd() function
    892                 (#@) Disable the CRC calculation using the SPI_CalculateCRC() function.
    893                 (#@) Enable the CRC calculation using the SPI_CalculateCRC() function.
    894                 (#@) Enable SPI using the SPI_Cmd() function.
    895          
    896          @endverbatim
    897            * @{
    898            */
    899          
    900          /**
    901            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    902            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    903            * @param  NewState: new state of the SPIx CRC value calculation.
    904            *          This parameter can be: ENABLE or DISABLE.
    905            * @retval None
    906            */

   \                                 In section .text, align 2, keep-with-next
    907          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    908          {
   \                     SPI_CalculateCRC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    909            /* Check the parameters */
    910            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable17  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD015             BEQ.N    ??SPI_CalculateCRC_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD012             BEQ.N    ??SPI_CalculateCRC_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00F             BEQ.N    ??SPI_CalculateCRC_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40013400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00C             BEQ.N    ??SPI_CalculateCRC_0
   \   0000001E   0x....             LDR.N    R0,??DataTable18  ;; 0x40015000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD009             BEQ.N    ??SPI_CalculateCRC_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD005             BEQ.N    ??SPI_CalculateCRC_0
   \   0000002C   0xF240 0x318E      MOVW     R1,#+910
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
    911            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_CalculateCRC_0: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD007             BEQ.N    ??SPI_CalculateCRC_1
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD005             BEQ.N    ??SPI_CalculateCRC_1
   \   00000040   0xF240 0x318F      MOVW     R1,#+911
   \   00000044   0x.... 0x....      ADR.W    R0,?_0
   \   00000048   0x.... 0x....      BL       assert_failed
    912            if (NewState != DISABLE)
   \                     ??SPI_CalculateCRC_1: (+1)
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0x8820             LDRH     R0,[R4, #+0]
   \   00000050   0xD003             BEQ.N    ??SPI_CalculateCRC_2
    913            {
    914              /* Enable the selected SPI CRC calculation */
    915              SPIx->CR1 |= SPI_CR1_CRCEN;
   \   00000052   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000056   0x8020             STRH     R0,[R4, #+0]
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}
    916            }
    917            else
    918            {
    919              /* Disable the selected SPI CRC calculation */
    920              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
   \                     ??SPI_CalculateCRC_2: (+1)
   \   0000005A   0xF64D 0x71FF      MOVW     R1,#+57343
   \   0000005E   0x4008             ANDS     R0,R1,R0
   \   00000060   0x8020             STRH     R0,[R4, #+0]
    921            }
    922          }
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    923          
    924          /**
    925            * @brief  Transmit the SPIx CRC value.
    926            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    927            * @retval None
    928            */

   \                                 In section .text, align 2, keep-with-next
    929          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    930          {
   \                     SPI_TransmitCRC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    931            /* Check the parameters */
    932            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable17  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD015             BEQ.N    ??SPI_TransmitCRC_0
   \   0000000A   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD012             BEQ.N    ??SPI_TransmitCRC_0
   \   00000010   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00F             BEQ.N    ??SPI_TransmitCRC_0
   \   00000016   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40013400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00C             BEQ.N    ??SPI_TransmitCRC_0
   \   0000001C   0x....             LDR.N    R0,??DataTable18  ;; 0x40015000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD009             BEQ.N    ??SPI_TransmitCRC_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD005             BEQ.N    ??SPI_TransmitCRC_0
   \   0000002A   0xF44F 0x7169      MOV      R1,#+932
   \   0000002E   0x.... 0x....      ADR.W    R0,?_0
   \   00000032   0x.... 0x....      BL       assert_failed
    933            
    934            /* Enable the selected SPI CRC transmission */
    935            SPIx->CR1 |= SPI_CR1_CRCNEXT;
   \                     ??SPI_TransmitCRC_0: (+1)
   \   00000036   0x8820             LDRH     R0,[R4, #+0]
   \   00000038   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   0000003C   0x8020             STRH     R0,[R4, #+0]
    936          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    937          
    938          /**
    939            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    940            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    941            * @param  SPI_CRC: specifies the CRC register to be read.
    942            *          This parameter can be one of the following values:
    943            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    944            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    945            * @retval The selected CRC register value..
    946            */

   \                                 In section .text, align 2, keep-with-next
    947          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    948          {
   \                     SPI_GetCRC: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    949            uint16_t crcreg = 0;
    950            /* Check the parameters */
    951            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable17  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD015             BEQ.N    ??SPI_GetCRC_0
   \   0000000C   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD012             BEQ.N    ??SPI_GetCRC_0
   \   00000012   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00F             BEQ.N    ??SPI_GetCRC_0
   \   00000018   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40013400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD00C             BEQ.N    ??SPI_GetCRC_0
   \   0000001E   0x....             LDR.N    R0,??DataTable18  ;; 0x40015000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD009             BEQ.N    ??SPI_GetCRC_0
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD005             BEQ.N    ??SPI_GetCRC_0
   \   0000002C   0xF240 0x31B7      MOVW     R1,#+951
   \   00000030   0x.... 0x....      ADR.W    R0,?_0
   \   00000034   0x.... 0x....      BL       assert_failed
    952            assert_param(IS_SPI_CRC(SPI_CRC));
   \                     ??SPI_GetCRC_0: (+1)
   \   00000038   0x002E             MOVS     R6,R5
   \   0000003A   0xD007             BEQ.N    ??SPI_GetCRC_1
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD005             BEQ.N    ??SPI_GetCRC_1
   \   00000040   0xF44F 0x716E      MOV      R1,#+952
   \   00000044   0x.... 0x....      ADR.W    R0,?_0
   \   00000048   0x.... 0x....      BL       assert_failed
    953            if (SPI_CRC != SPI_CRC_Rx)
   \                     ??SPI_GetCRC_1: (+1)
   \   0000004C   0x2E01             CMP      R6,#+1
   \   0000004E   0xD001             BEQ.N    ??SPI_GetCRC_2
    954            {
    955              /* Get the Tx CRC register */
    956              crcreg = SPIx->TXCRCR;
   \   00000050   0x8B20             LDRH     R0,[R4, #+24]
   \   00000052   0xBD70             POP      {R4-R6,PC}
    957            }
    958            else
    959            {
    960              /* Get the Rx CRC register */
    961              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_2: (+1)
   \   00000054   0x8AA0             LDRH     R0,[R4, #+20]
    962            }
    963            /* Return the selected CRC register */
    964            return crcreg;
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    965          }
    966          
    967          /**
    968            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    969            * @param  SPIx: where x can be 1, 2, 3, 4, 5 or 6 to select the SPI peripheral.
    970            * @retval The CRC Polynomial register value.
    971            */

   \                                 In section .text, align 2, keep-with-next
    972          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    973          {
   \                     SPI_GetCRCPolynomial: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    974            /* Check the parameters */
    975            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   \   00000004   0x....             LDR.N    R0,??DataTable17  ;; 0x40013000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD015             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   0000000A   0x....             LDR.N    R0,??DataTable17_1  ;; 0x40003800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD012             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   00000010   0x....             LDR.N    R0,??DataTable17_2  ;; 0x40003c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00F             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   00000016   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40013400
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD00C             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   0000001C   0x....             LDR.N    R0,??DataTable18  ;; 0x40015000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD009             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable23  ;; 0x40015400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD005             BEQ.N    ??SPI_GetCRCPolynomial_0
   \   0000002A   0xF240 0x31CF      MOVW     R1,#+975
   \   0000002E   0x.... 0x....      ADR.W    R0,?_0
   \   00000032   0x.... 0x....      BL       assert_failed
    976            
    977            /* Return the CRC polynomial register */
    978            return SPIx->CRCPR;
   \                     ??SPI_GetCRCPolynomial_0: (+1)
   \   00000036   0x8A20             LDRH     R0,[R4, #+16]
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    979          }
    980          
    981          /**
    982            * @}
    983            */
    984          
    985          /** @defgroup SPI_Group4 DMA transfers management functions
    986           *  @brief   DMA transfers management functions
    987            *
    988          @verbatim   
    989           ===============================================================================
    990                             ##### DMA transfers management functions #####
    991           ===============================================================================  
    992          
    993          @endverbatim
    994            * @{
    995            */
    996          
    997          /**
    998            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    999            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1000            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1001            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
   1002            *          This parameter can be any combination of the following values:
   1003            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
   1004            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
   1005            * @param  NewState: new state of the selected SPI DMA transfer request.
   1006            *          This parameter can be: ENABLE or DISABLE.
   1007            * @retval None
   1008            */

   \                                 In section .text, align 2, keep-with-next
   1009          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
   1010          {
   \                     SPI_I2S_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1011            /* Check the parameters */
   1012            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable23_3  ;; 0x40013000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD01A             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000010   0x....             LDR.N    R0,??DataTable23_4  ;; 0x40003800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD017             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000016   0x....             LDR.N    R0,??DataTable23_5  ;; 0x40003c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD014             BEQ.N    ??SPI_I2S_DMACmd_0
   \   0000001C   0x....             LDR.N    R0,??DataTable23_6  ;; 0x40013400
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD011             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000022   0x....             LDR.N    R0,??DataTable18  ;; 0x40015000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00E             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000028   0x....             LDR.N    R0,??DataTable22  ;; 0x40015400
   \   0000002A   0x4284             CMP      R4,R0
   \   0000002C   0xD00B             BEQ.N    ??SPI_I2S_DMACmd_0
   \   0000002E   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40003400
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD008             BEQ.N    ??SPI_I2S_DMACmd_0
   \   00000034   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000038   0xD005             BEQ.N    ??SPI_I2S_DMACmd_0
   \   0000003A   0xF44F 0x717D      MOV      R1,#+1012
   \   0000003E   0x.... 0x....      ADR.W    R0,?_0
   \   00000042   0x.... 0x....      BL       assert_failed
   1013            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_I2S_DMACmd_0: (+1)
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD007             BEQ.N    ??SPI_I2S_DMACmd_1
   \   0000004A   0x2E01             CMP      R6,#+1
   \   0000004C   0xD005             BEQ.N    ??SPI_I2S_DMACmd_1
   \   0000004E   0xF240 0x31F5      MOVW     R1,#+1013
   \   00000052   0x.... 0x....      ADR.W    R0,?_0
   \   00000056   0x.... 0x....      BL       assert_failed
   1014            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
   \                     ??SPI_I2S_DMACmd_1: (+1)
   \   0000005A   0xF64F 0x70FC      MOVW     R0,#+65532
   \   0000005E   0x4205             TST      R5,R0
   \   00000060   0xD101             BNE.N    ??SPI_I2S_DMACmd_2
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD105             BNE.N    ??SPI_I2S_DMACmd_3
   \                     ??SPI_I2S_DMACmd_2: (+1)
   \   00000066   0xF240 0x31F6      MOVW     R1,#+1014
   \   0000006A   0x.... 0x....      ADR.W    R0,?_0
   \   0000006E   0x.... 0x....      BL       assert_failed
   1015          
   1016            if (NewState != DISABLE)
   \                     ??SPI_I2S_DMACmd_3: (+1)
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0x88A0             LDRH     R0,[R4, #+4]
   \   00000076   0xD002             BEQ.N    ??SPI_I2S_DMACmd_4
   1017            {
   1018              /* Enable the selected SPI DMA requests */
   1019              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000078   0x4328             ORRS     R0,R5,R0
   \   0000007A   0x80A0             STRH     R0,[R4, #+4]
   \   0000007C   0xBD70             POP      {R4-R6,PC}
   1020            }
   1021            else
   1022            {
   1023              /* Disable the selected SPI DMA requests */
   1024              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_4: (+1)
   \   0000007E   0x43A8             BICS     R0,R0,R5
   \   00000080   0x80A0             STRH     R0,[R4, #+4]
   1025            }
   1026          }
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
   1027          
   1028          /**
   1029            * @}
   1030            */
   1031          
   1032          /** @defgroup SPI_Group5 Interrupts and flags management functions
   1033           *  @brief   Interrupts and flags management functions
   1034            *
   1035          @verbatim   
   1036           ===============================================================================
   1037                      ##### Interrupts and flags management functions #####
   1038           ===============================================================================  
   1039           
   1040           [..] This section provides a set of functions allowing to configure the SPI Interrupts 
   1041                sources and check or clear the flags or pending bits status.
   1042                The user should identify which mode will be used in his application to manage 
   1043                the communication: Polling mode, Interrupt mode or DMA mode. 
   1044              
   1045           *** Polling Mode ***
   1046           ====================
   1047          [..] In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
   1048            (#) SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
   1049            (#) SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
   1050            (#) SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
   1051            (#) SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
   1052            (#) SPI_FLAG_MODF : to indicate if a Mode Fault error occur
   1053            (#) SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
   1054            (#) I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
   1055            (#) I2S_FLAG_UDR: to indicate an Underrun error occurs.
   1056            (#) I2S_FLAG_CHSIDE: to indicate Channel Side.
   1057          
   1058            (@) Do not use the BSY flag to handle each data transmission or reception. It is
   1059                better to use the TXE and RXNE flags instead.
   1060          
   1061           [..] In this Mode it is advised to use the following functions:
   1062             (+) FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1063             (+) void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1064          
   1065           *** Interrupt Mode ***
   1066           ======================
   1067           [..] In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
   1068                and 7 pending bits: 
   1069             (+) Pending Bits:
   1070                 (##) SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
   1071                 (##) SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
   1072                 (##) SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
   1073                 (##) SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
   1074                 (##) SPI_I2S_IT_OVR : to indicate if an Overrun error occur
   1075                 (##) I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
   1076                 (##) I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).
   1077          
   1078             (+) Interrupt Source:
   1079                 (##) SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
   1080                      interrupt.  
   1081                 (##) SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1082                      empty interrupt.
   1083                 (##) SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
   1084          
   1085           [..] In this Mode it is advised to use the following functions:
   1086             (+) void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   1087             (+) ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1088             (+) void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1089          
   1090           *** DMA Mode ***
   1091           ================
   1092           [..] In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
   1093             (#) SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1094             (#) SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1095          
   1096           [..] In this Mode it is advised to use the following function:
   1097             (+) void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState 
   1098                 NewState);
   1099          
   1100          @endverbatim
   1101            * @{
   1102            */
   1103          
   1104          /**
   1105            * @brief  Enables or disables the specified SPI/I2S interrupts.
   1106            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1107            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1108            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
   1109            *          This parameter can be one of the following values:
   1110            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
   1111            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
   1112            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
   1113            * @param  NewState: new state of the specified SPI interrupt.
   1114            *          This parameter can be: ENABLE or DISABLE.
   1115            * @retval None
   1116            */

   \                                 In section .text, align 2, keep-with-next
   1117          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
   1118          {
   \                     SPI_I2S_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4615             MOV      R5,R2
   1119            uint16_t itpos = 0, itmask = 0 ;
   1120            
   1121            /* Check the parameters */
   1122            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable23_3  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD01A             BEQ.N    ??SPI_I2S_ITConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable23_4  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD017             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable23_5  ;; 0x40003c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD014             BEQ.N    ??SPI_I2S_ITConfig_0
   \   0000001A   0x....             LDR.N    R0,??DataTable23_6  ;; 0x40013400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD011             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000020   0x....             LDR.N    R0,??DataTable23_7  ;; 0x40015000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00E             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000026   0x....             LDR.N    R0,??DataTable22  ;; 0x40015400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD00B             BEQ.N    ??SPI_I2S_ITConfig_0
   \   0000002C   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40003400
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD008             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000032   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000036   0xD005             BEQ.N    ??SPI_I2S_ITConfig_0
   \   00000038   0xF240 0x4162      MOVW     R1,#+1122
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
   1123            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??SPI_I2S_ITConfig_0: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD007             BEQ.N    ??SPI_I2S_ITConfig_1
   \   00000048   0x2D01             CMP      R5,#+1
   \   0000004A   0xD005             BEQ.N    ??SPI_I2S_ITConfig_1
   \   0000004C   0xF240 0x4163      MOVW     R1,#+1123
   \   00000050   0x.... 0x....      ADR.W    R0,?_0
   \   00000054   0x.... 0x....      BL       assert_failed
   1124            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_ITConfig_1: (+1)
   \   00000058   0x4630             MOV      R0,R6
   \   0000005A   0x2871             CMP      R0,#+113
   \   0000005C   0xD009             BEQ.N    ??SPI_I2S_ITConfig_2
   \   0000005E   0x2860             CMP      R0,#+96
   \   00000060   0xD007             BEQ.N    ??SPI_I2S_ITConfig_2
   \   00000062   0x2850             CMP      R0,#+80
   \   00000064   0xD005             BEQ.N    ??SPI_I2S_ITConfig_2
   \   00000066   0xF240 0x4164      MOVW     R1,#+1124
   \   0000006A   0x.... 0x....      ADR.W    R0,?_0
   \   0000006E   0x.... 0x....      BL       assert_failed
   1125          
   1126            /* Get the SPI IT index */
   1127            itpos = SPI_I2S_IT >> 4;
   1128          
   1129            /* Set the IT mask */
   1130            itmask = (uint16_t)1 << (uint16_t)itpos;
   \                     ??SPI_I2S_ITConfig_2: (+1)
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x0931             LSRS     R1,R6,#+4
   \   00000076   0x4088             LSLS     R0,R0,R1
   \   00000078   0xB280             UXTH     R0,R0
   1131          
   1132            if (NewState != DISABLE)
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0x88A1             LDRH     R1,[R4, #+4]
   \   0000007E   0xD002             BEQ.N    ??SPI_I2S_ITConfig_3
   1133            {
   1134              /* Enable the selected SPI interrupt */
   1135              SPIx->CR2 |= itmask;
   \   00000080   0x4308             ORRS     R0,R0,R1
   \   00000082   0x80A0             STRH     R0,[R4, #+4]
   \   00000084   0xBD70             POP      {R4-R6,PC}
   1136            }
   1137            else
   1138            {
   1139              /* Disable the selected SPI interrupt */
   1140              SPIx->CR2 &= (uint16_t)~itmask;
   \                     ??SPI_I2S_ITConfig_3: (+1)
   \   00000086   0xEA21 0x0000      BIC      R0,R1,R0
   \   0000008A   0x80A0             STRH     R0,[R4, #+4]
   1141            }
   1142          }
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
   1143          
   1144          /**
   1145            * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
   1146            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1147            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1148            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1149            *          This parameter can be one of the following values:
   1150            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1151            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1152            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1153            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1154            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1155            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1156            *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
   1157            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1158            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
   1159            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1160            */

   \                                 In section .text, align 2, keep-with-next
   1161          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1162          {
   \                     SPI_I2S_GetFlagStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1163            FlagStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1164            /* Check the parameters */
   1165            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable23_3  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD01A             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable23_4  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD017             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable23_5  ;; 0x40003c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD014             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable23_6  ;; 0x40013400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD011             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000020   0x....             LDR.N    R0,??DataTable23_7  ;; 0x40015000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00E             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000026   0x....             LDR.N    R0,??DataTable22  ;; 0x40015400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD00B             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   0000002C   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40003400
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD008             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000032   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000036   0xD005             BEQ.N    ??SPI_I2S_GetFlagStatus_0
   \   00000038   0xF240 0x418D      MOVW     R1,#+1165
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
   1166            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   \                     ??SPI_I2S_GetFlagStatus_0: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x2880             CMP      R0,#+128
   \   00000048   0xD016             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000004A   0x2840             CMP      R0,#+64
   \   0000004C   0xD014             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000004E   0x2820             CMP      R0,#+32
   \   00000050   0xD012             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000052   0x2810             CMP      R0,#+16
   \   00000054   0xD010             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000056   0x2808             CMP      R0,#+8
   \   00000058   0xD00E             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000005A   0x2804             CMP      R0,#+4
   \   0000005C   0xD00C             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xD00A             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD008             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   00000066   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000006A   0xD005             BEQ.N    ??SPI_I2S_GetFlagStatus_1
   \   0000006C   0xF240 0x418E      MOVW     R1,#+1166
   \   00000070   0x.... 0x....      ADR.W    R0,?_0
   \   00000074   0x.... 0x....      BL       assert_failed
   1167            
   1168            /* Check the status of the specified SPI flag */
   1169            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   \                     ??SPI_I2S_GetFlagStatus_1: (+1)
   \   00000078   0x8920             LDRH     R0,[R4, #+8]
   \   0000007A   0x4228             TST      R0,R5
   \   0000007C   0xD000             BEQ.N    ??SPI_I2S_GetFlagStatus_2
   1170            {
   1171              /* SPI_I2S_FLAG is set */
   1172              bitstatus = SET;
   \   0000007E   0x2601             MOVS     R6,#+1
   1173            }
   1174            else
   1175            {
   1176              /* SPI_I2S_FLAG is reset */
   1177              bitstatus = RESET;
   1178            }
   1179            /* Return the SPI_I2S_FLAG status */
   1180            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_2: (+1)
   \   00000080   0x4630             MOV      R0,R6
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
   1181          }
   1182          
   1183          /**
   1184            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1185            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1186            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode. 
   1187            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1188            *          This function clears only CRCERR flag.
   1189            *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
   1190            *  
   1191            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1192            *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
   1193            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1194            * @note   UDR (UnderRun error) flag is cleared by a read operation to 
   1195            *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
   1196            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1197            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
   1198            *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1199            *  
   1200            * @retval None
   1201            */

   \                                 In section .text, align 2, keep-with-next
   1202          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1203          {
   \                     SPI_I2S_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1204            /* Check the parameters */
   1205            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable23_3  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD01A             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable23_4  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD017             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable23_5  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000018   0x....             LDR.N    R0,??DataTable23_6  ;; 0x40013400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   0000001E   0x....             LDR.N    R0,??DataTable23_7  ;; 0x40015000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00E             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000024   0x....             LDR.N    R0,??DataTable22  ;; 0x40015400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00B             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   0000002A   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40003400
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000030   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000034   0xD005             BEQ.N    ??SPI_I2S_ClearFlag_0
   \   00000036   0xF240 0x41B5      MOVW     R1,#+1205
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
   1206            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
   \                     ??SPI_I2S_ClearFlag_0: (+1)
   \   00000042   0x2D10             CMP      R5,#+16
   \   00000044   0xD005             BEQ.N    ??SPI_I2S_ClearFlag_1
   \   00000046   0xF240 0x41B6      MOVW     R1,#+1206
   \   0000004A   0x.... 0x....      ADR.W    R0,?_0
   \   0000004E   0x.... 0x....      BL       assert_failed
   1207              
   1208            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1209            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   \                     ??SPI_I2S_ClearFlag_1: (+1)
   \   00000052   0x43E8             MVNS     R0,R5
   \   00000054   0x8120             STRH     R0,[R4, #+8]
   1210          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1211          
   1212          /**
   1213            * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
   1214            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1215            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1216            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1217            *          This parameter can be one of the following values:
   1218            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1219            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1220            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1221            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1222            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1223            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1224            *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
   1225            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1226            */

   \                                 In section .text, align 2, keep-with-next
   1227          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1228          {
   \                     SPI_I2S_GetITStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1229            ITStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1230            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   1231          
   1232            /* Check the parameters */
   1233            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000008   0x....             LDR.N    R0,??DataTable23_3  ;; 0x40013000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD01A             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable23_4  ;; 0x40003800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD017             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable23_5  ;; 0x40003c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD014             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable23_6  ;; 0x40013400
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD011             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000020   0x....             LDR.N    R0,??DataTable23_7  ;; 0x40015000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD00E             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000026   0x....             LDR.N    R0,??DataTable22  ;; 0x40015400
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD00B             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   0000002C   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40003400
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD008             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000032   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000036   0xD005             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000038   0xF240 0x41D1      MOVW     R1,#+1233
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
   1234            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_GetITStatus_0: (+1)
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x2860             CMP      R0,#+96
   \   00000048   0xD011             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   0000004A   0x2871             CMP      R0,#+113
   \   0000004C   0xD00F             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   0000004E   0x2854             CMP      R0,#+84
   \   00000050   0xD00D             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000052   0x2855             CMP      R0,#+85
   \   00000054   0xD00B             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000056   0x2856             CMP      R0,#+86
   \   00000058   0xD009             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   0000005A   0x2853             CMP      R0,#+83
   \   0000005C   0xD007             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   0000005E   0x2858             CMP      R0,#+88
   \   00000060   0xD005             BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000062   0xF240 0x41D2      MOVW     R1,#+1234
   \   00000066   0x.... 0x....      ADR.W    R0,?_0
   \   0000006A   0x.... 0x....      BL       assert_failed
   1235          
   1236            /* Get the SPI_I2S_IT index */
   1237            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1238          
   1239            /* Get the SPI_I2S_IT IT mask */
   1240            itmask = SPI_I2S_IT >> 4;
   1241          
   1242            /* Set the IT mask */
   1243            itmask = 0x01 << itmask;
   1244          
   1245            /* Get the SPI_I2S_IT enable bit status */
   1246            enablestatus = (SPIx->CR2 & itmask) ;
   \                     ??SPI_I2S_GetITStatus_1: (+1)
   \   0000006E   0x88A0             LDRH     R0,[R4, #+4]
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x092A             LSRS     R2,R5,#+4
   \   00000074   0x4091             LSLS     R1,R1,R2
   \   00000076   0x4008             ANDS     R0,R1,R0
   1247          
   1248            /* Check the status of the specified SPI interrupt */
   1249            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   \   00000078   0x8921             LDRH     R1,[R4, #+8]
   \   0000007A   0xF005 0x020F      AND      R2,R5,#0xF
   \   0000007E   0x460B             MOV      R3,R1
   \   00000080   0x40D3             LSRS     R3,R3,R2
   \   00000082   0x07D9             LSLS     R1,R3,#+31
   \   00000084   0xD502             BPL.N    ??SPI_I2S_GetITStatus_2
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD000             BEQ.N    ??SPI_I2S_GetITStatus_2
   1250            {
   1251              /* SPI_I2S_IT is set */
   1252              bitstatus = SET;
   \   0000008A   0x2601             MOVS     R6,#+1
   1253            }
   1254            else
   1255            {
   1256              /* SPI_I2S_IT is reset */
   1257              bitstatus = RESET;
   1258            }
   1259            /* Return the SPI_I2S_IT status */
   1260            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_2: (+1)
   \   0000008C   0x4630             MOV      R0,R6
   \   0000008E   0xBD70             POP      {R4-R6,PC}       ;; return
   1261          }
   1262          
   1263          /**
   1264            * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
   1265            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2, 3, 4, 5 or 6 
   1266            *         in SPI mode or 2 or 3 in I2S mode or I2Sxext for I2S full duplex mode.  
   1267            * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
   1268            *         This function clears only CRCERR interrupt pending bit.   
   1269            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1270            *   
   1271            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
   1272            *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
   1273            *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
   1274            * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
   1275            *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
   1276            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
   1277            *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
   1278            *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
   1279            *          the SPI).
   1280            * @retval None
   1281            */

   \                                 In section .text, align 2, keep-with-next
   1282          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1283          {
   \                     SPI_I2S_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1284            uint16_t itpos = 0;
   1285            /* Check the parameters */
   1286            assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
   \   00000006   0x....             LDR.N    R0,??DataTable23_3  ;; 0x40013000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD01A             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   0000000C   0x....             LDR.N    R0,??DataTable23_4  ;; 0x40003800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD017             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000012   0x....             LDR.N    R0,??DataTable23_5  ;; 0x40003c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD014             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000018   0x....             LDR.N    R0,??DataTable23_6  ;; 0x40013400
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD011             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   0000001E   0x....             LDR.N    R0,??DataTable23_7  ;; 0x40015000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD00E             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000024   0x....             LDR.N    R0,??DataTable23  ;; 0x40015400
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD00B             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   0000002A   0x....             LDR.N    R0,??DataTable23_2  ;; 0x40003400
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD008             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000030   0xF1B4 0x2F40      CMP      R4,#+1073758208
   \   00000034   0xD005             BEQ.N    ??SPI_I2S_ClearITPendingBit_0
   \   00000036   0xF240 0x5106      MOVW     R1,#+1286
   \   0000003A   0x.... 0x....      ADR.W    R0,?_0
   \   0000003E   0x.... 0x....      BL       assert_failed
   1287            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
   \                     ??SPI_I2S_ClearITPendingBit_0: (+1)
   \   00000042   0x2D54             CMP      R5,#+84
   \   00000044   0xD005             BEQ.N    ??SPI_I2S_ClearITPendingBit_1
   \   00000046   0xF240 0x5107      MOVW     R1,#+1287
   \   0000004A   0x.... 0x....      ADR.W    R0,?_0
   \   0000004E   0x.... 0x....      BL       assert_failed
   1288          
   1289            /* Get the SPI_I2S IT index */
   1290            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1291          
   1292            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
   1293            SPIx->SR = (uint16_t)~itpos;
   \                     ??SPI_I2S_ClearITPendingBit_1: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF005 0x010F      AND      R1,R5,#0xF
   \   00000058   0x4088             LSLS     R0,R0,R1
   \   0000005A   0xB280             UXTH     R0,R0
   \   0000005C   0x43C0             MVNS     R0,R0
   \   0000005E   0x8120             STRH     R0,[R4, #+8]
   1294          }
   \   00000060   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40015000         DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x0002CEC1         DC32     0x2cec1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x40015400         DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x40015400         DC32     0x40015400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x40003400         DC32     0x40003400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x40013400         DC32     0x40013400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x40015000         DC32     0x40015000

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x73 0x70          DC8 73H, 70H, 69H, 2EH, 63H, 0
   \              0x69 0x2E    
   \              0x63 0x00    
   \   00000066   0x00 0x00          DC8 0, 0
   1295          
   1296          /**
   1297            * @}
   1298            */
   1299          
   1300          /**
   1301            * @}
   1302            */ 
   1303          
   1304          /**
   1305            * @}
   1306            */ 
   1307          
   1308          /**
   1309            * @}
   1310            */ 
   1311          
   1312          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2S_Cmd
        16   -> assert_failed
      16   I2S_FullDuplexConfig
        16   -> assert_failed
      24   I2S_Init
        24   -> assert_failed
       0   I2S_StructInit
      16   SPI_BiDirectionalLineConfig
        16   -> assert_failed
      16   SPI_CalculateCRC
        16   -> assert_failed
      16   SPI_Cmd
        16   -> assert_failed
      16   SPI_DataSizeConfig
        16   -> assert_failed
      16   SPI_GetCRC
        16   -> assert_failed
       8   SPI_GetCRCPolynomial
         8   -> assert_failed
      16   SPI_I2S_ClearFlag
        16   -> assert_failed
      16   SPI_I2S_ClearITPendingBit
        16   -> assert_failed
      16   SPI_I2S_DMACmd
        16   -> assert_failed
      16   SPI_I2S_DeInit
        16   -> RCC_APB1PeriphResetCmd
        16   -> RCC_APB2PeriphResetCmd
        16   -> assert_failed
      16   SPI_I2S_GetFlagStatus
        16   -> assert_failed
      16   SPI_I2S_GetITStatus
        16   -> assert_failed
      16   SPI_I2S_ITConfig
        16   -> assert_failed
       8   SPI_I2S_ReceiveData
         8   -> assert_failed
      16   SPI_I2S_SendData
        16   -> assert_failed
      16   SPI_Init
        16   -> assert_failed
      16   SPI_NSSInternalSoftwareConfig
        16   -> assert_failed
      16   SPI_SSOutputCmd
        16   -> assert_failed
       0   SPI_StructInit
      16   SPI_TIModeCmd
        16   -> assert_failed
       8   SPI_TransmitCRC
         8   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
     104  ?_0
      92  I2S_Cmd
     210  I2S_FullDuplexConfig
     406  I2S_Init
      20  I2S_StructInit
     114  SPI_BiDirectionalLineConfig
     100  SPI_CalculateCRC
     110  SPI_Cmd
     106  SPI_DataSizeConfig
      88  SPI_GetCRC
      58  SPI_GetCRCPolynomial
      88  SPI_I2S_ClearFlag
      98  SPI_I2S_ClearITPendingBit
     132  SPI_I2S_DMACmd
     252  SPI_I2S_DeInit
     132  SPI_I2S_GetFlagStatus
     144  SPI_I2S_GetITStatus
     142  SPI_I2S_ITConfig
      72  SPI_I2S_ReceiveData
      74  SPI_I2S_SendData
     344  SPI_Init
     112  SPI_NSSInternalSoftwareConfig
     110  SPI_SSOutputCmd
      24  SPI_StructInit
     102  SPI_TIModeCmd
      64  SPI_TransmitCRC

 
 3 366 bytes in section .text
 
 3 366 bytes of CODE memory

Errors: none
Warnings: none
