###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        17/Oct/2018  09:51:20
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TLcd.cpp
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TLcd.cpp -D IAR_ARM_CM4
#        -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D HAVE_CONFIG_H -D
#        SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D STENDBUY_NOT_USE
#        -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO -D
#        BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\TLcd.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\TLcd.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\TLcd.cpp
      1          /************************************************************************************/
      2          /* Title:		LCD lowlevel control 												*/
      3          /* Author:		Cyber Genius														*/
      4          /* Version:		1.0																	*/
      5          /* Date:		11.07.2012															*/
      6          /************************************************************************************/
      7          /*																					*/
      8          /************************************************************************************/
      9          
     10          #include "TLcd.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void __delay_cycles(int)
   \                     _Z14__delay_cyclesi: (+1)
   \   00000000   0xB401             PUSH     {R0}
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE001             B.N      ??__delay_cycles_0
   \                     ??__delay_cycles_1: (+1)
   \   00000006   0xBF00             Nop      
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \                     ??__delay_cycles_0: (+1)
   \   0000000A   0x9900             LDR      R1,[SP, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xDBFA             BLT.N    ??__delay_cycles_1
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void TLcd::WriteCmd(uint8_t, uint8_t)
   \                     _ZN4TLcd8WriteCmdEhh: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x4A09             LDR.N    R2,??WriteCmd_0  ;; 0x40020014
   \   00000004   0xF44F 0x7300      MOV      R3,#+512
   \   00000008   0x80D3             STRH     R3,[R2, #+6]
   \   0000000A   0xF44F 0x5480      MOV      R4,#+4096
   \   0000000E   0x80D4             STRH     R4,[R2, #+6]
   \   00000010   0xF44F 0x6400      MOV      R4,#+2048
   \   00000014   0x80D4             STRH     R4,[R2, #+6]
   \   00000016   0x7010             STRB     R0,[R2, #+0]
   \   00000018   0x8094             STRH     R4,[R2, #+4]
   \   0000001A   0x8093             STRH     R3,[R2, #+4]
   \   0000001C   0x80D4             STRH     R4,[R2, #+6]
   \   0000001E   0x7011             STRB     R1,[R2, #+0]
   \   00000020   0x8094             STRH     R4,[R2, #+4]
   \   00000022   0x8093             STRH     R3,[R2, #+4]
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
   \                     ??WriteCmd_0:
   \   00000028   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4
   \   __interwork __softfp void TLcd::WriteCmd(uint8_t)
   \                     _ZN4TLcd8WriteCmdEh: (+1)
   \   00000000   0x4906             LDR.N    R1,??WriteCmd_1  ;; 0x40020014
   \   00000002   0xF44F 0x7200      MOV      R2,#+512
   \   00000006   0x80CA             STRH     R2,[R1, #+6]
   \   00000008   0xF44F 0x5380      MOV      R3,#+4096
   \   0000000C   0x80CB             STRH     R3,[R1, #+6]
   \   0000000E   0xF44F 0x6300      MOV      R3,#+2048
   \   00000012   0x80CB             STRH     R3,[R1, #+6]
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   \   00000016   0x808B             STRH     R3,[R1, #+4]
   \   00000018   0x808A             STRH     R2,[R1, #+4]
   \   0000001A   0x4770             BX       LR               ;; return
   \                     ??WriteCmd_1:
   \   0000001C   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4
   \   __interwork __softfp void TLcd::WriteData(uint8_t)
   \                     _ZN4TLcd9WriteDataEh: (+1)
   \   00000000   0x4906             LDR.N    R1,??WriteData_0  ;; 0x40020014
   \   00000002   0xF44F 0x7200      MOV      R2,#+512
   \   00000006   0x808A             STRH     R2,[R1, #+4]
   \   00000008   0xF44F 0x5380      MOV      R3,#+4096
   \   0000000C   0x80CB             STRH     R3,[R1, #+6]
   \   0000000E   0xF44F 0x6300      MOV      R3,#+2048
   \   00000012   0x80CB             STRH     R3,[R1, #+6]
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   \   00000016   0x808B             STRH     R3,[R1, #+4]
   \   00000018   0x808A             STRH     R2,[R1, #+4]
   \   0000001A   0x4770             BX       LR               ;; return
   \                     ??WriteData_0:
   \   0000001C   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4
   \   __interwork __softfp void TLcd::WriteData(uint16_t)
   \                     _ZN4TLcd9WriteDataEt: (+1)
   \   00000000   0x4908             LDR.N    R1,??WriteData_1  ;; 0x40020014
   \   00000002   0xF44F 0x7200      MOV      R2,#+512
   \   00000006   0x808A             STRH     R2,[R1, #+4]
   \   00000008   0xF44F 0x5380      MOV      R3,#+4096
   \   0000000C   0x80CB             STRH     R3,[R1, #+6]
   \   0000000E   0xF44F 0x6300      MOV      R3,#+2048
   \   00000012   0x80CB             STRH     R3,[R1, #+6]
   \   00000014   0x7008             STRB     R0,[R1, #+0]
   \   00000016   0x808B             STRH     R3,[R1, #+4]
   \   00000018   0x80CB             STRH     R3,[R1, #+6]
   \   0000001A   0x0A00             LSRS     R0,R0,#+8
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   \   0000001E   0x808B             STRH     R3,[R1, #+4]
   \   00000020   0x808A             STRH     R2,[R1, #+4]
   \   00000022   0x4770             BX       LR               ;; return
   \                     ??WriteData_1:
   \   00000024   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4
   \   __interwork __softfp void TLcd::WriteData(uint32_t)
   \                     _ZN4TLcd9WriteDataEj: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x490D             LDR.N    R1,??WriteData_2  ;; 0x40020014
   \   00000004   0xF44F 0x7200      MOV      R2,#+512
   \   00000008   0x808A             STRH     R2,[R1, #+4]
   \   0000000A   0xF44F 0x5380      MOV      R3,#+4096
   \   0000000E   0x80CB             STRH     R3,[R1, #+6]
   \   00000010   0xF44F 0x6300      MOV      R3,#+2048
   \   00000014   0x80CB             STRH     R3,[R1, #+6]
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   \   00000018   0x808B             STRH     R3,[R1, #+4]
   \   0000001A   0x80CB             STRH     R3,[R1, #+6]
   \   0000001C   0x0A04             LSRS     R4,R0,#+8
   \   0000001E   0x700C             STRB     R4,[R1, #+0]
   \   00000020   0x808B             STRH     R3,[R1, #+4]
   \   00000022   0x80CB             STRH     R3,[R1, #+6]
   \   00000024   0x0C04             LSRS     R4,R0,#+16
   \   00000026   0x700C             STRB     R4,[R1, #+0]
   \   00000028   0x808B             STRH     R3,[R1, #+4]
   \   0000002A   0x80CB             STRH     R3,[R1, #+6]
   \   0000002C   0x0E00             LSRS     R0,R0,#+24
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   \   00000030   0x808B             STRH     R3,[R1, #+4]
   \   00000032   0x808A             STRH     R2,[R1, #+4]
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR               ;; return
   \                     ??WriteData_2:
   \   00000038   0x40020014         DC32     0x40020014
     11          #include "THardware.h"
     12          #include "main.h"
     13          #include "TFlash.h"
     14          #include "TDevice.h"
     15          #include "StnFont.h"
     16          #include "TAppProcessor.h"
     17          /*----------------------------------------------------------------------------------*/
     18          
     19          
     20          
     21          
     22          

   \                                 In section .bss, align 4
     23          uint16_t SysPal[2];
   \                     SysPal:
   \   00000000                      DS8 4
     24          
     25          /*----------------------------------------------------------------------------------*/

   \                                 In section .bss, align 1
     26          bool TLcd::LcdOff = false;
   \                     _ZN4TLcd6LcdOffE:
   \   00000000                      DS8 1
     27          /*----------------------------------------------------------------------------------*/
     28          #ifdef DISPLAY_FSMC
     29          static volatile uint8_t *fsmcRegister;
     30          static volatile uint8_t *fsmcData;
     31          static volatile uint16_t *fsmcData16;
     32          static volatile uint32_t *fsmcData32;
     33          #endif
     34          
     35          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     36          void TLcd::LcdPHYInit( void )
     37          {
   \                     _ZN4TLcd10LcdPHYInitEv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     38          	GPIO_InitTypeDef GPIO_InitStructure;
     39          
     40          	DISP_GPIO_RCC_ENABLE;
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2005             MOVS     R0,#+5
   \   00000008   0x.... 0x....      BL       RCC_AHB1PeriphClockCmd
     41          
     42          	/* RES pin */
     43          	GPIO_ResetBits( DISP_RES_PORT, DISP_RES_PIN );
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40020800
   \   00000010   0x2110             MOVS     R1,#+16
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       GPIO_ResetBits
     44          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xF88D 0x0004      STRB     R0,[SP, #+4]
     45          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     46          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     47          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000024   0xF88D 0x0005      STRB     R0,[SP, #+5]
     48          	GPIO_InitStructure.GPIO_Pin = DISP_RES_PIN;
   \   00000028   0x2010             MOVS     R0,#+16
   \   0000002A   0x9000             STR      R0,[SP, #+0]
     49          	GPIO_Init( DISP_RES_PORT, &GPIO_InitStructure );
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       GPIO_Init
     50          
     51          	/* EN pin */
     52          	LcdEnable( false );
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      BL       _ZN4TLcd9LcdEnableEb
     53          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF88D 0x0004      STRB     R0,[SP, #+4]
     54          //	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
     55          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     56          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     57          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000046   0xF88D 0x0005      STRB     R0,[SP, #+5]
     58          	GPIO_InitStructure.GPIO_Pin = DISP_EN_PIN;
   \   0000004A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000004E   0x9000             STR      R0,[SP, #+0]
     59          	GPIO_Init( DISP_EN_PORT, &GPIO_InitStructure );
   \   00000050   0x.... 0x....      LDR.W    R4,??DataTable16_1  ;; 0x40020000
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       GPIO_Init
     60          
     61          	/* BL pin */
     62          	LcdBL( false );
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      BL       _ZN4TLcd5LcdBLEb
     63          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF88D 0x0004      STRB     R0,[SP, #+4]
     64          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     65          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     66          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   0000006E   0xF88D 0x0005      STRB     R0,[SP, #+5]
     67          	GPIO_InitStructure.GPIO_Pin = DISP_BL_PIN;
   \   00000072   0x2040             MOVS     R0,#+64
   \   00000074   0x9000             STR      R0,[SP, #+0]
     68          	GPIO_Init( DISP_BL_PORT, &GPIO_InitStructure );
   \   00000076   0xA900             ADD      R1,SP,#+0
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       GPIO_Init
     69          
     70          #if defined DISPLAY_GPIO
     71          
     72          	/* RD pin */
     73          	GPIO_SetBits( DISP_RD_PORT, DISP_RD_PIN );
   \   0000007E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       GPIO_SetBits
     74          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0xF88D 0x0004      STRB     R0,[SP, #+4]
     75          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     76          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     77          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000094   0x2003             MOVS     R0,#+3
   \   00000096   0xF88D 0x0005      STRB     R0,[SP, #+5]
     78          	GPIO_InitStructure.GPIO_Pin = DISP_RD_PIN;
   \   0000009A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000009E   0x9000             STR      R0,[SP, #+0]
     79          	GPIO_Init( DISP_RD_PORT, &GPIO_InitStructure );
   \   000000A0   0xA900             ADD      R1,SP,#+0
   \   000000A2   0x4620             MOV      R0,R4
   \   000000A4   0x.... 0x....      BL       GPIO_Init
     80          
     81          	/* WR pin */
     82          	GPIO_SetBits( DISP_WR_PORT, DISP_WR_PIN );
   \   000000A8   0xF44F 0x6100      MOV      R1,#+2048
   \   000000AC   0x4620             MOV      R0,R4
   \   000000AE   0x.... 0x....      BL       GPIO_SetBits
     83          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xF88D 0x0004      STRB     R0,[SP, #+4]
     84          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     85          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     86          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   000000BE   0x2003             MOVS     R0,#+3
   \   000000C0   0xF88D 0x0005      STRB     R0,[SP, #+5]
     87          	GPIO_InitStructure.GPIO_Pin = DISP_WR_PIN;
   \   000000C4   0xF44F 0x6000      MOV      R0,#+2048
   \   000000C8   0x9000             STR      R0,[SP, #+0]
     88          	GPIO_Init( DISP_WR_PORT, &GPIO_InitStructure );
   \   000000CA   0xA900             ADD      R1,SP,#+0
   \   000000CC   0x4620             MOV      R0,R4
   \   000000CE   0x.... 0x....      BL       GPIO_Init
     89          
     90          	/* CS pin */
     91          	GPIO_SetBits( DISP_CS_PORT, DISP_CS_PIN );
   \   000000D2   0xF44F 0x5180      MOV      R1,#+4096
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       GPIO_SetBits
     92          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xF88D 0x0004      STRB     R0,[SP, #+4]
     93          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF8AD 0x0006      STRH     R0,[SP, #+6]
     94          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
     95          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   000000E8   0x2003             MOVS     R0,#+3
   \   000000EA   0xF88D 0x0005      STRB     R0,[SP, #+5]
     96          	GPIO_InitStructure.GPIO_Pin = DISP_CS_PIN;
   \   000000EE   0xF44F 0x5080      MOV      R0,#+4096
   \   000000F2   0x9000             STR      R0,[SP, #+0]
     97          	GPIO_Init( DISP_CS_PORT, &GPIO_InitStructure );
   \   000000F4   0xA900             ADD      R1,SP,#+0
   \   000000F6   0x4620             MOV      R0,R4
   \   000000F8   0x.... 0x....      BL       GPIO_Init
     98          
     99          	/* DC pin */
    100          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0xF88D 0x0004      STRB     R0,[SP, #+4]
    101          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    102          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    103          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000108   0x2003             MOVS     R0,#+3
   \   0000010A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    104          	GPIO_InitStructure.GPIO_Pin = DISP_DC_PIN;
   \   0000010E   0xF44F 0x7000      MOV      R0,#+512
   \   00000112   0x9000             STR      R0,[SP, #+0]
    105          	GPIO_Init( DISP_DC_PORT, &GPIO_InitStructure );
   \   00000114   0xA900             ADD      R1,SP,#+0
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       GPIO_Init
    106          
    107          	/* DATA pins */
    108          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0xF88D 0x0004      STRB     R0,[SP, #+4]
    109          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    110          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    111          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
   \   00000128   0x2003             MOVS     R0,#+3
   \   0000012A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    112          	GPIO_InitStructure.GPIO_Pin = DISP_D0_PIN;
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x9000             STR      R0,[SP, #+0]
    113          	GPIO_Init( DISP_D0_PORT, &GPIO_InitStructure );
   \   00000132   0xA900             ADD      R1,SP,#+0
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       GPIO_Init
    114          	GPIO_InitStructure.GPIO_Pin = DISP_D1_PIN;
   \   0000013A   0x2002             MOVS     R0,#+2
   \   0000013C   0x9000             STR      R0,[SP, #+0]
    115          	GPIO_Init( DISP_D1_PORT, &GPIO_InitStructure );
   \   0000013E   0xA900             ADD      R1,SP,#+0
   \   00000140   0x4620             MOV      R0,R4
   \   00000142   0x.... 0x....      BL       GPIO_Init
    116          	GPIO_InitStructure.GPIO_Pin = DISP_D2_PIN;
   \   00000146   0x2004             MOVS     R0,#+4
   \   00000148   0x9000             STR      R0,[SP, #+0]
    117          	GPIO_Init( DISP_D2_PORT, &GPIO_InitStructure );
   \   0000014A   0xA900             ADD      R1,SP,#+0
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       GPIO_Init
    118          	GPIO_InitStructure.GPIO_Pin = DISP_D3_PIN;
   \   00000152   0x2008             MOVS     R0,#+8
   \   00000154   0x9000             STR      R0,[SP, #+0]
    119          	GPIO_Init( DISP_D3_PORT, &GPIO_InitStructure );
   \   00000156   0xA900             ADD      R1,SP,#+0
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0x.... 0x....      BL       GPIO_Init
    120          	GPIO_InitStructure.GPIO_Pin = DISP_D4_PIN;
   \   0000015E   0x2010             MOVS     R0,#+16
   \   00000160   0x9000             STR      R0,[SP, #+0]
    121          	GPIO_Init( DISP_D4_PORT, &GPIO_InitStructure );
   \   00000162   0xA900             ADD      R1,SP,#+0
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       GPIO_Init
    122          	GPIO_InitStructure.GPIO_Pin = DISP_D5_PIN;
   \   0000016A   0x2020             MOVS     R0,#+32
   \   0000016C   0x9000             STR      R0,[SP, #+0]
    123          	GPIO_Init( DISP_D5_PORT, &GPIO_InitStructure );
   \   0000016E   0xA900             ADD      R1,SP,#+0
   \   00000170   0x4620             MOV      R0,R4
   \   00000172   0x.... 0x....      BL       GPIO_Init
    124          	GPIO_InitStructure.GPIO_Pin = DISP_D6_PIN;
   \   00000176   0x2040             MOVS     R0,#+64
   \   00000178   0x9000             STR      R0,[SP, #+0]
    125          	GPIO_Init( DISP_D6_PORT, &GPIO_InitStructure );
   \   0000017A   0xA900             ADD      R1,SP,#+0
   \   0000017C   0x4620             MOV      R0,R4
   \   0000017E   0x.... 0x....      BL       GPIO_Init
    126          	GPIO_InitStructure.GPIO_Pin = DISP_D7_PIN;
   \   00000182   0x2080             MOVS     R0,#+128
   \   00000184   0x9000             STR      R0,[SP, #+0]
    127          	GPIO_Init( DISP_D7_PORT, &GPIO_InitStructure );
   \   00000186   0xA900             ADD      R1,SP,#+0
   \   00000188   0x4620             MOV      R0,R4
   \   0000018A   0x.... 0x....      BL       GPIO_Init
    128          
    129          #elif defined DISPLAY_FSMC
    130          
    131          	/* RD pin */
    132          	GPIO_SetBits( DISP_RD_PORT, DISP_RD_PIN );
    133          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    134          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    135          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    136          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    137          	GPIO_InitStructure.GPIO_Pin = DISP_RD_PIN;
    138          	GPIO_Init( DISP_RD_PORT, &GPIO_InitStructure );
    139          
    140          	/* WR pin */
    141          	GPIO_SetBits( DISP_WR_PORT, DISP_WR_PIN );
    142          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    143          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    144          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    145          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    146          	GPIO_InitStructure.GPIO_Pin = DISP_WR_PIN;
    147          	GPIO_Init( DISP_WR_PORT, &GPIO_InitStructure );
    148          
    149          	/* CS pin */
    150          	GPIO_SetBits( DISP_CS_PORT, DISP_CS_PIN );
    151          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    152          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    153          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    154          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    155          	GPIO_InitStructure.GPIO_Pin = DISP_CS_PIN;
    156          	GPIO_Init( DISP_CS_PORT, &GPIO_InitStructure );
    157          
    158          	/* DC pin */
    159          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    160          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    161          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    162          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    163          	GPIO_InitStructure.GPIO_Pin = DISP_DC_PIN;
    164          	GPIO_Init( DISP_DC_PORT, &GPIO_InitStructure );
    165          
    166          	/* DATA pins */
    167          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    168          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    169          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    170          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    171          	GPIO_InitStructure.GPIO_Pin = DISP_D0_PIN;
    172          	GPIO_Init( DISP_D0_PORT, &GPIO_InitStructure );
    173          	GPIO_InitStructure.GPIO_Pin = DISP_D1_PIN;
    174          	GPIO_Init( DISP_D1_PORT, &GPIO_InitStructure );
    175          	GPIO_InitStructure.GPIO_Pin = DISP_D2_PIN;
    176          	GPIO_Init( DISP_D2_PORT, &GPIO_InitStructure );
    177          	GPIO_InitStructure.GPIO_Pin = DISP_D3_PIN;
    178          	GPIO_Init( DISP_D3_PORT, &GPIO_InitStructure );
    179          	GPIO_InitStructure.GPIO_Pin = DISP_D4_PIN;
    180          	GPIO_Init( DISP_D4_PORT, &GPIO_InitStructure );
    181          	GPIO_InitStructure.GPIO_Pin = DISP_D5_PIN;
    182          	GPIO_Init( DISP_D5_PORT, &GPIO_InitStructure );
    183          	GPIO_InitStructure.GPIO_Pin = DISP_D6_PIN;
    184          	GPIO_Init( DISP_D6_PORT, &GPIO_InitStructure );
    185          	GPIO_InitStructure.GPIO_Pin = DISP_D7_PIN;
    186          	GPIO_Init( DISP_D7_PORT, &GPIO_InitStructure );
    187          
    188          	/* FSMC Setup */
    189          	FSMC_NORSRAMTimingInitTypeDef   FSMC_TimingStructure;
    190          	FSMC_NORSRAMInitTypeDef		FSMC_InitStructure;
    191          
    192          	DISP_FSMC_RCC_ENABLE;
    193          
    194          	FSMC_TimingStructure.FSMC_AddressSetupTime = 10;
    195          	FSMC_TimingStructure.FSMC_DataSetupTime = 10;
    196          	FSMC_TimingStructure.FSMC_AddressHoldTime = 0x00;
    197          	FSMC_TimingStructure.FSMC_BusTurnAroundDuration = 0x00;
    198          	FSMC_TimingStructure.FSMC_DataLatency = 0x00;
    199          	FSMC_TimingStructure.FSMC_AccessMode = FSMC_AccessMode_A;
    200          	FSMC_TimingStructure.FSMC_CLKDivision=1;
    201          
    202          	FSMC_InitStructure.FSMC_Bank=FSMC_Bank1_NORSRAM1;
    203          	FSMC_InitStructure.FSMC_DataAddressMux=FSMC_DataAddressMux_Disable;
    204          	FSMC_InitStructure.FSMC_MemoryType=FSMC_MemoryType_SRAM;
    205          	FSMC_InitStructure.FSMC_MemoryDataWidth=FSMC_MemoryDataWidth_8b;
    206          	FSMC_InitStructure.FSMC_BurstAccessMode=FSMC_BurstAccessMode_Disable;
    207          	FSMC_InitStructure.FSMC_WaitSignalPolarity=FSMC_WaitSignalPolarity_Low;
    208          	FSMC_InitStructure.FSMC_WrapMode=FSMC_WrapMode_Disable;
    209          	FSMC_InitStructure.FSMC_WaitSignalActive=FSMC_WaitSignalActive_BeforeWaitState;
    210          	FSMC_InitStructure.FSMC_WriteOperation=FSMC_WriteOperation_Enable;
    211          	FSMC_InitStructure.FSMC_WaitSignal=FSMC_WaitSignal_Disable;
    212          	FSMC_InitStructure.FSMC_ExtendedMode=FSMC_ExtendedMode_Disable;
    213          	FSMC_InitStructure.FSMC_WriteBurst=FSMC_WriteBurst_Disable;
    214          	FSMC_InitStructure.FSMC_ReadWriteTimingStruct=&FSMC_TimingStructure;
    215          	FSMC_InitStructure.FSMC_WriteTimingStruct=&FSMC_TimingStructure;
    216          	FSMC_InitStructure.FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable;
    217          	FSMC_NORSRAMInit(&FSMC_InitStructure);
    218          	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM1, ENABLE);
    219          
    220          	fsmcRegister = (uint8_t *) 0x60000000;
    221          	fsmcData = (uint8_t *) 0x60020000;
    222          	fsmcData16 = (uint16_t *) 0x60020000; 
    223          	fsmcData32 = (uint32_t *) 0x60020000; 
    224          
    225          #else
    226           #error "Please select GPIO or FSMC interface for display"
    227          #endif
    228          
    229          }
   \   0000018E   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    230          
    231          
    232          
    233          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    234          void TLcd::LcdPHYDeInit( void )
    235          {
   \                     _ZN4TLcd12LcdPHYDeInitEv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    236          	LcdEnable( 0 );
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       _ZN4TLcd9LcdEnableEb
    237          
    238          	GPIO_InitTypeDef GPIO_InitStructure;
    239          
    240          	/* RD pin */
    241          	GPIO_SetBits( DISP_RD_PORT, DISP_RD_PIN );
   \   0000000A   0x.... 0x....      LDR.W    R4,??DataTable16_1  ;; 0x40020000
   \   0000000E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       GPIO_SetBits
    242          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    243          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000001E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    244          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0007      STRB     R0,[SP, #+7]
    245          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    246          	GPIO_InitStructure.GPIO_Pin = DISP_RD_PIN;
   \   0000002E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000032   0x9000             STR      R0,[SP, #+0]
    247          	GPIO_Init( DISP_RD_PORT, &GPIO_InitStructure );
   \   00000034   0xA900             ADD      R1,SP,#+0
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       GPIO_Init
    248          
    249          	/* WR pin */
    250          	GPIO_SetBits( DISP_WR_PORT, DISP_WR_PIN );
   \   0000003C   0xF44F 0x6100      MOV      R1,#+2048
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       GPIO_SetBits
    251          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF88D 0x0004      STRB     R0,[SP, #+4]
    252          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000004C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    253          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF88D 0x0007      STRB     R0,[SP, #+7]
    254          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF88D 0x0005      STRB     R0,[SP, #+5]
    255          	GPIO_InitStructure.GPIO_Pin = DISP_WR_PIN;
   \   0000005C   0xF44F 0x6000      MOV      R0,#+2048
   \   00000060   0x9000             STR      R0,[SP, #+0]
    256          	GPIO_Init( DISP_WR_PORT, &GPIO_InitStructure );
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0x4620             MOV      R0,R4
   \   00000066   0x.... 0x....      BL       GPIO_Init
    257          
    258          	/* CS pin */
    259          	GPIO_SetBits( DISP_CS_PORT, DISP_CS_PIN );
   \   0000006A   0xF44F 0x5180      MOV      R1,#+4096
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       GPIO_SetBits
    260          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF88D 0x0004      STRB     R0,[SP, #+4]
    261          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000007A   0xF88D 0x0006      STRB     R0,[SP, #+6]
    262          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xF88D 0x0007      STRB     R0,[SP, #+7]
    263          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xF88D 0x0005      STRB     R0,[SP, #+5]
    264          	GPIO_InitStructure.GPIO_Pin = DISP_CS_PIN;
   \   0000008A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000008E   0x9000             STR      R0,[SP, #+0]
    265          	GPIO_Init( DISP_CS_PORT, &GPIO_InitStructure );
   \   00000090   0xA900             ADD      R1,SP,#+0
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       GPIO_Init
    266          
    267          	/* DC pin */
    268          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    269          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000009E   0xF88D 0x0006      STRB     R0,[SP, #+6]
    270          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xF88D 0x0007      STRB     R0,[SP, #+7]
    271          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF88D 0x0005      STRB     R0,[SP, #+5]
    272          	GPIO_InitStructure.GPIO_Pin = DISP_DC_PIN;
   \   000000AE   0xF44F 0x7000      MOV      R0,#+512
   \   000000B2   0x9000             STR      R0,[SP, #+0]
    273          	GPIO_Init( DISP_DC_PORT, &GPIO_InitStructure );
   \   000000B4   0xA900             ADD      R1,SP,#+0
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       GPIO_Init
    274          
    275          	/* RES pin */
    276          	GPIO_ResetBits( DISP_RES_PORT, DISP_RES_PIN );
   \   000000BC   0x.... 0x....      LDR.W    R5,??DataTable16  ;; 0x40020800
   \   000000C0   0x2110             MOVS     R1,#+16
   \   000000C2   0x4628             MOV      R0,R5
   \   000000C4   0x.... 0x....      BL       GPIO_ResetBits
    277          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0xF88D 0x0004      STRB     R0,[SP, #+4]
    278          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   000000CE   0xF88D 0x0006      STRB     R0,[SP, #+6]
    279          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xF88D 0x0007      STRB     R0,[SP, #+7]
    280          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF88D 0x0005      STRB     R0,[SP, #+5]
    281          	GPIO_InitStructure.GPIO_Pin = DISP_RES_PIN;
   \   000000DE   0x2010             MOVS     R0,#+16
   \   000000E0   0x9000             STR      R0,[SP, #+0]
    282          	GPIO_Init( DISP_RES_PORT, &GPIO_InitStructure );
   \   000000E2   0xA900             ADD      R1,SP,#+0
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0x.... 0x....      BL       GPIO_Init
    283          
    284          	/* DATA pins */
    285          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0xF88D 0x0004      STRB     R0,[SP, #+4]
    286          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   000000F0   0xF88D 0x0006      STRB     R0,[SP, #+6]
    287          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xF88D 0x0007      STRB     R0,[SP, #+7]
    288          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xF88D 0x0005      STRB     R0,[SP, #+5]
    289          	GPIO_InitStructure.GPIO_Pin = DISP_D0_PIN;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0x9000             STR      R0,[SP, #+0]
    290          	GPIO_Init( DISP_D0_PORT, &GPIO_InitStructure );
   \   00000104   0xA900             ADD      R1,SP,#+0
   \   00000106   0x4620             MOV      R0,R4
   \   00000108   0x.... 0x....      BL       GPIO_Init
    291          	GPIO_InitStructure.GPIO_Pin = DISP_D1_PIN;
   \   0000010C   0x2002             MOVS     R0,#+2
   \   0000010E   0x9000             STR      R0,[SP, #+0]
    292          	GPIO_Init( DISP_D1_PORT, &GPIO_InitStructure );
   \   00000110   0xA900             ADD      R1,SP,#+0
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       GPIO_Init
    293          	GPIO_InitStructure.GPIO_Pin = DISP_D2_PIN;
   \   00000118   0x2004             MOVS     R0,#+4
   \   0000011A   0x9000             STR      R0,[SP, #+0]
    294          	GPIO_Init( DISP_D2_PORT, &GPIO_InitStructure );
   \   0000011C   0xA900             ADD      R1,SP,#+0
   \   0000011E   0x4620             MOV      R0,R4
   \   00000120   0x.... 0x....      BL       GPIO_Init
    295          	GPIO_InitStructure.GPIO_Pin = DISP_D3_PIN;
   \   00000124   0x2008             MOVS     R0,#+8
   \   00000126   0x9000             STR      R0,[SP, #+0]
    296          	GPIO_Init( DISP_D3_PORT, &GPIO_InitStructure );
   \   00000128   0xA900             ADD      R1,SP,#+0
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x.... 0x....      BL       GPIO_Init
    297          	GPIO_InitStructure.GPIO_Pin = DISP_D4_PIN;
   \   00000130   0x2010             MOVS     R0,#+16
   \   00000132   0x9000             STR      R0,[SP, #+0]
    298          	GPIO_Init( DISP_D4_PORT, &GPIO_InitStructure );
   \   00000134   0xA900             ADD      R1,SP,#+0
   \   00000136   0x4620             MOV      R0,R4
   \   00000138   0x.... 0x....      BL       GPIO_Init
    299          	GPIO_InitStructure.GPIO_Pin = DISP_D5_PIN;
   \   0000013C   0x2020             MOVS     R0,#+32
   \   0000013E   0x9000             STR      R0,[SP, #+0]
    300          	GPIO_Init( DISP_D5_PORT, &GPIO_InitStructure );
   \   00000140   0xA900             ADD      R1,SP,#+0
   \   00000142   0x4620             MOV      R0,R4
   \   00000144   0x.... 0x....      BL       GPIO_Init
    301          	GPIO_InitStructure.GPIO_Pin = DISP_D6_PIN;
   \   00000148   0x2040             MOVS     R0,#+64
   \   0000014A   0x9000             STR      R0,[SP, #+0]
    302          	GPIO_Init( DISP_D6_PORT, &GPIO_InitStructure );
   \   0000014C   0xA900             ADD      R1,SP,#+0
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0x.... 0x....      BL       GPIO_Init
    303          	GPIO_InitStructure.GPIO_Pin = DISP_D7_PIN;
   \   00000154   0x2080             MOVS     R0,#+128
   \   00000156   0x9000             STR      R0,[SP, #+0]
    304          	GPIO_Init( DISP_D7_PORT, &GPIO_InitStructure );
   \   00000158   0xA900             ADD      R1,SP,#+0
   \   0000015A   0x4620             MOV      R0,R4
   \   0000015C   0x.... 0x....      BL       GPIO_Init
    305          
    306          	/* EN pin */
    307          	LcdEnable( false );
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0x.... 0x....      BL       _ZN4TLcd9LcdEnableEb
    308          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   00000166   0x2001             MOVS     R0,#+1
   \   00000168   0xF88D 0x0004      STRB     R0,[SP, #+4]
    309          //	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
    310          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    311          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    312          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000172   0xF88D 0x0005      STRB     R0,[SP, #+5]
    313          	GPIO_InitStructure.GPIO_Pin = DISP_EN_PIN;
   \   00000176   0xF44F 0x4000      MOV      R0,#+32768
   \   0000017A   0x9000             STR      R0,[SP, #+0]
    314          	GPIO_Init( DISP_EN_PORT, &GPIO_InitStructure );
   \   0000017C   0xA900             ADD      R1,SP,#+0
   \   0000017E   0x4620             MOV      R0,R4
   \   00000180   0x.... 0x....      BL       GPIO_Init
    315          
    316          	/* BL pin */
    317          	LcdBL( false );
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x.... 0x....      BL       _ZN4TLcd5LcdBLEb
    318          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    319          	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    320          	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    321          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   \   00000196   0xF88D 0x0005      STRB     R0,[SP, #+5]
    322          	GPIO_InitStructure.GPIO_Pin = DISP_BL_PIN;
   \   0000019A   0x2040             MOVS     R0,#+64
   \   0000019C   0x9000             STR      R0,[SP, #+0]
    323          	GPIO_Init( DISP_BL_PORT, &GPIO_InitStructure );
   \   0000019E   0xA900             ADD      R1,SP,#+0
   \   000001A0   0x4628             MOV      R0,R5
   \   000001A2   0x.... 0x....      BL       GPIO_Init
    324          
    325          #if defined DISPLAY_GPIO
    326          
    327          #elif defined DISPLAY_FSMC
    328          
    329          	/* FSMC Setup */
    330          	DISP_FSMC_RCC_DISABLE;
    331          
    332          #else
    333           #error "Please select GPIO or FSMC interface for display"
    334          #endif
    335          
    336          }
   \   000001A6   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    337          
    338          
    339          #if defined DISPLAY_GPIO
    340          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    341          void TLcd::RDPin( bool state )
    342          {
    343          	if( state == 1 ) GPIO_SetBits( DISP_RD_PORT, DISP_RD_PIN );
   \                     _ZN4TLcd5RDPinEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0x40020000
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xF44F 0x6180      MOV      R1,#+1024
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0xD001             BEQ.N    ??RDPin_0
   \   0000000E   0x.... 0x....      B.W      GPIO_SetBits
    344          	else GPIO_ResetBits( DISP_RD_PORT, DISP_RD_PIN );
   \                     ??RDPin_0: (+1)
   \   00000012   0x.... 0x....      B.W      GPIO_ResetBits
    345          }
    346          #endif
    347          
    348          
    349          
    350          #if defined DISPLAY_GPIO
    351          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    352          void TLcd::WRPin( bool state )
    353          {
    354          	if( state == 1 ) GPIO_SetBits( DISP_WR_PORT, DISP_WR_PIN );
   \                     _ZN4TLcd5WRPinEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0x40020000
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xF44F 0x6100      MOV      R1,#+2048
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0xD001             BEQ.N    ??WRPin_0
   \   0000000E   0x.... 0x....      B.W      GPIO_SetBits
    355          	else GPIO_ResetBits( DISP_WR_PORT, DISP_WR_PIN );
   \                     ??WRPin_0: (+1)
   \   00000012   0x.... 0x....      B.W      GPIO_ResetBits
    356          }
    357          #endif
    358          
    359          
    360          
    361          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    362          void TLcd::CSPin( bool state )
    363          {
    364          	if( state == 1 ) GPIO_SetBits( DISP_CS_PORT, DISP_CS_PIN );
   \                     _ZN4TLcd5CSPinEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0x40020000
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xF44F 0x5180      MOV      R1,#+4096
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0xD001             BEQ.N    ??CSPin_0
   \   0000000E   0x.... 0x....      B.W      GPIO_SetBits
    365          	else GPIO_ResetBits( DISP_CS_PORT, DISP_CS_PIN );
   \                     ??CSPin_0: (+1)
   \   00000012   0x.... 0x....      B.W      GPIO_ResetBits
    366          }
    367          
    368          
    369          
    370          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    371          void TLcd::DCPin( bool state )
    372          {
    373          	if( state == 1 ) GPIO_SetBits( DISP_DC_PORT, DISP_DC_PIN );
   \                     _ZN4TLcd5DCPinEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0x40020000
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xF44F 0x7100      MOV      R1,#+512
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0xD001             BEQ.N    ??DCPin_0
   \   0000000E   0x.... 0x....      B.W      GPIO_SetBits
    374          	else GPIO_ResetBits( DISP_DC_PORT, DISP_DC_PIN );
   \                     ??DCPin_0: (+1)
   \   00000012   0x.... 0x....      B.W      GPIO_ResetBits
    375          }
    376          
    377          
    378          
    379          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    380          void TLcd::RESPin( bool state )
    381          {
    382          	if( state == 1 ) GPIO_SetBits( DISP_RES_PORT, DISP_RES_PIN );
   \                     _ZN4TLcd6RESPinEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16  ;; 0x40020800
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??RESPin_0
   \   00000008   0x2110             MOVS     R1,#+16
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x.... 0x....      B.W      GPIO_SetBits
    383          	else GPIO_ResetBits( DISP_RES_PORT, DISP_RES_PIN );
   \                     ??RESPin_0: (+1)
   \   00000010   0x2110             MOVS     R1,#+16
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0x.... 0x....      B.W      GPIO_ResetBits
    384          }
    385          
    386          
    387          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    388          void TLcd::LcdEnable( bool state )
    389          {
    390          #ifndef DISPLAY_OFF
    391          	if( state == 1 ) {
   \                     _ZN4TLcd9LcdEnableEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0x40020000
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xF44F 0x4100      MOV      R1,#+32768
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0xD001             BEQ.N    ??LcdEnable_0
    392          		GPIO_ResetBits( DISP_EN_PORT, DISP_EN_PIN );
   \   0000000E   0x.... 0x....      B.W      GPIO_ResetBits
    393          	}
    394          	else {
    395          		GPIO_SetBits( DISP_EN_PORT, DISP_EN_PIN );
   \                     ??LcdEnable_0: (+1)
   \   00000012   0x.... 0x....      B.W      GPIO_SetBits
    396          	}
    397          #else
    398          	GPIO_SetBits( DISP_EN_PORT, DISP_EN_PIN );
    399          #endif
    400          }
    401          
    402          

   \                                 In section .text, align 2, keep-with-next
    403          void TLcd::LcdBL( bool state )
    404          {
   \                     _ZN4TLcd5LcdBLEb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    405          #ifndef DISPLAY_OFF
    406          //	if((state != 0) && (TAppProcessor::SysVoltageValue > 3000)) 
    407          	if(state != 0) 
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable16  ;; 0x40020800
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD008             BEQ.N    ??LcdBL_0
    408            {
    409          		WriteCmd(TFT_INVOFF);
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    410          		GPIO_SetBits( DISP_BL_PORT, DISP_BL_PIN );
   \   00000010   0x2140             MOVS     R1,#+64
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xE8BD 0x4010      POP      {R4,LR}
   \   00000018   0x.... 0x....      B.W      GPIO_SetBits
    411          	}
    412          	else 
    413            {
    414          		GPIO_ResetBits( DISP_BL_PORT, DISP_BL_PIN );
   \                     ??LcdBL_0: (+1)
   \   0000001C   0x2140             MOVS     R1,#+64
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       GPIO_ResetBits
    415          		WriteCmd(TFT_INVON);
   \   00000024   0x2021             MOVS     R0,#+33
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x.... 0x....      B.W      _ZN4TLcd8WriteCmdEh
    416          	}
    417          #else
    418          	GPIO_ResetBits( DISP_BL_PORT, DISP_BL_PIN );
    419          #endif
    420          }
    421          

   \                                 In section .text, align 2, keep-with-next
    422          void TLcd::ColorInversion( bool state )
    423          {
    424          #ifndef DISPLAY_OFF
    425          	if( state == 0 ) {
   \                     _ZN4TLcd14ColorInversionEb: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD102             BNE.N    ??ColorInversion_0
    426          		WriteCmd(TFT_INVOFF);
   \   00000004   0x2020             MOVS     R0,#+32
   \   00000006   0x.... 0x....      B.W      _ZN4TLcd8WriteCmdEh
    427          	}
    428          	else {
    429          		WriteCmd(TFT_INVON);
   \                     ??ColorInversion_0: (+1)
   \   0000000A   0x2021             MOVS     R0,#+33
   \   0000000C   0x.... 0x....      B.W      _ZN4TLcd8WriteCmdEh
    430          	}
    431          #endif
    432          }
    433          
    434          /*----------------------------------------------------------------------------------*/
    435          #if defined DYSPLAY_FSMC
    436          void TLcd::WriteCmd( uint8_t cmd, uint8_t data )
    437          {
    438          	*fsmcRegister = cmd;
    439          	*fsmcData = data;
    440          }
    441          
    442          void TLcd::WriteCmd( uint8_t cmd )
    443          {
    444          	*fsmcRegister = cmd;
    445          }
    446          
    447          void TLcd::WriteData( uint8_t data )
    448          {
    449          	*fsmcData = data;
    450          }
    451          
    452          void TLcd::WriteData( uint16_t data )
    453          {
    454          	*fsmcData16 = data;
    455          }
    456          
    457          void TLcd::WriteData( uint32_t data )
    458          {
    459          	*fsmcData32 = data;
    460          }
    461          #endif
    462          
    463          

   \                                 In section .text, align 2, keep-with-next
    464          void TLcd::SetPos( uint16_t row, uint16_t col )
    465          {
   \                     _ZN4TLcd6SetPosEtt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    466          	uint16_t x1, x2, y1, y2;
    467          
    468          	x1 = col;
    469          	x2 = TFT_COLS;
    470          	y1 = row;
    471          	y2 = TFT_ROWS;
    472          
    473          	WriteCmd(TFT_CASET);
   \   00000006   0x202A             MOVS     R0,#+42
   \   00000008   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    474           
    475          	WriteData((uint8_t)(x1 >> 8));
   \   0000000C   0x1228             ASRS     R0,R5,#+8
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    476          	WriteData((uint8_t)(x1 & 0xff));
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    477          	WriteData((uint8_t)(x2 >> 8));
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    478          	WriteData((uint8_t)(x2 & 0xff));
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    479           
    480          	WriteCmd(TFT_RASET);
   \   00000028   0x202B             MOVS     R0,#+43
   \   0000002A   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    481           
    482          	WriteData((uint8_t)(y1 >> 8));
   \   0000002E   0x1220             ASRS     R0,R4,#+8
   \   00000030   0xB2C0             UXTB     R0,R0
   \   00000032   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    483          	WriteData((uint8_t)(y1 & 0xff));
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xB2C0             UXTB     R0,R0
   \   0000003A   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    484          	WriteData((uint8_t)(y2 >> 8));
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    485          	WriteData((uint8_t)(y2 & 0xff));
   \   00000044   0x20F0             MOVS     R0,#+240
   \   00000046   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000004A   0x.... 0x....      B.W      _ZN4TLcd9WriteDataEh
    486          }
    487          

   \                                 In section .text, align 2, keep-with-next
    488          void TLcd::SetPos( uint16_t x, uint16_t y, uint16_t width, uint16_t height )
    489          {
   \                     _ZN4TLcd6SetPosEtttt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    490          	uint16_t x1, x2, y1, y2;
    491          
    492          	x1 = x;
    493          	x2 = x1 + width - 1;
   \   00000006   0x1910             ADDS     R0,R2,R4
   \   00000008   0x1E46             SUBS     R6,R0,#+1
   \   0000000A   0xB2B6             UXTH     R6,R6
    494          	y1 = y;
    495          	y2 = y1 + height - 1;
   \   0000000C   0x1958             ADDS     R0,R3,R5
   \   0000000E   0x1E47             SUBS     R7,R0,#+1
   \   00000010   0xB2BF             UXTH     R7,R7
    496          
    497          	WriteCmd(TFT_CASET);
   \   00000012   0x202A             MOVS     R0,#+42
   \   00000014   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    498           
    499          	WriteData((uint8_t)(x1 >> 8));
   \   00000018   0x1220             ASRS     R0,R4,#+8
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    500          	WriteData((uint8_t)(x1 & 0xff));
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    501          	WriteData((uint8_t)(x2 >> 8));
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x0A00             LSRS     R0,R0,#+8
   \   0000002C   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    502          	WriteData((uint8_t)(x2 & 0xff));
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0xB2C0             UXTB     R0,R0
   \   00000034   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    503           
    504          	WriteCmd(TFT_RASET);
   \   00000038   0x202B             MOVS     R0,#+43
   \   0000003A   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    505           
    506          	WriteData((uint8_t)(y1 >> 8));
   \   0000003E   0x1228             ASRS     R0,R5,#+8
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    507          	WriteData((uint8_t)(y1 & 0xff));
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0xB2C0             UXTB     R0,R0
   \   0000004A   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    508          	WriteData((uint8_t)(y2 >> 8));
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x0A00             LSRS     R0,R0,#+8
   \   00000052   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
    509          	WriteData((uint8_t)(y2 & 0xff));
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0xB2C0             UXTB     R0,R0
   \   0000005A   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000005E   0x.... 0x....      B.W      _ZN4TLcd9WriteDataEh
    510          }
    511          
    512          
    513          
    514          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    515          void TLcd::LcdClear()
    516          {
   \                     _ZN4TLcd8LcdClearEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    517          
    518          	WriteCmd(TFT_CASET);
   \   00000002   0x202A             MOVS     R0,#+42
   \   00000004   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    519          	WriteData((uint32_t) ((__REV16( TFT_COLS - 1 ) << 16) + (__REV16( 0 ))));
   \   00000008   0x....             LDR.N    R0,??DataTable16_2  ;; 0x3f010000
   \   0000000A   0x.... 0x....      BL       _ZN4TLcd9WriteDataEj
    520          	WriteCmd(TFT_RASET);
   \   0000000E   0x202B             MOVS     R0,#+43
   \   00000010   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    521          	WriteData((uint32_t) ((__REV16( TFT_ROWS - 1 ) << 16) + (__REV16( 0 ))));
   \   00000014   0xF04F 0x406F      MOV      R0,#-285212672
   \   00000018   0x.... 0x....      BL       _ZN4TLcd9WriteDataEj
    522          	WriteCmd(TFT_RAMWR);
   \   0000001C   0x202C             MOVS     R0,#+44
   \   0000001E   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    523          	for(int pa=0; pa < TFT_ROWS * TFT_COLS; pa++ ) {
   \   00000022   0x2400             MOVS     R4,#+0
   \   00000024   0xE003             B.N      ??LcdClear_0
    524          		WriteData((uint16_t)clBlack);
   \                     ??LcdClear_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       _ZN4TLcd9WriteDataEt
    525          	}
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \                     ??LcdClear_0: (+1)
   \   0000002E   0xF5B4 0x3F96      CMP      R4,#+76800
   \   00000032   0xDBF8             BLT.N    ??LcdClear_1
    526          }
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    527          
    528          
    529          
    530          /*----------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    531          void TLcd::LCD_Init( void )
    532          {
   \                     _ZN4TLcd8LCD_InitEv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    533          	SetSysPal(0x0000, 0xFFFF);
   \   00000004   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       _ZN4TLcd9SetSysPalEtt
    534          	// reset
    535          //	__delay_cycles(25000);
    536           	RESPin(0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       _ZN4TLcd6RESPinEb
    537          	__delay_cycles(125000);
   \   00000014   0x....             LDR.N    R4,??DataTable16_3  ;; 0x1e848
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       _Z14__delay_cyclesi
    538          	RESPin(1);
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       _ZN4TLcd6RESPinEb
    539          	__delay_cycles(25000);
   \   00000022   0xF246 0x10A8      MOVW     R0,#+25000
   \   00000026   0x.... 0x....      BL       _Z14__delay_cyclesi
    540           
    541           	// init sequence
    542          	WriteCmd(TFT_SLPOUT);
   \   0000002A   0x2011             MOVS     R0,#+17
   \   0000002C   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    543          
    544            bool chinaLCD = false;
   \   00000030   0x2500             MOVS     R5,#+0
    545            const uint8_t chinaIDArr[] = {0x54, 0x8A, 0x27};
   \   00000032   0xA801             ADD      R0,SP,#+4
   \   00000034   0x.... 0x....      ADR.W    R1,?_0
   \   00000038   0x680A             LDR      R2,[R1, #0]
   \   0000003A   0x6002             STR      R2,[R0, #+0]
    546            uint8_t tmpIDArr[3];
    547            ReadData(TFT_RDDID, 3, &tmpIDArr[0]);
   \   0000003C   0xAA00             ADD      R2,SP,#+0
   \   0000003E   0x2103             MOVS     R1,#+3
   \   00000040   0x2004             MOVS     R0,#+4
   \   00000042   0x.... 0x....      BL       _ZN4TLcd8ReadDataEhhPh
    548            for (uint8_t i = 0, j = 0; i < 4; i++) 
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x4601             MOV      R1,R0
   \   0000004A   0xE00B             B.N      ??LCD_Init_0
    549            {
    550              if(tmpIDArr[i] == chinaIDArr[i]) j++;
   \                     ??LCD_Init_1: (+1)
   \   0000004C   0xAA00             ADD      R2,SP,#+0
   \   0000004E   0x5C82             LDRB     R2,[R0, R2]
   \   00000050   0xAB01             ADD      R3,SP,#+4
   \   00000052   0x5CC3             LDRB     R3,[R0, R3]
   \   00000054   0x429A             CMP      R2,R3
   \   00000056   0xD100             BNE.N    ??LCD_Init_2
   \   00000058   0x1C49             ADDS     R1,R1,#+1
    551              if(j >= 3) chinaLCD = true;
   \                     ??LCD_Init_2: (+1)
   \   0000005A   0xB2C9             UXTB     R1,R1
   \   0000005C   0x2903             CMP      R1,#+3
   \   0000005E   0xDB00             BLT.N    ??LCD_Init_3
   \   00000060   0x2501             MOVS     R5,#+1
    552            }
   \                     ??LCD_Init_3: (+1)
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \                     ??LCD_Init_0: (+1)
   \   00000064   0x2804             CMP      R0,#+4
   \   00000066   0xDBF1             BLT.N    ??LCD_Init_1
    553            
    554          	WriteCmd(TFT_INVOFF);
   \   00000068   0x2020             MOVS     R0,#+32
   \   0000006A   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    555          	WriteCmd(TFT_IDMOFF);
   \   0000006E   0x2038             MOVS     R0,#+56
   \   00000070   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    556          	WriteCmd(TFT_NORON);
   \   00000074   0x2013             MOVS     R0,#+19
   \   00000076   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    557          // 	WriteCmd(TFT_MEMORY_ACCESS_CONTROL,0xE0);	
    558           	WriteCmd(TFT_MADCTL,0xA0);	
   \   0000007A   0x21A0             MOVS     R1,#+160
   \   0000007C   0x2036             MOVS     R0,#+54
   \   0000007E   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEhh
    559           
    560          	// wait
    561          	__delay_cycles(125000);
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       _Z14__delay_cyclesi
    562          
    563          	// select 262K colour mode
    564          	WriteCmd(TFT_COLMOD,0x55);  //16bit
   \   00000088   0x2155             MOVS     R1,#+85
   \   0000008A   0x203A             MOVS     R0,#+58
   \   0000008C   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEhh
    565          	if(!chinaLCD)
   \   00000090   0x2D00             CMP      R5,#+0
   \   00000092   0xD13F             BNE.N    ??LCD_Init_4
    566            {
    567              WriteCmd( TFT_COLSET );  
   \   00000094   0x202D             MOVS     R0,#+45
   \   00000096   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    568              for ( uint8_t i = 0; i < 32; i++ ) WriteData(( uint8_t ) ( i * 255 / 31 ));
   \   0000009A   0x2400             MOVS     R4,#+0
   \   0000009C   0xE008             B.N      ??LCD_Init_5
   \                     ??LCD_Init_6: (+1)
   \   0000009E   0xEBC0 0x2000      RSB      R0,R0,R0, LSL #+8
   \   000000A2   0x211F             MOVS     R1,#+31
   \   000000A4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000A8   0xB2C0             UXTB     R0,R0
   \   000000AA   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
   \   000000AE   0x1C64             ADDS     R4,R4,#+1
   \                     ??LCD_Init_5: (+1)
   \   000000B0   0xB2E4             UXTB     R4,R4
   \   000000B2   0x4620             MOV      R0,R4
   \   000000B4   0x2820             CMP      R0,#+32
   \   000000B6   0xDBF2             BLT.N    ??LCD_Init_6
    569              for ( uint8_t i = 0; i < 32; i++ ) WriteData(( uint8_t ) 0xFF);
   \   000000B8   0x2400             MOVS     R4,#+0
   \   000000BA   0xE003             B.N      ??LCD_Init_7
   \                     ??LCD_Init_8: (+1)
   \   000000BC   0x20FF             MOVS     R0,#+255
   \   000000BE   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
   \   000000C2   0x1C64             ADDS     R4,R4,#+1
   \                     ??LCD_Init_7: (+1)
   \   000000C4   0x2C20             CMP      R4,#+32
   \   000000C6   0xDBF9             BLT.N    ??LCD_Init_8
    570              for ( uint8_t i = 0; i < 64; i++ ) WriteData(( uint8_t ) ( i * 255 / 63 ));
   \   000000C8   0x2400             MOVS     R4,#+0
   \   000000CA   0xE008             B.N      ??LCD_Init_9
   \                     ??LCD_Init_10: (+1)
   \   000000CC   0xEBC0 0x2000      RSB      R0,R0,R0, LSL #+8
   \   000000D0   0x213F             MOVS     R1,#+63
   \   000000D2   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000D6   0xB2C0             UXTB     R0,R0
   \   000000D8   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
   \   000000DC   0x1C64             ADDS     R4,R4,#+1
   \                     ??LCD_Init_9: (+1)
   \   000000DE   0xB2E4             UXTB     R4,R4
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0x2840             CMP      R0,#+64
   \   000000E4   0xDBF2             BLT.N    ??LCD_Init_10
    571              for ( uint8_t i = 0; i < 32; i++ ) WriteData(( uint8_t ) ( i * 255 / 31 ));
   \   000000E6   0x2400             MOVS     R4,#+0
   \   000000E8   0xE008             B.N      ??LCD_Init_11
   \                     ??LCD_Init_12: (+1)
   \   000000EA   0xEBC0 0x2000      RSB      R0,R0,R0, LSL #+8
   \   000000EE   0x211F             MOVS     R1,#+31
   \   000000F0   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000F4   0xB2C0             UXTB     R0,R0
   \   000000F6   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
   \   000000FA   0x1C64             ADDS     R4,R4,#+1
   \                     ??LCD_Init_11: (+1)
   \   000000FC   0xB2E4             UXTB     R4,R4
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x2820             CMP      R0,#+32
   \   00000102   0xDBF2             BLT.N    ??LCD_Init_12
    572              for ( uint8_t i = 0; i < 32; i++ ) WriteData(( uint8_t ) 0xFF);
   \   00000104   0x2400             MOVS     R4,#+0
   \   00000106   0xE003             B.N      ??LCD_Init_13
   \                     ??LCD_Init_14: (+1)
   \   00000108   0x20FF             MOVS     R0,#+255
   \   0000010A   0x.... 0x....      BL       _ZN4TLcd9WriteDataEh
   \   0000010E   0x1C64             ADDS     R4,R4,#+1
   \                     ??LCD_Init_13: (+1)
   \   00000110   0x2C20             CMP      R4,#+32
   \   00000112   0xDBF9             BLT.N    ??LCD_Init_14
    573            }
    574            LcdClear();
   \                     ??LCD_Init_4: (+1)
   \   00000114   0x.... 0x....      BL       _ZN4TLcd8LcdClearEv
    575           
    576          	// turn the display on
    577          	WriteCmd(TFT_DISPON);
   \   00000118   0x2029             MOVS     R0,#+41
   \   0000011A   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    578          //	GPIO_SetBits( DISP_BL_PORT, DISP_BL_PIN );
    579            LcdBL(true);
   \   0000011E   0x2001             MOVS     R0,#+1
   \   00000120   0x.... 0x....      BL       _ZN4TLcd5LcdBLEb
    580          
    581          }
   \   00000124   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    582          
    583          
    584          

   \                                 In section .text, align 2, keep-with-next
    585          void TLcd::PutPixel( uint16_t x, uint16_t y, uint16_t color )
    586          {
   \                     _ZN4TLcd8PutPixelEttt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4614             MOV      R4,R2
    587          	SetPos( x, y, x+1, y+1 );
   \   00000004   0x1C4B             ADDS     R3,R1,#+1
   \   00000006   0xB29B             UXTH     R3,R3
   \   00000008   0x1C42             ADDS     R2,R0,#+1
   \   0000000A   0xB292             UXTH     R2,R2
   \   0000000C   0x.... 0x....      BL       _ZN4TLcd6SetPosEtttt
    588          	WriteCmd(TFT_RAMWR);
   \   00000010   0x202C             MOVS     R0,#+44
   \   00000012   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    589          	WriteData((uint16_t) __REV16(color));
   \   00000016   0xBA60             REV16    R0,R4
   \   00000018   0xB280             UXTH     R0,R0
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN4TLcd9WriteDataEt
    590          }
    591          
    592          

   \                                 In section .text, align 2, keep-with-next
    593          void TLcd::PutBitmap(uint16_t x, uint16_t y, const TBitMap *_bmp)
    594          {
   \                     _ZN4TLcd9PutBitmapEttPK7TBitMap: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x460F             MOV      R7,R1
   \   0000000A   0x4614             MOV      R4,R2
    595          	uint8_t scale = 1;
   \   0000000C   0x2501             MOVS     R5,#+1
    596          	const uint16_t mask[] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      ADR.W    R1,?_1
   \   00000014   0x2214             MOVS     R2,#+20
   \   00000016   0x.... 0x....      BL       __aeabi_memcpy4
    597          	SetPos(x, y, _bmp->biWidth,  _bmp->biHeight);
   \   0000001A   0x88E3             LDRH     R3,[R4, #+6]
   \   0000001C   0x88A2             LDRH     R2,[R4, #+4]
   \   0000001E   0x4639             MOV      R1,R7
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       _ZN4TLcd6SetPosEtttt
    598          	WriteCmd(TFT_RAMWR);
   \   00000026   0x202C             MOVS     R0,#+44
   \   00000028   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    599          
    600          	if((_bmp->biPixelBit == 16) || ((_bmp->biPixelBit == 8) && (_bmp->biCompression == 1))) scale++;
   \   0000002C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD004             BEQ.N    ??PutBitmap_0
   \   00000032   0x2808             CMP      R0,#+8
   \   00000034   0xD103             BNE.N    ??PutBitmap_1
   \   00000036   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD100             BNE.N    ??PutBitmap_1
   \                     ??PutBitmap_0: (+1)
   \   0000003C   0x2502             MOVS     R5,#+2
    601          
    602          	for(uint32_t bmpIndx = 0; bmpIndx < _bmp->biArrSize;)
   \                     ??PutBitmap_1: (+1)
   \   0000003E   0x2600             MOVS     R6,#+0
   \                     ??PutBitmap_2: (+1)
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x4286             CMP      R6,R0
   \   00000044   0xD222             BCS.N    ??PutBitmap_3
    603          	{
    604          		uint16_t pixblock = _bmp->biArr[bmpIndx++];
   \   00000046   0x6920             LDR      R0,[R4, #+16]
   \   00000048   0x5C31             LDRB     R1,[R6, R0]
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
    605          		if(scale == 2) pixblock = (pixblock << 8) + _bmp->biArr[bmpIndx++];
   \   0000004C   0x2D02             CMP      R5,#+2
   \   0000004E   0xD104             BNE.N    ??PutBitmap_4
   \   00000050   0x5C30             LDRB     R0,[R6, R0]
   \   00000052   0xEB10 0x2101      ADDS     R1,R0,R1, LSL #+8
   \   00000056   0xB289             UXTH     R1,R1
   \   00000058   0x1C76             ADDS     R6,R6,#+1
    606          		uint8_t pixcount = pixblock >> _bmp->biPixelBit;
   \                     ??PutBitmap_4: (+1)
   \   0000005A   0x7A20             LDRB     R0,[R4, #+8]
   \   0000005C   0x460F             MOV      R7,R1
   \   0000005E   0x4107             ASRS     R7,R7,R0
   \   00000060   0xB2FF             UXTB     R7,R7
    607          		uint16_t pixcolor = _bmp->biPal[ pixblock & mask[_bmp->biPixelBit] ];
   \   00000062   0x68E2             LDR      R2,[R4, #+12]
   \   00000064   0xAB00             ADD      R3,SP,#+0
   \   00000066   0xF833 0x0010      LDRH     R0,[R3, R0, LSL #+1]
   \   0000006A   0x4008             ANDS     R0,R0,R1
   \   0000006C   0xF832 0x8010      LDRH     R8,[R2, R0, LSL #+1]
    608          		for( uint8_t pix = 0; pix < pixcount; pix++)
   \   00000070   0xF04F 0x0900      MOV      R9,#+0
   \                     ??PutBitmap_5: (+1)
   \   00000074   0xFA5F 0xF989      UXTB     R9,R9
   \   00000078   0x45B9             CMP      R9,R7
   \   0000007A   0xDAE1             BGE.N    ??PutBitmap_2
    609          		{
    610          			WriteData((uint16_t) __REV16(pixcolor));
   \   0000007C   0xFA98 0xF098      REV16    R0,R8
   \   00000080   0xB280             UXTH     R0,R0
   \   00000082   0x.... 0x....      BL       _ZN4TLcd9WriteDataEt
    611          		}
   \   00000086   0xF109 0x0901      ADD      R9,R9,#+1
   \   0000008A   0xE7F3             B.N      ??PutBitmap_5
    612          	}
    613          }
   \                     ??PutBitmap_3: (+1)
   \   0000008C   0xB005             ADD      SP,SP,#+20
   \   0000008E   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    614          

   \                                 In section .text, align 2, keep-with-next
    615          void TLcd::SetSysPal(uint16_t back, uint16_t front)
    616          {
    617          	SysPal[0] = back;
   \                     _ZN4TLcd9SetSysPalEtt: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable16_4
   \   00000002   0x8010             STRH     R0,[R2, #+0]
    618          	SysPal[1] = front;
   \   00000004   0x8051             STRH     R1,[R2, #+2]
    619          }
   \   00000006   0x4770             BX       LR               ;; return
    620          

   \                                 In section .text, align 2, keep-with-next
    621          void TLcd::ExchSysPal(void)
    622          {
    623            uint16_t tmp = SysPal[0];
   \                     _ZN4TLcd10ExchSysPalEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_4
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
    624          	SysPal[0] = SysPal[1];
   \   00000004   0x8842             LDRH     R2,[R0, #+2]
   \   00000006   0x8002             STRH     R2,[R0, #+0]
    625          	SysPal[1] = tmp;
   \   00000008   0x8041             STRH     R1,[R0, #+2]
    626          }
   \   0000000A   0x4770             BX       LR               ;; return
    627          

   \                                 In section .text, align 2, keep-with-next
    628          void TLcd::FillRectangle( uint16_t x, uint16_t y, uint16_t dx, uint16_t dy, uint16_t color )
    629          {
   \                     _ZN4TLcd13FillRectangleEttttt: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4615             MOV      R5,R2
   \   00000004   0x461E             MOV      R6,R3
    630          	SetPos( x, y, dx, dy );
   \   00000006   0x.... 0x....      BL       _ZN4TLcd6SetPosEtttt
    631          	WriteCmd(TFT_RAMWR);
   \   0000000A   0x202C             MOVS     R0,#+44
   \   0000000C   0x.... 0x....      BL       _ZN4TLcd8WriteCmdEh
    632          	for(int pa=0; pa < dx * dy; pa++ ) 
   \   00000010   0x2700             MOVS     R7,#+0
   \   00000012   0x9C06             LDR      R4,[SP, #+24]
   \   00000014   0xE004             B.N      ??FillRectangle_0
    633          	{
    634          		WriteData((uint16_t) __REV16(color));
   \                     ??FillRectangle_1: (+1)
   \   00000016   0xBA60             REV16    R0,R4
   \   00000018   0xB280             UXTH     R0,R0
   \   0000001A   0x.... 0x....      BL       _ZN4TLcd9WriteDataEt
    635          	}
   \   0000001E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??FillRectangle_0: (+1)
   \   00000020   0xFB06 0xF005      MUL      R0,R6,R5
   \   00000024   0x4287             CMP      R7,R0
   \   00000026   0xDBF6             BLT.N    ??FillRectangle_1
    636          }
   \   00000028   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    637          

   \                                 In section .text, align 2, keep-with-next
    638          void TLcd::ReadData( uint8_t cmd, uint8_t data_size, uint8_t *data)
    639          {
   \                     _ZN4TLcd8ReadDataEhhPh: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x4615             MOV      R5,R2
    640            DISP_DC_PORT->BSRRH = DISP_DC_PIN;
   \   00000006   0x....             LDR.N    R1,??DataTable16_5  ;; 0x40020014
   \   00000008   0xF44F 0x7200      MOV      R2,#+512
   \   0000000C   0x80CA             STRH     R2,[R1, #+6]
    641            DISP_CS_PORT->BSRRH = DISP_CS_PIN;
   \   0000000E   0xF44F 0x5380      MOV      R3,#+4096
   \   00000012   0x80CB             STRH     R3,[R1, #+6]
    642            lcdSendByte( cmd );
   \   00000014   0xF44F 0x6300      MOV      R3,#+2048
   \   00000018   0x80CB             STRH     R3,[R1, #+6]
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   \   0000001C   0x808B             STRH     R3,[R1, #+4]
    643            DISP_DC_PORT->BSRRL = DISP_DC_PIN;
   \   0000001E   0x808A             STRH     R2,[R1, #+4]
    644            lcdReciveByte();
   \   00000020   0x.... 0x....      BL       _ZN4TLcd13lcdReciveByteEv
    645            for (uint8_t i=0; i < data_size; i++)
   \   00000024   0x2600             MOVS     R6,#+0
   \   00000026   0xE003             B.N      ??ReadData_0
    646            {
    647              data[i] = lcdReciveByte();
   \                     ??ReadData_1: (+1)
   \   00000028   0x.... 0x....      BL       _ZN4TLcd13lcdReciveByteEv
   \   0000002C   0x5570             STRB     R0,[R6, R5]
    648            }
   \   0000002E   0x1C76             ADDS     R6,R6,#+1
   \                     ??ReadData_0: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6
   \   00000032   0x42A6             CMP      R6,R4
   \   00000034   0xD3F8             BCC.N    ??ReadData_1
    649          }
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    650          

   \                                 In section .text, align 2, keep-with-next
    651          uint8_t TLcd::lcdReciveByte(void)
    652          {
   \                     _ZN4TLcd13lcdReciveByteEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    653            volatile uint8_t byte;
    654            uint8_t* idrptr = (uint8_t*) &DISP_D0_PORT->IDR;
    655          
    656            DISP_D0_PORT->MODER = DISP_D0_PORT->MODER & 0xFFFF0000;
   \   00000002   0x....             LDR.N    R4,??DataTable16_1  ;; 0x40020000
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x0C00             LSRS     R0,R0,#+16
   \   00000008   0x0400             LSLS     R0,R0,#+16
   \   0000000A   0x6020             STR      R0,[R4, #+0]
    657          
    658            DISP_RD_PORT->BSRRH = DISP_RD_PIN;
   \   0000000C   0xF44F 0x6580      MOV      R5,#+1024
   \   00000010   0x8365             STRH     R5,[R4, #+26]
    659          	__delay_cycles(2);
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x.... 0x....      BL       _Z14__delay_cyclesi
    660            byte = *idrptr;
   \   00000018   0x7C20             LDRB     R0,[R4, #+16]
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    661            DISP_RD_PORT->BSRRL = DISP_RD_PIN;
   \   0000001E   0x8325             STRH     R5,[R4, #+24]
    662          	__delay_cycles(1);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       _Z14__delay_cyclesi
    663          
    664            DISP_D0_PORT->MODER = DISP_D0_PORT->MODER | 0x00005555;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0xF440 0x40AA      ORR      R0,R0,#0x5500
   \   0000002C   0xF040 0x0055      ORR      R0,R0,#0x55
   \   00000030   0x6020             STR      R0,[R4, #+0]
    665          
    666            return byte;
   \   00000032   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    667          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x3F010000         DC32     0x3f010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x0001E848         DC32     0x1e848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     SysPal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x54 0x8A          DC8 84, 138, 39, 0
   \              0x27 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x0000 0x0001      DC16 0, 1, 3, 7, 15, 31, 63, 127, 255
   \              0x0003 0x0007
   \              0x000F 0x001F
   \              0x003F 0x007F
   \              0x00FF       
   \   00000012   0x00 0x00          DC8 0, 0
    668          
    669          /*----------------------------------------------------------------------------------*/
    670          /* x1, y1 -  ; x2, y2 -  							*/
    671          /*----------------------------------------------------------------------------------*/
    672          /*
    673          void TLcd::Line( int x1, int y1, int x2, int y2, int action )
    674          {
    675          	int dx = ( x2 - x1 >= 0 ? 1 : -1 );
    676          	int dy = ( y2 - y1 >= 0 ? 1 : -1 );
    677          
    678          	int lengthX = abs( x2 - x1 );
    679          	int lengthY = abs( y2 - y1 );
    680          
    681          	int length = MAX( lengthX, lengthY );
    682          
    683          	if( length == 0 ){
    684          		PutPixel( x1, y1, action );
    685          	}
    686          
    687          	if( lengthY <= lengthX ){
    688          		//   
    689          		int x = x1;
    690          		int y = y1;
    691          		int d = -lengthX;
    692          
    693          		//   
    694          		length++;
    695          		while( length-- ){
    696          			PutPixel( x, y, action );
    697          			x += dx;
    698          			d += 2 * lengthY;
    699          			if( d > 0 ){
    700          				d -= 2 * lengthX;
    701          				y += dy;
    702          			}
    703          		}
    704          	}
    705          	else {
    706          		//   
    707          		int x = x1;
    708          		int y = y1;
    709          		int d = - lengthY;
    710          
    711          		//  
    712          		length++;
    713          		while( length-- ){
    714          			PutPixel( x, y, action );
    715          			y += dy;
    716          			d += 2 * lengthX;
    717          			if( d > 0 ){
    718          				d -= 2 * lengthY;
    719          				x += dx;
    720          			}
    721          		}
    722          	}
    723          	x_curr_pos = x2;
    724          	y_curr_pos = y2;
    725          }
    726          */
    727          
    728          /*
    729          bool TLcd::CheckBuff( int Indx )
    730          {
    731          	if( Indx >= ( 128 * 64 / 8 )) return false;
    732          
    733          	if( OffscreenBuff0[ Indx ] != OffscreenBuff1[ Indx ]){
    734          		return true;
    735          	}
    736          	return false;
    737          }
    738          
    739          
    740          
    741          void TLcd::ClearScreen( void )
    742          {
    743          	ClearSrcBuffer( OffscreenBuff0 );
    744          }
    745          
    746          void TLcd::ClearBackScreen()
    747          {
    748          	ClearSrcBuffer( OffscreenBuff1 );
    749          }
    750          */
    751          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   TLcd::CSPin(bool)
         0   -> GPIO_ResetBits
       0   TLcd::ColorInversion(bool)
         0   -> TLcd::WriteCmd(uint8_t)
       0   TLcd::DCPin(bool)
         0   -> GPIO_ResetBits
       0   TLcd::ExchSysPal()
      24   TLcd::FillRectangle(uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)
        24   -> TLcd::SetPos(uint16_t, uint16_t, uint16_t, uint16_t)
        24   -> TLcd::WriteCmd(uint8_t)
        24   -> TLcd::WriteData(uint16_t)
      24   TLcd::LCD_Init()
        24   -> TLcd::LcdBL(bool)
        24   -> TLcd::LcdClear()
        24   -> TLcd::RESPin(bool)
        24   -> TLcd::ReadData(uint8_t, uint8_t, uint8_t *)
        24   -> TLcd::SetSysPal(uint16_t, uint16_t)
        24   -> TLcd::WriteCmd(uint8_t)
        24   -> TLcd::WriteCmd(uint8_t, uint8_t)
        24   -> TLcd::WriteData(uint8_t)
        24   -> __delay_cycles(int)
       8   TLcd::LcdBL(bool)
         8   -> GPIO_ResetBits
         0   -> TLcd::WriteCmd(uint8_t)
         8   -> TLcd::WriteCmd(uint8_t)
       8   TLcd::LcdClear()
         8   -> TLcd::WriteCmd(uint8_t)
         8   -> TLcd::WriteData(uint16_t)
         8   -> TLcd::WriteData(uint32_t)
       0   TLcd::LcdEnable(bool)
         0   -> GPIO_SetBits
      24   TLcd::LcdPHYDeInit()
        24   -> GPIO_Init
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> TLcd::LcdBL(bool)
        24   -> TLcd::LcdEnable(bool)
      24   TLcd::LcdPHYInit()
        24   -> GPIO_Init
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> RCC_AHB1PeriphClockCmd
        24   -> TLcd::LcdBL(bool)
        24   -> TLcd::LcdEnable(bool)
      48   TLcd::PutBitmap(uint16_t, uint16_t, TBitMap const *)
        48   -> TLcd::SetPos(uint16_t, uint16_t, uint16_t, uint16_t)
        48   -> TLcd::WriteCmd(uint8_t)
        48   -> TLcd::WriteData(uint16_t)
        48   -> __aeabi_memcpy4
       8   TLcd::PutPixel(uint16_t, uint16_t, uint16_t)
         8   -> TLcd::SetPos(uint16_t, uint16_t, uint16_t, uint16_t)
         8   -> TLcd::WriteCmd(uint8_t)
         0   -> TLcd::WriteData(uint16_t)
       0   TLcd::RDPin(bool)
         0   -> GPIO_ResetBits
       0   TLcd::RESPin(bool)
         0   -> GPIO_ResetBits
      16   TLcd::ReadData(uint8_t, uint8_t, uint8_t *)
        16   -> TLcd::lcdReciveByte()
      16   TLcd::SetPos(uint16_t, uint16_t)
        16   -> TLcd::WriteCmd(uint8_t)
         0   -> TLcd::WriteData(uint8_t)
        16   -> TLcd::WriteData(uint8_t)
      24   TLcd::SetPos(uint16_t, uint16_t, uint16_t, uint16_t)
        24   -> TLcd::WriteCmd(uint8_t)
         0   -> TLcd::WriteData(uint8_t)
        24   -> TLcd::WriteData(uint8_t)
       0   TLcd::SetSysPal(uint16_t, uint16_t)
       0   TLcd::WRPin(bool)
         0   -> GPIO_ResetBits
       0   TLcd::WriteCmd(uint8_t)
       4   TLcd::WriteCmd(uint8_t, uint8_t)
       0   TLcd::WriteData(uint16_t)
       4   TLcd::WriteData(uint32_t)
       0   TLcd::WriteData(uint8_t)
      16   TLcd::lcdReciveByte()
        16   -> __delay_cycles(int)
       4   __delay_cycles(int)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ?_0
      20  ?_1
       4  SysPal
      22  TLcd::CSPin(bool)
      16  TLcd::ColorInversion(bool)
      22  TLcd::DCPin(bool)
      12  TLcd::ExchSysPal()
      42  TLcd::FillRectangle(uint16_t, uint16_t, uint16_t, uint16_t, uint16_t)
     294  TLcd::LCD_Init()
      46  TLcd::LcdBL(bool)
      54  TLcd::LcdClear()
      22  TLcd::LcdEnable(bool)
       1  TLcd::LcdOff
     424  TLcd::LcdPHYDeInit()
     400  TLcd::LcdPHYInit()
     146  TLcd::PutBitmap(uint16_t, uint16_t, TBitMap const *)
      34  TLcd::PutPixel(uint16_t, uint16_t, uint16_t)
      22  TLcd::RDPin(bool)
      24  TLcd::RESPin(bool)
      56  TLcd::ReadData(uint8_t, uint8_t, uint8_t *)
      78  TLcd::SetPos(uint16_t, uint16_t)
      98  TLcd::SetPos(uint16_t, uint16_t, uint16_t, uint16_t)
       8  TLcd::SetSysPal(uint16_t, uint16_t)
      22  TLcd::WRPin(bool)
      32  TLcd::WriteCmd(uint8_t)
      44  TLcd::WriteCmd(uint8_t, uint8_t)
      40  TLcd::WriteData(uint16_t)
      60  TLcd::WriteData(uint32_t)
      32  TLcd::WriteData(uint8_t)
      56  TLcd::lcdReciveByte()
      20  __delay_cycles(int)

 
     5 bytes in section .bss
 2 174 bytes in section .text
 
 1 946 bytes of CODE memory (+ 228 bytes shared)
     5 bytes of DATA memory

Errors: none
Warnings: none
