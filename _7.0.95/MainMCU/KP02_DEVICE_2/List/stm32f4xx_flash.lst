###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        08/Oct/2018  17:04:46
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_flash.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_flash.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *            + FLASH Interface configuration
     10            *            + FLASH Memory Programming
     11            *            + Option Bytes Programming
     12            *            + Interrupts and flags management
     13            *  
     14           @verbatim    
     15           ===============================================================================
     16                                  ##### How to use this driver #####
     17           ===============================================================================
     18              [..]                             
     19                This driver provides functions to configure and program the FLASH memory 
     20                of all STM32F4xx devices. These functions are split in 4 groups:
     21             
     22                (#) FLASH Interface configuration functions: this group includes the
     23                    management of the following features:
     24                  (++) Set the latency
     25                  (++) Enable/Disable the prefetch buffer
     26                  (++) Enable/Disable the Instruction cache and the Data cache
     27                  (++) Reset the Instruction cache and the Data cache
     28              
     29                (#) FLASH Memory Programming functions: this group includes all needed
     30                    functions to erase and program the main memory:
     31                  (++) Lock and Unlock the FLASH interface
     32                  (++) Erase function: Erase sector, erase all sectors
     33                  (++) Program functions: byte, half word, word and double word
     34              
     35                (#) Option Bytes Programming functions: this group includes all needed
     36                    functions to manage the Option Bytes:
     37                  (++) Set/Reset the write protection
     38                  (++) Set the Read protection Level
     39                  (++) Set the BOR level
     40                  (++) Program the user Option Bytes
     41                  (++) Launch the Option Bytes loader
     42              
     43                (#) Interrupts and flags management functions: this group 
     44                    includes all needed functions to:
     45                  (++) Enable/Disable the FLASH interrupt sources
     46                  (++) Get flags status
     47                  (++) Clear flags
     48                  (++) Get FLASH operation status
     49                  (++) Wait for last FLASH operation   
     50           @endverbatim                      
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     55            *
     56            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     57            * You may not use this file except in compliance with the License.
     58            * You may obtain a copy of the License at:
     59            *
     60            *        http://www.st.com/software_license_agreement_liberty_v2
     61            *
     62            * Unless required by applicable law or agreed to in writing, software 
     63            * distributed under the License is distributed on an "AS IS" BASIS, 
     64            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     65            * See the License for the specific language governing permissions and
     66            * limitations under the License.
     67            *
     68            ******************************************************************************
     69            */
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32f4xx_flash.h"
     73          
     74          /** @addtogroup STM32F4xx_StdPeriph_Driver
     75            * @{
     76            */
     77          
     78          /** @defgroup FLASH 
     79            * @brief FLASH driver modules
     80            * @{
     81            */ 
     82          
     83          /* Private typedef -----------------------------------------------------------*/
     84          /* Private define ------------------------------------------------------------*/ 
     85          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     86          
     87          /* Private macro -------------------------------------------------------------*/
     88          /* Private variables ---------------------------------------------------------*/
     89          /* Private function prototypes -----------------------------------------------*/
     90          /* Private functions ---------------------------------------------------------*/
     91          
     92          /** @defgroup FLASH_Private_Functions
     93            * @{
     94            */ 
     95          
     96          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
     97            *  @brief   FLASH Interface configuration functions 
     98           *
     99          
    100          @verbatim   
    101           ===============================================================================
    102                        ##### FLASH Interface configuration functions #####
    103           ===============================================================================
    104              [..]
    105                This group includes the following functions:
    106                (+) void FLASH_SetLatency(uint32_t FLASH_Latency)
    107                    To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    108                    must be correctly programmed according to the frequency of the CPU clock 
    109                    (HCLK) and the supply voltage of the device.
    110              [..]      
    111                For STM32F405xx/07xx and STM32F415xx/17xx devices
    112           +-------------------------------------------------------------------------------------+     
    113           | Latency       |                HCLK clock frequency (MHz)                           |
    114           |               |---------------------------------------------------------------------|     
    115           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    116           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    117           |---------------|----------------|----------------|-----------------|-----------------|              
    118           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    119           |---------------|----------------|----------------|-----------------|-----------------|   
    120           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    121           |---------------|----------------|----------------|-----------------|-----------------|   
    122           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    123           |---------------|----------------|----------------|-----------------|-----------------| 
    124           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    125           |---------------|----------------|----------------|-----------------|-----------------| 
    126           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    127           |---------------|----------------|----------------|-----------------|-----------------| 
    128           |5WS(6CPU cycle)|150< HCLK <= 168|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    129           |---------------|----------------|----------------|-----------------|-----------------| 
    130           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    131           |---------------|----------------|----------------|-----------------|-----------------| 
    132           |7WS(8CPU cycle)|      NA        |      NA        |154 < HCLK <= 168|140 < HCLK <= 160|
    133           +---------------|----------------|----------------|-----------------|-----------------+ 
    134          
    135              [..]      
    136                For STM32F42xxx/43xxx devices
    137           +-------------------------------------------------------------------------------------+     
    138           | Latency       |                HCLK clock frequency (MHz)                           |
    139           |               |---------------------------------------------------------------------|     
    140           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    141           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    142           |---------------|----------------|----------------|-----------------|-----------------|              
    143           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    144           |---------------|----------------|----------------|-----------------|-----------------|   
    145           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    146           |---------------|----------------|----------------|-----------------|-----------------|   
    147           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    148           |---------------|----------------|----------------|-----------------|-----------------| 
    149           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |66 < HCLK <= 88  |60 < HCLK <= 80  |
    150           |---------------|----------------|----------------|-----------------|-----------------| 
    151           |4WS(5CPU cycle)|120< HCLK <= 150|96 < HCLK <= 120|88 < HCLK <= 110 |80 < HCLK <= 100 |
    152           |---------------|----------------|----------------|-----------------|-----------------| 
    153           |5WS(6CPU cycle)|120< HCLK <= 180|120< HCLK <= 144|110 < HCLK <= 132|100 < HCLK <= 120| 
    154           |---------------|----------------|----------------|-----------------|-----------------| 
    155           |6WS(7CPU cycle)|      NA        |144< HCLK <= 168|132 < HCLK <= 154|120 < HCLK <= 140| 
    156           |---------------|----------------|----------------|-----------------|-----------------| 
    157           |7WS(8CPU cycle)|      NA        |168< HCLK <= 180|154 < HCLK <= 176|140 < HCLK <= 160|
    158           |---------------|----------------|----------------|-----------------|-----------------| 
    159           |8WS(9CPU cycle)|      NA        |      NA        |176 < HCLK <= 180|160 < HCLK <= 168|
    160           +-------------------------------------------------------------------------------------+
    161             
    162              [..]
    163              For STM32F401x devices
    164           +-------------------------------------------------------------------------------------+     
    165           | Latency       |                HCLK clock frequency (MHz)                           |
    166           |               |---------------------------------------------------------------------|     
    167           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    168           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    169           |---------------|----------------|----------------|-----------------|-----------------|              
    170           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 22   |0 < HCLK <= 20   |
    171           |---------------|----------------|----------------|-----------------|-----------------|   
    172           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |22 < HCLK <= 44  |20 < HCLK <= 40  | 
    173           |---------------|----------------|----------------|-----------------|-----------------|   
    174           |2WS(3CPU cycle)|60 < HCLK <= 84 |48 < HCLK <= 72 |44 < HCLK <= 66  |40 < HCLK <= 60  |
    175           |---------------|----------------|----------------|-----------------|-----------------| 
    176           |3WS(4CPU cycle)|      NA        |72 < HCLK <= 84 |66 < HCLK <= 84  |60 < HCLK <= 80  |
    177           |---------------|----------------|----------------|-----------------|-----------------| 
    178           |4WS(5CPU cycle)|      NA        |      NA        |      NA         |80 < HCLK <= 84  | 
    179           +-------------------------------------------------------------------------------------+ 
    180           
    181           [..]
    182           +-------------------------------------------------------------------------------------------------------------------+
    183           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    184           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
    185           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------| 
    186           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |              
    187           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|   
    188           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    189           +-------------------------------------------------------------------------------------------------------------------+  
    190          
    191                -@- On STM32F405xx/407xx and STM32F415xx/417xx devices: 
    192                     (++) when VOS = '0' Scale 2 mode, the maximum value of fHCLK = 144MHz. 
    193                     (++) when VOS = '1' Scale 1 mode, the maximum value of fHCLK = 168MHz. 
    194                    [..] 
    195                    On STM32F42xxx/43xxx devices:
    196                     (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 120MHz.
    197                     (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 144MHz if OverDrive OFF and 168MHz if OverDrive ON.
    198                     (++) when VOS[1:0] = '0x11' Scale 1 mode, the maximum value of fHCLK is 168MHz if OverDrive OFF and 180MHz if OverDrive ON. 
    199                    [..]  
    200                    On STM32F401x devices:
    201                     (++) when VOS[1:0] = '0x01' Scale 3 mode, the maximum value of fHCLK is 60MHz.
    202                     (++) when VOS[1:0] = '0x10' Scale 2 mode, the maximum value of fHCLK is 84MHz.
    203                     For more details please refer product DataSheet 
    204                     You can use PWR_MainRegulatorModeConfig() function to control VOS bits.
    205                           
    206                (+) void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    207                (+) void FLASH_InstructionCacheCmd(FunctionalState NewState)
    208                (+) void FLASH_DataCacheCmd(FunctionalState NewState)
    209                (+) void FLASH_InstructionCacheReset(void)
    210                (+) void FLASH_DataCacheReset(void)
    211                
    212              [..]   
    213                The unlock sequence is not needed for these functions.
    214           
    215          @endverbatim
    216            * @{
    217            */
    218           
    219          /**
    220            * @brief  Sets the code latency value.  
    221            * @param  FLASH_Latency: specifies the FLASH Latency value.
    222            *          This parameter can be one of the following values:
    223            *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
    224            *            @arg FLASH_Latency_1: FLASH One Latency cycle
    225            *            @arg FLASH_Latency_2: FLASH Two Latency cycles
    226            *            @arg FLASH_Latency_3: FLASH Three Latency cycles
    227            *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
    228            *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
    229            *            @arg FLASH_Latency_6: FLASH Six Latency cycles
    230            *            @arg FLASH_Latency_7: FLASH Seven Latency cycles 
    231            *            @arg FLASH_Latency_8: FLASH Eight Latency cycles
    232            *            @arg FLASH_Latency_9: FLASH Nine Latency cycles
    233            *            @arg FLASH_Latency_10: FLASH Teen Latency cycles 
    234            *            @arg FLASH_Latency_11: FLASH Eleven Latency cycles 
    235            *            @arg FLASH_Latency_12: FLASH Twelve Latency cycles
    236            *            @arg FLASH_Latency_13: FLASH Thirteen Latency cycles        
    237            *            @arg FLASH_Latency_14: FLASH Fourteen Latency cycles
    238            *            @arg FLASH_Latency_15: FLASH Fifteen Latency cycles 
    239            *              
    240            * @note For STM32F405xx/407xx, STM32F415xx/417xx and STM32F401xx devices this parameter    
    241            *       can be a value between FLASH_Latency_0 and FLASH_Latency_7.
    242            *         
    243            * @note For STM32F42xxx/43xxx devices this parameter can be a value between 
    244            *       FLASH_Latency_0 and FLASH_Latency_15. 
    245            *         
    246            * @retval None
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          void FLASH_SetLatency(uint32_t FLASH_Latency)
    249          {
   \                     FLASH_SetLatency: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    250            /* Check the parameters */
    251            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
   \   00000004   0xD022             BEQ.N    ??FLASH_SetLatency_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD020             BEQ.N    ??FLASH_SetLatency_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD01E             BEQ.N    ??FLASH_SetLatency_0
   \   0000000E   0x2C03             CMP      R4,#+3
   \   00000010   0xD01C             BEQ.N    ??FLASH_SetLatency_0
   \   00000012   0x2C04             CMP      R4,#+4
   \   00000014   0xD01A             BEQ.N    ??FLASH_SetLatency_0
   \   00000016   0x2C05             CMP      R4,#+5
   \   00000018   0xD018             BEQ.N    ??FLASH_SetLatency_0
   \   0000001A   0x2C06             CMP      R4,#+6
   \   0000001C   0xD016             BEQ.N    ??FLASH_SetLatency_0
   \   0000001E   0x2C07             CMP      R4,#+7
   \   00000020   0xD014             BEQ.N    ??FLASH_SetLatency_0
   \   00000022   0x2C08             CMP      R4,#+8
   \   00000024   0xD012             BEQ.N    ??FLASH_SetLatency_0
   \   00000026   0x2C09             CMP      R4,#+9
   \   00000028   0xD010             BEQ.N    ??FLASH_SetLatency_0
   \   0000002A   0x2C0A             CMP      R4,#+10
   \   0000002C   0xD00E             BEQ.N    ??FLASH_SetLatency_0
   \   0000002E   0x2C0B             CMP      R4,#+11
   \   00000030   0xD00C             BEQ.N    ??FLASH_SetLatency_0
   \   00000032   0x2C0C             CMP      R4,#+12
   \   00000034   0xD00A             BEQ.N    ??FLASH_SetLatency_0
   \   00000036   0x2C0D             CMP      R4,#+13
   \   00000038   0xD008             BEQ.N    ??FLASH_SetLatency_0
   \   0000003A   0x2C0E             CMP      R4,#+14
   \   0000003C   0xD006             BEQ.N    ??FLASH_SetLatency_0
   \   0000003E   0x2C0F             CMP      R4,#+15
   \   00000040   0xD004             BEQ.N    ??FLASH_SetLatency_0
   \   00000042   0x21FB             MOVS     R1,#+251
   \   00000044   0x.... 0x....      ADR.W    R0,?_0
   \   00000048   0x.... 0x....      BL       assert_failed
    252            
    253            /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    254            *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
   \                     ??FLASH_SetLatency_0: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40023c00
   \   00000050   0x7004             STRB     R4,[R0, #+0]
    255          }
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    256          
    257          /**
    258            * @brief  Enables or disables the Prefetch Buffer.
    259            * @param  NewState: new state of the Prefetch Buffer.
    260            *          This parameter  can be: ENABLE or DISABLE.
    261            * @retval None
    262            */

   \                                 In section .text, align 2, keep-with-next
    263          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    264          {
   \                     FLASH_PrefetchBufferCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    265            /* Check the parameters */
    266            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??FLASH_PrefetchBufferCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??FLASH_PrefetchBufferCmd_0
   \   0000000A   0xF44F 0x7185      MOV      R1,#+266
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    267            
    268            /* Enable or disable the Prefetch Buffer */
    269            if(NewState != DISABLE)
   \                     ??FLASH_PrefetchBufferCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40023c00
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??FLASH_PrefetchBufferCmd_1
    270            {
    271              FLASH->ACR |= FLASH_ACR_PRFTEN;
   \   00000020   0xF441 0x7180      ORR      R1,R1,#0x100
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
    272            }
    273            else
    274            {
    275              FLASH->ACR &= (~FLASH_ACR_PRFTEN);
   \                     ??FLASH_PrefetchBufferCmd_1: (+1)
   \   00000028   0xF421 0x7180      BIC      R1,R1,#0x100
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    276            }
    277          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    278          
    279          /**
    280            * @brief  Enables or disables the Instruction Cache feature.
    281            * @param  NewState: new state of the Instruction Cache.
    282            *          This parameter  can be: ENABLE or DISABLE.
    283            * @retval None
    284            */

   \                                 In section .text, align 2, keep-with-next
    285          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    286          {
   \                     FLASH_InstructionCacheCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    287            /* Check the parameters */
    288            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??FLASH_InstructionCacheCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??FLASH_InstructionCacheCmd_0
   \   0000000A   0xF44F 0x7190      MOV      R1,#+288
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    289            
    290            if(NewState != DISABLE)
   \                     ??FLASH_InstructionCacheCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40023c00
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??FLASH_InstructionCacheCmd_1
    291            {
    292              FLASH->ACR |= FLASH_ACR_ICEN;
   \   00000020   0xF441 0x7100      ORR      R1,R1,#0x200
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
    293            }
    294            else
    295            {
    296              FLASH->ACR &= (~FLASH_ACR_ICEN);
   \                     ??FLASH_InstructionCacheCmd_1: (+1)
   \   00000028   0xF421 0x7100      BIC      R1,R1,#0x200
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    297            }
    298          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    299          
    300          /**
    301            * @brief  Enables or disables the Data Cache feature.
    302            * @param  NewState: new state of the Data Cache.
    303            *          This parameter  can be: ENABLE or DISABLE.
    304            * @retval None
    305            */

   \                                 In section .text, align 2, keep-with-next
    306          void FLASH_DataCacheCmd(FunctionalState NewState)
    307          {
   \                     FLASH_DataCacheCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    308            /* Check the parameters */
    309            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??FLASH_DataCacheCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??FLASH_DataCacheCmd_0
   \   0000000A   0xF240 0x1135      MOVW     R1,#+309
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    310            
    311            if(NewState != DISABLE)
   \                     ??FLASH_DataCacheCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40023c00
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??FLASH_DataCacheCmd_1
    312            {
    313              FLASH->ACR |= FLASH_ACR_DCEN;
   \   00000020   0xF441 0x6180      ORR      R1,R1,#0x400
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
    314            }
    315            else
    316            {
    317              FLASH->ACR &= (~FLASH_ACR_DCEN);
   \                     ??FLASH_DataCacheCmd_1: (+1)
   \   00000028   0xF421 0x6180      BIC      R1,R1,#0x400
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    318            }
    319          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    320          
    321          /**
    322            * @brief  Resets the Instruction Cache.
    323            * @note   This function must be used only when the Instruction Cache is disabled.  
    324            * @param  None
    325            * @retval None
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void FLASH_InstructionCacheReset(void)
    328          {
    329            FLASH->ACR |= FLASH_ACR_ICRST;
   \                     FLASH_InstructionCacheReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40023c00
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF441 0x6100      ORR      R1,R1,#0x800
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    330          }
   \   0000000C   0x4770             BX       LR               ;; return
    331          
    332          /**
    333            * @brief  Resets the Data Cache.
    334            * @note   This function must be used only when the Data Cache is disabled.  
    335            * @param  None
    336            * @retval None
    337            */

   \                                 In section .text, align 2, keep-with-next
    338          void FLASH_DataCacheReset(void)
    339          {
    340            FLASH->ACR |= FLASH_ACR_DCRST;
   \                     FLASH_DataCacheReset: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39  ;; 0x40023c00
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    341          }
   \   0000000C   0x4770             BX       LR               ;; return
    342          
    343          /**
    344            * @}
    345            */
    346          
    347          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    348           *  @brief   FLASH Memory Programming functions
    349           *
    350          @verbatim   
    351           ===============================================================================
    352                          ##### FLASH Memory Programming functions #####
    353           ===============================================================================   
    354              [..]
    355                This group includes the following functions:
    356                (+) void FLASH_Unlock(void)
    357                (+) void FLASH_Lock(void)
    358                (+) FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    359                (+) FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)       
    360                (+) FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    361                (+) FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    362                (+) FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    363                (+) FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    364                    The following functions can be used only for STM32F42xxx/43xxx devices. 
    365                (+) FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
    366                (+) FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)    
    367              [..]   
    368                Any operation of erase or program should follow these steps:
    369                (#) Call the FLASH_Unlock() function to enable the FLASH control register access
    370          
    371                (#) Call the desired function to erase sector(s) or program data
    372          
    373                (#) Call the FLASH_Lock() function to disable the FLASH control register access
    374                    (recommended to protect the FLASH memory against possible unwanted operation)
    375              
    376          @endverbatim
    377            * @{
    378            */
    379          
    380          /**
    381            * @brief  Unlocks the FLASH control register access
    382            * @param  None
    383            * @retval None
    384            */

   \                                 In section .text, align 2, keep-with-next
    385          void FLASH_Unlock(void)
    386          {
    387            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
   \                     FLASH_Unlock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_1  ;; 0x40023c04
   \   00000004   0x68C1             LDR      R1,[R0, #+12]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD505             BPL.N    ??FLASH_Unlock_0
    388            {
    389              /* Authorize the FLASH Registers access */
    390              FLASH->KEYR = FLASH_KEY1;
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable39_2  ;; 0x45670123
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    391              FLASH->KEYR = FLASH_KEY2;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable39_3  ;; 0xcdef89ab
   \   00000014   0x6001             STR      R1,[R0, #+0]
    392            }  
    393          }
   \                     ??FLASH_Unlock_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    394          
    395          /**
    396            * @brief  Locks the FLASH control register access
    397            * @param  None
    398            * @retval None
    399            */

   \                                 In section .text, align 2, keep-with-next
    400          void FLASH_Lock(void)
    401          {
    402            /* Set the LOCK Bit to lock the FLASH Registers access */
    403            FLASH->CR |= FLASH_CR_LOCK;
   \                     FLASH_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_4  ;; 0x40023c10
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    404          }
   \   0000000C   0x4770             BX       LR               ;; return
    405          
    406          /**
    407            * @brief  Erases a specified FLASH Sector.
    408            *
    409            * @note   If an erase and a program operations are requested simustaneously,    
    410            *         the erase operation is performed before the program one.
    411            *   
    412            * @param  FLASH_Sector: The Sector number to be erased.
    413            *
    414            *  @note  For STM32F405xx/407xx and STM32F415xx/417xx devices this parameter can 
    415            *         be a value between FLASH_Sector_0 and FLASH_Sector_11.
    416            *           
    417            *         For STM32F42xxx/43xxx devices this parameter can be a value between 
    418            *         FLASH_Sector_0 and FLASH_Sector_23.
    419            *           
    420            *         For STM32F401xx devices this parameter can be a value between 
    421            *         FLASH_Sector_0 and FLASH_Sector_5.             
    422            *    
    423            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    424            *          This parameter can be one of the following values:
    425            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    426            *                                  the operation will be done by byte (8-bit) 
    427            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    428            *                                  the operation will be done by half word (16-bit)
    429            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    430            *                                  the operation will be done by word (32-bit)
    431            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    432            *                                  the operation will be done by double word (64-bit)
    433            *       
    434            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    435            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    436            */

   \                                 In section .text, align 2, keep-with-next
    437          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    438          {
   \                     FLASH_EraseSector: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    439            uint32_t tmp_psize = 0x0;
   \   00000006   0x2600             MOVS     R6,#+0
    440            FLASH_Status status = FLASH_COMPLETE;
    441          
    442            /* Check the parameters */
    443            assert_param(IS_FLASH_SECTOR(FLASH_Sector));
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD033             BEQ.N    ??FLASH_EraseSector_0
   \   0000000C   0x2C08             CMP      R4,#+8
   \   0000000E   0xD031             BEQ.N    ??FLASH_EraseSector_0
   \   00000010   0x2C10             CMP      R4,#+16
   \   00000012   0xD02F             BEQ.N    ??FLASH_EraseSector_0
   \   00000014   0x2C18             CMP      R4,#+24
   \   00000016   0xD02D             BEQ.N    ??FLASH_EraseSector_0
   \   00000018   0x2C20             CMP      R4,#+32
   \   0000001A   0xD02B             BEQ.N    ??FLASH_EraseSector_0
   \   0000001C   0x2C28             CMP      R4,#+40
   \   0000001E   0xD029             BEQ.N    ??FLASH_EraseSector_0
   \   00000020   0x2C30             CMP      R4,#+48
   \   00000022   0xD027             BEQ.N    ??FLASH_EraseSector_0
   \   00000024   0x2C38             CMP      R4,#+56
   \   00000026   0xD025             BEQ.N    ??FLASH_EraseSector_0
   \   00000028   0x2C40             CMP      R4,#+64
   \   0000002A   0xD023             BEQ.N    ??FLASH_EraseSector_0
   \   0000002C   0x2C48             CMP      R4,#+72
   \   0000002E   0xD021             BEQ.N    ??FLASH_EraseSector_0
   \   00000030   0x2C50             CMP      R4,#+80
   \   00000032   0xD01F             BEQ.N    ??FLASH_EraseSector_0
   \   00000034   0x2C58             CMP      R4,#+88
   \   00000036   0xD01D             BEQ.N    ??FLASH_EraseSector_0
   \   00000038   0x2C80             CMP      R4,#+128
   \   0000003A   0xD01B             BEQ.N    ??FLASH_EraseSector_0
   \   0000003C   0x2C88             CMP      R4,#+136
   \   0000003E   0xD019             BEQ.N    ??FLASH_EraseSector_0
   \   00000040   0x2C90             CMP      R4,#+144
   \   00000042   0xD017             BEQ.N    ??FLASH_EraseSector_0
   \   00000044   0x2C98             CMP      R4,#+152
   \   00000046   0xD015             BEQ.N    ??FLASH_EraseSector_0
   \   00000048   0x2CA0             CMP      R4,#+160
   \   0000004A   0xD013             BEQ.N    ??FLASH_EraseSector_0
   \   0000004C   0x2CA8             CMP      R4,#+168
   \   0000004E   0xD011             BEQ.N    ??FLASH_EraseSector_0
   \   00000050   0x2CB0             CMP      R4,#+176
   \   00000052   0xD00F             BEQ.N    ??FLASH_EraseSector_0
   \   00000054   0x2CB8             CMP      R4,#+184
   \   00000056   0xD00D             BEQ.N    ??FLASH_EraseSector_0
   \   00000058   0x2CC0             CMP      R4,#+192
   \   0000005A   0xD00B             BEQ.N    ??FLASH_EraseSector_0
   \   0000005C   0x2CC8             CMP      R4,#+200
   \   0000005E   0xD009             BEQ.N    ??FLASH_EraseSector_0
   \   00000060   0x2CD0             CMP      R4,#+208
   \   00000062   0xD007             BEQ.N    ??FLASH_EraseSector_0
   \   00000064   0x2CD8             CMP      R4,#+216
   \   00000066   0xD005             BEQ.N    ??FLASH_EraseSector_0
   \   00000068   0xF240 0x11BB      MOVW     R1,#+443
   \   0000006C   0x.... 0x....      ADR.W    R0,?_0
   \   00000070   0x.... 0x....      BL       assert_failed
    444            assert_param(IS_VOLTAGERANGE(VoltageRange));
   \                     ??FLASH_EraseSector_0: (+1)
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD00C             BEQ.N    ??FLASH_EraseSector_1
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD009             BEQ.N    ??FLASH_EraseSector_1
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD007             BEQ.N    ??FLASH_EraseSector_1
   \   00000082   0x2803             CMP      R0,#+3
   \   00000084   0xD005             BEQ.N    ??FLASH_EraseSector_1
   \   00000086   0xF44F 0x71DE      MOV      R1,#+444
   \   0000008A   0x.... 0x....      ADR.W    R0,?_0
   \   0000008E   0x.... 0x....      BL       assert_failed
    445            
    446            if(VoltageRange == VoltageRange_1)
   \                     ??FLASH_EraseSector_1: (+1)
   \   00000092   0x2D00             CMP      R5,#+0
   \   00000094   0xD00C             BEQ.N    ??FLASH_EraseSector_2
    447            {
    448               tmp_psize = FLASH_PSIZE_BYTE;
    449            }
    450            else if(VoltageRange == VoltageRange_2)
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD102             BNE.N    ??FLASH_EraseSector_3
    451            {
    452              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   0000009C   0xF44F 0x7680      MOV      R6,#+256
   \   000000A0   0xE006             B.N      ??FLASH_EraseSector_2
    453            }
    454            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseSector_3: (+1)
   \   000000A2   0x2802             CMP      R0,#+2
   \   000000A4   0xD102             BNE.N    ??FLASH_EraseSector_4
    455            {
    456              tmp_psize = FLASH_PSIZE_WORD;
   \   000000A6   0xF44F 0x7600      MOV      R6,#+512
   \   000000AA   0xE001             B.N      ??FLASH_EraseSector_2
    457            }
    458            else
    459            {
    460              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseSector_4: (+1)
   \   000000AC   0xF44F 0x7640      MOV      R6,#+768
    461            }
    462            /* Wait for last operation to be completed */
    463            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_EraseSector_2: (+1)
   \   000000B0   0x.... 0x....      BL       FLASH_WaitForLastOperation
    464            
    465            if(status == FLASH_COMPLETE)
   \   000000B4   0x2809             CMP      R0,#+9
   \   000000B6   0xD11F             BNE.N    ??FLASH_EraseSector_5
    466            { 
    467              /* if the previous operation is completed, proceed to erase the sector */
    468              FLASH->CR &= CR_PSIZE_MASK;
   \   000000B8   0x.... 0x....      LDR.W    R5,??DataTable39_4  ;; 0x40023c10
   \   000000BC   0x6828             LDR      R0,[R5, #+0]
   \   000000BE   0xF420 0x7040      BIC      R0,R0,#0x300
   \   000000C2   0x6028             STR      R0,[R5, #+0]
    469              FLASH->CR |= tmp_psize;
   \   000000C4   0x6828             LDR      R0,[R5, #+0]
   \   000000C6   0x4330             ORRS     R0,R6,R0
   \   000000C8   0x6028             STR      R0,[R5, #+0]
    470              FLASH->CR &= SECTOR_MASK;
   \   000000CA   0x6828             LDR      R0,[R5, #+0]
   \   000000CC   0xF020 0x00F8      BIC      R0,R0,#0xF8
   \   000000D0   0x6028             STR      R0,[R5, #+0]
    471              FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
   \   000000D2   0x6828             LDR      R0,[R5, #+0]
   \   000000D4   0xF044 0x0102      ORR      R1,R4,#0x2
   \   000000D8   0x4308             ORRS     R0,R1,R0
   \   000000DA   0x6028             STR      R0,[R5, #+0]
    472              FLASH->CR |= FLASH_CR_STRT;
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   000000E2   0x6028             STR      R0,[R5, #+0]
    473              
    474              /* Wait for last operation to be completed */
    475              status = FLASH_WaitForLastOperation();
   \   000000E4   0x.... 0x....      BL       FLASH_WaitForLastOperation
    476              
    477              /* if the erase operation is completed, disable the SER Bit */
    478              FLASH->CR &= (~FLASH_CR_SER);
   \   000000E8   0x6829             LDR      R1,[R5, #+0]
   \   000000EA   0xF021 0x0102      BIC      R1,R1,#0x2
   \   000000EE   0x6029             STR      R1,[R5, #+0]
    479              FLASH->CR &= SECTOR_MASK; 
   \   000000F0   0x6829             LDR      R1,[R5, #+0]
   \   000000F2   0xF021 0x01F8      BIC      R1,R1,#0xF8
   \   000000F6   0x6029             STR      R1,[R5, #+0]
    480            }
    481            /* Return the Erase Status */
    482            return status;
   \                     ??FLASH_EraseSector_5: (+1)
   \   000000F8   0xBD70             POP      {R4-R6,PC}       ;; return
    483          }
    484          
    485          /**
    486            * @brief  Erases all FLASH Sectors.
    487            *
    488            * @note   If an erase and a program operations are requested simustaneously,    
    489            *         the erase operation is performed before the program one.
    490            *  
    491            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    492            *          This parameter can be one of the following values:
    493            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    494            *                                  the operation will be done by byte (8-bit) 
    495            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    496            *                                  the operation will be done by half word (16-bit)
    497            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    498            *                                  the operation will be done by word (32-bit)
    499            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    500            *                                  the operation will be done by double word (64-bit)
    501            *       
    502            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    503            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    504            */

   \                                 In section .text, align 2, keep-with-next
    505          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    506          {
   \                     FLASH_EraseAllSectors: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    507            uint32_t tmp_psize = 0x0;
   \   00000004   0x2500             MOVS     R5,#+0
    508            FLASH_Status status = FLASH_COMPLETE;
    509            
    510            /* Wait for last operation to be completed */
    511            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000A   0x4606             MOV      R6,R0
    512            assert_param(IS_VOLTAGERANGE(VoltageRange));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD00C             BEQ.N    ??FLASH_EraseAllSectors_0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD009             BEQ.N    ??FLASH_EraseAllSectors_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD007             BEQ.N    ??FLASH_EraseAllSectors_0
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD005             BEQ.N    ??FLASH_EraseAllSectors_0
   \   0000001E   0xF44F 0x7100      MOV      R1,#+512
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    513            
    514            if(VoltageRange == VoltageRange_1)
   \                     ??FLASH_EraseAllSectors_0: (+1)
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD00C             BEQ.N    ??FLASH_EraseAllSectors_1
    515            {
    516               tmp_psize = FLASH_PSIZE_BYTE;
    517            }
    518            else if(VoltageRange == VoltageRange_2)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD102             BNE.N    ??FLASH_EraseAllSectors_2
    519            {
    520              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   00000034   0xF44F 0x7580      MOV      R5,#+256
   \   00000038   0xE006             B.N      ??FLASH_EraseAllSectors_1
    521            }
    522            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllSectors_2: (+1)
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD102             BNE.N    ??FLASH_EraseAllSectors_3
    523            {
    524              tmp_psize = FLASH_PSIZE_WORD;
   \   0000003E   0xF44F 0x7500      MOV      R5,#+512
   \   00000042   0xE001             B.N      ??FLASH_EraseAllSectors_1
    525            }
    526            else
    527            {
    528              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllSectors_3: (+1)
   \   00000044   0xF44F 0x7540      MOV      R5,#+768
    529            }  
    530            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllSectors_1: (+1)
   \   00000048   0x2E09             CMP      R6,#+9
   \   0000004A   0xD117             BNE.N    ??FLASH_EraseAllSectors_4
    531            {
    532              /* if the previous operation is completed, proceed to erase all sectors */
    533          #if defined (STM32F427_437xx) || defined (STM32F429_439xx)    
    534              FLASH->CR &= CR_PSIZE_MASK;
    535              FLASH->CR |= tmp_psize;
    536              FLASH->CR |= (FLASH_CR_MER1 | FLASH_CR_MER2);
    537              FLASH->CR |= FLASH_CR_STRT;
    538              
    539              /* Wait for last operation to be completed */
    540              status = FLASH_WaitForLastOperation();
    541          
    542              /* if the erase operation is completed, disable the MER Bit */
    543              FLASH->CR &= ~(FLASH_CR_MER1 | FLASH_CR_MER2);
    544          #endif /* STM32F427_437xx ||  STM32F429_439xx */
    545          
    546          #if defined (STM32F40_41xxx) || defined (STM32F401xx) 
    547              FLASH->CR &= CR_PSIZE_MASK;
   \   0000004C   0x.... 0x....      LDR.W    R4,??DataTable39_4  ;; 0x40023c10
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000056   0x6020             STR      R0,[R4, #+0]
    548              FLASH->CR |= tmp_psize;
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x6020             STR      R0,[R4, #+0]
    549              FLASH->CR |= FLASH_CR_MER;
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000064   0x6020             STR      R0,[R4, #+0]
    550              FLASH->CR |= FLASH_CR_STRT;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   0000006C   0x6020             STR      R0,[R4, #+0]
    551              
    552              /* Wait for last operation to be completed */
    553              status = FLASH_WaitForLastOperation();
   \   0000006E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000072   0x4606             MOV      R6,R0
    554          
    555              /* if the erase operation is completed, disable the MER Bit */
    556              FLASH->CR &= (~FLASH_CR_MER);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF020 0x0004      BIC      R0,R0,#0x4
   \   0000007A   0x6020             STR      R0,[R4, #+0]
    557          #endif /* STM32F40_41xxx || STM32F401xx */
    558          
    559            }   
    560            /* Return the Erase Status */
    561            return status;
   \                     ??FLASH_EraseAllSectors_4: (+1)
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
    562          }
    563          
    564          /**
    565            * @brief  Erases all FLASH Sectors in Bank 1.
    566            *
    567            * @note   This function can be used only for STM32F42xxx/43xxx devices.
    568            *      
    569            * @note   If an erase and a program operations are requested simultaneously,    
    570            *         the erase operation is performed before the program one. 
    571            *  
    572            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    573            *          This parameter can be one of the following values:
    574            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    575            *                                  the operation will be done by byte (8-bit) 
    576            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    577            *                                  the operation will be done by half word (16-bit)
    578            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    579            *                                  the operation will be done by word (32-bit)
    580            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    581            *                                  the operation will be done by double word (64-bit)
    582            *       
    583            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    584            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange)
    587          {
   \                     FLASH_EraseAllBank1Sectors: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    588            uint32_t tmp_psize = 0x0;
   \   00000004   0x2500             MOVS     R5,#+0
    589            FLASH_Status status = FLASH_COMPLETE;
    590            
    591            /* Wait for last operation to be completed */
    592            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000A   0x4606             MOV      R6,R0
    593            assert_param(IS_VOLTAGERANGE(VoltageRange));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD00C             BEQ.N    ??FLASH_EraseAllBank1Sectors_0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD009             BEQ.N    ??FLASH_EraseAllBank1Sectors_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD007             BEQ.N    ??FLASH_EraseAllBank1Sectors_0
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD005             BEQ.N    ??FLASH_EraseAllBank1Sectors_0
   \   0000001E   0xF240 0x2151      MOVW     R1,#+593
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    594            
    595            if(VoltageRange == VoltageRange_1)
   \                     ??FLASH_EraseAllBank1Sectors_0: (+1)
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD00C             BEQ.N    ??FLASH_EraseAllBank1Sectors_1
    596            {
    597               tmp_psize = FLASH_PSIZE_BYTE;
    598            }
    599            else if(VoltageRange == VoltageRange_2)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD102             BNE.N    ??FLASH_EraseAllBank1Sectors_2
    600            {
    601              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   00000034   0xF44F 0x7580      MOV      R5,#+256
   \   00000038   0xE006             B.N      ??FLASH_EraseAllBank1Sectors_1
    602            }
    603            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllBank1Sectors_2: (+1)
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD102             BNE.N    ??FLASH_EraseAllBank1Sectors_3
    604            {
    605              tmp_psize = FLASH_PSIZE_WORD;
   \   0000003E   0xF44F 0x7500      MOV      R5,#+512
   \   00000042   0xE001             B.N      ??FLASH_EraseAllBank1Sectors_1
    606            }
    607            else
    608            {
    609              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllBank1Sectors_3: (+1)
   \   00000044   0xF44F 0x7540      MOV      R5,#+768
    610            }  
    611            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllBank1Sectors_1: (+1)
   \   00000048   0x2E09             CMP      R6,#+9
   \   0000004A   0xD117             BNE.N    ??FLASH_EraseAllBank1Sectors_4
    612            {
    613              /* if the previous operation is completed, proceed to erase all sectors */
    614               FLASH->CR &= CR_PSIZE_MASK;
   \   0000004C   0x.... 0x....      LDR.W    R4,??DataTable39_4  ;; 0x40023c10
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000056   0x6020             STR      R0,[R4, #+0]
    615               FLASH->CR |= tmp_psize;
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x6020             STR      R0,[R4, #+0]
    616               FLASH->CR |= FLASH_CR_MER1;
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xF040 0x0004      ORR      R0,R0,#0x4
   \   00000064   0x6020             STR      R0,[R4, #+0]
    617               FLASH->CR |= FLASH_CR_STRT;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   0000006C   0x6020             STR      R0,[R4, #+0]
    618              
    619              /* Wait for last operation to be completed */
    620              status = FLASH_WaitForLastOperation();
   \   0000006E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000072   0x4606             MOV      R6,R0
    621          
    622              /* if the erase operation is completed, disable the MER Bit */
    623              FLASH->CR &= (~FLASH_CR_MER1);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF020 0x0004      BIC      R0,R0,#0x4
   \   0000007A   0x6020             STR      R0,[R4, #+0]
    624          
    625            }   
    626            /* Return the Erase Status */
    627            return status;
   \                     ??FLASH_EraseAllBank1Sectors_4: (+1)
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
    628          }
    629          
    630          
    631          /**
    632            * @brief  Erases all FLASH Sectors in Bank 2.
    633            *
    634            * @note   This function can be used only for STM32F42xxx/43xxx devices.
    635            *     
    636            * @note   If an erase and a program operations are requested simultaneously,    
    637            *         the erase operation is performed before the program one.
    638            *     
    639            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    640            *          This parameter can be one of the following values:
    641            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    642            *                                  the operation will be done by byte (8-bit) 
    643            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    644            *                                  the operation will be done by half word (16-bit)
    645            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    646            *                                  the operation will be done by word (32-bit)
    647            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    648            *                                  the operation will be done by double word (64-bit)
    649            *       
    650            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    651            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    652            */

   \                                 In section .text, align 2, keep-with-next
    653          FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange)
    654          {
   \                     FLASH_EraseAllBank2Sectors: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    655            uint32_t tmp_psize = 0x0;
   \   00000004   0x2500             MOVS     R5,#+0
    656            FLASH_Status status = FLASH_COMPLETE;
    657            
    658            /* Wait for last operation to be completed */
    659            status = FLASH_WaitForLastOperation();
   \   00000006   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000000A   0x4606             MOV      R6,R0
    660            assert_param(IS_VOLTAGERANGE(VoltageRange));
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD00C             BEQ.N    ??FLASH_EraseAllBank2Sectors_0
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD009             BEQ.N    ??FLASH_EraseAllBank2Sectors_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD007             BEQ.N    ??FLASH_EraseAllBank2Sectors_0
   \   0000001A   0x2803             CMP      R0,#+3
   \   0000001C   0xD005             BEQ.N    ??FLASH_EraseAllBank2Sectors_0
   \   0000001E   0xF44F 0x7125      MOV      R1,#+660
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    661            
    662            if(VoltageRange == VoltageRange_1)
   \                     ??FLASH_EraseAllBank2Sectors_0: (+1)
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD00C             BEQ.N    ??FLASH_EraseAllBank2Sectors_1
    663            {
    664               tmp_psize = FLASH_PSIZE_BYTE;
    665            }
    666            else if(VoltageRange == VoltageRange_2)
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD102             BNE.N    ??FLASH_EraseAllBank2Sectors_2
    667            {
    668              tmp_psize = FLASH_PSIZE_HALF_WORD;
   \   00000034   0xF44F 0x7580      MOV      R5,#+256
   \   00000038   0xE006             B.N      ??FLASH_EraseAllBank2Sectors_1
    669            }
    670            else if(VoltageRange == VoltageRange_3)
   \                     ??FLASH_EraseAllBank2Sectors_2: (+1)
   \   0000003A   0x2802             CMP      R0,#+2
   \   0000003C   0xD102             BNE.N    ??FLASH_EraseAllBank2Sectors_3
    671            {
    672              tmp_psize = FLASH_PSIZE_WORD;
   \   0000003E   0xF44F 0x7500      MOV      R5,#+512
   \   00000042   0xE001             B.N      ??FLASH_EraseAllBank2Sectors_1
    673            }
    674            else
    675            {
    676              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
   \                     ??FLASH_EraseAllBank2Sectors_3: (+1)
   \   00000044   0xF44F 0x7540      MOV      R5,#+768
    677            }  
    678            if(status == FLASH_COMPLETE)
   \                     ??FLASH_EraseAllBank2Sectors_1: (+1)
   \   00000048   0x2E09             CMP      R6,#+9
   \   0000004A   0xD117             BNE.N    ??FLASH_EraseAllBank2Sectors_4
    679            {
    680              /* if the previous operation is completed, proceed to erase all sectors */
    681               FLASH->CR &= CR_PSIZE_MASK;
   \   0000004C   0x.... 0x....      LDR.W    R4,??DataTable39_4  ;; 0x40023c10
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000056   0x6020             STR      R0,[R4, #+0]
    682               FLASH->CR |= tmp_psize;
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x6020             STR      R0,[R4, #+0]
    683               FLASH->CR |= FLASH_CR_MER2;
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000064   0x6020             STR      R0,[R4, #+0]
    684               FLASH->CR |= FLASH_CR_STRT;
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   0000006C   0x6020             STR      R0,[R4, #+0]
    685              
    686              /* Wait for last operation to be completed */
    687              status = FLASH_WaitForLastOperation();
   \   0000006E   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000072   0x4606             MOV      R6,R0
    688          
    689              /* if the erase operation is completed, disable the MER Bit */
    690              FLASH->CR &= (~FLASH_CR_MER2);
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   0000007A   0x6020             STR      R0,[R4, #+0]
    691          
    692            }   
    693            /* Return the Erase Status */
    694            return status;
   \                     ??FLASH_EraseAllBank2Sectors_4: (+1)
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
    695          }
    696          
    697          /**
    698            * @brief  Programs a double word (64-bit) at a specified address.
    699            * @note   This function must be used when the device voltage range is from
    700            *         2.7V to 3.6V and an External Vpp is present.
    701            *
    702            * @note   If an erase and a program operations are requested simustaneously,    
    703            *         the erase operation is performed before the program one.
    704            *  
    705            * @param  Address: specifies the address to be programmed.
    706            * @param  Data: specifies the data to be programmed.
    707            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    708            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    709            */

   \                                 In section .text, align 2, keep-with-next
    710          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    711          {
   \                     FLASH_ProgramDoubleWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x4614             MOV      R4,R2
   \   00000006   0x461D             MOV      R5,R3
    712            FLASH_Status status = FLASH_COMPLETE;
    713          
    714            /* Check the parameters */
    715            assert_param(IS_FLASH_ADDRESS(Address));
   \   00000008   0xF1A6 0x6000      SUB      R0,R6,#+134217728
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0xfffff
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD30D             BCC.N    ??FLASH_ProgramDoubleWord_0
   \   00000014   0xF106 0x4060      ADD      R0,R6,#-536870912
   \   00000018   0xF500 0x4008      ADD      R0,R0,#+34816
   \   0000001C   0xF240 0x210F      MOVW     R1,#+527
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD305             BCC.N    ??FLASH_ProgramDoubleWord_0
   \   00000024   0xF240 0x21CB      MOVW     R1,#+715
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
    716          
    717            /* Wait for last operation to be completed */
    718            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramDoubleWord_0: (+1)
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
    719            
    720            if(status == FLASH_COMPLETE)
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xD115             BNE.N    ??FLASH_ProgramDoubleWord_1
    721            {
    722              /* if the previous operation is completed, proceed to program the new data */
    723              FLASH->CR &= CR_PSIZE_MASK;
   \   00000038   0x.... 0x....      LDR.W    R7,??DataTable39_4  ;; 0x40023c10
   \   0000003C   0x6838             LDR      R0,[R7, #+0]
   \   0000003E   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000042   0x6038             STR      R0,[R7, #+0]
    724              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
   \   00000044   0x6838             LDR      R0,[R7, #+0]
   \   00000046   0xF440 0x7040      ORR      R0,R0,#0x300
   \   0000004A   0x6038             STR      R0,[R7, #+0]
    725              FLASH->CR |= FLASH_CR_PG;
   \   0000004C   0x6838             LDR      R0,[R7, #+0]
   \   0000004E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000052   0x6038             STR      R0,[R7, #+0]
    726            
    727              *(__IO uint64_t*)Address = Data;
   \   00000054   0xE9C6 0x4500      STRD     R4,R5,[R6, #+0]
    728                  
    729              /* Wait for last operation to be completed */
    730              status = FLASH_WaitForLastOperation();
   \   00000058   0x.... 0x....      BL       FLASH_WaitForLastOperation
    731          
    732              /* if the program operation is completed, disable the PG Bit */
    733              FLASH->CR &= (~FLASH_CR_PG);
   \   0000005C   0x6839             LDR      R1,[R7, #+0]
   \   0000005E   0x0849             LSRS     R1,R1,#+1
   \   00000060   0x0049             LSLS     R1,R1,#+1
   \   00000062   0x6039             STR      R1,[R7, #+0]
    734            } 
    735            /* Return the Program Status */
    736            return status;
   \                     ??FLASH_ProgramDoubleWord_1: (+1)
   \   00000064   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    737          }
    738          
    739          /**
    740            * @brief  Programs a word (32-bit) at a specified address.
    741            *
    742            * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
    743            *
    744            * @note   If an erase and a program operations are requested simustaneously,    
    745            *         the erase operation is performed before the program one.
    746            *  
    747            * @param  Address: specifies the address to be programmed.
    748            *         This parameter can be any address in Program memory zone or in OTP zone.  
    749            * @param  Data: specifies the data to be programmed.
    750            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    751            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    752            */

   \                                 In section .text, align 2, keep-with-next
    753          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    754          {
   \                     FLASH_ProgramWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    755            FLASH_Status status = FLASH_COMPLETE;
    756          
    757            /* Check the parameters */
    758            assert_param(IS_FLASH_ADDRESS(Address));
   \   00000006   0xF1A4 0x6000      SUB      R0,R4,#+134217728
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0xfffff
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD30D             BCC.N    ??FLASH_ProgramWord_0
   \   00000012   0xF104 0x4060      ADD      R0,R4,#-536870912
   \   00000016   0xF500 0x4008      ADD      R0,R0,#+34816
   \   0000001A   0xF240 0x210F      MOVW     R1,#+527
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD305             BCC.N    ??FLASH_ProgramWord_0
   \   00000022   0xF240 0x21F6      MOVW     R1,#+758
   \   00000026   0x.... 0x....      ADR.W    R0,?_0
   \   0000002A   0x.... 0x....      BL       assert_failed
    759          
    760            /* Wait for last operation to be completed */
    761            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramWord_0: (+1)
   \   0000002E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    762            
    763            if(status == FLASH_COMPLETE)
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xD114             BNE.N    ??FLASH_ProgramWord_1
    764            {
    765              /* if the previous operation is completed, proceed to program the new data */
    766              FLASH->CR &= CR_PSIZE_MASK;
   \   00000036   0x.... 0x....      LDR.W    R6,??DataTable39_4  ;; 0x40023c10
   \   0000003A   0x6830             LDR      R0,[R6, #+0]
   \   0000003C   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000040   0x6030             STR      R0,[R6, #+0]
    767              FLASH->CR |= FLASH_PSIZE_WORD;
   \   00000042   0x6830             LDR      R0,[R6, #+0]
   \   00000044   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000048   0x6030             STR      R0,[R6, #+0]
    768              FLASH->CR |= FLASH_CR_PG;
   \   0000004A   0x6830             LDR      R0,[R6, #+0]
   \   0000004C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000050   0x6030             STR      R0,[R6, #+0]
    769            
    770              *(__IO uint32_t*)Address = Data;
   \   00000052   0x6025             STR      R5,[R4, #+0]
    771                  
    772              /* Wait for last operation to be completed */
    773              status = FLASH_WaitForLastOperation();
   \   00000054   0x.... 0x....      BL       FLASH_WaitForLastOperation
    774          
    775              /* if the program operation is completed, disable the PG Bit */
    776              FLASH->CR &= (~FLASH_CR_PG);
   \   00000058   0x6831             LDR      R1,[R6, #+0]
   \   0000005A   0x0849             LSRS     R1,R1,#+1
   \   0000005C   0x0049             LSLS     R1,R1,#+1
   \   0000005E   0x6031             STR      R1,[R6, #+0]
    777            } 
    778            /* Return the Program Status */
    779            return status;
   \                     ??FLASH_ProgramWord_1: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    780          }
    781          
    782          /**
    783            * @brief  Programs a half word (16-bit) at a specified address. 
    784            * @note   This function must be used when the device voltage range is from 2.1V to 3.6V. 
    785            *
    786            * @note   If an erase and a program operations are requested simustaneously,    
    787            *         the erase operation is performed before the program one.
    788            * 
    789            * @param  Address: specifies the address to be programmed.
    790            *         This parameter can be any address in Program memory zone or in OTP zone.  
    791            * @param  Data: specifies the data to be programmed.
    792            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    793            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    794            */

   \                                 In section .text, align 2, keep-with-next
    795          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    796          {
   \                     FLASH_ProgramHalfWord: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    797            FLASH_Status status = FLASH_COMPLETE;
    798          
    799            /* Check the parameters */
    800            assert_param(IS_FLASH_ADDRESS(Address));
   \   00000006   0xF1A4 0x6000      SUB      R0,R4,#+134217728
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0xfffff
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD30D             BCC.N    ??FLASH_ProgramHalfWord_0
   \   00000012   0xF104 0x4060      ADD      R0,R4,#-536870912
   \   00000016   0xF500 0x4008      ADD      R0,R0,#+34816
   \   0000001A   0xF240 0x210F      MOVW     R1,#+527
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD305             BCC.N    ??FLASH_ProgramHalfWord_0
   \   00000022   0xF44F 0x7148      MOV      R1,#+800
   \   00000026   0x.... 0x....      ADR.W    R0,?_0
   \   0000002A   0x.... 0x....      BL       assert_failed
    801          
    802            /* Wait for last operation to be completed */
    803            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramHalfWord_0: (+1)
   \   0000002E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    804            
    805            if(status == FLASH_COMPLETE)
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xD114             BNE.N    ??FLASH_ProgramHalfWord_1
    806            {
    807              /* if the previous operation is completed, proceed to program the new data */
    808              FLASH->CR &= CR_PSIZE_MASK;
   \   00000036   0x.... 0x....      LDR.W    R6,??DataTable39_4  ;; 0x40023c10
   \   0000003A   0x6830             LDR      R0,[R6, #+0]
   \   0000003C   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000040   0x6030             STR      R0,[R6, #+0]
    809              FLASH->CR |= FLASH_PSIZE_HALF_WORD;
   \   00000042   0x6830             LDR      R0,[R6, #+0]
   \   00000044   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000048   0x6030             STR      R0,[R6, #+0]
    810              FLASH->CR |= FLASH_CR_PG;
   \   0000004A   0x6830             LDR      R0,[R6, #+0]
   \   0000004C   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000050   0x6030             STR      R0,[R6, #+0]
    811            
    812              *(__IO uint16_t*)Address = Data;
   \   00000052   0x8025             STRH     R5,[R4, #+0]
    813                  
    814              /* Wait for last operation to be completed */
    815              status = FLASH_WaitForLastOperation();
   \   00000054   0x.... 0x....      BL       FLASH_WaitForLastOperation
    816          
    817              /* if the program operation is completed, disable the PG Bit */
    818              FLASH->CR &= (~FLASH_CR_PG);
   \   00000058   0x6831             LDR      R1,[R6, #+0]
   \   0000005A   0x0849             LSRS     R1,R1,#+1
   \   0000005C   0x0049             LSLS     R1,R1,#+1
   \   0000005E   0x6031             STR      R1,[R6, #+0]
    819            } 
    820            /* Return the Program Status */
    821            return status;
   \                     ??FLASH_ProgramHalfWord_1: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    822          }
    823          
    824          /**
    825            * @brief  Programs a byte (8-bit) at a specified address.
    826            * @note   This function can be used within all the device supply voltage ranges.  
    827            *
    828            * @note   If an erase and a program operations are requested simustaneously,    
    829            *         the erase operation is performed before the program one.
    830            * 
    831            * @param  Address: specifies the address to be programmed.
    832            *         This parameter can be any address in Program memory zone or in OTP zone.  
    833            * @param  Data: specifies the data to be programmed.
    834            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    835            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    836            */

   \                                 In section .text, align 2, keep-with-next
    837          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    838          {
   \                     FLASH_ProgramByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    839            FLASH_Status status = FLASH_COMPLETE;
    840          
    841            /* Check the parameters */
    842            assert_param(IS_FLASH_ADDRESS(Address));
   \   00000006   0xF1A4 0x6000      SUB      R0,R4,#+134217728
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable39_5  ;; 0xfffff
   \   0000000E   0x4288             CMP      R0,R1
   \   00000010   0xD30D             BCC.N    ??FLASH_ProgramByte_0
   \   00000012   0xF104 0x4060      ADD      R0,R4,#-536870912
   \   00000016   0xF500 0x4008      ADD      R0,R0,#+34816
   \   0000001A   0xF240 0x210F      MOVW     R1,#+527
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD305             BCC.N    ??FLASH_ProgramByte_0
   \   00000022   0xF240 0x314A      MOVW     R1,#+842
   \   00000026   0x.... 0x....      ADR.W    R0,?_0
   \   0000002A   0x.... 0x....      BL       assert_failed
    843          
    844            /* Wait for last operation to be completed */
    845            status = FLASH_WaitForLastOperation();
   \                     ??FLASH_ProgramByte_0: (+1)
   \   0000002E   0x.... 0x....      BL       FLASH_WaitForLastOperation
    846            
    847            if(status == FLASH_COMPLETE)
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xD112             BNE.N    ??FLASH_ProgramByte_1
    848            {
    849              /* if the previous operation is completed, proceed to program the new data */
    850              FLASH->CR &= CR_PSIZE_MASK;
   \   00000036   0x.... 0x....      LDR.W    R6,??DataTable39_4  ;; 0x40023c10
   \   0000003A   0x6830             LDR      R0,[R6, #+0]
   \   0000003C   0xF420 0x7040      BIC      R0,R0,#0x300
   \   00000040   0x6030             STR      R0,[R6, #+0]
    851              FLASH->CR |= FLASH_PSIZE_BYTE;
   \   00000042   0x6830             LDR      R0,[R6, #+0]
   \   00000044   0x6030             STR      R0,[R6, #+0]
    852              FLASH->CR |= FLASH_CR_PG;
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000004C   0x6030             STR      R0,[R6, #+0]
    853            
    854              *(__IO uint8_t*)Address = Data;
   \   0000004E   0x7025             STRB     R5,[R4, #+0]
    855                  
    856              /* Wait for last operation to be completed */
    857              status = FLASH_WaitForLastOperation();
   \   00000050   0x.... 0x....      BL       FLASH_WaitForLastOperation
    858          
    859              /* if the program operation is completed, disable the PG Bit */
    860              FLASH->CR &= (~FLASH_CR_PG);
   \   00000054   0x6831             LDR      R1,[R6, #+0]
   \   00000056   0x0849             LSRS     R1,R1,#+1
   \   00000058   0x0049             LSLS     R1,R1,#+1
   \   0000005A   0x6031             STR      R1,[R6, #+0]
    861            } 
    862          
    863            /* Return the Program Status */
    864            return status;
   \                     ??FLASH_ProgramByte_1: (+1)
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    865          }
    866          
    867          /**
    868            * @}
    869            */
    870          
    871          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    872           *  @brief   Option Bytes Programming functions 
    873           *
    874          @verbatim   
    875           ===============================================================================
    876                          ##### Option Bytes Programming functions #####
    877           ===============================================================================  
    878              [..]
    879                This group includes the following functions:
    880                (+) void FLASH_OB_Unlock(void)
    881                (+) void FLASH_OB_Lock(void)
    882                (+) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    883                (+) void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)  
    884                (+) void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PCROPSelect)
    885                (+) void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
    886                (+) void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState) 
    887                (+) void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    888                (+) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    889                (+) void FLASH_OB_BORConfig(uint8_t OB_BOR)
    890                (+) FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)							
    891                (+) FLASH_Status FLASH_OB_Launch(void)
    892                (+) uint32_t FLASH_OB_GetUser(void)						
    893                (+) uint8_t FLASH_OB_GetWRP(void)
    894                (+) uint8_t FLASH_OB_GetWRP1(void)
    895                (+) uint8_t FLASH_OB_GetPCROP(void)
    896                (+) uint8_t FLASH_OB_GetPCROP1(void)    						
    897                (+) uint8_t FLASH_OB_GetRDP(void)							
    898                (+) uint8_t FLASH_OB_GetBOR(void)
    899              [..]  
    900                The following function can be used only for STM32F42xxx/43xxx devices. 
    901                (+) void FLASH_OB_BootConfig(uint8_t OB_BOOT)
    902              [..]   
    903               Any operation of erase or program should follow these steps:
    904                (#) Call the FLASH_OB_Unlock() function to enable the FLASH option control 
    905                    register access
    906          
    907                (#) Call one or several functions to program the desired Option Bytes:
    908                  (++) void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) 
    909                       => to Enable/Disable the desired sector write protection
    910                  (++) void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read 
    911                       Protection Level
    912                  (++) void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) 
    913                       => to configure the user Option Bytes.
    914                  (++) void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
    915          
    916                (#) Once all needed Option Bytes to be programmed are correctly written, 
    917                    call the FLASH_OB_Launch() function to launch the Option Bytes 
    918                    programming process.
    919               
    920                -@- When changing the IWDG mode from HW to SW or from SW to HW, a system 
    921                    reset is needed to make the change effective.  
    922          
    923                (#) Call the FLASH_OB_Lock() function to disable the FLASH option control 
    924                    register access (recommended to protect the Option Bytes against 
    925                    possible unwanted operations)
    926              
    927          @endverbatim
    928            * @{
    929            */
    930          
    931          /**
    932            * @brief  Unlocks the FLASH Option Control Registers access.
    933            * @param  None
    934            * @retval None
    935            */

   \                                 In section .text, align 2, keep-with-next
    936          void FLASH_OB_Unlock(void)
    937          {
    938            if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
   \                     FLASH_OB_Unlock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_6  ;; 0x40023c08
   \   00000004   0x68C1             LDR      R1,[R0, #+12]
   \   00000006   0x07C9             LSLS     R1,R1,#+31
   \   00000008   0xD505             BPL.N    ??FLASH_OB_Unlock_0
    939            {
    940              /* Authorizes the Option Byte register programming */
    941              FLASH->OPTKEYR = FLASH_OPT_KEY1;
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable39_7  ;; 0x8192a3b
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    942              FLASH->OPTKEYR = FLASH_OPT_KEY2;
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable39_8  ;; 0x4c5d6e7f
   \   00000014   0x6001             STR      R1,[R0, #+0]
    943            }  
    944          }
   \                     ??FLASH_OB_Unlock_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    945          
    946          /**
    947            * @brief  Locks the FLASH Option Control Registers access.
    948            * @param  None
    949            * @retval None
    950            */

   \                                 In section .text, align 2, keep-with-next
    951          void FLASH_OB_Lock(void)
    952          {
    953            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    954            FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
   \                     FLASH_OB_Lock: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable39_9  ;; 0x40023c14
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xF041 0x0101      ORR      R1,R1,#0x1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    955          }
   \   0000000C   0x4770             BX       LR               ;; return
    956          
    957          /**
    958            * @brief  Enables or disables the write protection of the desired sectors, for the first
    959            *         1 Mb of the Flash  
    960            *
    961            * @note   When the memory read protection level is selected (RDP level = 1), 
    962            *         it is not possible to program or erase the flash sector i if CortexM4  
    963            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
    964            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).   
    965            * 
    966            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
    967            *          This parameter can be one of the following values:
    968            *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
    969            *            @arg OB_WRP_Sector_All
    970            * @param  Newstate: new state of the Write Protection.
    971            *          This parameter can be: ENABLE or DISABLE.
    972            * @retval None  
    973            */

   \                                 In section .text, align 2, keep-with-next
    974          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    975          { 
   \                     FLASH_OB_WRPConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    976            FLASH_Status status = FLASH_COMPLETE;
    977            
    978            /* Check the parameters */
    979            assert_param(IS_OB_WRP(OB_WRP));
   \   00000006   0x0B20             LSRS     R0,R4,#+12
   \   00000008   0x0300             LSLS     R0,R0,#+12
   \   0000000A   0xD101             BNE.N    ??FLASH_OB_WRPConfig_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??FLASH_OB_WRPConfig_1
   \                     ??FLASH_OB_WRPConfig_0: (+1)
   \   00000010   0xF240 0x31D3      MOVW     R1,#+979
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
    980            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_OB_WRPConfig_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??FLASH_OB_WRPConfig_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??FLASH_OB_WRPConfig_2
   \   00000024   0xF44F 0x7175      MOV      R1,#+980
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
    981              
    982            status = FLASH_WaitForLastOperation();
    983          
    984            if(status == FLASH_COMPLETE)
   \                     ??FLASH_OB_WRPConfig_2: (+1)
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xD109             BNE.N    ??FLASH_OB_WRPConfig_3
    985            { 
    986              if(NewState != DISABLE)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable39_10  ;; 0x40023c16
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0x8801             LDRH     R1,[R0, #+0]
   \   00000040   0xD002             BEQ.N    ??FLASH_OB_WRPConfig_4
    987              {
    988                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
   \   00000042   0x43A1             BICS     R1,R1,R4
   \   00000044   0x8001             STRH     R1,[R0, #+0]
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}
    989              }
    990              else
    991              {
    992                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRPConfig_4: (+1)
   \   00000048   0x4321             ORRS     R1,R4,R1
   \   0000004A   0x8001             STRH     R1,[R0, #+0]
    993              }
    994            }
    995          }
   \                     ??FLASH_OB_WRPConfig_3: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    996          
    997          /**
    998            * @brief  Enables or disables the write protection of the desired sectors, for the second
    999            *         1 Mb of the Flash  
   1000            *           
   1001            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1002            *   
   1003            * @note   When the memory read out protection is selected (RDP level = 1), 
   1004            *         it is not possible to program or erase the flash sector i if CortexM4  
   1005            *         debug features are connected or boot code is executed in RAM, even if nWRPi = 1 
   1006            * @note   Active value of nWRPi bits is inverted when PCROP mode is active (SPRMOD =1).      
   1007            * 
   1008            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
   1009            *          This parameter can be one of the following values:
   1010            *            @arg OB_WRP: A value between OB_WRP_Sector12 and OB_WRP_Sector23
   1011            *            @arg OB_WRP_Sector_All                        
   1012            * @param  Newstate: new state of the Write Protection.
   1013            *          This parameter can be: ENABLE or DISABLE.
   1014            * @retval None  
   1015            */

   \                                 In section .text, align 2, keep-with-next
   1016          void FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState)
   1017          { 
   \                     FLASH_OB_WRP1Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1018            FLASH_Status status = FLASH_COMPLETE;
   1019            
   1020            /* Check the parameters */
   1021            assert_param(IS_OB_WRP(OB_WRP));
   \   00000006   0x0B20             LSRS     R0,R4,#+12
   \   00000008   0x0300             LSLS     R0,R0,#+12
   \   0000000A   0xD101             BNE.N    ??FLASH_OB_WRP1Config_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??FLASH_OB_WRP1Config_1
   \                     ??FLASH_OB_WRP1Config_0: (+1)
   \   00000010   0xF240 0x31FD      MOVW     R1,#+1021
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1022            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_OB_WRP1Config_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??FLASH_OB_WRP1Config_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??FLASH_OB_WRP1Config_2
   \   00000024   0xF240 0x31FE      MOVW     R1,#+1022
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1023              
   1024            status = FLASH_WaitForLastOperation();
   1025          
   1026            if(status == FLASH_COMPLETE)
   \                     ??FLASH_OB_WRP1Config_2: (+1)
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xD108             BNE.N    ??FLASH_OB_WRP1Config_3
   1027            { 
   1028              if(NewState != DISABLE)
   \   00000038   0x....             LDR.N    R0,??DataTable39_11  ;; 0x40023c1a
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x8801             LDRH     R1,[R0, #+0]
   \   0000003E   0xD002             BEQ.N    ??FLASH_OB_WRP1Config_4
   1029              {
   1030                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
   \   00000040   0x43A1             BICS     R1,R1,R4
   \   00000042   0x8001             STRH     R1,[R0, #+0]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1031              }
   1032              else
   1033              {
   1034                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
   \                     ??FLASH_OB_WRP1Config_4: (+1)
   \   00000046   0x4321             ORRS     R1,R4,R1
   \   00000048   0x8001             STRH     R1,[R0, #+0]
   1035              }
   1036            }
   1037          }
   \                     ??FLASH_OB_WRP1Config_3: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1038          
   1039          /**
   1040            * @brief  Select the Protection Mode (SPRMOD). 
   1041            * 
   1042            * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx devices.       
   1043            * 
   1044            * @note   After PCROP activation, Option Byte modification is not possible. 
   1045            *         Exception made for the global Read Out Protection modification level (level1 to level0) 
   1046            * @note   Once SPRMOD bit is active unprotection of a protected sector is not possible 
   1047            *   
   1048            * @note   Read a protected sector will set RDERR Flag and write a protected sector will set WRPERR Flag
   1049            *   
   1050            * @note   Some Precautions should be taken when activating the PCROP feature :
   1051            *         The active value of nWRPi bits is inverted when PCROP mode is active, this means if SPRMOD = 1
   1052            *         and WRPi = 1 (default value), then the user sector i is read/write protected.
   1053            *         In order to avoid activation of PCROP Mode for undesired sectors, please follow the
   1054            *         below safety sequence :       
   1055            *         - Disable PCROP for all Sectors using FLASH_OB_PCROPConfig(OB_PCROP_Sector_All, DISABLE) function 
   1056            *           for Bank1 or FLASH_OB_PCROP1Config(OB_PCROP_Sector_All, DISABLE) function for Bank2   
   1057            *         - Enable PCROP for the desired Sector i using FLASH_OB_PCROPConfig(Sector i, ENABLE) function
   1058            *         - Activate the PCROP Mode FLASH_OB_PCROPSelectionConfig() function. 
   1059            * 
   1060            * @param  OB_PCROP:  Select the Protection Mode of nWPRi bits 
   1061            *          This parameter can be one of the following values:
   1062            *            @arg OB_PcROP_Disable: nWRPi control the write protection of respective user sectors.
   1063            *            @arg OB_PcROP_Enable: nWRPi control the  read&write protection (PCROP) of respective user sectors.
   1064            * @retval None
   1065            */

   \                                 In section .text, align 2, keep-with-next
   1066          void FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP)
   1067          {  
   \                     FLASH_OB_PCROPSelectionConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1068            uint8_t optiontmp = 0xFF;
   1069                
   1070            /* Check the parameters */
   1071            assert_param(IS_OB_PCROP_SELECT(OB_PcROP));
   \   00000004   0xD007             BEQ.N    ??FLASH_OB_PCROPSelectionConfig_0
   \   00000006   0x2C80             CMP      R4,#+128
   \   00000008   0xD005             BEQ.N    ??FLASH_OB_PCROPSelectionConfig_0
   \   0000000A   0xF240 0x412F      MOVW     R1,#+1071
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
   1072            
   1073            /* Mask SPRMOD bit */
   1074            optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE3_ADDRESS) & (uint8_t)0x7F); 
   \                     ??FLASH_OB_PCROPSelectionConfig_0: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable39_12  ;; 0x40023c17
   \   00000018   0x7801             LDRB     R1,[R0, #+0]
   \   0000001A   0xF001 0x017F      AND      R1,R1,#0x7F
   1075            /* Update Option Byte */
   1076            *(__IO uint8_t *)OPTCR_BYTE3_ADDRESS = (uint8_t)(OB_PcROP | optiontmp); 
   \   0000001E   0x4321             ORRS     R1,R1,R4
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   1077              
   1078          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   1079          
   1080          /**
   1081            * @brief  Enables or disables the read/write protection (PCROP) of the desired 
   1082            *         sectors, for the first 1 MB of the Flash.
   1083            *           
   1084            * @note   This function can be used only for STM32F42xxx/43xxx and STM32F401xx devices. 
   1085            *   
   1086            * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
   1087            *          This parameter can be one of the following values:
   1088            *            @arg OB_PCROP: A value between OB_PCROP_Sector0 and OB_PCROP_Sector11 for 
   1089            *                           STM32F42xxx/43xxx devices and between OB_PCROP_Sector0 and 
   1090            *                           OB_PCROP_Sector5 for STM32F401xx devices.
   1091            *            @arg OB_PCROP_Sector_All                         
   1092            * @param  Newstate: new state of the Write Protection.
   1093            *          This parameter can be: ENABLE or DISABLE.
   1094            * @retval None  
   1095            */

   \                                 In section .text, align 2, keep-with-next
   1096          void FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState)
   1097          { 
   \                     FLASH_OB_PCROPConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1098            FLASH_Status status = FLASH_COMPLETE;
   1099            
   1100            /* Check the parameters */
   1101            assert_param(IS_OB_PCROP(OB_PCROP));
   \   00000006   0x0B20             LSRS     R0,R4,#+12
   \   00000008   0x0300             LSLS     R0,R0,#+12
   \   0000000A   0xD101             BNE.N    ??FLASH_OB_PCROPConfig_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??FLASH_OB_PCROPConfig_1
   \                     ??FLASH_OB_PCROPConfig_0: (+1)
   \   00000010   0xF240 0x414D      MOVW     R1,#+1101
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1102            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_OB_PCROPConfig_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??FLASH_OB_PCROPConfig_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??FLASH_OB_PCROPConfig_2
   \   00000024   0xF240 0x414E      MOVW     R1,#+1102
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1103              
   1104            status = FLASH_WaitForLastOperation();
   1105          
   1106            if(status == FLASH_COMPLETE)
   \                     ??FLASH_OB_PCROPConfig_2: (+1)
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xD108             BNE.N    ??FLASH_OB_PCROPConfig_3
   1107            { 
   1108              if(NewState != DISABLE)
   \   00000038   0x....             LDR.N    R0,??DataTable39_10  ;; 0x40023c16
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x8801             LDRH     R1,[R0, #+0]
   \   0000003E   0xD002             BEQ.N    ??FLASH_OB_PCROPConfig_4
   1109              {
   1110                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;    
   \   00000040   0x4321             ORRS     R1,R4,R1
   \   00000042   0x8001             STRH     R1,[R0, #+0]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1111              }
   1112              else
   1113              {
   1114                *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_PCROP);
   \                     ??FLASH_OB_PCROPConfig_4: (+1)
   \   00000046   0x43A1             BICS     R1,R1,R4
   \   00000048   0x8001             STRH     R1,[R0, #+0]
   1115              }
   1116            }
   1117          }
   \                     ??FLASH_OB_PCROPConfig_3: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1118          
   1119          /**
   1120             * @brief Enables or disables the read/write protection (PCROP) of the desired 
   1121            *         sectors
   1122            *           
   1123            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1124            *   
   1125            * @param  OB_PCROP: specifies the sector(s) to be read/write protected or unprotected.
   1126            *          This parameter can be one of the following values:
   1127            *            @arg OB_PCROP: A value between OB_PCROP_Sector12 and OB_PCROP_Sector23 
   1128            *            @arg OB_PCROP_Sector_All                    
   1129            * @param  Newstate: new state of the Write Protection.
   1130            *          This parameter can be: ENABLE or DISABLE.
   1131            * @retval None  
   1132            */

   \                                 In section .text, align 2, keep-with-next
   1133          void FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState)
   1134          { 
   \                     FLASH_OB_PCROP1Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1135            FLASH_Status status = FLASH_COMPLETE;
   1136            
   1137            /* Check the parameters */
   1138            assert_param(IS_OB_PCROP(OB_PCROP));
   \   00000006   0x0B20             LSRS     R0,R4,#+12
   \   00000008   0x0300             LSLS     R0,R0,#+12
   \   0000000A   0xD101             BNE.N    ??FLASH_OB_PCROP1Config_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??FLASH_OB_PCROP1Config_1
   \                     ??FLASH_OB_PCROP1Config_0: (+1)
   \   00000010   0xF240 0x4172      MOVW     R1,#+1138
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1139            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_OB_PCROP1Config_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??FLASH_OB_PCROP1Config_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??FLASH_OB_PCROP1Config_2
   \   00000024   0xF240 0x4173      MOVW     R1,#+1139
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1140              
   1141            status = FLASH_WaitForLastOperation();
   1142          
   1143            if(status == FLASH_COMPLETE)
   \                     ??FLASH_OB_PCROP1Config_2: (+1)
   \   00000030   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000034   0x2809             CMP      R0,#+9
   \   00000036   0xD108             BNE.N    ??FLASH_OB_PCROP1Config_3
   1144            { 
   1145              if(NewState != DISABLE)
   \   00000038   0x....             LDR.N    R0,??DataTable39_11  ;; 0x40023c1a
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x8801             LDRH     R1,[R0, #+0]
   \   0000003E   0xD002             BEQ.N    ??FLASH_OB_PCROP1Config_4
   1146              {
   1147                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_PCROP;
   \   00000040   0x4321             ORRS     R1,R4,R1
   \   00000042   0x8001             STRH     R1,[R0, #+0]
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}
   1148              }
   1149              else
   1150              {
   1151                *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_PCROP);
   \                     ??FLASH_OB_PCROP1Config_4: (+1)
   \   00000046   0x43A1             BICS     R1,R1,R4
   \   00000048   0x8001             STRH     R1,[R0, #+0]
   1152              }
   1153            }
   1154          }
   \                     ??FLASH_OB_PCROP1Config_3: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1155          
   1156          
   1157          /**
   1158            * @brief  Sets the read protection level.
   1159            * @param  OB_RDP: specifies the read protection level.
   1160            *          This parameter can be one of the following values:
   1161            *            @arg OB_RDP_Level_0: No protection
   1162            *            @arg OB_RDP_Level_1: Read protection of the memory
   1163            *            @arg OB_RDP_Level_2: Full chip protection
   1164            *   
   1165            * /!\ Warning /!\ When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
   1166            *    
   1167            * @retval None
   1168            */

   \                                 In section .text, align 2, keep-with-next
   1169          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
   1170          {
   \                     FLASH_OB_RDPConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1171            FLASH_Status status = FLASH_COMPLETE;
   1172          
   1173            /* Check the parameters */
   1174            assert_param(IS_OB_RDP(OB_RDP));
   \   00000004   0x28AA             CMP      R0,#+170
   \   00000006   0xD007             BEQ.N    ??FLASH_OB_RDPConfig_0
   \   00000008   0x2855             CMP      R0,#+85
   \   0000000A   0xD005             BEQ.N    ??FLASH_OB_RDPConfig_0
   \   0000000C   0xF240 0x4196      MOVW     R1,#+1174
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   1175          
   1176            status = FLASH_WaitForLastOperation();
   1177          
   1178            if(status == FLASH_COMPLETE)
   \                     ??FLASH_OB_RDPConfig_0: (+1)
   \   00000018   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   0000001C   0x2809             CMP      R0,#+9
   \   0000001E   0xD101             BNE.N    ??FLASH_OB_RDPConfig_1
   1179            {
   1180              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
   \   00000020   0x....             LDR.N    R0,??DataTable39_13  ;; 0x40023c15
   \   00000022   0x7004             STRB     R4,[R0, #+0]
   1181          
   1182            }
   1183          }
   \                     ??FLASH_OB_RDPConfig_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1184          
   1185          /**
   1186            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
   1187            * @param  OB_IWDG: Selects the IWDG mode
   1188            *          This parameter can be one of the following values:
   1189            *            @arg OB_IWDG_SW: Software IWDG selected
   1190            *            @arg OB_IWDG_HW: Hardware IWDG selected
   1191            * @param  OB_STOP: Reset event when entering STOP mode.
   1192            *          This parameter  can be one of the following values:
   1193            *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
   1194            *            @arg OB_STOP_RST: Reset generated when entering in STOP
   1195            * @param  OB_STDBY: Reset event when entering Standby mode.
   1196            *          This parameter  can be one of the following values:
   1197            *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
   1198            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
   1199            * @retval None
   1200            */

   \                                 In section .text, align 2, keep-with-next
   1201          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
   1202          {
   \                     FLASH_OB_UserConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1203            uint8_t optiontmp = 0xFF;
   1204            FLASH_Status status = FLASH_COMPLETE; 
   1205          
   1206            /* Check the parameters */
   1207            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
   \   00000008   0x2C20             CMP      R4,#+32
   \   0000000A   0xD007             BEQ.N    ??FLASH_OB_UserConfig_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD005             BEQ.N    ??FLASH_OB_UserConfig_0
   \   00000010   0xF240 0x41B7      MOVW     R1,#+1207
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1208            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
   \                     ??FLASH_OB_UserConfig_0: (+1)
   \   0000001C   0x2D40             CMP      R5,#+64
   \   0000001E   0xD007             BEQ.N    ??FLASH_OB_UserConfig_1
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD005             BEQ.N    ??FLASH_OB_UserConfig_1
   \   00000024   0xF44F 0x6197      MOV      R1,#+1208
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1209            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
   \                     ??FLASH_OB_UserConfig_1: (+1)
   \   00000030   0x2E80             CMP      R6,#+128
   \   00000032   0xD007             BEQ.N    ??FLASH_OB_UserConfig_2
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD005             BEQ.N    ??FLASH_OB_UserConfig_2
   \   00000038   0xF240 0x41B9      MOVW     R1,#+1209
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
   1210          
   1211            /* Wait for last operation to be completed */
   1212            status = FLASH_WaitForLastOperation();
   1213            
   1214            if(status == FLASH_COMPLETE)
   \                     ??FLASH_OB_UserConfig_2: (+1)
   \   00000044   0x.... 0x....      BL       FLASH_WaitForLastOperation
   \   00000048   0x2809             CMP      R0,#+9
   \   0000004A   0xD108             BNE.N    ??FLASH_OB_UserConfig_3
   1215            { 
   1216          #if defined (STM32F427_437xx) || defined (STM32F429_439xx)     
   1217              /* Mask OPTLOCK, OPTSTRT, BOR_LEV and BFB2 bits */
   1218              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x1F);
   1219          #endif /* STM32F427_437xx ||  STM32F429_439xx */
   1220          
   1221          #if defined (STM32F40_41xxx) || defined (STM32F401xx) 
   1222              /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
   1223              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
   \   0000004C   0x....             LDR.N    R0,??DataTable39_9  ;; 0x40023c14
   \   0000004E   0x7801             LDRB     R1,[R0, #+0]
   \   00000050   0xF001 0x010F      AND      R1,R1,#0xF
   1224          #endif /* STM32F40_41xxx || STM32F401xx */ 
   1225          
   1226              /* Update User Option Byte */
   1227              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
   \   00000054   0xEA46 0x0204      ORR      R2,R6,R4
   \   00000058   0x432A             ORRS     R2,R5,R2
   \   0000005A   0x4311             ORRS     R1,R1,R2
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
   1228            }  
   1229          }
   \                     ??FLASH_OB_UserConfig_3: (+1)
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
   1230          
   1231          /**
   1232            * @brief  Configure the Dual Bank Boot.
   1233            *   
   1234            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1235            *      
   1236            * @param  OB_BOOT: specifies the Dual Bank Boot Option byte.
   1237            *          This parameter can be one of the following values:
   1238            *            @arg OB_Dual_BootEnabled: Dual Bank Boot Enable
   1239            *            @arg OB_Dual_BootDisabled: Dual Bank Boot Disabled
   1240            * @retval None
   1241            */

   \                                 In section .text, align 2, keep-with-next
   1242          void FLASH_OB_BootConfig(uint8_t OB_BOOT)
   1243          {
   \                     FLASH_OB_BootConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1244            /* Check the parameters */
   1245            assert_param(IS_OB_BOOT(OB_BOOT));
   \   00000004   0x2C10             CMP      R4,#+16
   \   00000006   0xD007             BEQ.N    ??FLASH_OB_BootConfig_0
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD005             BEQ.N    ??FLASH_OB_BootConfig_0
   \   0000000C   0xF240 0x41DD      MOVW     R1,#+1245
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
   1246          
   1247            /* Set Dual Bank Boot */
   1248            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BFB2);
   \                     ??FLASH_OB_BootConfig_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable39_9  ;; 0x40023c14
   \   0000001A   0x7801             LDRB     R1,[R0, #+0]
   \   0000001C   0xF001 0x01EF      AND      R1,R1,#0xEF
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   1249            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOOT;
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   \   00000024   0x4321             ORRS     R1,R4,R1
   \   00000026   0x7001             STRB     R1,[R0, #+0]
   1250          
   1251          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   1252          
   1253          /**
   1254            * @brief  Sets the BOR Level. 
   1255            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
   1256            *          This parameter can be one of the following values:
   1257            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1258            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1259            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1260            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
   1261            * @retval None
   1262            */

   \                                 In section .text, align 2, keep-with-next
   1263          void FLASH_OB_BORConfig(uint8_t OB_BOR)
   1264          {
   \                     FLASH_OB_BORConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1265            /* Check the parameters */
   1266            assert_param(IS_OB_BOR(OB_BOR));
   \   00000004   0x2808             CMP      R0,#+8
   \   00000006   0xD00B             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD009             BEQ.N    ??FLASH_OB_BORConfig_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD007             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000010   0x280C             CMP      R0,#+12
   \   00000012   0xD005             BEQ.N    ??FLASH_OB_BORConfig_0
   \   00000014   0xF240 0x41F2      MOVW     R1,#+1266
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       assert_failed
   1267          
   1268            /* Set the BOR Level */
   1269            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
   \                     ??FLASH_OB_BORConfig_0: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable39_9  ;; 0x40023c14
   \   00000022   0x7801             LDRB     R1,[R0, #+0]
   \   00000024   0xF001 0x01F3      AND      R1,R1,#0xF3
   \   00000028   0x7001             STRB     R1,[R0, #+0]
   1270            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
   \   0000002A   0x7801             LDRB     R1,[R0, #+0]
   \   0000002C   0x4321             ORRS     R1,R4,R1
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
   1271          
   1272          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1273          
   1274          /**
   1275            * @brief  Launch the option byte loading.
   1276            * @param  None
   1277            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1278            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1279            */

   \                                 In section .text, align 2, keep-with-next
   1280          FLASH_Status FLASH_OB_Launch(void)
   1281          {
   1282            FLASH_Status status = FLASH_COMPLETE;
   1283          
   1284            /* Set the OPTSTRT bit in OPTCR register */
   1285            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
   \                     FLASH_OB_Launch: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_9  ;; 0x40023c14
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0xF041 0x0102      ORR      R1,R1,#0x2
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   1286          
   1287            /* Wait for last operation to be completed */
   1288            status = FLASH_WaitForLastOperation();
   1289          
   1290            return status;
   \   0000000A   0x....             B.N      FLASH_WaitForLastOperation
   1291          }
   1292          
   1293          /**
   1294            * @brief  Returns the FLASH User Option Bytes values.
   1295            * @param  None
   1296            * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
   1297            *         and RST_STDBY(Bit2).
   1298            */

   \                                 In section .text, align 2, keep-with-next
   1299          uint8_t FLASH_OB_GetUser(void)
   1300          {
   1301            /* Return the User Option Byte */
   1302            return (uint8_t)(FLASH->OPTCR >> 5);
   \                     FLASH_OB_GetUser: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_9  ;; 0x40023c14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0940             LSRS     R0,R0,#+5
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x4770             BX       LR               ;; return
   1303          }
   1304          
   1305          /**
   1306            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1307            * @param  None
   1308            * @retval The FLASH Write Protection  Option Bytes value
   1309            */

   \                                 In section .text, align 2, keep-with-next
   1310          uint16_t FLASH_OB_GetWRP(void)
   1311          {
   1312            /* Return the FLASH write protection Register value */
   1313            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_10  ;; 0x40023c16
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1314          }
   1315          
   1316          /**
   1317            * @brief  Returns the FLASH Write Protection Option Bytes value.
   1318            *   
   1319            * @note   This function can be used only for STM32F42xxx/43xxx devices.
   1320            *   
   1321            * @param  None
   1322            * @retval The FLASH Write Protection  Option Bytes value
   1323            */

   \                                 In section .text, align 2, keep-with-next
   1324          uint16_t FLASH_OB_GetWRP1(void)
   1325          {
   1326            /* Return the FLASH write protection Register value */
   1327            return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
   \                     FLASH_OB_GetWRP1: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_11  ;; 0x40023c1a
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1328          }
   1329          
   1330          /**
   1331            * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
   1332            *   
   1333            * @note   This function can be used only for STM32F42xxx/43xxx devices and STM32F401xx devices.
   1334            *   
   1335            * @param  None
   1336            * @retval The FLASH PC Read/Write Protection Option Bytes value
   1337            */

   \                                 In section .text, align 2, keep-with-next
   1338          uint16_t FLASH_OB_GetPCROP(void)
   1339          {
   1340            /* Return the FLASH PC Read/write protection Register value */
   1341            return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
   \                     FLASH_OB_GetPCROP: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_10  ;; 0x40023c16
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1342          }
   1343          
   1344          /**
   1345            * @brief  Returns the FLASH PC Read/Write Protection Option Bytes value.
   1346            *   
   1347            * @note   This function can be used only for STM32F42xxx/43xxx devices. 
   1348            *     
   1349            * @param  None
   1350            * @retval The FLASH PC Read/Write Protection Option Bytes value
   1351            */

   \                                 In section .text, align 2, keep-with-next
   1352          uint16_t FLASH_OB_GetPCROP1(void)
   1353          {
   1354            /* Return the FLASH write protection Register value */
   1355            return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
   \                     FLASH_OB_GetPCROP1: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_11  ;; 0x40023c1a
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1356          }
   1357          
   1358          /**
   1359            * @brief  Returns the FLASH Read Protection level.
   1360            * @param  None
   1361            * @retval FLASH ReadOut Protection Status:
   1362            *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
   1363            *           - RESET, when OB_RDP_Level_0 is set
   1364            */

   \                                 In section .text, align 2, keep-with-next
   1365          FlagStatus FLASH_OB_GetRDP(void)
   1366          {
   1367            FlagStatus readstatus = RESET;
   \                     FLASH_OB_GetRDP: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   1368          
   1369            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
   \   00000002   0x....             LDR.N    R1,??DataTable39_13  ;; 0x40023c15
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x29AA             CMP      R1,#+170
   \   00000008   0xD000             BEQ.N    ??FLASH_OB_GetRDP_0
   1370            {
   1371              readstatus = SET;
   \   0000000A   0x2001             MOVS     R0,#+1
   1372            }
   1373            else
   1374            {
   1375              readstatus = RESET;
   1376            }
   1377            return readstatus;
   \                     ??FLASH_OB_GetRDP_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
   1378          }
   1379          
   1380          /**
   1381            * @brief  Returns the FLASH BOR level.
   1382            * @param  None
   1383            * @retval The FLASH BOR level:
   1384            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
   1385            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
   1386            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
   1387            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
   1388            */

   \                                 In section .text, align 2, keep-with-next
   1389          uint8_t FLASH_OB_GetBOR(void)
   1390          {
   1391            /* Return the FLASH BOR level */
   1392            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
   \                     FLASH_OB_GetBOR: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable39_9  ;; 0x40023c14
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xF000 0x000C      AND      R0,R0,#0xC
   \   00000008   0x4770             BX       LR               ;; return
   1393          }
   1394          
   1395          /**
   1396            * @}
   1397            */
   1398          
   1399          /** @defgroup FLASH_Group4 Interrupts and flags management functions
   1400           *  @brief   Interrupts and flags management functions
   1401           *
   1402          @verbatim   
   1403           ===============================================================================
   1404                        ##### Interrupts and flags management functions #####
   1405           ===============================================================================  
   1406          @endverbatim
   1407            * @{
   1408            */
   1409          
   1410          /**
   1411            * @brief  Enables or disables the specified FLASH interrupts.
   1412            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
   1413            *          This parameter can be any combination of the following values:
   1414            *            @arg FLASH_IT_ERR: FLASH Error Interrupt
   1415            *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
   1416            * @retval None 
   1417            */

   \                                 In section .text, align 2, keep-with-next
   1418          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
   1419          {
   \                     FLASH_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1420            /* Check the parameters */
   1421            assert_param(IS_FLASH_IT(FLASH_IT)); 
   \   00000006   0xF034 0x7040      BICS     R0,R4,#0x3000000
   \   0000000A   0xD101             BNE.N    ??FLASH_ITConfig_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??FLASH_ITConfig_1
   \                     ??FLASH_ITConfig_0: (+1)
   \   00000010   0xF240 0x518D      MOVW     R1,#+1421
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1422            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??FLASH_ITConfig_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??FLASH_ITConfig_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??FLASH_ITConfig_2
   \   00000024   0xF240 0x518E      MOVW     R1,#+1422
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
   1423          
   1424            if(NewState != DISABLE)
   \                     ??FLASH_ITConfig_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable39_4  ;; 0x40023c10
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xD002             BEQ.N    ??FLASH_ITConfig_3
   1425            {
   1426              /* Enable the interrupt sources */
   1427              FLASH->CR |= FLASH_IT;
   \   00000038   0x4321             ORRS     R1,R4,R1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}
   1428            }
   1429            else
   1430            {
   1431              /* Disable the interrupt sources */
   1432              FLASH->CR &= ~(uint32_t)FLASH_IT;
   \                     ??FLASH_ITConfig_3: (+1)
   \   0000003E   0x43A1             BICS     R1,R1,R4
   \   00000040   0x6001             STR      R1,[R0, #+0]
   1433            }
   1434          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1435          
   1436          /**
   1437            * @brief  Checks whether the specified FLASH flag is set or not.
   1438            * @param  FLASH_FLAG: specifies the FLASH flag to check.
   1439            *          This parameter can be one of the following values:
   1440            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
   1441            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
   1442            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1443            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
   1444            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
   1445            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
   1446            *            @arg FLASH_FLAG_RDERR: FLASH (PCROP) Read Protection error flag (STM32F42/43xxx and STM32F401xx devices) 
   1447            *            @arg FLASH_FLAG_BSY: FLASH Busy flag
   1448            * @retval The new state of FLASH_FLAG (SET or RESET).
   1449            */

   \                                 In section .text, align 2, keep-with-next
   1450          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
   1451          {
   \                     FLASH_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1452            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1453            /* Check the parameters */
   1454            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD015             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD013             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000000E   0x2C10             CMP      R4,#+16
   \   00000010   0xD011             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000012   0x2C20             CMP      R4,#+32
   \   00000014   0xD00F             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000016   0x2C40             CMP      R4,#+64
   \   00000018   0xD00D             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000001A   0x2C80             CMP      R4,#+128
   \   0000001C   0xD00B             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000001E   0xF5B4 0x3F80      CMP      R4,#+65536
   \   00000022   0xD008             BEQ.N    ??FLASH_GetFlagStatus_0
   \   00000024   0xF5B4 0x7F80      CMP      R4,#+256
   \   00000028   0xD005             BEQ.N    ??FLASH_GetFlagStatus_0
   \   0000002A   0xF240 0x51AE      MOVW     R1,#+1454
   \   0000002E   0x.... 0x....      ADR.W    R0,?_0
   \   00000032   0x.... 0x....      BL       assert_failed
   1455          
   1456            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
   \                     ??FLASH_GetFlagStatus_0: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable39_14  ;; 0x40023c0c
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x4220             TST      R0,R4
   \   0000003C   0xD000             BEQ.N    ??FLASH_GetFlagStatus_1
   1457            {
   1458              bitstatus = SET;
   \   0000003E   0x2501             MOVS     R5,#+1
   1459            }
   1460            else
   1461            {
   1462              bitstatus = RESET;
   1463            }
   1464            /* Return the new state of FLASH_FLAG (SET or RESET) */
   1465            return bitstatus; 
   \                     ??FLASH_GetFlagStatus_1: (+1)
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1466          }
   1467          
   1468          /**
   1469            * @brief  Clears the FLASH's pending flags.
   1470            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
   1471            *          This parameter can be any combination of the following values:
   1472            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
   1473            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
   1474            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
   1475            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
   1476            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
   1477            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
   1478            *            @arg FLASH_FLAG_RDERR: FLASH Read Protection error flag (STM32F42/43xxx and STM32F401xx devices)   
   1479            * @retval None
   1480            */

   \                                 In section .text, align 2, keep-with-next
   1481          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
   1482          {
   \                     FLASH_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1483            /* Check the parameters */
   1484            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
   \   00000004   0x....             LDR.N    R0,??DataTable39_15  ;; 0xfffffe0c
   \   00000006   0x4204             TST      R4,R0
   \   00000008   0xD101             BNE.N    ??FLASH_ClearFlag_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??FLASH_ClearFlag_1
   \                     ??FLASH_ClearFlag_0: (+1)
   \   0000000E   0xF240 0x51CC      MOVW     R1,#+1484
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       assert_failed
   1485            
   1486            /* Clear the flags */
   1487            FLASH->SR = FLASH_FLAG;
   \                     ??FLASH_ClearFlag_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable39_14  ;; 0x40023c0c
   \   0000001C   0x6004             STR      R4,[R0, #+0]
   1488          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   1489          
   1490          /**
   1491            * @brief  Returns the FLASH Status.
   1492            * @param  None
   1493            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1494            *                       FLASH_ERROR_WRP, FLASH_ERROR_RD, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1495            */

   \                                 In section .text, align 2, keep-with-next
   1496          FLASH_Status FLASH_GetStatus(void)
   1497          {
   1498            FLASH_Status flashstatus = FLASH_COMPLETE;
   \                     FLASH_GetStatus: (+1)
   \   00000000   0x2009             MOVS     R0,#+9
   1499            
   1500            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   \   00000002   0x....             LDR.N    R1,??DataTable39_14  ;; 0x40023c0c
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x03D2             LSLS     R2,R2,#+15
   \   00000008   0xD501             BPL.N    ??FLASH_GetStatus_0
   1501            {
   1502              flashstatus = FLASH_BUSY;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
   1503            }
   1504            else 
   1505            {  
   1506              if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_0: (+1)
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0x06D2             LSLS     R2,R2,#+27
   \   00000012   0xD501             BPL.N    ??FLASH_GetStatus_1
   1507              { 
   1508                flashstatus = FLASH_ERROR_WRP;
   \   00000014   0x2006             MOVS     R0,#+6
   \   00000016   0x4770             BX       LR
   1509              }
   1510              else
   1511              {
   1512                if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_1: (+1)
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0x05D2             LSLS     R2,R2,#+23
   \   0000001C   0xD501             BPL.N    ??FLASH_GetStatus_2
   1513                { 
   1514                  flashstatus = FLASH_ERROR_RD;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x4770             BX       LR
   1515                } 
   1516                else 
   1517                {
   1518                  if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_2: (+1)
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0xF012 0x0FEF      TST      R2,#0xEF
   \   00000028   0xD001             BEQ.N    ??FLASH_GetStatus_3
   1519                  {
   1520                    flashstatus = FLASH_ERROR_PROGRAM; 
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0x4770             BX       LR
   1521                  }
   1522                  else
   1523                  {
   1524                    if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
   \                     ??FLASH_GetStatus_3: (+1)
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x0789             LSLS     R1,R1,#+30
   \   00000032   0xD500             BPL.N    ??FLASH_GetStatus_4
   1525                    {
   1526                      flashstatus = FLASH_ERROR_OPERATION;
   \   00000034   0x2008             MOVS     R0,#+8
   1527                    }
   1528                    else
   1529                    {
   1530                      flashstatus = FLASH_COMPLETE;
   1531                    }
   1532                  }
   1533                }
   1534              }
   1535            }
   1536            /* Return the FLASH Status */
   1537            return flashstatus;
   \                     ??FLASH_GetStatus_4: (+1)
   \   00000036   0x4770             BX       LR               ;; return
   1538          }
   1539          
   1540          /**
   1541            * @brief  Waits for a FLASH operation to complete.
   1542            * @param  None
   1543            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1544            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1545            */

   \                                 In section .text, align 2, keep-with-next
   1546          FLASH_Status FLASH_WaitForLastOperation(void)
   1547          { 
   \                     FLASH_WaitForLastOperation: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1548            __IO FLASH_Status status = FLASH_COMPLETE;
   \   00000002   0x2009             MOVS     R0,#+9
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1549             
   1550            /* Check for the FLASH Status */
   1551            status = FLASH_GetStatus();
   \   00000008   0x.... 0x....      BL       FLASH_GetStatus
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000010   0xE003             B.N      ??FLASH_WaitForLastOperation_0
   1552          
   1553            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   1554               Even if the FLASH operation fails, the BUSY flag will be reset and an error
   1555               flag will be set */
   1556            while(status == FLASH_BUSY)
   1557            {
   1558              status = FLASH_GetStatus();
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \   00000012   0x.... 0x....      BL       FLASH_GetStatus
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1559            }
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \   0000001A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD0F7             BEQ.N    ??FLASH_WaitForLastOperation_1
   1560            /* Return the operation status */
   1561            return status;
   \   00000022   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000026   0xBD02             POP      {R1,PC}          ;; return
   1562          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \   00000000   0x40023C00         DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_1:
   \   00000000   0x40023C04         DC32     0x40023c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_2:
   \   00000000   0x45670123         DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_3:
   \   00000000   0xCDEF89AB         DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_4:
   \   00000000   0x40023C10         DC32     0x40023c10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_5:
   \   00000000   0x000FFFFF         DC32     0xfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_6:
   \   00000000   0x40023C08         DC32     0x40023c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_7:
   \   00000000   0x08192A3B         DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_8:
   \   00000000   0x4C5D6E7F         DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_9:
   \   00000000   0x40023C14         DC32     0x40023c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_10:
   \   00000000   0x40023C16         DC32     0x40023c16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_11:
   \   00000000   0x40023C1A         DC32     0x40023c1a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_12:
   \   00000000   0x40023C17         DC32     0x40023c17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_13:
   \   00000000   0x40023C15         DC32     0x40023c15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_14:
   \   00000000   0x40023C0C         DC32     0x40023c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_15:
   \   00000000   0xFFFFFE0C         DC32     0xfffffe0c

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x66 0x6C          DC8 66H, 6CH, 61H, 73H, 68H, 2EH, 63H, 0
   \              0x61 0x73    
   \              0x68 0x2E    
   \              0x63 0x00    
   1563          
   1564          /**
   1565            * @}
   1566            */ 
   1567          
   1568          /**
   1569            * @}
   1570            */ 
   1571          
   1572          /**
   1573            * @}
   1574            */ 
   1575          
   1576          /**
   1577            * @}
   1578            */
   1579          
   1580          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FLASH_ClearFlag
         8   -> assert_failed
       8   FLASH_DataCacheCmd
         8   -> assert_failed
       0   FLASH_DataCacheReset
      16   FLASH_EraseAllBank1Sectors
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_EraseAllBank2Sectors
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_EraseAllSectors
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_EraseSector
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_GetFlagStatus
        16   -> assert_failed
       0   FLASH_GetStatus
      16   FLASH_ITConfig
        16   -> assert_failed
       8   FLASH_InstructionCacheCmd
         8   -> assert_failed
       0   FLASH_InstructionCacheReset
       0   FLASH_Lock
       8   FLASH_OB_BORConfig
         8   -> assert_failed
       8   FLASH_OB_BootConfig
         8   -> assert_failed
       0   FLASH_OB_GetBOR
       0   FLASH_OB_GetPCROP
       0   FLASH_OB_GetPCROP1
       0   FLASH_OB_GetRDP
       0   FLASH_OB_GetUser
       0   FLASH_OB_GetWRP
       0   FLASH_OB_GetWRP1
       0   FLASH_OB_Launch
         0   -> FLASH_WaitForLastOperation
       0   FLASH_OB_Lock
      16   FLASH_OB_PCROP1Config
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_OB_PCROPConfig
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       8   FLASH_OB_PCROPSelectionConfig
         8   -> assert_failed
       8   FLASH_OB_RDPConfig
         8   -> FLASH_WaitForLastOperation
         8   -> assert_failed
       0   FLASH_OB_Unlock
      16   FLASH_OB_UserConfig
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_OB_WRP1Config
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_OB_WRPConfig
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       8   FLASH_PrefetchBufferCmd
         8   -> assert_failed
      16   FLASH_ProgramByte
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      24   FLASH_ProgramDoubleWord
        24   -> FLASH_WaitForLastOperation
        24   -> assert_failed
      16   FLASH_ProgramHalfWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
      16   FLASH_ProgramWord
        16   -> FLASH_WaitForLastOperation
        16   -> assert_failed
       8   FLASH_SetLatency
         8   -> assert_failed
       0   FLASH_Unlock
       8   FLASH_WaitForLastOperation
         8   -> FLASH_GetStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_10
       4  ??DataTable39_11
       4  ??DataTable39_12
       4  ??DataTable39_13
       4  ??DataTable39_14
       4  ??DataTable39_15
       4  ??DataTable39_2
       4  ??DataTable39_3
       4  ??DataTable39_4
       4  ??DataTable39_5
       4  ??DataTable39_6
       4  ??DataTable39_7
       4  ??DataTable39_8
       4  ??DataTable39_9
     104  ?_0
      32  FLASH_ClearFlag
      48  FLASH_DataCacheCmd
      14  FLASH_DataCacheReset
     128  FLASH_EraseAllBank1Sectors
     128  FLASH_EraseAllBank2Sectors
     128  FLASH_EraseAllSectors
     250  FLASH_EraseSector
      68  FLASH_GetFlagStatus
      56  FLASH_GetStatus
      68  FLASH_ITConfig
      48  FLASH_InstructionCacheCmd
      14  FLASH_InstructionCacheReset
      14  FLASH_Lock
      50  FLASH_OB_BORConfig
      42  FLASH_OB_BootConfig
      10  FLASH_OB_GetBOR
       6  FLASH_OB_GetPCROP
       6  FLASH_OB_GetPCROP1
      14  FLASH_OB_GetRDP
      10  FLASH_OB_GetUser
       6  FLASH_OB_GetWRP
       6  FLASH_OB_GetWRP1
      12  FLASH_OB_Launch
      14  FLASH_OB_Lock
      76  FLASH_OB_PCROP1Config
      76  FLASH_OB_PCROPConfig
      36  FLASH_OB_PCROPSelectionConfig
      38  FLASH_OB_RDPConfig
      24  FLASH_OB_Unlock
      96  FLASH_OB_UserConfig
      76  FLASH_OB_WRP1Config
      78  FLASH_OB_WRPConfig
      48  FLASH_PrefetchBufferCmd
      94  FLASH_ProgramByte
     102  FLASH_ProgramDoubleWord
      98  FLASH_ProgramHalfWord
      98  FLASH_ProgramWord
      84  FLASH_SetLatency
      24  FLASH_Unlock
      40  FLASH_WaitForLastOperation

 
 2 428 bytes in section .text
 
 2 428 bytes of CODE memory

Errors: none
Warnings: none
