###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        08/Oct/2018  17:04:47
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_ltdc.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_ltdc.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_ltdc.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_ltdc.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_ltdc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_ltdc.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the LTDC controller (LTDC) peripheral:
      9            *           + Initialization and configuration
     10            *           + Interrupts and flags management
     11            *           
     12            *  @verbatim
     13            
     14           ===============================================================================
     15                                ##### How to use this driver #####
     16           ===============================================================================
     17              [..]
     18                  (#) Enable LTDC clock using 
     19                      RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, ENABLE) function.
     20                  (#) Configures LTDC
     21                    (++) Configure the required Pixel clock following the panel datasheet
     22                    (++) Configure the Synchronous timings: VSYNC, HSYNC, Vertical and 
     23                        Horizontal back proch, active data area and the front proch 
     24                        timings 
     25                    (++) Configure the synchronous signals and clock polarity in the 
     26                        LTDC_GCR register
     27                  (#) Configures Layer1/2 parameters
     28                    (++) The Layer window horizontal and vertical position in the LTDC_LxWHPCR and 
     29                         LTDC_WVPCR registers. The layer window must be in the active data area.
     30                    (++) The pixel input format in the LTDC_LxPFCR register
     31                    (++) The color frame buffer start address in the LTDC_LxCFBAR register
     32                    (++) The line length and pitch of the color frame buffer in the 
     33                         LTDC_LxCFBLR register
     34                    (++) The number of lines of the color frame buffer in 
     35                         the LTDC_LxCFBLNR register
     36                    (++) if needed, load the CLUT with the RGB values and the address 
     37                         in the LTDC_LxCLUTWR register
     38                    (++) If needed, configure the default color and the blending factors 
     39                         respectively in the LTDC_LxDCCR and LTDC_LxBFCR registers 
     40          
     41                    (++) If needed, Dithering and color keying can be be enabled respectively 
     42                         in the LTDC_GCR and LTDC_LxCKCR registers. It can be also enabled 
     43                         on the fly.    
     44                  (#) Enable Layer1/2 and if needed the CLUT in the LTDC_LxCR register 
     45            
     46                  (#) Reload the shadow registers to active register through 
     47                      the LTDC_SRCR register.
     48                    -@- All layer parameters can be be modified on the fly except the CLUT. 
     49                        The new configuration has to be either reloaded immediately 
     50                        or during vertical blanking period by configuring the LTDC_SRCR register.              
     51                  (#) Call the LTDC_Cmd() to enable the LTDC controller.
     52          
     53              @endverbatim
     54            
     55            ******************************************************************************
     56            * @attention
     57            *
     58            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     59            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     60            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     61            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     62            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     63            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     64            *
     65            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     66            ******************************************************************************
     67            */ 
     68          
     69          /* Includes ------------------------------------------------------------------*/
     70          #include "stm32f4xx_ltdc.h"
     71          #include "stm32f4xx_rcc.h"
     72          
     73          /** @addtogroup STM32F4xx_StdPeriph_Driver
     74            * @{
     75            */
     76          
     77          /** @defgroup LTDC 
     78            * @brief LTDC driver modules
     79            * @{
     80            */
     81          
     82          /* Private typedef -----------------------------------------------------------*/
     83          /* Private define ------------------------------------------------------------*/
     84          /* Private macro -------------------------------------------------------------*/
     85          /* Private variables ---------------------------------------------------------*/
     86          /* Private function prototypes -----------------------------------------------*/
     87          /* Private functions ---------------------------------------------------------*/
     88          
     89          #define GCR_MASK                     ((uint32_t)0x0FFE888F)  /* LTDC GCR Mask */
     90          
     91          
     92          /** @defgroup LTDC_Private_Functions
     93            * @{
     94            */
     95          
     96          /** @defgroup LTDC_Group1 Initialization and Configuration functions
     97           *  @brief   Initialization and Configuration functions 
     98           *
     99          @verbatim
    100           ===============================================================================
    101                      ##### Initialization and Configuration functions #####
    102           ===============================================================================
    103              [..]  This section provides functions allowing to:
    104                (+) Initialize and configure the LTDC
    105                (+) Enable or Disable Dither
    106                (+) Define the position of the line interrupt
    107                (+) reload layers registers with new parameters
    108                (+) Initialize and configure layer1 and layer2
    109                (+) Set and configure the color keying functionality
    110                (+) Configure and Enables or disables CLUT 
    111                
    112          @endverbatim
    113            * @{
    114            */
    115          
    116          /**
    117            * @brief  Deinitializes the LTDC peripheral registers to their default reset
    118            *         values.
    119            * @param  None
    120            * @retval None
    121            */
    122          

   \                                 In section .text, align 2, keep-with-next
    123          void LTDC_DeInit(void)
    124          {
   \                     LTDC_DeInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    125            /* Enable LTDC reset state */
    126            RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    127            /* Release LTDC from reset state */
    128            RCC_APB2PeriphResetCmd(RCC_APB2Periph_LTDC, DISABLE);
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF04F 0x6080      MOV      R0,#+67108864
   \   00000012   0xE8BD 0x4004      POP      {R2,LR}
   \   00000016   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    129          }
    130          
    131          /**
    132            * @brief  Initializes the LTDC peripheral according to the specified parameters
    133            *         in the LTDC_InitStruct.
    134            * @note   This function can be used only when the LTDC is disabled.
    135            * @param  LTDC_InitStruct: pointer to a LTDC_InitTypeDef structure that contains
    136            *         the configuration information for the specified LTDC peripheral.
    137            * @retval None
    138            */
    139          

   \                                 In section .text, align 2, keep-with-next
    140          void LTDC_Init(LTDC_InitTypeDef* LTDC_InitStruct)
    141          {
   \                     LTDC_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    142            uint32_t horizontalsync = 0;
    143            uint32_t accumulatedHBP = 0;
    144            uint32_t accumulatedactiveW = 0;
    145            uint32_t totalwidth = 0;
    146            uint32_t backgreen = 0;
    147            uint32_t backred = 0;
    148          
    149            /* Check function parameters */
    150            assert_param(IS_LTDC_HSYNC(LTDC_InitStruct->LTDC_HorizontalSync));
   \   00000004   0x.... 0x....      ADR.W    R5,?_0
   \   00000008   0x6920             LDR      R0,[R4, #+16]
   \   0000000A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000000E   0xD303             BCC.N    ??LTDC_Init_0
   \   00000010   0x2196             MOVS     R1,#+150
   \   00000012   0x4628             MOV      R0,R5
   \   00000014   0x.... 0x....      BL       assert_failed
    151            assert_param(IS_LTDC_VSYNC(LTDC_InitStruct->LTDC_VerticalSync));
   \                     ??LTDC_Init_0: (+1)
   \   00000018   0x6960             LDR      R0,[R4, #+20]
   \   0000001A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000001E   0xD303             BCC.N    ??LTDC_Init_1
   \   00000020   0x2197             MOVS     R1,#+151
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       assert_failed
    152            assert_param(IS_LTDC_AHBP(LTDC_InitStruct->LTDC_AccumulatedHBP));
   \                     ??LTDC_Init_1: (+1)
   \   00000028   0x69A0             LDR      R0,[R4, #+24]
   \   0000002A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000002E   0xD303             BCC.N    ??LTDC_Init_2
   \   00000030   0x2198             MOVS     R1,#+152
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       assert_failed
    153            assert_param(IS_LTDC_AVBP(LTDC_InitStruct->LTDC_AccumulatedVBP));
   \                     ??LTDC_Init_2: (+1)
   \   00000038   0x69E0             LDR      R0,[R4, #+28]
   \   0000003A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000003E   0xD303             BCC.N    ??LTDC_Init_3
   \   00000040   0x2199             MOVS     R1,#+153
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0x.... 0x....      BL       assert_failed
    154            assert_param(IS_LTDC_AAH(LTDC_InitStruct->LTDC_AccumulatedActiveH));
   \                     ??LTDC_Init_3: (+1)
   \   00000048   0x6A60             LDR      R0,[R4, #+36]
   \   0000004A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000004E   0xD303             BCC.N    ??LTDC_Init_4
   \   00000050   0x219A             MOVS     R1,#+154
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       assert_failed
    155            assert_param(IS_LTDC_AAW(LTDC_InitStruct->LTDC_AccumulatedActiveW));
   \                     ??LTDC_Init_4: (+1)
   \   00000058   0x6A20             LDR      R0,[R4, #+32]
   \   0000005A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000005E   0xD303             BCC.N    ??LTDC_Init_5
   \   00000060   0x219B             MOVS     R1,#+155
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       assert_failed
    156            assert_param(IS_LTDC_TOTALH(LTDC_InitStruct->LTDC_TotalHeigh));
   \                     ??LTDC_Init_5: (+1)
   \   00000068   0x6AE0             LDR      R0,[R4, #+44]
   \   0000006A   0xF5B0 0x6F00      CMP      R0,#+2048
   \   0000006E   0xD303             BCC.N    ??LTDC_Init_6
   \   00000070   0x219C             MOVS     R1,#+156
   \   00000072   0x4628             MOV      R0,R5
   \   00000074   0x.... 0x....      BL       assert_failed
    157            assert_param(IS_LTDC_TOTALW(LTDC_InitStruct->LTDC_TotalWidth));
   \                     ??LTDC_Init_6: (+1)
   \   00000078   0x6AA0             LDR      R0,[R4, #+40]
   \   0000007A   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000007E   0xD303             BCC.N    ??LTDC_Init_7
   \   00000080   0x219D             MOVS     R1,#+157
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       assert_failed
    158            assert_param(IS_LTDC_HSPOL(LTDC_InitStruct->LTDC_HSPolarity));
   \                     ??LTDC_Init_7: (+1)
   \   00000088   0x6820             LDR      R0,[R4, #+0]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD006             BEQ.N    ??LTDC_Init_8
   \   0000008E   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   00000092   0xD003             BEQ.N    ??LTDC_Init_8
   \   00000094   0x219E             MOVS     R1,#+158
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x.... 0x....      BL       assert_failed
    159            assert_param(IS_LTDC_VSPOL(LTDC_InitStruct->LTDC_VSPolarity));
   \                     ??LTDC_Init_8: (+1)
   \   0000009C   0x6860             LDR      R0,[R4, #+4]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD006             BEQ.N    ??LTDC_Init_9
   \   000000A2   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \   000000A6   0xD003             BEQ.N    ??LTDC_Init_9
   \   000000A8   0x219F             MOVS     R1,#+159
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       assert_failed
    160            assert_param(IS_LTDC_DEPOL(LTDC_InitStruct->LTDC_DEPolarity));
   \                     ??LTDC_Init_9: (+1)
   \   000000B0   0x68A0             LDR      R0,[R4, #+8]
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD006             BEQ.N    ??LTDC_Init_10
   \   000000B6   0xF1B0 0x5F00      CMP      R0,#+536870912
   \   000000BA   0xD003             BEQ.N    ??LTDC_Init_10
   \   000000BC   0x21A0             MOVS     R1,#+160
   \   000000BE   0x4628             MOV      R0,R5
   \   000000C0   0x.... 0x....      BL       assert_failed
    161            assert_param(IS_LTDC_PCPOL(LTDC_InitStruct->LTDC_PCPolarity));
   \                     ??LTDC_Init_10: (+1)
   \   000000C4   0x68E0             LDR      R0,[R4, #+12]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD006             BEQ.N    ??LTDC_Init_11
   \   000000CA   0xF1B0 0x5F80      CMP      R0,#+268435456
   \   000000CE   0xD003             BEQ.N    ??LTDC_Init_11
   \   000000D0   0x21A1             MOVS     R1,#+161
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       assert_failed
    162            assert_param(IS_LTDC_BackBlueValue(LTDC_InitStruct->LTDC_BackgroundBlueValue));
   \                     ??LTDC_Init_11: (+1)
   \   000000D8   0x6BA0             LDR      R0,[R4, #+56]
   \   000000DA   0x28FF             CMP      R0,#+255
   \   000000DC   0xD903             BLS.N    ??LTDC_Init_12
   \   000000DE   0x21A2             MOVS     R1,#+162
   \   000000E0   0x4628             MOV      R0,R5
   \   000000E2   0x.... 0x....      BL       assert_failed
    163            assert_param(IS_LTDC_BackGreenValue(LTDC_InitStruct->LTDC_BackgroundGreenValue));
   \                     ??LTDC_Init_12: (+1)
   \   000000E6   0x6B60             LDR      R0,[R4, #+52]
   \   000000E8   0x28FF             CMP      R0,#+255
   \   000000EA   0xD903             BLS.N    ??LTDC_Init_13
   \   000000EC   0x21A3             MOVS     R1,#+163
   \   000000EE   0x4628             MOV      R0,R5
   \   000000F0   0x.... 0x....      BL       assert_failed
    164            assert_param(IS_LTDC_BackRedValue(LTDC_InitStruct->LTDC_BackgroundRedValue));
   \                     ??LTDC_Init_13: (+1)
   \   000000F4   0x6B20             LDR      R0,[R4, #+48]
   \   000000F6   0x28FF             CMP      R0,#+255
   \   000000F8   0xD903             BLS.N    ??LTDC_Init_14
   \   000000FA   0x21A4             MOVS     R1,#+164
   \   000000FC   0x4628             MOV      R0,R5
   \   000000FE   0x.... 0x....      BL       assert_failed
    165          
    166            /* Sets Synchronization size */
    167            LTDC->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
   \                     ??LTDC_Init_14: (+1)
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0xf000f800
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40016808
   \   0000010A   0x6802             LDR      R2,[R0, #+0]
   \   0000010C   0x400A             ANDS     R2,R1,R2
   \   0000010E   0x6002             STR      R2,[R0, #+0]
    168            horizontalsync = (LTDC_InitStruct->LTDC_HorizontalSync << 16);
    169            LTDC->SSCR |= (horizontalsync | LTDC_InitStruct->LTDC_VerticalSync);
   \   00000110   0x6802             LDR      R2,[R0, #+0]
   \   00000112   0x6923             LDR      R3,[R4, #+16]
   \   00000114   0x6965             LDR      R5,[R4, #+20]
   \   00000116   0xEA45 0x4303      ORR      R3,R5,R3, LSL #+16
   \   0000011A   0x431A             ORRS     R2,R3,R2
   \   0000011C   0x6002             STR      R2,[R0, #+0]
    170          
    171            /* Sets Accumulated Back porch */
    172            LTDC->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
   \   0000011E   0x6842             LDR      R2,[R0, #+4]
   \   00000120   0x400A             ANDS     R2,R1,R2
   \   00000122   0x6042             STR      R2,[R0, #+4]
    173            accumulatedHBP = (LTDC_InitStruct->LTDC_AccumulatedHBP << 16);
    174            LTDC->BPCR |= (accumulatedHBP | LTDC_InitStruct->LTDC_AccumulatedVBP);
   \   00000124   0x6842             LDR      R2,[R0, #+4]
   \   00000126   0x69A3             LDR      R3,[R4, #+24]
   \   00000128   0x69E5             LDR      R5,[R4, #+28]
   \   0000012A   0xEA45 0x4303      ORR      R3,R5,R3, LSL #+16
   \   0000012E   0x431A             ORRS     R2,R3,R2
   \   00000130   0x6042             STR      R2,[R0, #+4]
    175          
    176            /* Sets Accumulated Active Width */
    177            LTDC->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
   \   00000132   0x6882             LDR      R2,[R0, #+8]
   \   00000134   0x400A             ANDS     R2,R1,R2
   \   00000136   0x6082             STR      R2,[R0, #+8]
    178            accumulatedactiveW = (LTDC_InitStruct->LTDC_AccumulatedActiveW << 16);
    179            LTDC->AWCR |= (accumulatedactiveW | LTDC_InitStruct->LTDC_AccumulatedActiveH);
   \   00000138   0x6882             LDR      R2,[R0, #+8]
   \   0000013A   0x6A23             LDR      R3,[R4, #+32]
   \   0000013C   0x6A65             LDR      R5,[R4, #+36]
   \   0000013E   0xEA45 0x4303      ORR      R3,R5,R3, LSL #+16
   \   00000142   0x431A             ORRS     R2,R3,R2
   \   00000144   0x6082             STR      R2,[R0, #+8]
    180          
    181            /* Sets Total Width */
    182            LTDC->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
   \   00000146   0x68C2             LDR      R2,[R0, #+12]
   \   00000148   0x4011             ANDS     R1,R1,R2
   \   0000014A   0x60C1             STR      R1,[R0, #+12]
    183            totalwidth = (LTDC_InitStruct->LTDC_TotalWidth << 16);
    184            LTDC->TWCR |= (totalwidth | LTDC_InitStruct->LTDC_TotalHeigh);
   \   0000014C   0x68C1             LDR      R1,[R0, #+12]
   \   0000014E   0x6AA2             LDR      R2,[R4, #+40]
   \   00000150   0x6AE3             LDR      R3,[R4, #+44]
   \   00000152   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   00000156   0x4311             ORRS     R1,R2,R1
   \   00000158   0x60C1             STR      R1,[R0, #+12]
    185          
    186            LTDC->GCR &= (uint32_t)GCR_MASK;
   \   0000015A   0x6901             LDR      R1,[R0, #+16]
   \   0000015C   0x.... 0x....      LDR.W    R2,??DataTable17_2  ;; 0xffe888f
   \   00000160   0x4011             ANDS     R1,R2,R1
   \   00000162   0x6101             STR      R1,[R0, #+16]
    187            LTDC->GCR |=  (uint32_t)(LTDC_InitStruct->LTDC_HSPolarity | LTDC_InitStruct->LTDC_VSPolarity | \
    188                                     LTDC_InitStruct->LTDC_DEPolarity | LTDC_InitStruct->LTDC_PCPolarity);
   \   00000164   0x6901             LDR      R1,[R0, #+16]
   \   00000166   0x6822             LDR      R2,[R4, #+0]
   \   00000168   0x6863             LDR      R3,[R4, #+4]
   \   0000016A   0x431A             ORRS     R2,R3,R2
   \   0000016C   0x68A3             LDR      R3,[R4, #+8]
   \   0000016E   0x431A             ORRS     R2,R3,R2
   \   00000170   0x68E3             LDR      R3,[R4, #+12]
   \   00000172   0x431A             ORRS     R2,R3,R2
   \   00000174   0x4311             ORRS     R1,R2,R1
   \   00000176   0x6101             STR      R1,[R0, #+16]
    189          
    190            /* sets the background color value */
    191            backgreen = (LTDC_InitStruct->LTDC_BackgroundGreenValue << 8);
   \   00000178   0x6B61             LDR      R1,[R4, #+52]
    192            backred = (LTDC_InitStruct->LTDC_BackgroundRedValue << 16);
   \   0000017A   0x6B22             LDR      R2,[R4, #+48]
   \   0000017C   0x0412             LSLS     R2,R2,#+16
    193          
    194            LTDC->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
   \   0000017E   0x6A43             LDR      R3,[R0, #+36]
   \   00000180   0xF003 0x437F      AND      R3,R3,#0xFF000000
   \   00000184   0x6243             STR      R3,[R0, #+36]
    195            LTDC->BCCR |= (backred | backgreen | LTDC_InitStruct->LTDC_BackgroundBlueValue);
   \   00000186   0x6A43             LDR      R3,[R0, #+36]
   \   00000188   0xEA52 0x2101      ORRS     R1,R2,R1, LSL #+8
   \   0000018C   0x6BA2             LDR      R2,[R4, #+56]
   \   0000018E   0x4311             ORRS     R1,R2,R1
   \   00000190   0x4319             ORRS     R1,R1,R3
   \   00000192   0x6241             STR      R1,[R0, #+36]
    196          }
   \   00000194   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    197          
    198          /**
    199            * @brief  Fills each LTDC_InitStruct member with its default value.
    200            * @param  LTDC_InitStruct: pointer to a LTDC_InitTypeDef structure which will
    201            *         be initialized.
    202            * @retval None
    203            */
    204          

   \                                 In section .text, align 2, keep-with-next
    205          void LTDC_StructInit(LTDC_InitTypeDef* LTDC_InitStruct)
    206          {
    207            /*--------------- Reset LTDC init structure parameters values ----------------*/
    208            LTDC_InitStruct->LTDC_HSPolarity = LTDC_HSPolarity_AL;      /*!< Initialize the LTDC_HSPolarity member */ 
   \                     LTDC_StructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    209            LTDC_InitStruct->LTDC_VSPolarity = LTDC_VSPolarity_AL;      /*!< Initialize the LTDC_VSPolarity member */
   \   00000004   0x6041             STR      R1,[R0, #+4]
    210            LTDC_InitStruct->LTDC_DEPolarity = LTDC_DEPolarity_AL;      /*!< Initialize the LTDC_DEPolarity member */
   \   00000006   0x6081             STR      R1,[R0, #+8]
    211            LTDC_InitStruct->LTDC_PCPolarity = LTDC_PCPolarity_IPC;     /*!< Initialize the LTDC_PCPolarity member */
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    212            LTDC_InitStruct->LTDC_HorizontalSync = 0x00;                /*!< Initialize the LTDC_HorizontalSync member */
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    213            LTDC_InitStruct->LTDC_VerticalSync = 0x00;                  /*!< Initialize the LTDC_VerticalSync member */
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    214            LTDC_InitStruct->LTDC_AccumulatedHBP = 0x00;                /*!< Initialize the LTDC_AccumulatedHBP member */
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    215            LTDC_InitStruct->LTDC_AccumulatedVBP = 0x00;                /*!< Initialize the LTDC_AccumulatedVBP member */
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    216            LTDC_InitStruct->LTDC_AccumulatedActiveW = 0x00;            /*!< Initialize the LTDC_AccumulatedActiveW member */
   \   00000012   0x6201             STR      R1,[R0, #+32]
    217            LTDC_InitStruct->LTDC_AccumulatedActiveH = 0x00;            /*!< Initialize the LTDC_AccumulatedActiveH member */
   \   00000014   0x6241             STR      R1,[R0, #+36]
    218            LTDC_InitStruct->LTDC_TotalWidth = 0x00;                    /*!< Initialize the LTDC_TotalWidth member */
   \   00000016   0x6281             STR      R1,[R0, #+40]
    219            LTDC_InitStruct->LTDC_TotalHeigh = 0x00;                    /*!< Initialize the LTDC_TotalHeigh member */
   \   00000018   0x62C1             STR      R1,[R0, #+44]
    220            LTDC_InitStruct->LTDC_BackgroundRedValue = 0x00;            /*!< Initialize the LTDC_BackgroundRedValue member */
   \   0000001A   0x6301             STR      R1,[R0, #+48]
    221            LTDC_InitStruct->LTDC_BackgroundGreenValue = 0x00;          /*!< Initialize the LTDC_BackgroundGreenValue member */
   \   0000001C   0x6341             STR      R1,[R0, #+52]
    222            LTDC_InitStruct->LTDC_BackgroundBlueValue = 0x00;           /*!< Initialize the LTDC_BackgroundBlueValue member */
   \   0000001E   0x6381             STR      R1,[R0, #+56]
    223          }
   \   00000020   0x4770             BX       LR               ;; return
    224          
    225          /**
    226            * @brief  Enables or disables the LTDC Controller.
    227            * @param  NewState: new state of the LTDC peripheral.
    228            *   This parameter can be: ENABLE or DISABLE.
    229            * @retval None
    230            */
    231          

   \                                 In section .text, align 2, keep-with-next
    232          void LTDC_Cmd(FunctionalState NewState)
    233          {
   \                     LTDC_Cmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    234            /* Check the parameters */
    235            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD006             BEQ.N    ??LTDC_Cmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD004             BEQ.N    ??LTDC_Cmd_0
   \   0000000A   0x21EB             MOVS     R1,#+235
   \   0000000C   0x.... 0x....      ADR.W    R0,?_0
   \   00000010   0x.... 0x....      BL       assert_failed
    236          
    237            if (NewState != DISABLE)
   \                     ??LTDC_Cmd_0: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40016818
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xD003             BEQ.N    ??LTDC_Cmd_1
    238            {
    239              /* Enable LTDC by setting LTDCEN bit */
    240              LTDC->GCR |= (uint32_t)LTDC_GCR_LTDCEN;
   \   0000001E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000022   0x6001             STR      R1,[R0, #+0]
   \   00000024   0xBD10             POP      {R4,PC}
    241            }
    242            else
    243            {
    244              /* Disable LTDC by clearing LTDCEN bit */
    245              LTDC->GCR &= ~(uint32_t)LTDC_GCR_LTDCEN;
   \                     ??LTDC_Cmd_1: (+1)
   \   00000026   0x0849             LSRS     R1,R1,#+1
   \   00000028   0x0049             LSLS     R1,R1,#+1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    246            }
    247          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    248          
    249          /**
    250            * @brief  Enables or disables Dither.
    251            * @param  NewState: new state of the Dither.
    252            *   This parameter can be: ENABLE or DISABLE.
    253            * @retval None
    254            */
    255          

   \                                 In section .text, align 2, keep-with-next
    256          void LTDC_DitherCmd(FunctionalState NewState)
    257          {
   \                     LTDC_DitherCmd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    258            /* Check the parameters */
    259            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000004   0xD007             BEQ.N    ??LTDC_DitherCmd_0
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD005             BEQ.N    ??LTDC_DitherCmd_0
   \   0000000A   0xF240 0x1103      MOVW     R1,#+259
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    260          
    261            if (NewState != DISABLE)
   \                     ??LTDC_DitherCmd_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40016818
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xD003             BEQ.N    ??LTDC_DitherCmd_1
    262            {
    263              /* Enable Dither by setting DTEN bit */
    264              LTDC->GCR |= (uint32_t)LTDC_GCR_DTEN;
   \   00000020   0xF441 0x3180      ORR      R1,R1,#0x10000
   \   00000024   0x6001             STR      R1,[R0, #+0]
   \   00000026   0xBD10             POP      {R4,PC}
    265            }
    266            else
    267            {
    268              /* Disable Dither by clearing DTEN bit */
    269              LTDC->GCR &= ~(uint32_t)LTDC_GCR_DTEN;
   \                     ??LTDC_DitherCmd_1: (+1)
   \   00000028   0xF421 0x3180      BIC      R1,R1,#0x10000
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    270            }
    271          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    272          
    273          /**
    274            * @brief  Get the dither RGB width.
    275            * @param  LTDC_RGB_InitStruct: pointer to a LTDC_RGBTypeDef structure that contains
    276            *         the Dither RGB width.
    277            * @retval None
    278            */
    279          

   \                                 In section .text, align 2, keep-with-next
    280          LTDC_RGBTypeDef LTDC_GetRGBWidth(void)
    281          {
   \                     LTDC_GetRGBWidth: (+1)
   \   00000000   0xB41E             PUSH     {R1-R4}
    282            LTDC_RGBTypeDef LTDC_RGB_InitStruct;
    283          
    284            LTDC->GCR &= (uint32_t)GCR_MASK;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable17_3  ;; 0x40016818
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0x.... 0x....      LDR.W    R3,??DataTable17_2  ;; 0xffe888f
   \   0000000C   0x401A             ANDS     R2,R3,R2
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    285          
    286            LTDC_RGB_InitStruct.LTDC_BlueWidth = (uint32_t)((LTDC->GCR >> 4) & 0x7);
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0xF3C2 0x1202      UBFX     R2,R2,#+4,#+3
   \   00000016   0x9200             STR      R2,[SP, #+0]
    287            LTDC_RGB_InitStruct.LTDC_GreenWidth = (uint32_t)((LTDC->GCR >> 8) & 0x7);
   \   00000018   0x680A             LDR      R2,[R1, #+0]
   \   0000001A   0xF3C2 0x2202      UBFX     R2,R2,#+8,#+3
   \   0000001E   0x9201             STR      R2,[SP, #+4]
    288            LTDC_RGB_InitStruct.LTDC_RedWidth = (uint32_t)((LTDC->GCR >> 12) & 0x7);
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0xF3C1 0x3102      UBFX     R1,R1,#+12,#+3
   \   00000026   0x9102             STR      R1,[SP, #+8]
    289          
    290            return LTDC_RGB_InitStruct;
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0xC91C             LDM      R1!,{R2-R4}
   \   0000002C   0xC01C             STM      R0!,{R2-R4}
   \   0000002E   0x380C             SUBS     R0,R0,#+12
   \   00000030   0xBC1E             POP      {R1-R4}
   \   00000032   0x4770             BX       LR               ;; return
    291          }
    292          
    293          /**
    294            * @brief  Fills each LTDC_RGBStruct member with its default value.
    295            * @param  LTDC_RGB_InitStruct: pointer to a LTDC_RGBTypeDef structure which will
    296            *         be initialized.
    297            * @retval None
    298            */
    299          

   \                                 In section .text, align 2, keep-with-next
    300          void LTDC_RGBStructInit(LTDC_RGBTypeDef* LTDC_RGB_InitStruct)
    301          {
    302            LTDC_RGB_InitStruct->LTDC_BlueWidth = 0x02;
   \                     LTDC_RGBStructInit: (+1)
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x6001             STR      R1,[R0, #+0]
    303            LTDC_RGB_InitStruct->LTDC_GreenWidth = 0x02;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    304            LTDC_RGB_InitStruct->LTDC_RedWidth = 0x02;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    305          }
   \   00000008   0x4770             BX       LR               ;; return
    306          
    307          
    308          /**
    309            * @brief  Define the position of the line interrupt .
    310            * @param  LTDC_LIPositionConfig: Line Interrupt Position.
    311            * @retval None
    312            */
    313          

   \                                 In section .text, align 2, keep-with-next
    314          void LTDC_LIPConfig(uint32_t LTDC_LIPositionConfig)
    315          {
   \                     LTDC_LIPConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    316            /* Check the parameters */
    317            assert_param(IS_LTDC_LIPOS(LTDC_LIPositionConfig));
   \   00000004   0xF5B4 0x6F00      CMP      R4,#+2048
   \   00000008   0xD305             BCC.N    ??LTDC_LIPConfig_0
   \   0000000A   0xF240 0x113D      MOVW     R1,#+317
   \   0000000E   0x.... 0x....      ADR.W    R0,?_0
   \   00000012   0x.... 0x....      BL       assert_failed
    318          
    319            /* Sets the Line Interrupt position */
    320            LTDC->LIPCR = (uint32_t)LTDC_LIPositionConfig;
   \                     ??LTDC_LIPConfig_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_4  ;; 0x40016840
   \   0000001A   0x6004             STR      R4,[R0, #+0]
    321          }
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    322          
    323          /**
    324            * @brief  reload layers registers with new parameters 
    325            * @param  LTDC_Reload: specifies the type of reload.
    326            *   This parameter can be one of the following values:
    327            *     @arg LTDC_IMReload: Vertical blanking reload.
    328            *     @arg LTDC_VBReload: Immediate reload.  
    329            * @retval None
    330            */
    331          

   \                                 In section .text, align 2, keep-with-next
    332          void LTDC_ReloadConfig(uint32_t LTDC_Reload)
    333          {
   \                     LTDC_ReloadConfig: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    334            /* Check the parameters */
    335            assert_param(IS_LTDC_RELOAD(LTDC_Reload));
   \   00000004   0x2C01             CMP      R4,#+1
   \   00000006   0xD007             BEQ.N    ??LTDC_ReloadConfig_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD005             BEQ.N    ??LTDC_ReloadConfig_0
   \   0000000C   0xF240 0x114F      MOVW     R1,#+335
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
    336          
    337            /* Sets the Reload type */
    338            LTDC->SRCR = (uint32_t)LTDC_Reload;
   \                     ??LTDC_ReloadConfig_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40016824
   \   0000001C   0x6004             STR      R4,[R0, #+0]
    339          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    340          
    341          
    342          /**
    343            * @brief  Initializes the LTDC Layer according to the specified parameters
    344            *         in the LTDC_LayerStruct.
    345            * @note   This function can be used only when the LTDC is disabled.
    346            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    347            *         one of the following values: LTDC_Layer1, LTDC_Layer2    
    348            * @param  LTDC_LayerStruct: pointer to a LTDC_LayerTypeDef structure that contains
    349            *         the configuration information for the specified LTDC peripheral.
    350            * @retval None
    351            */
    352          

   \                                 In section .text, align 2, keep-with-next
    353          void LTDC_LayerInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_Layer_InitTypeDef* LTDC_Layer_InitStruct)
    354          {
   \                     LTDC_LayerInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    355          
    356            uint32_t whsppos = 0;
    357            uint32_t wvsppos = 0;
    358            uint32_t dcgreen = 0;
    359            uint32_t dcred = 0;
    360            uint32_t dcalpha = 0;
    361            uint32_t cfbp = 0;
    362          
    363          /* Check the parameters */
    364            assert_param(IS_LTDC_Pixelformat(LTDC_Layer_InitStruct->LTDC_PixelFormat));
   \   00000006   0x6928             LDR      R0,[R5, #+16]
   \   00000008   0x.... 0x....      ADR.W    R6,?_0
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD012             BEQ.N    ??LTDC_LayerInit_0
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD010             BEQ.N    ??LTDC_LayerInit_0
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD00E             BEQ.N    ??LTDC_LayerInit_0
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD00C             BEQ.N    ??LTDC_LayerInit_0
   \   0000001C   0x2804             CMP      R0,#+4
   \   0000001E   0xD00A             BEQ.N    ??LTDC_LayerInit_0
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xD008             BEQ.N    ??LTDC_LayerInit_0
   \   00000024   0x2806             CMP      R0,#+6
   \   00000026   0xD006             BEQ.N    ??LTDC_LayerInit_0
   \   00000028   0x2807             CMP      R0,#+7
   \   0000002A   0xD004             BEQ.N    ??LTDC_LayerInit_0
   \   0000002C   0xF44F 0x71B6      MOV      R1,#+364
   \   00000030   0x4630             MOV      R0,R6
   \   00000032   0x.... 0x....      BL       assert_failed
    365            assert_param(IS_LTDC_BlendingFactor1(LTDC_Layer_InitStruct->LTDC_BlendingFactor_1));
   \                     ??LTDC_LayerInit_0: (+1)
   \   00000036   0x6AA8             LDR      R0,[R5, #+40]
   \   00000038   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000003C   0xD007             BEQ.N    ??LTDC_LayerInit_1
   \   0000003E   0xF5B0 0x6FC0      CMP      R0,#+1536
   \   00000042   0xD004             BEQ.N    ??LTDC_LayerInit_1
   \   00000044   0xF240 0x116D      MOVW     R1,#+365
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       assert_failed
    366            assert_param(IS_LTDC_BlendingFactor2(LTDC_Layer_InitStruct->LTDC_BlendingFactor_2));
   \                     ??LTDC_LayerInit_1: (+1)
   \   0000004E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000050   0x2805             CMP      R0,#+5
   \   00000052   0xD006             BEQ.N    ??LTDC_LayerInit_2
   \   00000054   0x2807             CMP      R0,#+7
   \   00000056   0xD004             BEQ.N    ??LTDC_LayerInit_2
   \   00000058   0xF44F 0x71B7      MOV      R1,#+366
   \   0000005C   0x4630             MOV      R0,R6
   \   0000005E   0x.... 0x....      BL       assert_failed
    367            assert_param(IS_LTDC_HCONFIGST(LTDC_Layer_InitStruct->LTDC_HorizontalStart));
   \                     ??LTDC_LayerInit_2: (+1)
   \   00000062   0x6828             LDR      R0,[R5, #+0]
   \   00000064   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000068   0xD304             BCC.N    ??LTDC_LayerInit_3
   \   0000006A   0xF240 0x116F      MOVW     R1,#+367
   \   0000006E   0x4630             MOV      R0,R6
   \   00000070   0x.... 0x....      BL       assert_failed
    368            assert_param(IS_LTDC_HCONFIGSP(LTDC_Layer_InitStruct->LTDC_HorizontalStop));
   \                     ??LTDC_LayerInit_3: (+1)
   \   00000074   0x6868             LDR      R0,[R5, #+4]
   \   00000076   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000007A   0xD304             BCC.N    ??LTDC_LayerInit_4
   \   0000007C   0xF44F 0x71B8      MOV      R1,#+368
   \   00000080   0x4630             MOV      R0,R6
   \   00000082   0x.... 0x....      BL       assert_failed
    369            assert_param(IS_LTDC_VCONFIGST(LTDC_Layer_InitStruct->LTDC_VerticalStart));
   \                     ??LTDC_LayerInit_4: (+1)
   \   00000086   0x68A8             LDR      R0,[R5, #+8]
   \   00000088   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000008C   0xD304             BCC.N    ??LTDC_LayerInit_5
   \   0000008E   0xF240 0x1171      MOVW     R1,#+369
   \   00000092   0x4630             MOV      R0,R6
   \   00000094   0x.... 0x....      BL       assert_failed
    370            assert_param(IS_LTDC_VCONFIGSP(LTDC_Layer_InitStruct->LTDC_VerticalStop));  
   \                     ??LTDC_LayerInit_5: (+1)
   \   00000098   0x68E8             LDR      R0,[R5, #+12]
   \   0000009A   0xF5B0 0x3F80      CMP      R0,#+65536
   \   0000009E   0xD304             BCC.N    ??LTDC_LayerInit_6
   \   000000A0   0xF44F 0x71B9      MOV      R1,#+370
   \   000000A4   0x4630             MOV      R0,R6
   \   000000A6   0x.... 0x....      BL       assert_failed
    371            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorBlue));
   \                     ??LTDC_LayerInit_6: (+1)
   \   000000AA   0x69A8             LDR      R0,[R5, #+24]
   \   000000AC   0x28FF             CMP      R0,#+255
   \   000000AE   0xD904             BLS.N    ??LTDC_LayerInit_7
   \   000000B0   0xF240 0x1173      MOVW     R1,#+371
   \   000000B4   0x4630             MOV      R0,R6
   \   000000B6   0x.... 0x....      BL       assert_failed
    372            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorGreen));
   \                     ??LTDC_LayerInit_7: (+1)
   \   000000BA   0x69E8             LDR      R0,[R5, #+28]
   \   000000BC   0x28FF             CMP      R0,#+255
   \   000000BE   0xD904             BLS.N    ??LTDC_LayerInit_8
   \   000000C0   0xF44F 0x71BA      MOV      R1,#+372
   \   000000C4   0x4630             MOV      R0,R6
   \   000000C6   0x.... 0x....      BL       assert_failed
    373            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorRed));
   \                     ??LTDC_LayerInit_8: (+1)
   \   000000CA   0x6A28             LDR      R0,[R5, #+32]
   \   000000CC   0x28FF             CMP      R0,#+255
   \   000000CE   0xD904             BLS.N    ??LTDC_LayerInit_9
   \   000000D0   0xF240 0x1175      MOVW     R1,#+373
   \   000000D4   0x4630             MOV      R0,R6
   \   000000D6   0x.... 0x....      BL       assert_failed
    374            assert_param(IS_LTDC_DEFAULTCOLOR(LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha));
   \                     ??LTDC_LayerInit_9: (+1)
   \   000000DA   0x6A68             LDR      R0,[R5, #+36]
   \   000000DC   0x28FF             CMP      R0,#+255
   \   000000DE   0xD904             BLS.N    ??LTDC_LayerInit_10
   \   000000E0   0xF44F 0x71BB      MOV      R1,#+374
   \   000000E4   0x4630             MOV      R0,R6
   \   000000E6   0x.... 0x....      BL       assert_failed
    375            assert_param(IS_LTDC_CFBP(LTDC_Layer_InitStruct->LTDC_CFBPitch));
   \                     ??LTDC_LayerInit_10: (+1)
   \   000000EA   0x6BA8             LDR      R0,[R5, #+56]
   \   000000EC   0xF5B0 0x5F00      CMP      R0,#+8192
   \   000000F0   0xD304             BCC.N    ??LTDC_LayerInit_11
   \   000000F2   0xF240 0x1177      MOVW     R1,#+375
   \   000000F6   0x4630             MOV      R0,R6
   \   000000F8   0x.... 0x....      BL       assert_failed
    376            assert_param(IS_LTDC_CFBLL(LTDC_Layer_InitStruct->LTDC_CFBLineLength));
   \                     ??LTDC_LayerInit_11: (+1)
   \   000000FC   0x6B68             LDR      R0,[R5, #+52]
   \   000000FE   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000102   0xD304             BCC.N    ??LTDC_LayerInit_12
   \   00000104   0xF44F 0x71BC      MOV      R1,#+376
   \   00000108   0x4630             MOV      R0,R6
   \   0000010A   0x.... 0x....      BL       assert_failed
    377            assert_param(IS_LTDC_CFBLNBR(LTDC_Layer_InitStruct->LTDC_CFBLineNumber));
   \                     ??LTDC_LayerInit_12: (+1)
   \   0000010E   0x6BE8             LDR      R0,[R5, #+60]
   \   00000110   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000114   0xD304             BCC.N    ??LTDC_LayerInit_13
   \   00000116   0xF240 0x1179      MOVW     R1,#+377
   \   0000011A   0x4630             MOV      R0,R6
   \   0000011C   0x.... 0x....      BL       assert_failed
    378          
    379            /* Configures the horizontal start and stop position */
    380            whsppos = LTDC_Layer_InitStruct->LTDC_HorizontalStop << 16;
   \                     ??LTDC_LayerInit_13: (+1)
   \   00000120   0x6868             LDR      R0,[R5, #+4]
    381            LTDC_Layerx->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
   \   00000122   0x6861             LDR      R1,[R4, #+4]
   \   00000124   0xF401 0x4170      AND      R1,R1,#0xF000
   \   00000128   0x6061             STR      R1,[R4, #+4]
    382            LTDC_Layerx->WHPCR = (LTDC_Layer_InitStruct->LTDC_HorizontalStart | whsppos);
   \   0000012A   0x6829             LDR      R1,[R5, #+0]
   \   0000012C   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000130   0x6060             STR      R0,[R4, #+4]
    383          
    384            /* Configures the vertical start and stop position */
    385            wvsppos = LTDC_Layer_InitStruct->LTDC_VerticalStop << 16;
   \   00000132   0x68E8             LDR      R0,[R5, #+12]
    386            LTDC_Layerx->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
   \   00000134   0x68A1             LDR      R1,[R4, #+8]
   \   00000136   0xF401 0x4170      AND      R1,R1,#0xF000
   \   0000013A   0x60A1             STR      R1,[R4, #+8]
    387            LTDC_Layerx->WVPCR  = (LTDC_Layer_InitStruct->LTDC_VerticalStart | wvsppos);
   \   0000013C   0x68A9             LDR      R1,[R5, #+8]
   \   0000013E   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   00000142   0x60A0             STR      R0,[R4, #+8]
    388          
    389            /* Specifies the pixel format */
    390            LTDC_Layerx->PFCR &= ~(LTDC_LxPFCR_PF);
   \   00000144   0x6920             LDR      R0,[R4, #+16]
   \   00000146   0x08C0             LSRS     R0,R0,#+3
   \   00000148   0x00C0             LSLS     R0,R0,#+3
   \   0000014A   0x6120             STR      R0,[R4, #+16]
    391            LTDC_Layerx->PFCR = (LTDC_Layer_InitStruct->LTDC_PixelFormat);
   \   0000014C   0x6928             LDR      R0,[R5, #+16]
   \   0000014E   0x6120             STR      R0,[R4, #+16]
    392          
    393            /* Configures the default color values */
    394            dcgreen = (LTDC_Layer_InitStruct->LTDC_DefaultColorGreen << 8);
   \   00000150   0x69E8             LDR      R0,[R5, #+28]
    395            dcred = (LTDC_Layer_InitStruct->LTDC_DefaultColorRed << 16);
   \   00000152   0x6A29             LDR      R1,[R5, #+32]
    396            dcalpha = (LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha << 24);
   \   00000154   0x6A6A             LDR      R2,[R5, #+36]
    397            LTDC_Layerx->DCCR &=  ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
   \   00000156   0x69A3             LDR      R3,[R4, #+24]
   \   00000158   0x2300             MOVS     R3,#+0
   \   0000015A   0x61A3             STR      R3,[R4, #+24]
    398            LTDC_Layerx->DCCR = (LTDC_Layer_InitStruct->LTDC_DefaultColorBlue | dcgreen | \
    399                                  dcred | dcalpha);
   \   0000015C   0x69AB             LDR      R3,[R5, #+24]
   \   0000015E   0xEA53 0x2000      ORRS     R0,R3,R0, LSL #+8
   \   00000162   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000166   0xEA50 0x6002      ORRS     R0,R0,R2, LSL #+24
   \   0000016A   0x61A0             STR      R0,[R4, #+24]
    400          
    401            /* Specifies the constant alpha value */      
    402            LTDC_Layerx->CACR &= ~(LTDC_LxCACR_CONSTA);
   \   0000016C   0x6960             LDR      R0,[R4, #+20]
   \   0000016E   0x0A00             LSRS     R0,R0,#+8
   \   00000170   0x0200             LSLS     R0,R0,#+8
   \   00000172   0x6160             STR      R0,[R4, #+20]
    403            LTDC_Layerx->CACR = (LTDC_Layer_InitStruct->LTDC_ConstantAlpha);
   \   00000174   0x6968             LDR      R0,[R5, #+20]
   \   00000176   0x6160             STR      R0,[R4, #+20]
    404          
    405            /* Specifies the blending factors */
    406            LTDC_Layerx->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
   \   00000178   0x69E0             LDR      R0,[R4, #+28]
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable17_6  ;; 0xfffff8f8
   \   0000017E   0x4008             ANDS     R0,R1,R0
   \   00000180   0x61E0             STR      R0,[R4, #+28]
    407            LTDC_Layerx->BFCR = (LTDC_Layer_InitStruct->LTDC_BlendingFactor_1 | LTDC_Layer_InitStruct->LTDC_BlendingFactor_2);
   \   00000182   0x6AA8             LDR      R0,[R5, #+40]
   \   00000184   0x6AE9             LDR      R1,[R5, #+44]
   \   00000186   0x4308             ORRS     R0,R1,R0
   \   00000188   0x61E0             STR      R0,[R4, #+28]
    408          
    409            /* Configures the color frame buffer start address */
    410            LTDC_Layerx->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
   \   0000018A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000018C   0x2000             MOVS     R0,#+0
   \   0000018E   0x62A0             STR      R0,[R4, #+40]
    411            LTDC_Layerx->CFBAR = (LTDC_Layer_InitStruct->LTDC_CFBStartAdress);
   \   00000190   0x6B28             LDR      R0,[R5, #+48]
   \   00000192   0x62A0             STR      R0,[R4, #+40]
    412          
    413            /* Configures the color frame buffer pitch in byte */
    414            cfbp = (LTDC_Layer_InitStruct->LTDC_CFBPitch << 16);
   \   00000194   0x6BA8             LDR      R0,[R5, #+56]
    415            LTDC_Layerx->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
   \   00000196   0x6AE1             LDR      R1,[R4, #+44]
   \   00000198   0xF001 0x21E0      AND      R1,R1,#0xE000E000
   \   0000019C   0x62E1             STR      R1,[R4, #+44]
    416            LTDC_Layerx->CFBLR  = (LTDC_Layer_InitStruct->LTDC_CFBLineLength | cfbp);
   \   0000019E   0x6B69             LDR      R1,[R5, #+52]
   \   000001A0   0xEA51 0x4000      ORRS     R0,R1,R0, LSL #+16
   \   000001A4   0x62E0             STR      R0,[R4, #+44]
    417          
    418            /* Configures the frame buffer line number */
    419            LTDC_Layerx->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
   \   000001A6   0x6B20             LDR      R0,[R4, #+48]
   \   000001A8   0x0AC0             LSRS     R0,R0,#+11
   \   000001AA   0x02C0             LSLS     R0,R0,#+11
   \   000001AC   0x6320             STR      R0,[R4, #+48]
    420            LTDC_Layerx->CFBLNR  = (LTDC_Layer_InitStruct->LTDC_CFBLineNumber);
   \   000001AE   0x6BE8             LDR      R0,[R5, #+60]
   \   000001B0   0x6320             STR      R0,[R4, #+48]
    421          
    422          }
   \   000001B2   0xBD70             POP      {R4-R6,PC}       ;; return
    423          
    424          /**
    425            * @brief  Fills each LTDC_Layer_InitStruct member with its default value.
    426            * @param  LTDC_Layer_InitStruct: pointer to a LTDC_LayerTypeDef structure which will
    427            *         be initialized.
    428            * @retval None
    429            */
    430          

   \                                 In section .text, align 2, keep-with-next
    431          void LTDC_LayerStructInit(LTDC_Layer_InitTypeDef * LTDC_Layer_InitStruct)
    432          {
    433            /*--------------- Reset Layer structure parameters values -------------------*/
    434          
    435            /*!< Initialize the horizontal limit member */
    436            LTDC_Layer_InitStruct->LTDC_HorizontalStart = 0x00;
   \                     LTDC_LayerStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    437            LTDC_Layer_InitStruct->LTDC_HorizontalStop = 0x00;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    438          
    439            /*!< Initialize the vertical limit member */
    440            LTDC_Layer_InitStruct->LTDC_VerticalStart = 0x00;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    441            LTDC_Layer_InitStruct->LTDC_VerticalStop = 0x00;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    442          
    443            /*!< Initialize the pixel format member */
    444            LTDC_Layer_InitStruct->LTDC_PixelFormat = LTDC_Pixelformat_ARGB8888;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    445          
    446            /*!< Initialize the constant alpha value */
    447            LTDC_Layer_InitStruct->LTDC_ConstantAlpha = 0xFF;
   \   0000000C   0x21FF             MOVS     R1,#+255
   \   0000000E   0x6141             STR      R1,[R0, #+20]
    448          
    449            /*!< Initialize the default color values */
    450            LTDC_Layer_InitStruct->LTDC_DefaultColorBlue = 0x00;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6181             STR      R1,[R0, #+24]
    451            LTDC_Layer_InitStruct->LTDC_DefaultColorGreen = 0x00;
   \   00000014   0x61C1             STR      R1,[R0, #+28]
    452            LTDC_Layer_InitStruct->LTDC_DefaultColorRed = 0x00;
   \   00000016   0x6201             STR      R1,[R0, #+32]
    453            LTDC_Layer_InitStruct->LTDC_DefaultColorAlpha = 0x00;
   \   00000018   0x6241             STR      R1,[R0, #+36]
    454          
    455            /*!< Initialize the blending factors */
    456            LTDC_Layer_InitStruct->LTDC_BlendingFactor_1 = LTDC_BlendingFactor1_PAxCA;
   \   0000001A   0xF44F 0x61C0      MOV      R1,#+1536
   \   0000001E   0x6281             STR      R1,[R0, #+40]
    457            LTDC_Layer_InitStruct->LTDC_BlendingFactor_2 = LTDC_BlendingFactor2_PAxCA;
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x62C1             STR      R1,[R0, #+44]
    458          
    459            /*!< Initialize the frame buffer start address */
    460            LTDC_Layer_InitStruct->LTDC_CFBStartAdress = 0x00;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6301             STR      R1,[R0, #+48]
    461          
    462            /*!< Initialize the frame buffer pitch and line length */
    463            LTDC_Layer_InitStruct->LTDC_CFBLineLength = 0x00;
   \   00000028   0x6341             STR      R1,[R0, #+52]
    464            LTDC_Layer_InitStruct->LTDC_CFBPitch = 0x00;
   \   0000002A   0x6381             STR      R1,[R0, #+56]
    465          
    466            /*!< Initialize the frame buffer line number */
    467            LTDC_Layer_InitStruct->LTDC_CFBLineNumber = 0x00;
   \   0000002C   0x63C1             STR      R1,[R0, #+60]
    468          }
   \   0000002E   0x4770             BX       LR               ;; return
    469          
    470          
    471          /**
    472            * @brief  Enables or disables the LTDC_Layer Controller.
    473            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    474            *         one of the following values: LTDC_Layer1, LTDC_Layer2
    475            * @param  NewState: new state of the LTDC_Layer peripheral.
    476            *   This parameter can be: ENABLE or DISABLE.
    477            * @retval None
    478            */
    479          

   \                                 In section .text, align 2, keep-with-next
    480          void LTDC_LayerCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState)
    481          {
   \                     LTDC_LayerCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    482            /* Check the parameters */
    483            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0xD007             BEQ.N    ??LTDC_LayerCmd_0
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0xD005             BEQ.N    ??LTDC_LayerCmd_0
   \   0000000C   0xF240 0x11E3      MOVW     R1,#+483
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
    484          
    485            if (NewState != DISABLE)
   \                     ??LTDC_LayerCmd_0: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0xD003             BEQ.N    ??LTDC_LayerCmd_1
    486            {
    487              /* Enable LTDC_Layer by setting LEN bit */
    488              LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_LEN;
   \   0000001E   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000022   0x6020             STR      R0,[R4, #+0]
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}
    489            }
    490            else
    491            {
    492              /* Disable LTDC_Layer by clearing LEN bit */
    493              LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_LEN;
   \                     ??LTDC_LayerCmd_1: (+1)
   \   00000026   0x0840             LSRS     R0,R0,#+1
   \   00000028   0x0040             LSLS     R0,R0,#+1
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    494            }
    495          }
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    496          
    497          
    498          /**
    499            * @brief  Get the current position.
    500            * @param  LTDC_Pos_InitStruct: pointer to a LTDC_PosTypeDef structure that contains
    501            *         the current position.
    502            * @retval None
    503            */
    504          

   \                                 In section .text, align 2, keep-with-next
    505          LTDC_PosTypeDef LTDC_GetPosStatus(void)
    506          {
   \                     LTDC_GetPosStatus: (+1)
   \   00000000   0xB410             PUSH     {R4}
    507            LTDC_PosTypeDef LTDC_Pos_InitStruct;
    508          
    509            LTDC->CPSR &= ~(LTDC_CPSR_CYPOS | LTDC_CPSR_CXPOS);
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable17_7  ;; 0x40016844
   \   00000006   0x680C             LDR      R4,[R1, #+0]
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x600C             STR      R4,[R1, #+0]
    510          
    511            LTDC_Pos_InitStruct.LTDC_POSX = (uint32_t)(LTDC->CPSR >> 16);
   \   0000000C   0x680C             LDR      R4,[R1, #+0]
   \   0000000E   0x0C24             LSRS     R4,R4,#+16
   \   00000010   0x4622             MOV      R2,R4
    512            LTDC_Pos_InitStruct.LTDC_POSY = (uint32_t)(LTDC->CPSR & 0xFFFF);
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0xB289             UXTH     R1,R1
   \   00000016   0x460B             MOV      R3,R1
    513          
    514            return LTDC_Pos_InitStruct;
   \   00000018   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
    515          }
    516          
    517          /**
    518            * @brief  Fills each LTDC_Pos_InitStruct member with its default value.
    519            * @param  LTDC_Pos_InitStruct: pointer to a LTDC_PosTypeDef structure which will
    520            *         be initialized.
    521            * @retval None
    522            */
    523          

   \                                 In section .text, align 2, keep-with-next
    524          void LTDC_PosStructInit(LTDC_PosTypeDef* LTDC_Pos_InitStruct)
    525          {
    526            LTDC_Pos_InitStruct->LTDC_POSX = 0x00;
   \                     LTDC_PosStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    527            LTDC_Pos_InitStruct->LTDC_POSY = 0x00;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    528          }
   \   00000006   0x4770             BX       LR               ;; return
    529          
    530          /**
    531            * @brief  Checks whether the specified LTDC's flag is set or not.
    532            * @param  LTDC_CD: specifies the flag to check.
    533            *   This parameter can be one of the following values:
    534            *     @arg LTDC_CD_VDES: vertical data enable current status.
    535            *     @arg LTDC_CD_HDES: horizontal data enable current status.
    536            *     @arg LTDC_CD_VSYNC:  Vertical Synchronization current status.
    537            *     @arg LTDC_CD_HSYNC:  Horizontal Synchronization current status.
    538            * @retval The new state of LTDC_CD (SET or RESET).
    539            */
    540          

   \                                 In section .text, align 2, keep-with-next
    541          FlagStatus LTDC_GetCDStatus(uint32_t LTDC_CD)
    542          {
   \                     LTDC_GetCDStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    543            FlagStatus bitstatus;
    544          
    545            /* Check the parameters */
    546            assert_param(IS_LTDC_GET_CD(LTDC_CD));
   \   00000004   0x2C01             CMP      R4,#+1
   \   00000006   0xD00B             BEQ.N    ??LTDC_GetCDStatus_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD009             BEQ.N    ??LTDC_GetCDStatus_0
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xD007             BEQ.N    ??LTDC_GetCDStatus_0
   \   00000010   0x2C08             CMP      R4,#+8
   \   00000012   0xD005             BEQ.N    ??LTDC_GetCDStatus_0
   \   00000014   0xF240 0x2122      MOVW     R1,#+546
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       assert_failed
    547          
    548            if ((LTDC->CDSR & LTDC_CD) != (uint32_t)RESET)
   \                     ??LTDC_GetCDStatus_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable17_8  ;; 0x40016848
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x4020             ANDS     R0,R4,R0
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x4180             SBCS     R0,R0,R0
   \   0000002C   0x43C0             MVNS     R0,R0
   \   0000002E   0x0FC0             LSRS     R0,R0,#+31
    549            {
    550              bitstatus = SET;
    551            }
    552            else
    553            {
    554              bitstatus = RESET;
    555            }
    556            return bitstatus;
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    557          }
    558          
    559          /**
    560            * @brief  Set and configure the color keying.
    561            * @param  LTDC_colorkeying_InitStruct: pointer to a LTDC_ColorKeying_InitTypeDef 
    562            *         structure that contains the color keying configuration.
    563            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    564            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    565            * @retval None
    566            */
    567          

   \                                 In section .text, align 2, keep-with-next
    568          void LTDC_ColorKeyingConfig(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct, FunctionalState NewState)
    569          { 
   \                     LTDC_ColorKeyingConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    570            uint32_t ckgreen = 0;
    571            uint32_t ckred = 0;
    572          
    573            /* Check the parameters */
    574            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000008   0xD007             BEQ.N    ??LTDC_ColorKeyingConfig_0
   \   0000000A   0x2E01             CMP      R6,#+1
   \   0000000C   0xD005             BEQ.N    ??LTDC_ColorKeyingConfig_0
   \   0000000E   0xF240 0x213E      MOVW     R1,#+574
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       assert_failed
    575            assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue));
   \                     ??LTDC_ColorKeyingConfig_0: (+1)
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x28FF             CMP      R0,#+255
   \   0000001E   0xD905             BLS.N    ??LTDC_ColorKeyingConfig_1
   \   00000020   0xF240 0x213F      MOVW     R1,#+575
   \   00000024   0x.... 0x....      ADR.W    R0,?_0
   \   00000028   0x.... 0x....      BL       assert_failed
    576            assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen));
   \                     ??LTDC_ColorKeyingConfig_1: (+1)
   \   0000002C   0x6868             LDR      R0,[R5, #+4]
   \   0000002E   0x28FF             CMP      R0,#+255
   \   00000030   0xD905             BLS.N    ??LTDC_ColorKeyingConfig_2
   \   00000032   0xF44F 0x7110      MOV      R1,#+576
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    577            assert_param(IS_LTDC_CKEYING(LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed));
   \                     ??LTDC_ColorKeyingConfig_2: (+1)
   \   0000003E   0x68A8             LDR      R0,[R5, #+8]
   \   00000040   0x28FF             CMP      R0,#+255
   \   00000042   0xD905             BLS.N    ??LTDC_ColorKeyingConfig_3
   \   00000044   0xF240 0x2141      MOVW     R1,#+577
   \   00000048   0x.... 0x....      ADR.W    R0,?_0
   \   0000004C   0x.... 0x....      BL       assert_failed
    578            
    579            if (NewState != DISABLE)
   \                     ??LTDC_ColorKeyingConfig_3: (+1)
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0xD011             BEQ.N    ??LTDC_ColorKeyingConfig_4
    580            {
    581              /* Enable LTDC color keying by setting COLKEN bit */
    582              LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_COLKEN;
   \   00000056   0xF040 0x0002      ORR      R0,R0,#0x2
   \   0000005A   0x6020             STR      R0,[R4, #+0]
    583              
    584              /* Sets the color keying values */
    585              ckgreen = (LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen << 8);
   \   0000005C   0x6868             LDR      R0,[R5, #+4]
    586              ckred = (LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed << 16);
   \   0000005E   0x68A9             LDR      R1,[R5, #+8]
    587              LTDC_Layerx->CKCR  &= ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
   \   00000060   0x68E2             LDR      R2,[R4, #+12]
   \   00000062   0xF002 0x427F      AND      R2,R2,#0xFF000000
   \   00000066   0x60E2             STR      R2,[R4, #+12]
    588              LTDC_Layerx->CKCR |= (LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue | ckgreen | ckred);
   \   00000068   0x68E2             LDR      R2,[R4, #+12]
   \   0000006A   0x682B             LDR      R3,[R5, #+0]
   \   0000006C   0xEA53 0x2000      ORRS     R0,R3,R0, LSL #+8
   \   00000070   0xEA50 0x4001      ORRS     R0,R0,R1, LSL #+16
   \   00000074   0x4310             ORRS     R0,R0,R2
   \   00000076   0x60E0             STR      R0,[R4, #+12]
   \   00000078   0xE002             B.N      ??LTDC_ColorKeyingConfig_5
    589            }
    590            else
    591            {
    592              /* Disable LTDC color keying by clearing COLKEN bit */
    593              LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
   \                     ??LTDC_ColorKeyingConfig_4: (+1)
   \   0000007A   0xF020 0x0002      BIC      R0,R0,#0x2
   \   0000007E   0x6020             STR      R0,[R4, #+0]
    594            }
    595            
    596            /* Reload shadow register */
    597            LTDC->SRCR = LTDC_IMReload;
   \                     ??LTDC_ColorKeyingConfig_5: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x....             LDR.N    R1,??DataTable17_5  ;; 0x40016824
   \   00000084   0x6008             STR      R0,[R1, #+0]
    598          }
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
    599          
    600          /**
    601            * @brief  Fills each LTDC_colorkeying_InitStruct member with its default value.
    602            * @param  LTDC_colorkeying_InitStruct: pointer to a LTDC_ColorKeying_InitTypeDef structure which will
    603            *         be initialized.
    604            * @retval None
    605            */
    606          

   \                                 In section .text, align 2, keep-with-next
    607          void LTDC_ColorKeyingStructInit(LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct)
    608          {
    609            /*!< Initialize the color keying values */
    610            LTDC_colorkeying_InitStruct->LTDC_ColorKeyBlue = 0x00;
   \                     LTDC_ColorKeyingStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    611            LTDC_colorkeying_InitStruct->LTDC_ColorKeyGreen = 0x00;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    612            LTDC_colorkeying_InitStruct->LTDC_ColorKeyRed = 0x00;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    613          }
   \   00000008   0x4770             BX       LR               ;; return
    614          
    615          
    616          /**
    617            * @brief  Enables or disables CLUT.
    618            * @param  NewState: new state of CLUT.
    619            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    620            *         one of the following values: LTDC_Layer1, LTDC_Layer2  
    621            *   This parameter can be: ENABLE or DISABLE.
    622            * @retval None
    623            */
    624          

   \                                 In section .text, align 2, keep-with-next
    625          void LTDC_CLUTCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState)
    626          {
   \                     LTDC_CLUTCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    627            /* Check the parameters */
    628            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \   00000006   0xD007             BEQ.N    ??LTDC_CLUTCmd_0
   \   00000008   0x2D01             CMP      R5,#+1
   \   0000000A   0xD005             BEQ.N    ??LTDC_CLUTCmd_0
   \   0000000C   0xF44F 0x711D      MOV      R1,#+628
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
    629          
    630            if (NewState != DISABLE)
   \                     ??LTDC_CLUTCmd_0: (+1)
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0x6820             LDR      R0,[R4, #+0]
   \   0000001C   0xD003             BEQ.N    ??LTDC_CLUTCmd_1
    631            {
    632              /* Enable CLUT by setting CLUTEN bit */
    633              LTDC_Layerx->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
   \   0000001E   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000022   0x6020             STR      R0,[R4, #+0]
   \   00000024   0xE002             B.N      ??LTDC_CLUTCmd_2
    634            }
    635            else
    636            {
    637              /* Disable CLUT by clearing CLUTEN bit */
    638              LTDC_Layerx->CR &= ~(uint32_t)LTDC_LxCR_CLUTEN;
   \                     ??LTDC_CLUTCmd_1: (+1)
   \   00000026   0xF020 0x0010      BIC      R0,R0,#0x10
   \   0000002A   0x6020             STR      R0,[R4, #+0]
    639            }
    640            
    641            /* Reload shadow register */
    642            LTDC->SRCR = LTDC_IMReload;
   \                     ??LTDC_CLUTCmd_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable17_5  ;; 0x40016824
   \   00000030   0x6008             STR      R0,[R1, #+0]
    643          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    644          
    645          /**
    646            * @brief  configure the CLUT.
    647            * @param  LTDC_CLUT_InitStruct: pointer to a LTDC_CLUT_InitTypeDef structure that contains
    648            *         the CLUT configuration.
    649            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    650            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    651            * @retval None
    652            */
    653          

   \                                 In section .text, align 2, keep-with-next
    654          void LTDC_CLUTInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct)
    655          {  
   \                     LTDC_CLUTInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    656            uint32_t green = 0;
    657            uint32_t red = 0;
    658            uint32_t clutadd = 0;
    659          
    660            /* Check the parameters */
    661            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_CLUTAdress));
   \   00000006   0x6828             LDR      R0,[R5, #+0]
   \   00000008   0x28FF             CMP      R0,#+255
   \   0000000A   0xD905             BLS.N    ??LTDC_CLUTInit_0
   \   0000000C   0xF240 0x2195      MOVW     R1,#+661
   \   00000010   0x.... 0x....      ADR.W    R0,?_0
   \   00000014   0x.... 0x....      BL       assert_failed
    662            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_RedValue));
   \                     ??LTDC_CLUTInit_0: (+1)
   \   00000018   0x68E8             LDR      R0,[R5, #+12]
   \   0000001A   0x28FF             CMP      R0,#+255
   \   0000001C   0xD905             BLS.N    ??LTDC_CLUTInit_1
   \   0000001E   0xF240 0x2196      MOVW     R1,#+662
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    663            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_GreenValue));
   \                     ??LTDC_CLUTInit_1: (+1)
   \   0000002A   0x68A8             LDR      R0,[R5, #+8]
   \   0000002C   0x28FF             CMP      R0,#+255
   \   0000002E   0xD905             BLS.N    ??LTDC_CLUTInit_2
   \   00000030   0xF240 0x2197      MOVW     R1,#+663
   \   00000034   0x.... 0x....      ADR.W    R0,?_0
   \   00000038   0x.... 0x....      BL       assert_failed
    664            assert_param(IS_LTDC_CLUTWR(LTDC_CLUT_InitStruct->LTDC_BlueValue));
   \                     ??LTDC_CLUTInit_2: (+1)
   \   0000003C   0x6868             LDR      R0,[R5, #+4]
   \   0000003E   0x28FF             CMP      R0,#+255
   \   00000040   0xD905             BLS.N    ??LTDC_CLUTInit_3
   \   00000042   0xF44F 0x7126      MOV      R1,#+664
   \   00000046   0x.... 0x....      ADR.W    R0,?_0
   \   0000004A   0x.... 0x....      BL       assert_failed
    665              
    666            /* Specifies the CLUT address and RGB value */
    667            green = (LTDC_CLUT_InitStruct->LTDC_GreenValue << 8);
    668            red = (LTDC_CLUT_InitStruct->LTDC_RedValue << 16);
    669            clutadd = (LTDC_CLUT_InitStruct->LTDC_CLUTAdress << 24);
    670            LTDC_Layerx->CLUTWR  = (clutadd | LTDC_CLUT_InitStruct->LTDC_BlueValue | \
    671                                        green | red);
   \                     ??LTDC_CLUTInit_3: (+1)
   \   0000004E   0x6828             LDR      R0,[R5, #+0]
   \   00000050   0x6869             LDR      R1,[R5, #+4]
   \   00000052   0xEA41 0x6000      ORR      R0,R1,R0, LSL #+24
   \   00000056   0x68A9             LDR      R1,[R5, #+8]
   \   00000058   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   0000005C   0x68E9             LDR      R1,[R5, #+12]
   \   0000005E   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   00000062   0x6420             STR      R0,[R4, #+64]
    672          }
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    673          
    674          /**
    675            * @brief  Fills each LTDC_CLUT_InitStruct member with its default value.
    676            * @param  LTDC_CLUT_InitStruct: pointer to a LTDC_CLUT_InitTypeDef structure which will
    677            *         be initialized.
    678            * @retval None
    679            */
    680          

   \                                 In section .text, align 2, keep-with-next
    681          void LTDC_CLUTStructInit(LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct)
    682          {
    683            /*!< Initialize the CLUT adress and RGB values */
    684            LTDC_CLUT_InitStruct->LTDC_CLUTAdress = 0x00;
   \                     LTDC_CLUTStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    685            LTDC_CLUT_InitStruct->LTDC_BlueValue = 0x00;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    686            LTDC_CLUT_InitStruct->LTDC_GreenValue = 0x00;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    687            LTDC_CLUT_InitStruct->LTDC_RedValue = 0x00;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    688          }
   \   0000000A   0x4770             BX       LR               ;; return
    689          
    690          
    691          /**
    692            * @brief  reconfigure the layer position.
    693            * @param  OffsetX: horizontal offset from start active width .
    694            * @param  OffsetY: vertical offset from start active height.   
    695            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    696            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    697            * @retval Reload of the shadow registers values must be applied after layer 
    698            *         position reconfiguration.
    699            */
    700          

   \                                 In section .text, align 2, keep-with-next
    701          void LTDC_LayerPosition(LTDC_Layer_TypeDef* LTDC_Layerx, uint16_t OffsetX, uint16_t OffsetY)
    702          {
   \                     LTDC_LayerPosition: (+1)
   \   00000000   0xB410             PUSH     {R4}
    703            
    704            uint32_t tempreg, temp;
    705            uint32_t horizontal_start;
    706            uint32_t horizontal_stop;
    707            uint32_t vertical_start;
    708            uint32_t vertical_stop;
    709            
    710            LTDC_Layerx->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
   \   00000002   0x6843             LDR      R3,[R0, #+4]
   \   00000004   0xF403 0x4370      AND      R3,R3,#0xF000
   \   00000008   0x6043             STR      R3,[R0, #+4]
    711            LTDC_Layerx->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
   \   0000000A   0x6883             LDR      R3,[R0, #+8]
   \   0000000C   0xF403 0x4370      AND      R3,R3,#0xF000
   \   00000010   0x6083             STR      R3,[R0, #+8]
    712            
    713            /* Reconfigures the horizontal and vertical start position */
    714            tempreg = LTDC->BPCR;
   \   00000012   0x....             LDR.N    R3,??DataTable17_9  ;; 0x4001680c
   \   00000014   0x681B             LDR      R3,[R3, #+0]
    715            horizontal_start = (tempreg >> 16) + 1 + OffsetX;
   \   00000016   0x0C1C             LSRS     R4,R3,#+16
   \   00000018   0xFA14 0xF181      UXTAH    R1,R4,R1
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
    716            vertical_start = (tempreg & 0xFFFF) + 1 + OffsetY;
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0xFA13 0xF282      UXTAH    R2,R3,R2
   \   00000024   0x1C52             ADDS     R2,R2,#+1
    717            
    718            /* Reconfigures the horizontal and vertical stop position */
    719            /* Get the number of byte per pixel */
    720            
    721            tempreg = LTDC_Layerx->PFCR;
   \   00000026   0x6903             LDR      R3,[R0, #+16]
    722            
    723            if (tempreg == LTDC_Pixelformat_ARGB8888)
   \   00000028   0x2B00             CMP      R3,#+0
   \   0000002A   0xD101             BNE.N    ??LTDC_LayerPosition_0
    724            {
    725              temp = 4;
   \   0000002C   0x2304             MOVS     R3,#+4
   \   0000002E   0xE00E             B.N      ??LTDC_LayerPosition_1
    726            }
    727            else if (tempreg == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerPosition_0: (+1)
   \   00000030   0x2B01             CMP      R3,#+1
   \   00000032   0xD101             BNE.N    ??LTDC_LayerPosition_2
    728            {
    729              temp = 3;
   \   00000034   0x2303             MOVS     R3,#+3
   \   00000036   0xE00A             B.N      ??LTDC_LayerPosition_1
    730            }
    731            else if ((tempreg == LTDC_Pixelformat_ARGB4444) || 
    732                    (tempreg == LTDC_Pixelformat_RGB565)    ||  
    733                    (tempreg == LTDC_Pixelformat_ARGB1555)  ||
    734                    (tempreg == LTDC_Pixelformat_AL88))
   \                     ??LTDC_LayerPosition_2: (+1)
   \   00000038   0x2B04             CMP      R3,#+4
   \   0000003A   0xD005             BEQ.N    ??LTDC_LayerPosition_3
   \   0000003C   0x2B02             CMP      R3,#+2
   \   0000003E   0xD003             BEQ.N    ??LTDC_LayerPosition_3
   \   00000040   0x2B03             CMP      R3,#+3
   \   00000042   0xD001             BEQ.N    ??LTDC_LayerPosition_3
   \   00000044   0x2B07             CMP      R3,#+7
   \   00000046   0xD101             BNE.N    ??LTDC_LayerPosition_4
    735            {
    736              temp = 2;  
   \                     ??LTDC_LayerPosition_3: (+1)
   \   00000048   0x2302             MOVS     R3,#+2
   \   0000004A   0xE000             B.N      ??LTDC_LayerPosition_1
    737            }
    738            else
    739            {
    740              temp = 1;
   \                     ??LTDC_LayerPosition_4: (+1)
   \   0000004C   0x2301             MOVS     R3,#+1
    741            }  
    742              
    743            tempreg = LTDC_Layerx->CFBLR;
   \                     ??LTDC_LayerPosition_1: (+1)
   \   0000004E   0x6AC4             LDR      R4,[R0, #+44]
    744            horizontal_stop = (((tempreg & 0x1FFF) - 3)/temp) + horizontal_start - 1;
   \   00000050   0x04E4             LSLS     R4,R4,#+19
   \   00000052   0x0CE4             LSRS     R4,R4,#+19
   \   00000054   0x1EE4             SUBS     R4,R4,#+3
   \   00000056   0xFBB4 0xF3F3      UDIV     R3,R4,R3
   \   0000005A   0x18CB             ADDS     R3,R1,R3
   \   0000005C   0x1E5B             SUBS     R3,R3,#+1
    745            
    746            tempreg = LTDC_Layerx->CFBLNR;
   \   0000005E   0x6B04             LDR      R4,[R0, #+48]
    747            vertical_stop = (tempreg & 0x7FF) + vertical_start - 1;  
    748            
    749            LTDC_Layerx->WHPCR = horizontal_start | (horizontal_stop << 16);
   \   00000060   0xEA41 0x4103      ORR      R1,R1,R3, LSL #+16
   \   00000064   0x6041             STR      R1,[R0, #+4]
    750            LTDC_Layerx->WVPCR = vertical_start | (vertical_stop << 16);  
   \   00000066   0x0561             LSLS     R1,R4,#+21
   \   00000068   0xEB12 0x5151      ADDS     R1,R2,R1, LSR #+21
   \   0000006C   0x1E49             SUBS     R1,R1,#+1
   \   0000006E   0xEA42 0x4101      ORR      R1,R2,R1, LSL #+16
   \   00000072   0x6081             STR      R1,[R0, #+8]
    751          }
   \   00000074   0xBC10             POP      {R4}
   \   00000076   0x4770             BX       LR               ;; return
    752            
    753          /**
    754            * @brief  reconfigure constant alpha.
    755            * @param  ConstantAlpha: constant alpha value.
    756            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    757            *         one of the following values: LTDC_Layer1, LTDC_Layer2    
    758            * @retval Reload of the shadow registers values must be applied after constant 
    759            *         alpha reconfiguration.         
    760            */
    761          

   \                                 In section .text, align 2, keep-with-next
    762          void LTDC_LayerAlpha(LTDC_Layer_TypeDef* LTDC_Layerx, uint8_t ConstantAlpha)
    763          {  
    764            /* reconfigure the constant alpha value */      
    765            LTDC_Layerx->CACR = ConstantAlpha;
   \                     LTDC_LayerAlpha: (+1)
   \   00000000   0x6141             STR      R1,[R0, #+20]
    766          }
   \   00000002   0x4770             BX       LR               ;; return
    767          
    768          /**
    769            * @brief  reconfigure layer address.
    770            * @param  Address: The color frame buffer start address.
    771            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    772            *         one of the following values: LTDC_Layer1, LTDC_Layer2     
    773            * @retval Reload of the shadow registers values must be applied after layer 
    774            *         address reconfiguration.
    775            */
    776          

   \                                 In section .text, align 2, keep-with-next
    777          void LTDC_LayerAddress(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Address)
    778          {
    779            /* Reconfigures the color frame buffer start address */
    780            LTDC_Layerx->CFBAR = Address;
   \                     LTDC_LayerAddress: (+1)
   \   00000000   0x6281             STR      R1,[R0, #+40]
    781          }
   \   00000002   0x4770             BX       LR               ;; return
    782            
    783          /**
    784            * @brief  reconfigure layer size.
    785            * @param  Width: layer window width.
    786            * @param  Height: layer window height.   
    787            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    788            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    789            * @retval Reload of the shadow registers values must be applied after layer 
    790            *         size reconfiguration.
    791            */
    792          

   \                                 In section .text, align 2, keep-with-next
    793          void LTDC_LayerSize(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Width, uint32_t Height)
    794          {
   \                     LTDC_LayerSize: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    795          
    796            uint8_t temp;
    797            uint32_t tempreg;
    798            uint32_t horizontal_start;
    799            uint32_t horizontal_stop;
    800            uint32_t vertical_start;
    801            uint32_t vertical_stop;  
    802            
    803            tempreg = LTDC_Layerx->PFCR;
   \   00000002   0x6903             LDR      R3,[R0, #+16]
    804            
    805            if (tempreg == LTDC_Pixelformat_ARGB8888)
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD101             BNE.N    ??LTDC_LayerSize_0
    806            {
    807              temp = 4;
   \   00000008   0x2304             MOVS     R3,#+4
   \   0000000A   0xE00E             B.N      ??LTDC_LayerSize_1
    808            }
    809            else if (tempreg == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerSize_0: (+1)
   \   0000000C   0x2B01             CMP      R3,#+1
   \   0000000E   0xD101             BNE.N    ??LTDC_LayerSize_2
    810            {
    811              temp = 3;
   \   00000010   0x2303             MOVS     R3,#+3
   \   00000012   0xE00A             B.N      ??LTDC_LayerSize_1
    812            }
    813            else if ((tempreg == LTDC_Pixelformat_ARGB4444) || \
    814                    (tempreg == LTDC_Pixelformat_RGB565)    || \
    815                    (tempreg == LTDC_Pixelformat_ARGB1555)  || \
    816                    (tempreg == LTDC_Pixelformat_AL88))
   \                     ??LTDC_LayerSize_2: (+1)
   \   00000014   0x2B04             CMP      R3,#+4
   \   00000016   0xD005             BEQ.N    ??LTDC_LayerSize_3
   \   00000018   0x2B02             CMP      R3,#+2
   \   0000001A   0xD003             BEQ.N    ??LTDC_LayerSize_3
   \   0000001C   0x2B03             CMP      R3,#+3
   \   0000001E   0xD001             BEQ.N    ??LTDC_LayerSize_3
   \   00000020   0x2B07             CMP      R3,#+7
   \   00000022   0xD101             BNE.N    ??LTDC_LayerSize_4
    817            {
    818              temp = 2;  
   \                     ??LTDC_LayerSize_3: (+1)
   \   00000024   0x2302             MOVS     R3,#+2
   \   00000026   0xE000             B.N      ??LTDC_LayerSize_1
    819            }
    820            else
    821            {
    822              temp = 1;
   \                     ??LTDC_LayerSize_4: (+1)
   \   00000028   0x2301             MOVS     R3,#+1
    823            }
    824          
    825            /* update horizontal and vertical stop */
    826            tempreg = LTDC_Layerx->WHPCR;
   \                     ??LTDC_LayerSize_1: (+1)
   \   0000002A   0x6844             LDR      R4,[R0, #+4]
    827            horizontal_start = (tempreg & 0x1FFF);
   \   0000002C   0x04E4             LSLS     R4,R4,#+19
   \   0000002E   0x0CE4             LSRS     R4,R4,#+19
    828            horizontal_stop = Width + horizontal_start - 1;  
    829          
    830            tempreg = LTDC_Layerx->WVPCR;
   \   00000030   0x6885             LDR      R5,[R0, #+8]
    831            vertical_start = (tempreg & 0x1FFF);
   \   00000032   0x04ED             LSLS     R5,R5,#+19
   \   00000034   0x0CED             LSRS     R5,R5,#+19
    832            vertical_stop = Height + vertical_start - 1;  
    833            
    834            LTDC_Layerx->WHPCR = horizontal_start | (horizontal_stop << 16);
   \   00000036   0x1866             ADDS     R6,R4,R1
   \   00000038   0x1E76             SUBS     R6,R6,#+1
   \   0000003A   0xEA44 0x4406      ORR      R4,R4,R6, LSL #+16
   \   0000003E   0x6044             STR      R4,[R0, #+4]
    835            LTDC_Layerx->WVPCR = vertical_start | (vertical_stop << 16);  
   \   00000040   0x18AC             ADDS     R4,R5,R2
   \   00000042   0x1E64             SUBS     R4,R4,#+1
   \   00000044   0xEA45 0x4404      ORR      R4,R5,R4, LSL #+16
   \   00000048   0x6084             STR      R4,[R0, #+8]
    836          
    837            /* Reconfigures the color frame buffer pitch in byte */
    838            LTDC_Layerx->CFBLR  = ((Width * temp) << 16) | ((Width * temp) + 3);  
   \   0000004A   0x4359             MULS     R1,R3,R1
   \   0000004C   0x1CCB             ADDS     R3,R1,#+3
   \   0000004E   0xEA43 0x4101      ORR      R1,R3,R1, LSL #+16
   \   00000052   0x62C1             STR      R1,[R0, #+44]
    839          
    840            /* Reconfigures the frame buffer line number */
    841            LTDC_Layerx->CFBLNR  = Height;  
   \   00000054   0x6302             STR      R2,[R0, #+48]
    842            
    843          }
   \   00000056   0xBC70             POP      {R4-R6}
   \   00000058   0x4770             BX       LR               ;; return
    844          
    845          /**
    846            * @brief  reconfigure layer pixel format.
    847            * @param  PixelFormat: reconfigure the pixel format, this parameter can be 
    848            *         one of the following values:@ref LTDC_Pixelformat.   
    849            * @param  LTDC_layerx: Select the layer to be configured, this parameter can be 
    850            *         one of the following values: LTDC_Layer1, LTDC_Layer2   
    851            * @retval Reload of the shadow registers values must be applied after layer 
    852            *         pixel format reconfiguration.
    853            */
    854          

   \                                 In section .text, align 2, keep-with-next
    855          void LTDC_LayerPixelFormat(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t PixelFormat)
    856          {
    857          
    858            uint8_t temp;
    859            uint32_t tempreg;
    860            
    861            tempreg = LTDC_Layerx->PFCR;
   \                     LTDC_LayerPixelFormat: (+1)
   \   00000000   0x6902             LDR      R2,[R0, #+16]
    862            
    863            if (tempreg == LTDC_Pixelformat_ARGB8888)
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??LTDC_LayerPixelFormat_0
    864            {
    865              temp = 4;
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0xE00E             B.N      ??LTDC_LayerPixelFormat_1
    866            }
    867            else if (tempreg == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerPixelFormat_0: (+1)
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD101             BNE.N    ??LTDC_LayerPixelFormat_2
    868            {
    869              temp = 3;
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0xE00A             B.N      ??LTDC_LayerPixelFormat_1
    870            }
    871            else if ((tempreg == LTDC_Pixelformat_ARGB4444) || \
    872                    (tempreg == LTDC_Pixelformat_RGB565)    || \
    873                    (tempreg == LTDC_Pixelformat_ARGB1555)  || \
    874                    (tempreg == LTDC_Pixelformat_AL88))  
   \                     ??LTDC_LayerPixelFormat_2: (+1)
   \   00000012   0x2A04             CMP      R2,#+4
   \   00000014   0xD005             BEQ.N    ??LTDC_LayerPixelFormat_3
   \   00000016   0x2A02             CMP      R2,#+2
   \   00000018   0xD003             BEQ.N    ??LTDC_LayerPixelFormat_3
   \   0000001A   0x2A03             CMP      R2,#+3
   \   0000001C   0xD001             BEQ.N    ??LTDC_LayerPixelFormat_3
   \   0000001E   0x2A07             CMP      R2,#+7
   \   00000020   0xD101             BNE.N    ??LTDC_LayerPixelFormat_4
    875            {
    876              temp = 2;  
   \                     ??LTDC_LayerPixelFormat_3: (+1)
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0xE000             B.N      ??LTDC_LayerPixelFormat_1
    877            }
    878            else
    879            {
    880              temp = 1;
   \                     ??LTDC_LayerPixelFormat_4: (+1)
   \   00000026   0x2201             MOVS     R2,#+1
    881            }
    882            
    883            tempreg = (LTDC_Layerx->CFBLR >> 16);
   \                     ??LTDC_LayerPixelFormat_1: (+1)
   \   00000028   0x6AC3             LDR      R3,[R0, #+44]
   \   0000002A   0x0C1B             LSRS     R3,R3,#+16
    884            tempreg = (tempreg / temp); 
   \   0000002C   0xFBB3 0xF2F2      UDIV     R2,R3,R2
    885            
    886            if (PixelFormat == LTDC_Pixelformat_ARGB8888)
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD101             BNE.N    ??LTDC_LayerPixelFormat_5
    887            {
    888              temp = 4;
   \   00000034   0x2304             MOVS     R3,#+4
   \   00000036   0xE00E             B.N      ??LTDC_LayerPixelFormat_6
    889            }
    890            else if (PixelFormat == LTDC_Pixelformat_RGB888)
   \                     ??LTDC_LayerPixelFormat_5: (+1)
   \   00000038   0x2901             CMP      R1,#+1
   \   0000003A   0xD101             BNE.N    ??LTDC_LayerPixelFormat_7
    891            {
    892              temp = 3;
   \   0000003C   0x2303             MOVS     R3,#+3
   \   0000003E   0xE00A             B.N      ??LTDC_LayerPixelFormat_6
    893            }
    894            else if ((PixelFormat == LTDC_Pixelformat_ARGB4444) || \
    895                    (PixelFormat == LTDC_Pixelformat_RGB565)    || \
    896                    (PixelFormat == LTDC_Pixelformat_ARGB1555)  || \
    897                    (PixelFormat == LTDC_Pixelformat_AL88))
   \                     ??LTDC_LayerPixelFormat_7: (+1)
   \   00000040   0x2904             CMP      R1,#+4
   \   00000042   0xD005             BEQ.N    ??LTDC_LayerPixelFormat_8
   \   00000044   0x2902             CMP      R1,#+2
   \   00000046   0xD003             BEQ.N    ??LTDC_LayerPixelFormat_8
   \   00000048   0x2903             CMP      R1,#+3
   \   0000004A   0xD001             BEQ.N    ??LTDC_LayerPixelFormat_8
   \   0000004C   0x2907             CMP      R1,#+7
   \   0000004E   0xD101             BNE.N    ??LTDC_LayerPixelFormat_9
    898            {
    899              temp = 2;  
   \                     ??LTDC_LayerPixelFormat_8: (+1)
   \   00000050   0x2302             MOVS     R3,#+2
   \   00000052   0xE000             B.N      ??LTDC_LayerPixelFormat_6
    900            }
    901            else
    902            {
    903              temp = 1;
   \                     ??LTDC_LayerPixelFormat_9: (+1)
   \   00000054   0x2301             MOVS     R3,#+1
    904            }
    905            
    906            /* Reconfigures the color frame buffer pitch in byte */
    907            LTDC_Layerx->CFBLR  = ((tempreg * temp) << 16) | ((tempreg * temp) + 3);  
   \                     ??LTDC_LayerPixelFormat_6: (+1)
   \   00000056   0x435A             MULS     R2,R3,R2
   \   00000058   0x1CD3             ADDS     R3,R2,#+3
   \   0000005A   0xEA43 0x4202      ORR      R2,R3,R2, LSL #+16
   \   0000005E   0x62C2             STR      R2,[R0, #+44]
    908          
    909            /* Reconfigures the color frame buffer start address */
    910            LTDC_Layerx->PFCR = PixelFormat;
   \   00000060   0x6101             STR      R1,[R0, #+16]
    911              
    912          }
   \   00000062   0x4770             BX       LR               ;; return
    913              
    914          /**
    915            * @}
    916            */
    917          
    918          /** @defgroup LTDC_Group2 Interrupts and flags management functions
    919           *  @brief   Interrupts and flags management functions
    920           *
    921          @verbatim
    922           ===============================================================================
    923                      ##### Interrupts and flags management functions #####
    924           ===============================================================================
    925          
    926              [..] This section provides functions allowing to configure the LTDC Interrupts 
    927                   and to get the status and clear flags and Interrupts pending bits.
    928            
    929              [..] The LTDC provides 4 Interrupts sources and 4 Flags
    930              
    931              *** Flags ***
    932              =============
    933              [..]
    934                (+) LTDC_FLAG_LI:   Line Interrupt flag.
    935                (+) LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
    936                (+) LTDC_FLAG_TERR: Transfer Error Interrupt flag.
    937                (+) LTDC_FLAG_RR:   Register Reload interrupt flag.
    938                
    939              *** Interrupts ***
    940              ==================
    941              [..]
    942                (+) LTDC_IT_LI: Line Interrupt is generated when a programmed line 
    943                                is reached. The line interrupt position is programmed in 
    944                                the LTDC_LIPR register.
    945                (+) LTDC_IT_FU: FIFO Underrun interrupt is generated when a pixel is requested 
    946                                from an empty layer FIFO
    947                (+) LTDC_IT_TERR: Transfer Error interrupt is generated when an AHB bus 
    948                                  error occurs during data transfer.
    949                (+) LTDC_IT_RR: Register Reload interrupt is generated when the shadow 
    950                                registers reload was performed during the vertical blanking 
    951                                period.
    952                         
    953          @endverbatim
    954            * @{
    955            */
    956          
    957          /**
    958            * @brief  Enables or disables the specified LTDC's interrupts.
    959            * @param  LTDC_IT: specifies the LTDC interrupts sources to be enabled or disabled.
    960            *   This parameter can be any combination of the following values:
    961            *     @arg LTDC_IT_LI: Line Interrupt Enable.
    962            *     @arg LTDC_IT_FU: FIFO Underrun Interrupt Enable.
    963            *     @arg LTDC_IT_TERR: Transfer Error Interrupt Enable.
    964            *     @arg LTDC_IT_RR: Register Reload interrupt enable.  
    965            * @param NewState: new state of the specified LTDC interrupts.
    966            *   This parameter can be: ENABLE or DISABLE.
    967            * @retval None
    968            */

   \                                 In section .text, align 2, keep-with-next
    969          void LTDC_ITConfig(uint32_t LTDC_IT, FunctionalState NewState)
    970          {
   \                     LTDC_ITConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    971            /* Check the parameters */
    972            assert_param(IS_LTDC_IT(LTDC_IT));
   \   00000006   0x0920             LSRS     R0,R4,#+4
   \   00000008   0x0100             LSLS     R0,R0,#+4
   \   0000000A   0xD101             BNE.N    ??LTDC_ITConfig_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??LTDC_ITConfig_1
   \                     ??LTDC_ITConfig_0: (+1)
   \   00000010   0xF44F 0x7173      MOV      R1,#+972
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
    973            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??LTDC_ITConfig_1: (+1)
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??LTDC_ITConfig_2
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD005             BEQ.N    ??LTDC_ITConfig_2
   \   00000024   0xF240 0x31CD      MOVW     R1,#+973
   \   00000028   0x.... 0x....      ADR.W    R0,?_0
   \   0000002C   0x.... 0x....      BL       assert_failed
    974          
    975            if (NewState != DISABLE)
   \                     ??LTDC_ITConfig_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable17_10  ;; 0x40016834
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0x6801             LDR      R1,[R0, #+0]
   \   00000036   0xD002             BEQ.N    ??LTDC_ITConfig_3
    976            {
    977              LTDC->IER |= LTDC_IT;
   \   00000038   0x4321             ORRS     R1,R4,R1
   \   0000003A   0x6001             STR      R1,[R0, #+0]
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}
    978            }
    979            else
    980            {
    981              LTDC->IER &= (uint32_t)~LTDC_IT;
   \                     ??LTDC_ITConfig_3: (+1)
   \   0000003E   0x43A1             BICS     R1,R1,R4
   \   00000040   0x6001             STR      R1,[R0, #+0]
    982            }
    983          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    984          
    985          /**
    986            * @brief  Checks whether the specified LTDC's flag is set or not.
    987            * @param  LTDC_FLAG: specifies the flag to check.
    988            *   This parameter can be one of the following values:
    989            *     @arg LTDC_FLAG_LI:    Line Interrupt flag.
    990            *     @arg LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
    991            *     @arg LTDC_FLAG_TERR: Transfer Error Interrupt flag.
    992            *     @arg LTDC_FLAG_RR:   Register Reload interrupt flag.
    993            * @retval The new state of LTDC_FLAG (SET or RESET).
    994            */

   \                                 In section .text, align 2, keep-with-next
    995          FlagStatus LTDC_GetFlagStatus(uint32_t LTDC_FLAG)
    996          {
   \                     LTDC_GetFlagStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    997            FlagStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
    998          
    999            /* Check the parameters */
   1000            assert_param(IS_LTDC_FLAG(LTDC_FLAG));
   \   00000006   0x2C01             CMP      R4,#+1
   \   00000008   0xD00B             BEQ.N    ??LTDC_GetFlagStatus_0
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD009             BEQ.N    ??LTDC_GetFlagStatus_0
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xD007             BEQ.N    ??LTDC_GetFlagStatus_0
   \   00000012   0x2C08             CMP      R4,#+8
   \   00000014   0xD005             BEQ.N    ??LTDC_GetFlagStatus_0
   \   00000016   0xF44F 0x717A      MOV      R1,#+1000
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       assert_failed
   1001          
   1002            if ((LTDC->ISR & LTDC_FLAG) != (uint32_t)RESET)
   \                     ??LTDC_GetFlagStatus_0: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable17_11  ;; 0x40016838
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x4220             TST      R0,R4
   \   00000028   0xD000             BEQ.N    ??LTDC_GetFlagStatus_1
   1003            {
   1004              bitstatus = SET;
   \   0000002A   0x2501             MOVS     R5,#+1
   1005            }
   1006            else
   1007            {
   1008              bitstatus = RESET;
   1009            }
   1010            return bitstatus;
   \                     ??LTDC_GetFlagStatus_1: (+1)
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1011          }
   1012          
   1013          /**
   1014            * @brief  Clears the LTDC's pending flags.
   1015            * @param  LTDC_FLAG: specifies the flag to clear.
   1016            *   This parameter can be any combination of the following values:
   1017            *     @arg LTDC_FLAG_LI:    Line Interrupt flag.
   1018            *     @arg LTDC_FLAG_FU:   FIFO Underrun Interrupt flag.
   1019            *     @arg LTDC_FLAG_TERR: Transfer Error Interrupt flag.
   1020            *     @arg LTDC_FLAG_RR:   Register Reload interrupt flag.  
   1021            * @retval None
   1022            */

   \                                 In section .text, align 2, keep-with-next
   1023          void LTDC_ClearFlag(uint32_t LTDC_FLAG)
   1024          {
   \                     LTDC_ClearFlag: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1025            /* Check the parameters */
   1026            assert_param(IS_LTDC_FLAG(LTDC_FLAG));
   \   00000004   0x2C01             CMP      R4,#+1
   \   00000006   0xD00B             BEQ.N    ??LTDC_ClearFlag_0
   \   00000008   0x2C02             CMP      R4,#+2
   \   0000000A   0xD009             BEQ.N    ??LTDC_ClearFlag_0
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xD007             BEQ.N    ??LTDC_ClearFlag_0
   \   00000010   0x2C08             CMP      R4,#+8
   \   00000012   0xD005             BEQ.N    ??LTDC_ClearFlag_0
   \   00000014   0xF240 0x4102      MOVW     R1,#+1026
   \   00000018   0x.... 0x....      ADR.W    R0,?_0
   \   0000001C   0x.... 0x....      BL       assert_failed
   1027          
   1028            /* Clear the corresponding LTDC flag */
   1029            LTDC->ICR = (uint32_t)LTDC_FLAG;
   \                     ??LTDC_ClearFlag_0: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable17_12  ;; 0x4001683c
   \   00000022   0x6004             STR      R4,[R0, #+0]
   1030          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1031          
   1032          /**
   1033            * @brief  Checks whether the specified LTDC's interrupt has occurred or not.
   1034            * @param  LTDC_IT: specifies the LTDC interrupts sources to check.
   1035            *   This parameter can be one of the following values:
   1036            *     @arg LTDC_IT_LI:    Line Interrupt Enable.
   1037            *     @arg LTDC_IT_FU:   FIFO Underrun Interrupt Enable.
   1038            *     @arg LTDC_IT_TERR: Transfer Error Interrupt Enable.
   1039            *     @arg LTDC_IT_RR:   Register Reload interrupt Enable.
   1040            * @retval The new state of the LTDC_IT (SET or RESET).
   1041            */

   \                                 In section .text, align 2, keep-with-next
   1042          ITStatus LTDC_GetITStatus(uint32_t LTDC_IT)
   1043          {
   \                     LTDC_GetITStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1044            ITStatus bitstatus = RESET;
   \   00000004   0x2500             MOVS     R5,#+0
   1045          
   1046            /* Check the parameters */
   1047            assert_param(IS_LTDC_IT(LTDC_IT));
   \   00000006   0x0920             LSRS     R0,R4,#+4
   \   00000008   0x0100             LSLS     R0,R0,#+4
   \   0000000A   0xD101             BNE.N    ??LTDC_GetITStatus_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD105             BNE.N    ??LTDC_GetITStatus_1
   \                     ??LTDC_GetITStatus_0: (+1)
   \   00000010   0xF240 0x4117      MOVW     R1,#+1047
   \   00000014   0x.... 0x....      ADR.W    R0,?_0
   \   00000018   0x.... 0x....      BL       assert_failed
   1048          
   1049            if ((LTDC->ISR & LTDC_IT) != (uint32_t)RESET)
   \                     ??LTDC_GetITStatus_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable17_10  ;; 0x40016834
   \   0000001E   0x6841             LDR      R1,[R0, #+4]
   \   00000020   0x4221             TST      R1,R4
   \   00000022   0xD000             BEQ.N    ??LTDC_GetITStatus_2
   1050            {
   1051              bitstatus = SET;
   \   00000024   0x2501             MOVS     R5,#+1
   1052            }
   1053            else
   1054            {
   1055              bitstatus = RESET;
   1056            }
   1057          
   1058            if (((LTDC->IER & LTDC_IT) != (uint32_t)RESET) && (bitstatus != (uint32_t)RESET))
   \                     ??LTDC_GetITStatus_2: (+1)
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x4220             TST      R0,R4
   \   0000002A   0xD005             BEQ.N    ??LTDC_GetITStatus_3
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x4180             SBCS     R0,R0,R0
   \   00000032   0x43C0             MVNS     R0,R0
   \   00000034   0x0FC0             LSRS     R0,R0,#+31
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}
   1059            {
   1060              bitstatus = SET;
   1061            }
   1062            else
   1063            {
   1064              bitstatus = RESET;
   \                     ??LTDC_GetITStatus_3: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   1065            }
   1066            return bitstatus;
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1067          }
   1068          
   1069          
   1070          /**
   1071            * @brief  Clears the LTDC's interrupt pending bits.
   1072            * @param  LTDC_IT: specifies the interrupt pending bit to clear.
   1073            *   This parameter can be any combination of the following values:
   1074            *     @arg LTDC_IT_LIE:    Line Interrupt.
   1075            *     @arg LTDC_IT_FUIE:   FIFO Underrun Interrupt.
   1076            *     @arg LTDC_IT_TERRIE: Transfer Error Interrupt.
   1077            *     @arg LTDC_IT_RRIE:   Register Reload interrupt.
   1078            * @retval None
   1079            */

   \                                 In section .text, align 2, keep-with-next
   1080          void LTDC_ClearITPendingBit(uint32_t LTDC_IT)
   1081          {
   \                     LTDC_ClearITPendingBit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1082            /* Check the parameters */
   1083            assert_param(IS_LTDC_IT(LTDC_IT));
   \   00000004   0x0920             LSRS     R0,R4,#+4
   \   00000006   0x0100             LSLS     R0,R0,#+4
   \   00000008   0xD101             BNE.N    ??LTDC_ClearITPendingBit_0
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD105             BNE.N    ??LTDC_ClearITPendingBit_1
   \                     ??LTDC_ClearITPendingBit_0: (+1)
   \   0000000E   0xF240 0x413B      MOVW     R1,#+1083
   \   00000012   0x.... 0x....      ADR.W    R0,?_0
   \   00000016   0x.... 0x....      BL       assert_failed
   1084          
   1085            /* Clear the corresponding LTDC Interrupt */
   1086            LTDC->ICR = (uint32_t)LTDC_IT;
   \                     ??LTDC_ClearITPendingBit_1: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable17_12  ;; 0x4001683c
   \   0000001C   0x6004             STR      R4,[R0, #+0]
   1087          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0xF000F800         DC32     0xf000f800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40016808         DC32     0x40016808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x0FFE888F         DC32     0xffe888f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40016818         DC32     0x40016818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40016840         DC32     0x40016840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x40016824         DC32     0x40016824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0xFFFFF8F8         DC32     0xfffff8f8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x40016844         DC32     0x40016844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x40016848         DC32     0x40016848

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x4001680C         DC32     0x4001680c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x40016834         DC32     0x40016834

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x40016838         DC32     0x40016838

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x4001683C         DC32     0x4001683c

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x6C 0x74          DC8 6CH, 74H, 64H, 63H, 2EH, 63H, 0
   \              0x64 0x63    
   \              0x2E 0x63    
   \              0x00         
   \   00000067   0x00               DC8 0
   1088          /**
   1089            * @}
   1090            */
   1091          
   1092          /**
   1093            * @}
   1094            */ 
   1095          
   1096          /**
   1097            * @}
   1098            */ 
   1099          
   1100          /**
   1101            * @}
   1102            */ 
   1103          
   1104          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   LTDC_CLUTCmd
        16   -> assert_failed
      16   LTDC_CLUTInit
        16   -> assert_failed
       0   LTDC_CLUTStructInit
       8   LTDC_ClearFlag
         8   -> assert_failed
       8   LTDC_ClearITPendingBit
         8   -> assert_failed
       8   LTDC_Cmd
         8   -> assert_failed
      16   LTDC_ColorKeyingConfig
        16   -> assert_failed
       0   LTDC_ColorKeyingStructInit
       8   LTDC_DeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       8   LTDC_DitherCmd
         8   -> assert_failed
       8   LTDC_GetCDStatus
         8   -> assert_failed
      16   LTDC_GetFlagStatus
        16   -> assert_failed
      16   LTDC_GetITStatus
        16   -> assert_failed
       4   LTDC_GetPosStatus
      16   LTDC_GetRGBWidth
      16   LTDC_ITConfig
        16   -> assert_failed
      16   LTDC_Init
        16   -> assert_failed
       8   LTDC_LIPConfig
         8   -> assert_failed
       0   LTDC_LayerAddress
       0   LTDC_LayerAlpha
      16   LTDC_LayerCmd
        16   -> assert_failed
      16   LTDC_LayerInit
        16   -> assert_failed
       0   LTDC_LayerPixelFormat
       4   LTDC_LayerPosition
      12   LTDC_LayerSize
       0   LTDC_LayerStructInit
       0   LTDC_PosStructInit
       0   LTDC_RGBStructInit
       8   LTDC_ReloadConfig
         8   -> assert_failed
       0   LTDC_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
     104  ?_0
      52  LTDC_CLUTCmd
     102  LTDC_CLUTInit
      12  LTDC_CLUTStructInit
      38  LTDC_ClearFlag
      32  LTDC_ClearITPendingBit
      46  LTDC_Cmd
     136  LTDC_ColorKeyingConfig
      10  LTDC_ColorKeyingStructInit
      26  LTDC_DeInit
      48  LTDC_DitherCmd
      50  LTDC_GetCDStatus
      48  LTDC_GetFlagStatus
      60  LTDC_GetITStatus
      32  LTDC_GetPosStatus
      52  LTDC_GetRGBWidth
      68  LTDC_ITConfig
     406  LTDC_Init
      30  LTDC_LIPConfig
       4  LTDC_LayerAddress
       4  LTDC_LayerAlpha
      46  LTDC_LayerCmd
     436  LTDC_LayerInit
     100  LTDC_LayerPixelFormat
     120  LTDC_LayerPosition
      90  LTDC_LayerSize
      48  LTDC_LayerStructInit
       8  LTDC_PosStructInit
      10  LTDC_RGBStructInit
      32  LTDC_ReloadConfig
      34  LTDC_StructInit

 
 2 336 bytes in section .text
 
 2 336 bytes of CODE memory

Errors: none
Warnings: none
