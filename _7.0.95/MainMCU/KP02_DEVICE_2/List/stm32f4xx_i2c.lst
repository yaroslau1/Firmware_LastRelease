###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.2.8542/W32 for ARM        09/Oct/2018  16:32:37
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c
#    Command line =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c
#        -D IAR_ARM_CM4 -D USE_STDPERIPH_DRIVER -D STM32F40_41xxx -D
#        HAVE_CONFIG_H -D SD_SPI_MODE -D USE_FULL_ASSERT -D DEVICE_2 -D TFT -D
#        STENDBUY_NOT_USE -D SCREEN_NOT_ROTATE -D USE_ADS1292R -D DISPLAY_GPIO
#        -D BUFFERED_TRANSFER -D LCD_TRACE -lCN
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\ -o
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4F -e --fpu=VFPv4_sp --dlib_config
#        "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FatFs\ -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\CoreSupport\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\CMSIS\CM4\DeviceSupport\STM32F4xx\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\inc\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\speex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\include\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\
#        -I
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F10x_Speex_Lib\STM32\libspeex\iar\
#        -I D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Fonts\ -Om --ec++
#    List file    =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\List\stm32f4xx_i2c.lst
#    Object file  =  
#        D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\KP02_DEVICE_2\Obj\stm32f4xx_i2c.o
#
###############################################################################

D:\WORK\Firmware_LastRelease\_7.0.95\MainMCU\Libraries\STM32F4xx_StdPeriph_Driver\src\stm32f4xx_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_i2c.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    08-November-2013
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Inter-integrated circuit (I2C)
      9            *           + Initialization and Configuration
     10            *           + Data transfers
     11            *           + PEC management
     12            *           + DMA transfers management
     13            *           + Interrupts, events and flags management 
     14            *           
     15              @verbatim    
     16           ===============================================================================
     17                              ##### How to use this driver #####
     18           ===============================================================================
     19              [..]
     20                (#) Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
     21                    function for I2C1, I2C2 or I2C3.
     22            
     23                (#) Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
     24                    RCC_AHBPeriphClockCmd() function. 
     25            
     26                (#) Peripherals alternate function: 
     27                  (++) Connect the pin to the desired peripherals' Alternate 
     28                       Function (AF) using GPIO_PinAFConfig() function
     29                  (++) Configure the desired pin in alternate function by:
     30                       GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     31                  (++) Select the type, pull-up/pull-down and output speed via 
     32                       GPIO_PuPd, GPIO_OType and GPIO_Speed members
     33                  (++) Call GPIO_Init() function
     34                       Recommended configuration is Push-Pull, Pull-up, Open-Drain.
     35                       Add an external pull up if necessary (typically 4.7 KOhm).      
     36                    
     37                (#) Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
     38                    Address using the I2C_Init() function.
     39            
     40                (#) Optionally you can enable/configure the following parameters without
     41                    re-initialization (i.e there is no need to call again I2C_Init() function):
     42                  (++) Enable the acknowledge feature using I2C_AcknowledgeConfig() function
     43                  (++) Enable the dual addressing mode using I2C_DualAddressCmd() function
     44                  (++) Enable the general call using the I2C_GeneralCallCmd() function
     45                  (++) Enable the clock stretching using I2C_StretchClockCmd() function
     46                  (++) Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
     47                       function.
     48                  (++) Configure the NACK position for Master Receiver mode in case of 
     49                       2 bytes reception using the function I2C_NACKPositionConfig().  
     50                  (++) Enable the PEC Calculation using I2C_CalculatePEC() function
     51                  (++) For SMBus Mode: 
     52                    (+++) Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
     53                    (+++) Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
     54            
     55                (#) Enable the NVIC and the corresponding interrupt using the function 
     56                    I2C_ITConfig() if you need to use interrupt mode. 
     57            
     58                (#) When using the DMA mode 
     59                  (++) Configure the DMA using DMA_Init() function
     60                  (++) Active the needed channel Request using I2C_DMACmd() or
     61                       I2C_DMALastTransferCmd() function.
     62                  -@@- When using DMA mode, I2C interrupts may be used at the same time to
     63                       control the communication flow (Start/Stop/Ack... events and errors).
     64             
     65                (#) Enable the I2C using the I2C_Cmd() function.
     66             
     67                (#) Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
     68                    transfers. 
     69            
     70              @endverbatim  
     71            ******************************************************************************
     72            * @attention
     73            *
     74            * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
     75            *
     76            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     77            * You may not use this file except in compliance with the License.
     78            * You may obtain a copy of the License at:
     79            *
     80            *        http://www.st.com/software_license_agreement_liberty_v2
     81            *
     82            * Unless required by applicable law or agreed to in writing, software 
     83            * distributed under the License is distributed on an "AS IS" BASIS, 
     84            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     85            * See the License for the specific language governing permissions and
     86            * limitations under the License.
     87            *
     88            ******************************************************************************  
     89            */ 
     90          
     91          /* Includes ------------------------------------------------------------------*/
     92          #include "stm32f4xx_i2c.h"
     93          #include "stm32f4xx_rcc.h"
     94          
     95          /** @addtogroup STM32F4xx_StdPeriph_Driver
     96            * @{
     97            */
     98          
     99          /** @defgroup I2C 
    100            * @brief I2C driver modules
    101            * @{
    102            */ 
    103          
    104          /* Private typedef -----------------------------------------------------------*/
    105          /* Private define ------------------------------------------------------------*/
    106          
    107          #define CR1_CLEAR_MASK    ((uint16_t)0xFBF5)      /*<! I2C registers Masks */
    108          #define FLAG_MASK         ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */
    109          #define ITEN_MASK         ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */
    110          
    111          /* Private macro -------------------------------------------------------------*/
    112          /* Private variables ---------------------------------------------------------*/
    113          /* Private function prototypes -----------------------------------------------*/
    114          /* Private functions ---------------------------------------------------------*/
    115          
    116          /** @defgroup I2C_Private_Functions
    117            * @{
    118            */
    119          
    120          /** @defgroup I2C_Group1 Initialization and Configuration functions
    121           *  @brief   Initialization and Configuration functions 
    122           *
    123          @verbatim   
    124           ===============================================================================
    125                      ##### Initialization and Configuration functions #####
    126           ===============================================================================  
    127          
    128          @endverbatim
    129            * @{
    130            */
    131          
    132          /**
    133            * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
    134            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    135            * @retval None
    136            */

   \                                 In section .text, align 2, keep-with-next
    137          void I2C_DeInit(I2C_TypeDef* I2Cx)
    138          {
   \                     I2C_DeInit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    139            /* Check the parameters */
    140            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable28  ;; 0x40005400
   \   00000008   0x42AC             CMP      R4,R5
   \   0000000A   0xD00C             BEQ.N    ??I2C_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??I2C_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40005c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD004             BEQ.N    ??I2C_DeInit_0
   \   0000001C   0x218C             MOVS     R1,#+140
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000022   0x.... 0x....      BL       assert_failed
    141          
    142            if (I2Cx == I2C1)
   \                     ??I2C_DeInit_0: (+1)
   \   00000026   0x42AC             CMP      R4,R5
   \   00000028   0xD10B             BNE.N    ??I2C_DeInit_1
    143            {
    144              /* Enable I2C1 reset state */
    145              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0xF44F 0x1000      MOV      R0,#+2097152
   \   00000030   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    146              /* Release I2C1 from reset state */
    147              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xF44F 0x1000      MOV      R0,#+2097152
   \   0000003A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000003E   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    148            }
    149            else if (I2Cx == I2C2)
   \                     ??I2C_DeInit_1: (+1)
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xD10B             BNE.N    ??I2C_DeInit_2
    150            {
    151              /* Enable I2C2 reset state */
    152              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0xF44F 0x0080      MOV      R0,#+4194304
   \   00000050   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    153              /* Release I2C2 from reset state */
    154              RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xF44F 0x0080      MOV      R0,#+4194304
   \   0000005A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000005E   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    155            }
    156            else 
    157            {
    158              if (I2Cx == I2C3)
   \                     ??I2C_DeInit_2: (+1)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40005c00
   \   00000066   0x4284             CMP      R4,R0
   \   00000068   0xD10B             BNE.N    ??I2C_DeInit_3
    159              {
    160                /* Enable I2C3 reset state */
    161                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0xF44F 0x0000      MOV      R0,#+8388608
   \   00000070   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    162                /* Release I2C3 from reset state */
    163                RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0xF44F 0x0000      MOV      R0,#+8388608
   \   0000007A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000007E   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    164              }
    165            }
    166          }
   \                     ??I2C_DeInit_3: (+1)
   \   00000082   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    167          
    168          /**
    169            * @brief  Initializes the I2Cx peripheral according to the specified 
    170            *         parameters in the I2C_InitStruct.
    171            *           
    172            * @note   To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency 
    173            *         (I2C peripheral input clock) must be a multiple of 10 MHz.  
    174            *           
    175            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    176            * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
    177            *         the configuration information for the specified I2C peripheral.
    178            * @retval None
    179            */

   \                                 In section .text, align 2, keep-with-next
    180          void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
    181          {
   \                     I2C_Init: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    182            uint16_t tmpreg = 0, freqrange = 0;
    183            uint16_t result = 0x04;
    184            uint32_t pclk1 = 8000000;
    185            RCC_ClocksTypeDef  rcc_clocks;
    186            /* Check the parameters */
    187            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable28_3
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD00B             BEQ.N    ??I2C_Init_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD007             BEQ.N    ??I2C_Init_0
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40005c00
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD003             BEQ.N    ??I2C_Init_0
   \   00000022   0x21BB             MOVS     R1,#+187
   \   00000024   0x4630             MOV      R0,R6
   \   00000026   0x.... 0x....      BL       assert_failed
    188            assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));
   \                     ??I2C_Init_0: (+1)
   \   0000002A   0x6828             LDR      R0,[R5, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??I2C_Init_1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable28_4  ;; 0x61a81
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD303             BCC.N    ??I2C_Init_2
   \                     ??I2C_Init_1: (+1)
   \   00000038   0x21BC             MOVS     R1,#+188
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0x.... 0x....      BL       assert_failed
    189            assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
   \                     ??I2C_Init_2: (+1)
   \   00000040   0x88A8             LDRH     R0,[R5, #+4]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD007             BEQ.N    ??I2C_Init_3
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD005             BEQ.N    ??I2C_Init_3
   \   0000004A   0x280A             CMP      R0,#+10
   \   0000004C   0xD003             BEQ.N    ??I2C_Init_3
   \   0000004E   0x21BD             MOVS     R1,#+189
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       assert_failed
    190            assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));
   \                     ??I2C_Init_3: (+1)
   \   00000056   0x88E8             LDRH     R0,[R5, #+6]
   \   00000058   0xF5B0 0x4F80      CMP      R0,#+16384
   \   0000005C   0xD007             BEQ.N    ??I2C_Init_4
   \   0000005E   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xD003             BEQ.N    ??I2C_Init_4
   \   00000066   0x21BE             MOVS     R1,#+190
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0x.... 0x....      BL       assert_failed
    191            assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
   \                     ??I2C_Init_4: (+1)
   \   0000006E   0x8928             LDRH     R0,[R5, #+8]
   \   00000070   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000074   0xDB03             BLT.N    ??I2C_Init_5
   \   00000076   0x21BF             MOVS     R1,#+191
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0x.... 0x....      BL       assert_failed
    192            assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
   \                     ??I2C_Init_5: (+1)
   \   0000007E   0x8968             LDRH     R0,[R5, #+10]
   \   00000080   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000084   0xD005             BEQ.N    ??I2C_Init_6
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD003             BEQ.N    ??I2C_Init_6
   \   0000008A   0x21C0             MOVS     R1,#+192
   \   0000008C   0x4630             MOV      R0,R6
   \   0000008E   0x.... 0x....      BL       assert_failed
    193            assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
   \                     ??I2C_Init_6: (+1)
   \   00000092   0x89A8             LDRH     R0,[R5, #+12]
   \   00000094   0xF5B0 0x4F80      CMP      R0,#+16384
   \   00000098   0xD006             BEQ.N    ??I2C_Init_7
   \   0000009A   0xF5B0 0x4F40      CMP      R0,#+49152
   \   0000009E   0xD003             BEQ.N    ??I2C_Init_7
   \   000000A0   0x21C1             MOVS     R1,#+193
   \   000000A2   0x4630             MOV      R0,R6
   \   000000A4   0x.... 0x....      BL       assert_failed
    194          
    195          /*---------------------------- I2Cx CR2 Configuration ------------------------*/
    196            /* Get the I2Cx CR2 value */
    197            tmpreg = I2Cx->CR2;
   \                     ??I2C_Init_7: (+1)
   \   000000A8   0x88A6             LDRH     R6,[R4, #+4]
    198            /* Clear frequency FREQ[5:0] bits */
    199            tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
    200            /* Get pclk1 frequency value */
    201            RCC_GetClocksFreq(&rcc_clocks);
   \   000000AA   0xA800             ADD      R0,SP,#+0
   \   000000AC   0x.... 0x....      BL       RCC_GetClocksFreq
    202            pclk1 = rcc_clocks.PCLK1_Frequency;
   \   000000B0   0x9902             LDR      R1,[SP, #+8]
    203            /* Set frequency bits depending on pclk1 value */
    204            freqrange = (uint16_t)(pclk1 / 1000000);
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable30  ;; 0xf4240
   \   000000B6   0xFBB1 0xF0F0      UDIV     R0,R1,R0
    205            tmpreg |= freqrange;
    206            /* Write to I2Cx CR2 */
    207            I2Cx->CR2 = tmpreg;
   \   000000BA   0xF64F 0x72C0      MOVW     R2,#+65472
   \   000000BE   0x4032             ANDS     R2,R2,R6
   \   000000C0   0x4302             ORRS     R2,R0,R2
   \   000000C2   0x80A2             STRH     R2,[R4, #+4]
    208          
    209          /*---------------------------- I2Cx CCR Configuration ------------------------*/
    210            /* Disable the selected I2C peripheral to configure TRISE */
    211            I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
   \   000000C4   0x8822             LDRH     R2,[R4, #+0]
   \   000000C6   0xF64F 0x73FE      MOVW     R3,#+65534
   \   000000CA   0x401A             ANDS     R2,R3,R2
   \   000000CC   0x8022             STRH     R2,[R4, #+0]
    212            /* Reset tmpreg value */
    213            /* Clear F/S, DUTY and CCR[11:0] bits */
    214            tmpreg = 0;
    215          
    216            /* Configure speed in standard mode */
    217            if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
   \   000000CE   0x682A             LDR      R2,[R5, #+0]
   \   000000D0   0x.... 0x....      LDR.W    R3,??DataTable33  ;; 0x186a1
   \   000000D4   0x429A             CMP      R2,R3
   \   000000D6   0xD20A             BCS.N    ??I2C_Init_8
    218            {
    219              /* Standard mode speed calculate */
    220              result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
   \   000000D8   0x0052             LSLS     R2,R2,#+1
   \   000000DA   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    221              /* Test if CCR value is under 0x4*/
    222              if (result < 0x04)
   \   000000DE   0x460A             MOV      R2,R1
   \   000000E0   0xB292             UXTH     R2,R2
   \   000000E2   0x2A04             CMP      R2,#+4
   \   000000E4   0xDA00             BGE.N    ??I2C_Init_9
    223              {
    224                /* Set minimum allowed value */
    225                result = 0x04;  
   \   000000E6   0x2104             MOVS     R1,#+4
    226              }
    227              /* Set speed value for standard mode */
    228              tmpreg |= result;	  
    229              /* Set Maximum Rise Time for standard mode */
    230              I2Cx->TRISE = freqrange + 1; 
   \                     ??I2C_Init_9: (+1)
   \   000000E8   0x1C40             ADDS     R0,R0,#+1
   \   000000EA   0x8420             STRH     R0,[R4, #+32]
   \   000000EC   0xE021             B.N      ??I2C_Init_10
    231            }
    232            /* Configure speed in fast mode */
    233            /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
    234               input clock) must be a multiple of 10 MHz */
    235            else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
    236            {
    237              if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
   \                     ??I2C_Init_8: (+1)
   \   000000EE   0x88EB             LDRH     R3,[R5, #+6]
   \   000000F0   0xF64B 0x76FF      MOVW     R6,#+49151
   \   000000F4   0x42B3             CMP      R3,R6
   \   000000F6   0xD104             BNE.N    ??I2C_Init_11
    238              {
    239                /* Fast mode speed calculate: Tlow/Thigh = 2 */
    240                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
   \   000000F8   0xEB02 0x0242      ADD      R2,R2,R2, LSL #+1
   \   000000FC   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000100   0xE006             B.N      ??I2C_Init_12
    241              }
    242              else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    243              {
    244                /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
    245                result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
    246                /* Set DUTY bit */
    247                result |= I2C_DutyCycle_16_9;
   \                     ??I2C_Init_11: (+1)
   \   00000102   0x2319             MOVS     R3,#+25
   \   00000104   0x435A             MULS     R2,R3,R2
   \   00000106   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000010A   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000010E   0xB289             UXTH     R1,R1
    248              }
    249          
    250              /* Test if CCR value is under 0x1*/
    251              if ((result & I2C_CCR_CCR) == 0)
   \                     ??I2C_Init_12: (+1)
   \   00000110   0x050A             LSLS     R2,R1,#+20
   \   00000112   0xD102             BNE.N    ??I2C_Init_13
    252              {
    253                /* Set minimum allowed value */
    254                result |= (uint16_t)0x0001;  
   \   00000114   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000118   0xB289             UXTH     R1,R1
    255              }
    256              /* Set speed value and set F/S bit for fast mode */
    257              tmpreg |= (uint16_t)(result | I2C_CCR_FS);
   \                     ??I2C_Init_13: (+1)
   \   0000011A   0xF441 0x4100      ORR      R1,R1,#0x8000
    258              /* Set Maximum Rise Time for fast mode */
    259              I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
   \   0000011E   0xB280             UXTH     R0,R0
   \   00000120   0xF44F 0x7296      MOV      R2,#+300
   \   00000124   0x4350             MULS     R0,R2,R0
   \   00000126   0xF44F 0x727A      MOV      R2,#+1000
   \   0000012A   0xFB90 0xF0F2      SDIV     R0,R0,R2
   \   0000012E   0x1C40             ADDS     R0,R0,#+1
   \   00000130   0x8420             STRH     R0,[R4, #+32]
    260            }
    261          
    262            /* Write to I2Cx CCR */
    263            I2Cx->CCR = tmpreg;
   \                     ??I2C_Init_10: (+1)
   \   00000132   0x83A1             STRH     R1,[R4, #+28]
    264            /* Enable the selected I2C peripheral */
    265            I2Cx->CR1 |= I2C_CR1_PE;
   \   00000134   0x8820             LDRH     R0,[R4, #+0]
   \   00000136   0xF040 0x0001      ORR      R0,R0,#0x1
   \   0000013A   0x8020             STRH     R0,[R4, #+0]
    266          
    267          /*---------------------------- I2Cx CR1 Configuration ------------------------*/
    268            /* Get the I2Cx CR1 value */
    269            tmpreg = I2Cx->CR1;
   \   0000013C   0x8820             LDRH     R0,[R4, #+0]
    270            /* Clear ACK, SMBTYPE and  SMBUS bits */
    271            tmpreg &= CR1_CLEAR_MASK;
    272            /* Configure I2Cx: mode and acknowledgement */
    273            /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
    274            /* Set ACK bit according to I2C_Ack value */
    275            tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
    276            /* Write to I2Cx CR1 */
    277            I2Cx->CR1 = tmpreg;
   \   0000013E   0xF64F 0x31F5      MOVW     R1,#+64501
   \   00000142   0x4008             ANDS     R0,R1,R0
   \   00000144   0x88A9             LDRH     R1,[R5, #+4]
   \   00000146   0x4308             ORRS     R0,R1,R0
   \   00000148   0x8969             LDRH     R1,[R5, #+10]
   \   0000014A   0x4308             ORRS     R0,R1,R0
   \   0000014C   0x8020             STRH     R0,[R4, #+0]
    278          
    279          /*---------------------------- I2Cx OAR1 Configuration -----------------------*/
    280            /* Set I2Cx Own Address1 and acknowledged address */
    281            I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
   \   0000014E   0x89A8             LDRH     R0,[R5, #+12]
   \   00000150   0x8929             LDRH     R1,[R5, #+8]
   \   00000152   0x4308             ORRS     R0,R1,R0
   \   00000154   0x8120             STRH     R0,[R4, #+8]
    282          }
   \   00000156   0xBD7F             POP      {R0-R6,PC}       ;; return
    283          
    284          /**
    285            * @brief  Fills each I2C_InitStruct member with its default value.
    286            * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
    287            * @retval None
    288            */

   \                                 In section .text, align 2, keep-with-next
    289          void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
    290          {
    291          /*---------------- Reset I2C init structure parameters values ----------------*/
    292            /* initialize the I2C_ClockSpeed member */
    293            I2C_InitStruct->I2C_ClockSpeed = 5000;
   \                     I2C_StructInit: (+1)
   \   00000000   0xF241 0x3188      MOVW     R1,#+5000
   \   00000004   0x6001             STR      R1,[R0, #+0]
    294            /* Initialize the I2C_Mode member */
    295            I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x8081             STRH     R1,[R0, #+4]
    296            /* Initialize the I2C_DutyCycle member */
    297            I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
   \   0000000A   0xF64B 0x71FF      MOVW     R1,#+49151
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    298            /* Initialize the I2C_OwnAddress1 member */
    299            I2C_InitStruct->I2C_OwnAddress1 = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    300            /* Initialize the I2C_Ack member */
    301            I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
   \   00000014   0x8141             STRH     R1,[R0, #+10]
    302            /* Initialize the I2C_AcknowledgedAddress member */
    303            I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   \   00000016   0xF44F 0x4180      MOV      R1,#+16384
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    304          }
   \   0000001C   0x4770             BX       LR               ;; return
    305          
    306          /**
    307            * @brief  Enables or disables the specified I2C peripheral.
    308            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    309            * @param  NewState: new state of the I2Cx peripheral. 
    310            *          This parameter can be: ENABLE or DISABLE.
    311            * @retval None
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    314          {
   \                     I2C_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    315            /* Check the parameters */
    316            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_Cmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_Cmd_0
   \   0000001E   0xF44F 0x719E      MOV      R1,#+316
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000026   0x.... 0x....      BL       assert_failed
    317            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_Cmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_Cmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_Cmd_1
   \   00000032   0xF240 0x113D      MOVW     R1,#+317
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   0000003A   0x.... 0x....      BL       assert_failed
    318            if (NewState != DISABLE)
   \                     ??I2C_Cmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD003             BEQ.N    ??I2C_Cmd_2
    319            {
    320              /* Enable the selected I2C peripheral */
    321              I2Cx->CR1 |= I2C_CR1_PE;
   \   00000044   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    322            }
    323            else
    324            {
    325              /* Disable the selected I2C peripheral */
    326              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
   \                     ??I2C_Cmd_2: (+1)
   \   0000004C   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    327            }
    328          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    329          
    330          /**
    331            * @brief  Enables or disables the Analog filter of I2C peripheral.
    332            * 
    333            * @note   This function can be used only for STM32F42xxx/STM3243xxx and STM32F401xx devices.
    334            *        
    335            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    336            * @param  NewState: new state of the Analog filter. 
    337            *          This parameter can be: ENABLE or DISABLE.
    338            * @note   This function should be called before initializing and enabling
    339                      the I2C Peripheral.
    340            * @retval None
    341            */

   \                                 In section .text, align 2, keep-with-next
    342          void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    343          {
   \                     I2C_AnalogFilterCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    344            /* Check the parameters */
    345            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_AnalogFilterCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_AnalogFilterCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_AnalogFilterCmd_0
   \   0000001E   0xF240 0x1159      MOVW     R1,#+345
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000026   0x.... 0x....      BL       assert_failed
    346            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_AnalogFilterCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_AnalogFilterCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_AnalogFilterCmd_1
   \   00000032   0xF44F 0x71AD      MOV      R1,#+346
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   0000003A   0x.... 0x....      BL       assert_failed
    347            if (NewState != DISABLE)
   \                     ??I2C_AnalogFilterCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8CA0             LDRH     R0,[R4, #+36]
   \   00000042   0xD004             BEQ.N    ??I2C_AnalogFilterCmd_2
    348            {
    349              /* Enable the analog filter */
    350              I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
   \   00000044   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000048   0x4008             ANDS     R0,R1,R0
   \   0000004A   0x84A0             STRH     R0,[R4, #+36]
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}
    351            }
    352            else
    353            {
    354              /* Disable the analog filter */
    355              I2Cx->FLTR |= I2C_FLTR_ANOFF;
   \                     ??I2C_AnalogFilterCmd_2: (+1)
   \   0000004E   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000052   0x84A0             STRH     R0,[R4, #+36]
    356            }
    357          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    358          
    359          /**
    360            * @brief  Configures the Digital noise filter of I2C peripheral.
    361            * 
    362            * @note   This function can be used only for STM32F42xxx/STM3243xxx and STM32F401xx devices.
    363            *       
    364            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    365            * @param  I2C_DigitalFilter: Coefficient of digital noise filter. 
    366            *          This parameter can be a number between 0x00 and 0x0F.
    367            * @note   This function should be called before initializing and enabling
    368                      the I2C Peripheral.
    369            * @retval None
    370            */

   \                                 In section .text, align 2, keep-with-next
    371          void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
    372          {
   \                     I2C_DigitalFilterConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    373            uint16_t tmpreg = 0;
    374            
    375            /* Check the parameters */
    376            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_DigitalFilterConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_DigitalFilterConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_DigitalFilterConfig_0
   \   0000001E   0xF44F 0x71BC      MOV      R1,#+376
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000026   0x.... 0x....      BL       assert_failed
    377            assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
   \                     ??I2C_DigitalFilterConfig_0: (+1)
   \   0000002A   0x2D10             CMP      R5,#+16
   \   0000002C   0xDB05             BLT.N    ??I2C_DigitalFilterConfig_1
   \   0000002E   0xF240 0x1179      MOVW     R1,#+377
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000036   0x.... 0x....      BL       assert_failed
    378            
    379            /* Get the old register value */
    380            tmpreg = I2Cx->FLTR;
   \                     ??I2C_DigitalFilterConfig_1: (+1)
   \   0000003A   0x8CA0             LDRH     R0,[R4, #+36]
    381            
    382            /* Reset I2Cx DNF bit [3:0] */
    383            tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
    384            
    385            /* Set I2Cx DNF coefficient */
    386            tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
    387            
    388            /* Store the new register value */
    389            I2Cx->FLTR = tmpreg;
   \   0000003C   0xF64F 0x71F0      MOVW     R1,#+65520
   \   00000040   0x4008             ANDS     R0,R1,R0
   \   00000042   0xF005 0x010F      AND      R1,R5,#0xF
   \   00000046   0x4308             ORRS     R0,R1,R0
   \   00000048   0x84A0             STRH     R0,[R4, #+36]
    390          }
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    391          
    392          /**
    393            * @brief  Generates I2Cx communication START condition.
    394            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    395            * @param  NewState: new state of the I2C START condition generation.
    396            *          This parameter can be: ENABLE or DISABLE.
    397            * @retval None.
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
    400          {
   \                     I2C_GenerateSTART: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    401            /* Check the parameters */
    402            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_GenerateSTART_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_GenerateSTART_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable28_2  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_GenerateSTART_0
   \   0000001E   0xF44F 0x71C9      MOV      R1,#+402
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   00000026   0x.... 0x....      BL       assert_failed
    403            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_GenerateSTART_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_GenerateSTART_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_GenerateSTART_1
   \   00000032   0xF240 0x1193      MOVW     R1,#+403
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable28_3
   \   0000003A   0x.... 0x....      BL       assert_failed
    404            if (NewState != DISABLE)
   \                     ??I2C_GenerateSTART_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD003             BEQ.N    ??I2C_GenerateSTART_2
    405            {
    406              /* Generate a START condition */
    407              I2Cx->CR1 |= I2C_CR1_START;
   \   00000044   0xF440 0x7080      ORR      R0,R0,#0x100
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    408            }
    409            else
    410            {
    411              /* Disable the START condition generation */
    412              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
   \                     ??I2C_GenerateSTART_2: (+1)
   \   0000004C   0xF64F 0x61FF      MOVW     R1,#+65279
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    413            }
    414          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    415          
    416          /**
    417            * @brief  Generates I2Cx communication STOP condition.
    418            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    419            * @param  NewState: new state of the I2C STOP condition generation.
    420            *          This parameter can be: ENABLE or DISABLE.
    421            * @retval None.
    422            */

   \                                 In section .text, align 2, keep-with-next
    423          void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
    424          {
   \                     I2C_GenerateSTOP: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    425            /* Check the parameters */
    426            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_GenerateSTOP_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_GenerateSTOP_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_GenerateSTOP_0
   \   0000001E   0xF44F 0x71D5      MOV      R1,#+426
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    427            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_GenerateSTOP_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_GenerateSTOP_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_GenerateSTOP_1
   \   00000032   0xF240 0x11AB      MOVW     R1,#+427
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    428            if (NewState != DISABLE)
   \                     ??I2C_GenerateSTOP_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD003             BEQ.N    ??I2C_GenerateSTOP_2
    429            {
    430              /* Generate a STOP condition */
    431              I2Cx->CR1 |= I2C_CR1_STOP;
   \   00000044   0xF440 0x7000      ORR      R0,R0,#0x200
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    432            }
    433            else
    434            {
    435              /* Disable the STOP condition generation */
    436              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
   \                     ??I2C_GenerateSTOP_2: (+1)
   \   0000004C   0xF64F 0x51FF      MOVW     R1,#+65023
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    437            }
    438          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    439          
    440          /**
    441            * @brief  Transmits the address byte to select the slave device.
    442            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    443            * @param  Address: specifies the slave address which will be transmitted
    444            * @param  I2C_Direction: specifies whether the I2C device will be a Transmitter
    445            *         or a Receiver. 
    446            *          This parameter can be one of the following values
    447            *            @arg I2C_Direction_Transmitter: Transmitter mode
    448            *            @arg I2C_Direction_Receiver: Receiver mode
    449            * @retval None.
    450            */

   \                                 In section .text, align 2, keep-with-next
    451          void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
    452          {
   \                     I2C_Send7bitAddress: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    453            /* Check the parameters */
    454            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00D             BEQ.N    ??I2C_Send7bitAddress_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD009             BEQ.N    ??I2C_Send7bitAddress_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??I2C_Send7bitAddress_0
   \   00000020   0xF44F 0x71E3      MOV      R1,#+454
   \   00000024   0x.... 0x....      ADR.W    R0,?_0
   \   00000028   0x.... 0x....      BL       assert_failed
    455            assert_param(IS_I2C_DIRECTION(I2C_Direction));
   \                     ??I2C_Send7bitAddress_0: (+1)
   \   0000002C   0x2E00             CMP      R6,#+0
   \   0000002E   0xD007             BEQ.N    ??I2C_Send7bitAddress_1
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xD005             BEQ.N    ??I2C_Send7bitAddress_1
   \   00000034   0xF240 0x11C7      MOVW     R1,#+455
   \   00000038   0x.... 0x....      ADR.W    R0,?_0
   \   0000003C   0x.... 0x....      BL       assert_failed
    456            /* Test on the direction to set/reset the read/write bit */
    457            if (I2C_Direction != I2C_Direction_Transmitter)
   \                     ??I2C_Send7bitAddress_1: (+1)
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD002             BEQ.N    ??I2C_Send7bitAddress_2
    458            {
    459              /* Set the address bit0 for read */
    460              Address |= I2C_OAR1_ADD0;
   \   00000044   0xF045 0x0001      ORR      R0,R5,#0x1
   \   00000048   0xE001             B.N      ??I2C_Send7bitAddress_3
    461            }
    462            else
    463            {
    464              /* Reset the address bit0 for write */
    465              Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
   \                     ??I2C_Send7bitAddress_2: (+1)
   \   0000004A   0xF005 0x00FE      AND      R0,R5,#0xFE
    466            }
    467            /* Send the address */
    468            I2Cx->DR = Address;
   \                     ??I2C_Send7bitAddress_3: (+1)
   \   0000004E   0x8220             STRH     R0,[R4, #+16]
    469          }
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    470          
    471          /**
    472            * @brief  Enables or disables the specified I2C acknowledge feature.
    473            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    474            * @param  NewState: new state of the I2C Acknowledgement.
    475            *          This parameter can be: ENABLE or DISABLE.
    476            * @retval None.
    477            */

   \                                 In section .text, align 2, keep-with-next
    478          void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
    479          {
   \                     I2C_AcknowledgeConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    480            /* Check the parameters */
    481            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_AcknowledgeConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_AcknowledgeConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_AcknowledgeConfig_0
   \   0000001E   0xF240 0x11E1      MOVW     R1,#+481
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    482            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_AcknowledgeConfig_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_AcknowledgeConfig_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_AcknowledgeConfig_1
   \   00000032   0xF44F 0x71F1      MOV      R1,#+482
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    483            if (NewState != DISABLE)
   \                     ??I2C_AcknowledgeConfig_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD003             BEQ.N    ??I2C_AcknowledgeConfig_2
    484            {
    485              /* Enable the acknowledgement */
    486              I2Cx->CR1 |= I2C_CR1_ACK;
   \   00000044   0xF440 0x6080      ORR      R0,R0,#0x400
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    487            }
    488            else
    489            {
    490              /* Disable the acknowledgement */
    491              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
   \                     ??I2C_AcknowledgeConfig_2: (+1)
   \   0000004C   0xF64F 0x31FF      MOVW     R1,#+64511
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    492            }
    493          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    494          
    495          /**
    496            * @brief  Configures the specified I2C own address2.
    497            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    498            * @param  Address: specifies the 7bit I2C own address2.
    499            * @retval None.
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
    502          {
   \                     I2C_OwnAddress2Config: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    503            uint16_t tmpreg = 0;
    504          
    505            /* Check the parameters */
    506            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_OwnAddress2Config_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_OwnAddress2Config_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_OwnAddress2Config_0
   \   0000001E   0xF44F 0x71FD      MOV      R1,#+506
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    507          
    508            /* Get the old register value */
    509            tmpreg = I2Cx->OAR2;
   \                     ??I2C_OwnAddress2Config_0: (+1)
   \   0000002A   0x89A0             LDRH     R0,[R4, #+12]
    510          
    511            /* Reset I2Cx Own address2 bit [7:1] */
    512            tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
    513          
    514            /* Set I2Cx Own address2 */
    515            tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
    516          
    517            /* Store the new register value */
    518            I2Cx->OAR2 = tmpreg;
   \   0000002C   0xF64F 0x7101      MOVW     R1,#+65281
   \   00000030   0x4008             ANDS     R0,R1,R0
   \   00000032   0xF005 0x01FE      AND      R1,R5,#0xFE
   \   00000036   0x4308             ORRS     R0,R1,R0
   \   00000038   0x81A0             STRH     R0,[R4, #+12]
    519          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    520          
    521          /**
    522            * @brief  Enables or disables the specified I2C dual addressing mode.
    523            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    524            * @param  NewState: new state of the I2C dual addressing mode.
    525            *          This parameter can be: ENABLE or DISABLE.
    526            * @retval None
    527            */

   \                                 In section .text, align 2, keep-with-next
    528          void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    529          {
   \                     I2C_DualAddressCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    530            /* Check the parameters */
    531            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_DualAddressCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_DualAddressCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_DualAddressCmd_0
   \   0000001E   0xF240 0x2113      MOVW     R1,#+531
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    532            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_DualAddressCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_DualAddressCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_DualAddressCmd_1
   \   00000032   0xF44F 0x7105      MOV      R1,#+532
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    533            if (NewState != DISABLE)
   \                     ??I2C_DualAddressCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x89A0             LDRH     R0,[R4, #+12]
   \   00000042   0xD003             BEQ.N    ??I2C_DualAddressCmd_2
    534            {
    535              /* Enable dual addressing mode */
    536              I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
   \   00000044   0xF040 0x0001      ORR      R0,R0,#0x1
   \   00000048   0x81A0             STRH     R0,[R4, #+12]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    537            }
    538            else
    539            {
    540              /* Disable dual addressing mode */
    541              I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
   \                     ??I2C_DualAddressCmd_2: (+1)
   \   0000004C   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x81A0             STRH     R0,[R4, #+12]
    542            }
    543          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    544          
    545          /**
    546            * @brief  Enables or disables the specified I2C general call feature.
    547            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    548            * @param  NewState: new state of the I2C General call.
    549            *          This parameter can be: ENABLE or DISABLE.
    550            * @retval None
    551            */

   \                                 In section .text, align 2, keep-with-next
    552          void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    553          {
   \                     I2C_GeneralCallCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    554            /* Check the parameters */
    555            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_GeneralCallCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_GeneralCallCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_GeneralCallCmd_0
   \   0000001E   0xF240 0x212B      MOVW     R1,#+555
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    556            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_GeneralCallCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_GeneralCallCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_GeneralCallCmd_1
   \   00000032   0xF44F 0x710B      MOV      R1,#+556
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    557            if (NewState != DISABLE)
   \                     ??I2C_GeneralCallCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD003             BEQ.N    ??I2C_GeneralCallCmd_2
    558            {
    559              /* Enable generall call */
    560              I2Cx->CR1 |= I2C_CR1_ENGC;
   \   00000044   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    561            }
    562            else
    563            {
    564              /* Disable generall call */
    565              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
   \                     ??I2C_GeneralCallCmd_2: (+1)
   \   0000004C   0xF64F 0x71BF      MOVW     R1,#+65471
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    566            }
    567          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    568          
    569          /**
    570            * @brief  Enables or disables the specified I2C software reset.
    571            * @note   When software reset is enabled, the I2C IOs are released (this can
    572            *         be useful to recover from bus errors).  
    573            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    574            * @param  NewState: new state of the I2C software reset.
    575            *          This parameter can be: ENABLE or DISABLE.
    576            * @retval None
    577            */

   \                                 In section .text, align 2, keep-with-next
    578          void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    579          {
   \                     I2C_SoftwareResetCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    580            /* Check the parameters */
    581            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_SoftwareResetCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_SoftwareResetCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_SoftwareResetCmd_0
   \   0000001E   0xF240 0x2145      MOVW     R1,#+581
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    582            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_SoftwareResetCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_SoftwareResetCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_SoftwareResetCmd_1
   \   00000032   0xF240 0x2146      MOVW     R1,#+582
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    583            if (NewState != DISABLE)
   \                     ??I2C_SoftwareResetCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD003             BEQ.N    ??I2C_SoftwareResetCmd_2
    584            {
    585              /* Peripheral under reset */
    586              I2Cx->CR1 |= I2C_CR1_SWRST;
   \   00000044   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    587            }
    588            else
    589            {
    590              /* Peripheral not under reset */
    591              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
   \                     ??I2C_SoftwareResetCmd_2: (+1)
   \   0000004C   0x0440             LSLS     R0,R0,#+17
   \   0000004E   0x0C40             LSRS     R0,R0,#+17
   \   00000050   0x8020             STRH     R0,[R4, #+0]
    592            }
    593          }
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    594          
    595          /**
    596            * @brief  Enables or disables the specified I2C Clock stretching.
    597            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    598            * @param  NewState: new state of the I2Cx Clock stretching.
    599            *          This parameter can be: ENABLE or DISABLE.
    600            * @retval None
    601            */

   \                                 In section .text, align 2, keep-with-next
    602          void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    603          {
   \                     I2C_StretchClockCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    604            /* Check the parameters */
    605            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_StretchClockCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_StretchClockCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_StretchClockCmd_0
   \   0000001E   0xF240 0x215D      MOVW     R1,#+605
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    606            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_StretchClockCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_StretchClockCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_StretchClockCmd_1
   \   00000032   0xF240 0x215E      MOVW     R1,#+606
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    607            if (NewState == DISABLE)
   \                     ??I2C_StretchClockCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD103             BNE.N    ??I2C_StretchClockCmd_2
    608            {
    609              /* Enable the selected I2C Clock stretching */
    610              I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
   \   00000044   0xF040 0x0080      ORR      R0,R0,#0x80
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    611            }
    612            else
    613            {
    614              /* Disable the selected I2C Clock stretching */
    615              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
   \                     ??I2C_StretchClockCmd_2: (+1)
   \   0000004C   0xF64F 0x717F      MOVW     R1,#+65407
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    616            }
    617          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    618          
    619          /**
    620            * @brief  Selects the specified I2C fast mode duty cycle.
    621            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    622            * @param  I2C_DutyCycle: specifies the fast mode duty cycle.
    623            *          This parameter can be one of the following values:
    624            *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
    625            *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
    626            * @retval None
    627            */

   \                                 In section .text, align 2, keep-with-next
    628          void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
    629          {
   \                     I2C_FastModeDutyCycleConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    630            /* Check the parameters */
    631            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_FastModeDutyCycleConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_FastModeDutyCycleConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_FastModeDutyCycleConfig_0
   \   0000001E   0xF240 0x2177      MOVW     R1,#+631
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    632            assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
   \                     ??I2C_FastModeDutyCycleConfig_0: (+1)
   \   0000002A   0xF5B5 0x4F80      CMP      R5,#+16384
   \   0000002E   0xD009             BEQ.N    ??I2C_FastModeDutyCycleConfig_1
   \   00000030   0xF64B 0x70FF      MOVW     R0,#+49151
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD005             BEQ.N    ??I2C_FastModeDutyCycleConfig_1
   \   00000038   0xF44F 0x711E      MOV      R1,#+632
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    633            if (I2C_DutyCycle != I2C_DutyCycle_16_9)
   \                     ??I2C_FastModeDutyCycleConfig_1: (+1)
   \   00000044   0xF5B5 0x4F80      CMP      R5,#+16384
   \   00000048   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000004A   0xD004             BEQ.N    ??I2C_FastModeDutyCycleConfig_2
    634            {
    635              /* I2C fast mode Tlow/Thigh=2 */
    636              I2Cx->CCR &= I2C_DutyCycle_2;
   \   0000004C   0xF64B 0x71FF      MOVW     R1,#+49151
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x83A0             STRH     R0,[R4, #+28]
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}
    637            }
    638            else
    639            {
    640              /* I2C fast mode Tlow/Thigh=16/9 */
    641              I2Cx->CCR |= I2C_DutyCycle_16_9;
   \                     ??I2C_FastModeDutyCycleConfig_2: (+1)
   \   00000056   0xF440 0x4080      ORR      R0,R0,#0x4000
   \   0000005A   0x83A0             STRH     R0,[R4, #+28]
    642            }
    643          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    644          
    645          /**
    646            * @brief  Selects the specified I2C NACK position in master receiver mode.
    647            * @note   This function is useful in I2C Master Receiver mode when the number
    648            *         of data to be received is equal to 2. In this case, this function 
    649            *         should be called (with parameter I2C_NACKPosition_Next) before data 
    650            *         reception starts,as described in the 2-byte reception procedure 
    651            *         recommended in Reference Manual in Section: Master receiver.                
    652            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    653            * @param  I2C_NACKPosition: specifies the NACK position. 
    654            *          This parameter can be one of the following values:
    655            *            @arg I2C_NACKPosition_Next: indicates that the next byte will be the last
    656            *                                        received byte.  
    657            *            @arg I2C_NACKPosition_Current: indicates that current byte is the last 
    658            *                                           received byte.
    659            *            
    660            * @note    This function configures the same bit (POS) as I2C_PECPositionConfig() 
    661            *          but is intended to be used in I2C mode while I2C_PECPositionConfig() 
    662            *          is intended to used in SMBUS mode. 
    663            *            
    664            * @retval None
    665            */

   \                                 In section .text, align 2, keep-with-next
    666          void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
    667          {
   \                     I2C_NACKPositionConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    668            /* Check the parameters */
    669            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_NACKPositionConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_NACKPositionConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_NACKPositionConfig_0
   \   0000001E   0xF240 0x219D      MOVW     R1,#+669
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    670            assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
   \                     ??I2C_NACKPositionConfig_0: (+1)
   \   0000002A   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000002E   0xD009             BEQ.N    ??I2C_NACKPositionConfig_1
   \   00000030   0xF24F 0x70FF      MOVW     R0,#+63487
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD005             BEQ.N    ??I2C_NACKPositionConfig_1
   \   00000038   0xF240 0x219E      MOVW     R1,#+670
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    671            
    672            /* Check the input parameter */
    673            if (I2C_NACKPosition == I2C_NACKPosition_Next)
   \                     ??I2C_NACKPositionConfig_1: (+1)
   \   00000044   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0xD103             BNE.N    ??I2C_NACKPositionConfig_2
    674            {
    675              /* Next byte in shift register is the last received byte */
    676              I2Cx->CR1 |= I2C_NACKPosition_Next;
   \   0000004C   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}
    677            }
    678            else
    679            {
    680              /* Current byte in shift register is the last received byte */
    681              I2Cx->CR1 &= I2C_NACKPosition_Current;
   \                     ??I2C_NACKPositionConfig_2: (+1)
   \   00000054   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    682            }
    683          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    684          
    685          /**
    686            * @brief  Drives the SMBusAlert pin high or low for the specified I2C.
    687            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    688            * @param  I2C_SMBusAlert: specifies SMBAlert pin level. 
    689            *          This parameter can be one of the following values:
    690            *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
    691            *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
    692            * @retval None
    693            */

   \                                 In section .text, align 2, keep-with-next
    694          void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
    695          {
   \                     I2C_SMBusAlertConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    696            /* Check the parameters */
    697            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_SMBusAlertConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_SMBusAlertConfig_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_SMBusAlertConfig_0
   \   0000001E   0xF240 0x21B9      MOVW     R1,#+697
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    698            assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
   \                     ??I2C_SMBusAlertConfig_0: (+1)
   \   0000002A   0xF5B5 0x5F00      CMP      R5,#+8192
   \   0000002E   0xD009             BEQ.N    ??I2C_SMBusAlertConfig_1
   \   00000030   0xF64D 0x70FF      MOVW     R0,#+57343
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD005             BEQ.N    ??I2C_SMBusAlertConfig_1
   \   00000038   0xF240 0x21BA      MOVW     R1,#+698
   \   0000003C   0x.... 0x....      ADR.W    R0,?_0
   \   00000040   0x.... 0x....      BL       assert_failed
    699            if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
   \                     ??I2C_SMBusAlertConfig_1: (+1)
   \   00000044   0xF5B5 0x5F00      CMP      R5,#+8192
   \   00000048   0x8820             LDRH     R0,[R4, #+0]
   \   0000004A   0xD103             BNE.N    ??I2C_SMBusAlertConfig_2
    700            {
    701              /* Drive the SMBusAlert pin Low */
    702              I2Cx->CR1 |= I2C_SMBusAlert_Low;
   \   0000004C   0xF440 0x5000      ORR      R0,R0,#0x2000
   \   00000050   0x8020             STRH     R0,[R4, #+0]
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}
    703            }
    704            else
    705            {
    706              /* Drive the SMBusAlert pin High  */
    707              I2Cx->CR1 &= I2C_SMBusAlert_High;
   \                     ??I2C_SMBusAlertConfig_2: (+1)
   \   00000054   0xF64D 0x71FF      MOVW     R1,#+57343
   \   00000058   0x4008             ANDS     R0,R1,R0
   \   0000005A   0x8020             STRH     R0,[R4, #+0]
    708            }
    709          }
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    710          
    711          /**
    712            * @brief  Enables or disables the specified I2C ARP.
    713            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    714            * @param  NewState: new state of the I2Cx ARP. 
    715            *          This parameter can be: ENABLE or DISABLE.
    716            * @retval None
    717            */

   \                                 In section .text, align 2, keep-with-next
    718          void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    719          {
   \                     I2C_ARPCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    720            /* Check the parameters */
    721            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_ARPCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_ARPCmd_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_ARPCmd_0
   \   0000001E   0xF240 0x21D1      MOVW     R1,#+721
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
    722            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_ARPCmd_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD007             BEQ.N    ??I2C_ARPCmd_1
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD005             BEQ.N    ??I2C_ARPCmd_1
   \   00000032   0xF240 0x21D2      MOVW     R1,#+722
   \   00000036   0x.... 0x....      ADR.W    R0,?_0
   \   0000003A   0x.... 0x....      BL       assert_failed
    723            if (NewState != DISABLE)
   \                     ??I2C_ARPCmd_1: (+1)
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0x8820             LDRH     R0,[R4, #+0]
   \   00000042   0xD003             BEQ.N    ??I2C_ARPCmd_2
    724            {
    725              /* Enable the selected I2C ARP */
    726              I2Cx->CR1 |= I2C_CR1_ENARP;
   \   00000044   0xF040 0x0010      ORR      R0,R0,#0x10
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}
    727            }
    728            else
    729            {
    730              /* Disable the selected I2C ARP */
    731              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
   \                     ??I2C_ARPCmd_2: (+1)
   \   0000004C   0xF64F 0x71EF      MOVW     R1,#+65519
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x8020             STRH     R0,[R4, #+0]
    732            }
    733          }
   \   00000054   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    734          /**
    735            * @}
    736            */
    737          
    738          /** @defgroup I2C_Group2 Data transfers functions
    739           *  @brief   Data transfers functions 
    740           *
    741          @verbatim   
    742           ===============================================================================
    743                            ##### Data transfers functions #####
    744           ===============================================================================  
    745          
    746          @endverbatim
    747            * @{
    748            */
    749          
    750          /**
    751            * @brief  Sends a data byte through the I2Cx peripheral.
    752            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    753            * @param  Data: Byte to be transmitted..
    754            * @retval None
    755            */

   \                                 In section .text, align 2, keep-with-next
    756          void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
    757          {
   \                     I2C_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    758            /* Check the parameters */
    759            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??I2C_SendData_0
   \   0000000C   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD009             BEQ.N    ??I2C_SendData_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??I2C_SendData_0
   \   0000001A   0xF240 0x21F7      MOVW     R1,#+759
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
    760            /* Write in the DR register the data to be sent */
    761            I2Cx->DR = Data;
   \                     ??I2C_SendData_0: (+1)
   \   00000026   0x8225             STRH     R5,[R4, #+16]
    762          }
   \   00000028   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    763          
    764          /**
    765            * @brief  Returns the most recent received data by the I2Cx peripheral.
    766            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    767            * @retval The value of the received data.
    768            */

   \                                 In section .text, align 2, keep-with-next
    769          uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
    770          {
   \                     I2C_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    771            /* Check the parameters */
    772            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000004   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00C             BEQ.N    ??I2C_ReceiveData_0
   \   0000000A   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??I2C_ReceiveData_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??I2C_ReceiveData_0
   \   00000018   0xF44F 0x7141      MOV      R1,#+772
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
    773            /* Return the data in the DR register */
    774            return (uint8_t)I2Cx->DR;
   \                     ??I2C_ReceiveData_0: (+1)
   \   00000024   0x8A20             LDRH     R0,[R4, #+16]
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    775          }
    776          
    777          /**
    778            * @}
    779            */
    780          
    781          /** @defgroup I2C_Group3 PEC management functions
    782           *  @brief   PEC management functions 
    783           *
    784          @verbatim   
    785           ===============================================================================
    786                            ##### PEC management functions #####
    787           ===============================================================================  
    788          
    789          @endverbatim
    790            * @{
    791            */
    792          
    793          /**
    794            * @brief  Enables or disables the specified I2C PEC transfer.
    795            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    796            * @param  NewState: new state of the I2C PEC transmission.
    797            *          This parameter can be: ENABLE or DISABLE.
    798            * @retval None
    799            */

   \                                 In section .text, align 2, keep-with-next
    800          void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    801          {
   \                     I2C_TransmitPEC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    802            /* Check the parameters */
    803            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??I2C_TransmitPEC_0
   \   0000000C   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD009             BEQ.N    ??I2C_TransmitPEC_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??I2C_TransmitPEC_0
   \   0000001A   0xF240 0x3123      MOVW     R1,#+803
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
    804            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_TransmitPEC_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??I2C_TransmitPEC_1
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_TransmitPEC_1
   \   0000002E   0xF44F 0x7149      MOV      R1,#+804
   \   00000032   0x.... 0x....      ADR.W    R0,?_0
   \   00000036   0x.... 0x....      BL       assert_failed
    805            if (NewState != DISABLE)
   \                     ??I2C_TransmitPEC_1: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x8820             LDRH     R0,[R4, #+0]
   \   0000003E   0xD003             BEQ.N    ??I2C_TransmitPEC_2
    806            {
    807              /* Enable the selected I2C PEC transmission */
    808              I2Cx->CR1 |= I2C_CR1_PEC;
   \   00000040   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000044   0x8020             STRH     R0,[R4, #+0]
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}
    809            }
    810            else
    811            {
    812              /* Disable the selected I2C PEC transmission */
    813              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
   \                     ??I2C_TransmitPEC_2: (+1)
   \   00000048   0xF64E 0x71FF      MOVW     R1,#+61439
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
    814            }
    815          }
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    816          
    817          /**
    818            * @brief  Selects the specified I2C PEC position.
    819            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    820            * @param  I2C_PECPosition: specifies the PEC position. 
    821            *          This parameter can be one of the following values:
    822            *            @arg I2C_PECPosition_Next: indicates that the next byte is PEC
    823            *            @arg I2C_PECPosition_Current: indicates that current byte is PEC
    824            *       
    825            * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()
    826            *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig() 
    827            *          is intended to used in I2C mode.
    828            *                
    829            * @retval None
    830            */

   \                                 In section .text, align 2, keep-with-next
    831          void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
    832          {
   \                     I2C_PECPositionConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    833            /* Check the parameters */
    834            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??I2C_PECPositionConfig_0
   \   0000000C   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD009             BEQ.N    ??I2C_PECPositionConfig_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??I2C_PECPositionConfig_0
   \   0000001A   0xF240 0x3142      MOVW     R1,#+834
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
    835            assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
   \                     ??I2C_PECPositionConfig_0: (+1)
   \   00000026   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000002A   0xD009             BEQ.N    ??I2C_PECPositionConfig_1
   \   0000002C   0xF24F 0x70FF      MOVW     R0,#+63487
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xD005             BEQ.N    ??I2C_PECPositionConfig_1
   \   00000034   0xF240 0x3143      MOVW     R1,#+835
   \   00000038   0x.... 0x....      ADR.W    R0,?_0
   \   0000003C   0x.... 0x....      BL       assert_failed
    836            if (I2C_PECPosition == I2C_PECPosition_Next)
   \                     ??I2C_PECPositionConfig_1: (+1)
   \   00000040   0xF5B5 0x6F00      CMP      R5,#+2048
   \   00000044   0x8820             LDRH     R0,[R4, #+0]
   \   00000046   0xD103             BNE.N    ??I2C_PECPositionConfig_2
    837            {
    838              /* Next byte in shift register is PEC */
    839              I2Cx->CR1 |= I2C_PECPosition_Next;
   \   00000048   0xF440 0x6000      ORR      R0,R0,#0x800
   \   0000004C   0x8020             STRH     R0,[R4, #+0]
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}
    840            }
    841            else
    842            {
    843              /* Current byte in shift register is PEC */
    844              I2Cx->CR1 &= I2C_PECPosition_Current;
   \                     ??I2C_PECPositionConfig_2: (+1)
   \   00000050   0xF24F 0x71FF      MOVW     R1,#+63487
   \   00000054   0x4008             ANDS     R0,R1,R0
   \   00000056   0x8020             STRH     R0,[R4, #+0]
    845            }
    846          }
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    847          
    848          /**
    849            * @brief  Enables or disables the PEC value calculation of the transferred bytes.
    850            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    851            * @param  NewState: new state of the I2Cx PEC value calculation.
    852            *          This parameter can be: ENABLE or DISABLE.
    853            * @retval None
    854            */

   \                                 In section .text, align 2, keep-with-next
    855          void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
    856          {
   \                     I2C_CalculatePEC: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    857            /* Check the parameters */
    858            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??I2C_CalculatePEC_0
   \   0000000C   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD009             BEQ.N    ??I2C_CalculatePEC_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??I2C_CalculatePEC_0
   \   0000001A   0xF240 0x315A      MOVW     R1,#+858
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
    859            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_CalculatePEC_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??I2C_CalculatePEC_1
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_CalculatePEC_1
   \   0000002E   0xF240 0x315B      MOVW     R1,#+859
   \   00000032   0x.... 0x....      ADR.W    R0,?_0
   \   00000036   0x.... 0x....      BL       assert_failed
    860            if (NewState != DISABLE)
   \                     ??I2C_CalculatePEC_1: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x8820             LDRH     R0,[R4, #+0]
   \   0000003E   0xD003             BEQ.N    ??I2C_CalculatePEC_2
    861            {
    862              /* Enable the selected I2C PEC calculation */
    863              I2Cx->CR1 |= I2C_CR1_ENPEC;
   \   00000040   0xF040 0x0020      ORR      R0,R0,#0x20
   \   00000044   0x8020             STRH     R0,[R4, #+0]
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}
    864            }
    865            else
    866            {
    867              /* Disable the selected I2C PEC calculation */
    868              I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
   \                     ??I2C_CalculatePEC_2: (+1)
   \   00000048   0xF64F 0x71DF      MOVW     R1,#+65503
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x8020             STRH     R0,[R4, #+0]
    869            }
    870          }
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    871          
    872          /**
    873            * @brief  Returns the PEC value for the specified I2C.
    874            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    875            * @retval The PEC value.
    876            */

   \                                 In section .text, align 2, keep-with-next
    877          uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
    878          {
   \                     I2C_GetPEC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    879            /* Check the parameters */
    880            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000004   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00C             BEQ.N    ??I2C_GetPEC_0
   \   0000000A   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD009             BEQ.N    ??I2C_GetPEC_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??I2C_GetPEC_0
   \   00000018   0xF44F 0x715C      MOV      R1,#+880
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
    881            /* Return the selected I2C PEC value */
    882            return ((I2Cx->SR2) >> 8);
   \                     ??I2C_GetPEC_0: (+1)
   \   00000024   0x8B20             LDRH     R0,[R4, #+24]
   \   00000026   0x0A00             LSRS     R0,R0,#+8
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    883          }
    884          
    885          /**
    886            * @}
    887            */
    888          
    889          /** @defgroup I2C_Group4 DMA transfers management functions
    890           *  @brief   DMA transfers management functions 
    891           *
    892          @verbatim   
    893           ===============================================================================
    894                          ##### DMA transfers management functions #####
    895           ===============================================================================  
    896            This section provides functions allowing to configure the I2C DMA channels 
    897            requests.
    898            
    899          @endverbatim
    900            * @{
    901            */
    902          
    903          /**
    904            * @brief  Enables or disables the specified I2C DMA requests.
    905            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    906            * @param  NewState: new state of the I2C DMA transfer.
    907            *          This parameter can be: ENABLE or DISABLE.
    908            * @retval None
    909            */

   \                                 In section .text, align 2, keep-with-next
    910          void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    911          {
   \                     I2C_DMACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    912            /* Check the parameters */
    913            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??I2C_DMACmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD009             BEQ.N    ??I2C_DMACmd_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??I2C_DMACmd_0
   \   0000001A   0xF240 0x3191      MOVW     R1,#+913
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
    914            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_DMACmd_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??I2C_DMACmd_1
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_DMACmd_1
   \   0000002E   0xF240 0x3192      MOVW     R1,#+914
   \   00000032   0x.... 0x....      ADR.W    R0,?_0
   \   00000036   0x.... 0x....      BL       assert_failed
    915            if (NewState != DISABLE)
   \                     ??I2C_DMACmd_1: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000003E   0xD003             BEQ.N    ??I2C_DMACmd_2
    916            {
    917              /* Enable the selected I2C DMA requests */
    918              I2Cx->CR2 |= I2C_CR2_DMAEN;
   \   00000040   0xF440 0x6000      ORR      R0,R0,#0x800
   \   00000044   0x80A0             STRH     R0,[R4, #+4]
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}
    919            }
    920            else
    921            {
    922              /* Disable the selected I2C DMA requests */
    923              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
   \                     ??I2C_DMACmd_2: (+1)
   \   00000048   0xF24F 0x71FF      MOVW     R1,#+63487
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x80A0             STRH     R0,[R4, #+4]
    924            }
    925          }
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    926          
    927          /**
    928            * @brief  Specifies that the next DMA transfer is the last one.
    929            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
    930            * @param  NewState: new state of the I2C DMA last transfer.
    931            *          This parameter can be: ENABLE or DISABLE.
    932            * @retval None
    933            */

   \                                 In section .text, align 2, keep-with-next
    934          void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
    935          {
   \                     I2C_DMALastTransferCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    936            /* Check the parameters */
    937            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00C             BEQ.N    ??I2C_DMALastTransferCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD009             BEQ.N    ??I2C_DMALastTransferCmd_0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??I2C_DMALastTransferCmd_0
   \   0000001A   0xF240 0x31A9      MOVW     R1,#+937
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
    938            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_DMALastTransferCmd_0: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??I2C_DMALastTransferCmd_1
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??I2C_DMALastTransferCmd_1
   \   0000002E   0xF240 0x31AA      MOVW     R1,#+938
   \   00000032   0x.... 0x....      ADR.W    R0,?_0
   \   00000036   0x.... 0x....      BL       assert_failed
    939            if (NewState != DISABLE)
   \                     ??I2C_DMALastTransferCmd_1: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x88A0             LDRH     R0,[R4, #+4]
   \   0000003E   0xD003             BEQ.N    ??I2C_DMALastTransferCmd_2
    940            {
    941              /* Next DMA transfer is the last transfer */
    942              I2Cx->CR2 |= I2C_CR2_LAST;
   \   00000040   0xF440 0x5080      ORR      R0,R0,#0x1000
   \   00000044   0x80A0             STRH     R0,[R4, #+4]
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}
    943            }
    944            else
    945            {
    946              /* Next DMA transfer is not the last transfer */
    947              I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
   \                     ??I2C_DMALastTransferCmd_2: (+1)
   \   00000048   0xF64E 0x71FF      MOVW     R1,#+61439
   \   0000004C   0x4008             ANDS     R0,R1,R0
   \   0000004E   0x80A0             STRH     R0,[R4, #+4]
    948            }
    949          }
   \   00000050   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    950          
    951          /**
    952            * @}
    953            */
    954          
    955          /** @defgroup I2C_Group5 Interrupts events and flags management functions
    956           *  @brief   Interrupts, events and flags management functions
    957           *
    958          @verbatim   
    959           ===============================================================================
    960                    ##### Interrupts, events and flags management functions #####
    961           ===============================================================================
    962              [..]
    963              This section provides functions allowing to configure the I2C Interrupts 
    964              sources and check or clear the flags or pending bits status.
    965              The user should identify which mode will be used in his application to manage 
    966              the communication: Polling mode, Interrupt mode or DMA mode. 
    967          
    968          
    969                          ##### I2C State Monitoring Functions #####                   
    970           =============================================================================== 
    971              [..]  
    972              This I2C driver provides three different ways for I2C state monitoring
    973              depending on the application requirements and constraints:
    974                   
    975             
    976               (#) Basic state monitoring (Using I2C_CheckEvent() function)
    977               
    978                  It compares the status registers (SR1 and SR2) content to a given event
    979                  (can be the combination of one or more flags).
    980                  It returns SUCCESS if the current status includes the given flags 
    981                  and returns ERROR if one or more flags are missing in the current status.
    982          
    983                    (++) When to use
    984                       (+++) This function is suitable for most applications as well as for startup 
    985                         activity since the events are fully described in the product reference 
    986                         manual (RM0090).
    987                       (+++) It is also suitable for users who need to define their own events.
    988          
    989                    (++) Limitations
    990                         If an error occurs (ie. error flags are set besides to the monitored 
    991                         flags), the I2C_CheckEvent() function may return SUCCESS despite 
    992                         the communication hold or corrupted real state. 
    993                         In this case, it is advised to use error interrupts to monitor 
    994                         the error events and handle them in the interrupt IRQ handler.
    995                   
    996               -@@- For error management, it is advised to use the following functions:
    997                  (+@@) I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
    998                  (+@@) I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
    999                        Where x is the peripheral instance (I2C1, I2C2 ...)
   1000                  (+@@) I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
   1001                        I2Cx_ER_IRQHandler() function in order to determine which error occurred.
   1002                  (+@@) I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
   1003                        and/or I2C_GenerateStop() in order to clear the error flag and source 
   1004                        and return to correct  communication status.
   1005                       
   1006           
   1007               (#) Advanced state monitoring (Using the function I2C_GetLastEvent())
   1008          
   1009                  Using the function I2C_GetLastEvent() which returns the image of both status 
   1010                  registers in a single word (uint32_t) (Status Register 2 value is shifted left 
   1011                  by 16 bits and concatenated to Status Register 1).
   1012          
   1013                    (++) When to use
   1014                       (+++) This function is suitable for the same applications above but it 
   1015                         allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
   1016                         function.
   1017                       (+++) The returned value could be compared to events already defined in 
   1018                         the library (stm32f4xx_i2c.h) or to custom values defined by user.
   1019                         This function is suitable when multiple flags are monitored at the 
   1020                         same time.
   1021                       (+++) At the opposite of I2C_CheckEvent() function, this function allows 
   1022                         user to choose when an event is accepted (when all events flags are 
   1023                         set and no other flags are set or just when the needed flags are set 
   1024                         like I2C_CheckEvent() function.
   1025          
   1026                    (++) Limitations
   1027                       (+++) User may need to define his own events.
   1028                       (+++) Same remark concerning the error management is applicable for this 
   1029                         function if user decides to check only regular communication flags 
   1030                         (and ignores error flags).
   1031                
   1032           
   1033               (#) Flag-based state monitoring (Using the function I2C_GetFlagStatus())
   1034               
   1035                Using the function I2C_GetFlagStatus() which simply returns the status of 
   1036                one single flag (ie. I2C_FLAG_RXNE ...). 
   1037          
   1038                    (++) When to use
   1039                       (+++) This function could be used for specific applications or in debug 
   1040                         phase.
   1041                       (+++) It is suitable when only one flag checking is needed (most I2C 
   1042                         events are monitored through multiple flags).
   1043                    (++) Limitations: 
   1044                       (+++) When calling this function, the Status register is accessed. 
   1045                         Some flags are cleared when the status register is accessed. 
   1046                         So checking the status of one Flag, may clear other ones.
   1047                       (+++) Function may need to be called twice or more in order to monitor 
   1048                         one single event.
   1049           
   1050             For detailed description of Events, please refer to section I2C_Events in 
   1051             stm32f4xx_i2c.h file.
   1052                 
   1053          @endverbatim
   1054            * @{
   1055            */
   1056             
   1057          /**
   1058            * @brief  Reads the specified I2C register and returns its value.
   1059            * @param  I2C_Register: specifies the register to read.
   1060            *          This parameter can be one of the following values:
   1061            *            @arg I2C_Register_CR1:  CR1 register.
   1062            *            @arg I2C_Register_CR2:   CR2 register.
   1063            *            @arg I2C_Register_OAR1:  OAR1 register.
   1064            *            @arg I2C_Register_OAR2:  OAR2 register.
   1065            *            @arg I2C_Register_DR:    DR register.
   1066            *            @arg I2C_Register_SR1:   SR1 register.
   1067            *            @arg I2C_Register_SR2:   SR2 register.
   1068            *            @arg I2C_Register_CCR:   CCR register.
   1069            *            @arg I2C_Register_TRISE: TRISE register.
   1070            * @retval The value of the read register.
   1071            */

   \                                 In section .text, align 2, keep-with-next
   1072          uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
   1073          {
   \                     I2C_ReadRegister: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1074            __IO uint32_t tmp = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
   1075          
   1076            /* Check the parameters */
   1077            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   0000000A   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD00C             BEQ.N    ??I2C_ReadRegister_0
   \   00000010   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_ReadRegister_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_ReadRegister_0
   \   0000001E   0xF240 0x4135      MOVW     R1,#+1077
   \   00000022   0x.... 0x....      ADR.W    R0,?_0
   \   00000026   0x.... 0x....      BL       assert_failed
   1078            assert_param(IS_I2C_REGISTER(I2C_Register));
   \                     ??I2C_ReadRegister_0: (+1)
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD016             BEQ.N    ??I2C_ReadRegister_1
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x2804             CMP      R0,#+4
   \   00000032   0xD013             BEQ.N    ??I2C_ReadRegister_1
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD011             BEQ.N    ??I2C_ReadRegister_1
   \   00000038   0x280C             CMP      R0,#+12
   \   0000003A   0xD00F             BEQ.N    ??I2C_ReadRegister_1
   \   0000003C   0x2810             CMP      R0,#+16
   \   0000003E   0xD00D             BEQ.N    ??I2C_ReadRegister_1
   \   00000040   0x2814             CMP      R0,#+20
   \   00000042   0xD00B             BEQ.N    ??I2C_ReadRegister_1
   \   00000044   0x2818             CMP      R0,#+24
   \   00000046   0xD009             BEQ.N    ??I2C_ReadRegister_1
   \   00000048   0x281C             CMP      R0,#+28
   \   0000004A   0xD007             BEQ.N    ??I2C_ReadRegister_1
   \   0000004C   0x2820             CMP      R0,#+32
   \   0000004E   0xD005             BEQ.N    ??I2C_ReadRegister_1
   \   00000050   0xF240 0x4136      MOVW     R1,#+1078
   \   00000054   0x.... 0x....      ADR.W    R0,?_0
   \   00000058   0x.... 0x....      BL       assert_failed
   1079          
   1080            tmp = (uint32_t) I2Cx;
   \                     ??I2C_ReadRegister_1: (+1)
   \   0000005C   0x9400             STR      R4,[SP, #+0]
   1081            tmp += I2C_Register;
   \   0000005E   0x9800             LDR      R0,[SP, #+0]
   \   00000060   0xFA50 0xF085      UXTAB    R0,R0,R5
   \   00000064   0x9000             STR      R0,[SP, #+0]
   1082          
   1083            /* Return the selected register value */
   1084            return (*(__IO uint16_t *) tmp);
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x8800             LDRH     R0,[R0, #+0]
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1085          }
   1086          
   1087          /**
   1088            * @brief  Enables or disables the specified I2C interrupts.
   1089            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1090            * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled. 
   1091            *          This parameter can be any combination of the following values:
   1092            *            @arg I2C_IT_BUF: Buffer interrupt mask
   1093            *            @arg I2C_IT_EVT: Event interrupt mask
   1094            *            @arg I2C_IT_ERR: Error interrupt mask
   1095            * @param  NewState: new state of the specified I2C interrupts.
   1096            *          This parameter can be: ENABLE or DISABLE.
   1097            * @retval None
   1098            */

   \                                 In section .text, align 2, keep-with-next
   1099          void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
   1100          {
   \                     I2C_ITConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   1101            /* Check the parameters */
   1102            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x....             LDR.N    R0,??DataTable28  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00C             BEQ.N    ??I2C_ITConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable28_1  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??I2C_ITConfig_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??I2C_ITConfig_0
   \   0000001C   0xF240 0x414E      MOVW     R1,#+1102
   \   00000020   0x.... 0x....      ADR.W    R0,?_0
   \   00000024   0x.... 0x....      BL       assert_failed
   1103            assert_param(IS_FUNCTIONAL_STATE(NewState));
   \                     ??I2C_ITConfig_0: (+1)
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD007             BEQ.N    ??I2C_ITConfig_1
   \   0000002C   0x2E01             CMP      R6,#+1
   \   0000002E   0xD005             BEQ.N    ??I2C_ITConfig_1
   \   00000030   0xF240 0x414F      MOVW     R1,#+1103
   \   00000034   0x.... 0x....      ADR.W    R0,?_0
   \   00000038   0x.... 0x....      BL       assert_failed
   1104            assert_param(IS_I2C_CONFIG_IT(I2C_IT));
   \                     ??I2C_ITConfig_1: (+1)
   \   0000003C   0xF64F 0x00FF      MOVW     R0,#+63743
   \   00000040   0x4205             TST      R5,R0
   \   00000042   0xD101             BNE.N    ??I2C_ITConfig_2
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD105             BNE.N    ??I2C_ITConfig_3
   \                     ??I2C_ITConfig_2: (+1)
   \   00000048   0xF44F 0x618A      MOV      R1,#+1104
   \   0000004C   0x.... 0x....      ADR.W    R0,?_0
   \   00000050   0x.... 0x....      BL       assert_failed
   1105            
   1106            if (NewState != DISABLE)
   \                     ??I2C_ITConfig_3: (+1)
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0x88A0             LDRH     R0,[R4, #+4]
   \   00000058   0xD002             BEQ.N    ??I2C_ITConfig_4
   1107            {
   1108              /* Enable the selected I2C interrupts */
   1109              I2Cx->CR2 |= I2C_IT;
   \   0000005A   0x4328             ORRS     R0,R5,R0
   \   0000005C   0x80A0             STRH     R0,[R4, #+4]
   \   0000005E   0xBD70             POP      {R4-R6,PC}
   1110            }
   1111            else
   1112            {
   1113              /* Disable the selected I2C interrupts */
   1114              I2Cx->CR2 &= (uint16_t)~I2C_IT;
   \                     ??I2C_ITConfig_4: (+1)
   \   00000060   0x43A8             BICS     R0,R0,R5
   \   00000062   0x80A0             STRH     R0,[R4, #+4]
   1115            }
   1116          }
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
   1117          
   1118          /*
   1119           ===============================================================================
   1120                                    1. Basic state monitoring                    
   1121           ===============================================================================  
   1122           */
   1123          
   1124          /**
   1125            * @brief  Checks whether the last I2Cx Event is equal to the one passed
   1126            *         as parameter.
   1127            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1128            * @param  I2C_EVENT: specifies the event to be checked. 
   1129            *          This parameter can be one of the following values:
   1130            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1
   1131            *            @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1
   1132            *            @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1
   1133            *            @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1
   1134            *            @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1
   1135            *            @arg I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2
   1136            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2
   1137            *            @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2
   1138            *            @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3
   1139            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3
   1140            *            @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3
   1141            *            @arg I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2
   1142            *            @arg I2C_EVENT_SLAVE_STOP_DETECTED: EV4
   1143            *            @arg I2C_EVENT_MASTER_MODE_SELECT: EV5
   1144            *            @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6     
   1145            *            @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6
   1146            *            @arg I2C_EVENT_MASTER_BYTE_RECEIVED: EV7
   1147            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8
   1148            *            @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2
   1149            *            @arg I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
   1150            *     
   1151            * @note   For detailed description of Events, please refer to section I2C_Events
   1152            *         in stm32f4xx_i2c.h file.
   1153            *    
   1154            * @retval An ErrorStatus enumeration value:
   1155            *           - SUCCESS: Last event is equal to the I2C_EVENT
   1156            *           - ERROR: Last event is different from the I2C_EVENT
   1157            */

   \                                 In section .text, align 2, keep-with-next
   1158          ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
   1159          {
   \                     I2C_CheckEvent: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460C             MOV      R4,R1
   1160            uint32_t lastevent = 0;
   1161            uint32_t flag1 = 0, flag2 = 0;
   1162            ErrorStatus status = ERROR;
   \   00000006   0x2500             MOVS     R5,#+0
   1163          
   1164            /* Check the parameters */
   1165            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable34_1  ;; 0x40005400
   \   0000000C   0x4286             CMP      R6,R0
   \   0000000E   0xD00D             BEQ.N    ??I2C_CheckEvent_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable34_2  ;; 0x40005800
   \   00000014   0x4286             CMP      R6,R0
   \   00000016   0xD009             BEQ.N    ??I2C_CheckEvent_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable34  ;; 0x40005c00
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xD005             BEQ.N    ??I2C_CheckEvent_0
   \   00000020   0xF240 0x418D      MOVW     R1,#+1165
   \   00000024   0x.... 0x....      ADR.W    R0,?_0
   \   00000028   0x.... 0x....      BL       assert_failed
   1166            assert_param(IS_I2C_EVENT(I2C_EVENT));
   \                     ??I2C_CheckEvent_0: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable34_3  ;; 0x60082
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD03E             BEQ.N    ??I2C_CheckEvent_1
   \   00000034   0xF1B4 0x1F02      CMP      R4,#+131074
   \   00000038   0xD03B             BEQ.N    ??I2C_CheckEvent_1
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable34_4  ;; 0x860080
   \   0000003E   0x4284             CMP      R4,R0
   \   00000040   0xD037             BEQ.N    ??I2C_CheckEvent_1
   \   00000042   0xF5B4 0x0F02      CMP      R4,#+8519680
   \   00000046   0xD034             BEQ.N    ??I2C_CheckEvent_1
   \   00000048   0xF5B4 0x1F90      CMP      R4,#+1179648
   \   0000004C   0xD031             BEQ.N    ??I2C_CheckEvent_1
   \   0000004E   0x....             LDR.N    R0,??DataTable34_5  ;; 0x20040
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD02E             BEQ.N    ??I2C_CheckEvent_1
   \   00000054   0x....             LDR.N    R0,??DataTable34_6  ;; 0x820040
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD02B             BEQ.N    ??I2C_CheckEvent_1
   \   0000005A   0x....             LDR.N    R0,??DataTable34_7  ;; 0x120040
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD028             BEQ.N    ??I2C_CheckEvent_1
   \   00000060   0x....             LDR.N    R0,??DataTable34_8  ;; 0x60084
   \   00000062   0x4284             CMP      R4,R0
   \   00000064   0xD025             BEQ.N    ??I2C_CheckEvent_1
   \   00000066   0x....             LDR.N    R0,??DataTable34_9  ;; 0x860084
   \   00000068   0x4284             CMP      R4,R0
   \   0000006A   0xD022             BEQ.N    ??I2C_CheckEvent_1
   \   0000006C   0x....             LDR.N    R0,??DataTable34_10  ;; 0x160084
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD01F             BEQ.N    ??I2C_CheckEvent_1
   \   00000072   0x2C10             CMP      R4,#+16
   \   00000074   0xD01D             BEQ.N    ??I2C_CheckEvent_1
   \   00000076   0x....             LDR.N    R0,??DataTable34_11  ;; 0x30001
   \   00000078   0x4284             CMP      R4,R0
   \   0000007A   0xD01A             BEQ.N    ??I2C_CheckEvent_1
   \   0000007C   0x....             LDR.N    R0,??DataTable34_12  ;; 0x70082
   \   0000007E   0x4284             CMP      R4,R0
   \   00000080   0xD017             BEQ.N    ??I2C_CheckEvent_1
   \   00000082   0x....             LDR.N    R0,??DataTable34_13  ;; 0x30002
   \   00000084   0x4284             CMP      R4,R0
   \   00000086   0xD014             BEQ.N    ??I2C_CheckEvent_1
   \   00000088   0x....             LDR.N    R0,??DataTable34_14  ;; 0x30040
   \   0000008A   0x4284             CMP      R4,R0
   \   0000008C   0xD011             BEQ.N    ??I2C_CheckEvent_1
   \   0000008E   0x....             LDR.N    R0,??DataTable34_15  ;; 0x70084
   \   00000090   0x4284             CMP      R4,R0
   \   00000092   0xD00E             BEQ.N    ??I2C_CheckEvent_1
   \   00000094   0x....             LDR.N    R0,??DataTable34_16  ;; 0x70080
   \   00000096   0x4284             CMP      R4,R0
   \   00000098   0xD00B             BEQ.N    ??I2C_CheckEvent_1
   \   0000009A   0x....             LDR.N    R0,??DataTable34_17  ;; 0x30008
   \   0000009C   0x4284             CMP      R4,R0
   \   0000009E   0xD008             BEQ.N    ??I2C_CheckEvent_1
   \   000000A0   0xF5B4 0x6F80      CMP      R4,#+1024
   \   000000A4   0xD005             BEQ.N    ??I2C_CheckEvent_1
   \   000000A6   0xF240 0x418E      MOVW     R1,#+1166
   \   000000AA   0x.... 0x....      ADR.W    R0,?_0
   \   000000AE   0x.... 0x....      BL       assert_failed
   1167          
   1168            /* Read the I2Cx status register */
   1169            flag1 = I2Cx->SR1;
   \                     ??I2C_CheckEvent_1: (+1)
   \   000000B2   0x8AB0             LDRH     R0,[R6, #+20]
   1170            flag2 = I2Cx->SR2;
   \   000000B4   0x8B31             LDRH     R1,[R6, #+24]
   1171            flag2 = flag2 << 16;
   1172          
   1173            /* Get the last event value from I2C status register */
   1174            lastevent = (flag1 | flag2) & FLAG_MASK;
   1175          
   1176            /* Check whether the last event contains the I2C_EVENT */
   1177            if ((lastevent & I2C_EVENT) == I2C_EVENT)
   \   000000B6   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   000000BA   0x4020             ANDS     R0,R4,R0
   \   000000BC   0x0200             LSLS     R0,R0,#+8
   \   000000BE   0x0A00             LSRS     R0,R0,#+8
   \   000000C0   0x42A0             CMP      R0,R4
   \   000000C2   0xD100             BNE.N    ??I2C_CheckEvent_2
   1178            {
   1179              /* SUCCESS: last event is equal to I2C_EVENT */
   1180              status = SUCCESS;
   \   000000C4   0x2501             MOVS     R5,#+1
   1181            }
   1182            else
   1183            {
   1184              /* ERROR: last event is different from I2C_EVENT */
   1185              status = ERROR;
   1186            }
   1187            /* Return status */
   1188            return status;
   \                     ??I2C_CheckEvent_2: (+1)
   \   000000C6   0x4628             MOV      R0,R5
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
   1189          }
   1190          
   1191          /*
   1192           ===============================================================================
   1193                                    2. Advanced state monitoring                   
   1194           ===============================================================================  
   1195           */
   1196          
   1197          /**
   1198            * @brief  Returns the last I2Cx Event.
   1199            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1200            *     
   1201            * @note   For detailed description of Events, please refer to section I2C_Events
   1202            *         in stm32f4xx_i2c.h file.
   1203            *    
   1204            * @retval The last event
   1205            */

   \                                 In section .text, align 2, keep-with-next
   1206          uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
   1207          {
   \                     I2C_GetLastEvent: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1208            uint32_t lastevent = 0;
   1209            uint32_t flag1 = 0, flag2 = 0;
   1210          
   1211            /* Check the parameters */
   1212            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000004   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40005400
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00B             BEQ.N    ??I2C_GetLastEvent_0
   \   0000000A   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40005800
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??I2C_GetLastEvent_0
   \   00000010   0x....             LDR.N    R0,??DataTable34  ;; 0x40005c00
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??I2C_GetLastEvent_0
   \   00000016   0xF240 0x41BC      MOVW     R1,#+1212
   \   0000001A   0x.... 0x....      ADR.W    R0,?_0
   \   0000001E   0x.... 0x....      BL       assert_failed
   1213          
   1214            /* Read the I2Cx status register */
   1215            flag1 = I2Cx->SR1;
   \                     ??I2C_GetLastEvent_0: (+1)
   \   00000022   0x8AA0             LDRH     R0,[R4, #+20]
   1216            flag2 = I2Cx->SR2;
   \   00000024   0x8B21             LDRH     R1,[R4, #+24]
   1217            flag2 = flag2 << 16;
   1218          
   1219            /* Get the last event value from I2C status register */
   1220            lastevent = (flag1 | flag2) & FLAG_MASK;
   1221          
   1222            /* Return status */
   1223            return lastevent;
   \   00000026   0xEA40 0x4001      ORR      R0,R0,R1, LSL #+16
   \   0000002A   0x0200             LSLS     R0,R0,#+8
   \   0000002C   0x0A00             LSRS     R0,R0,#+8
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1224          }
   1225          
   1226          /*
   1227           ===============================================================================
   1228                                    3. Flag-based state monitoring                   
   1229           ===============================================================================  
   1230           */
   1231          
   1232          /**
   1233            * @brief  Checks whether the specified I2C flag is set or not.
   1234            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1235            * @param  I2C_FLAG: specifies the flag to check. 
   1236            *          This parameter can be one of the following values:
   1237            *            @arg I2C_FLAG_DUALF: Dual flag (Slave mode)
   1238            *            @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)
   1239            *            @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)
   1240            *            @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)
   1241            *            @arg I2C_FLAG_TRA: Transmitter/Receiver flag
   1242            *            @arg I2C_FLAG_BUSY: Bus busy flag
   1243            *            @arg I2C_FLAG_MSL: Master/Slave flag
   1244            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1245            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1246            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1247            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1248            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1249            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1250            *            @arg I2C_FLAG_BERR: Bus error flag
   1251            *            @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)
   1252            *            @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag
   1253            *            @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)
   1254            *            @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)
   1255            *            @arg I2C_FLAG_BTF: Byte transfer finished flag
   1256            *            @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"
   1257            *                                Address matched flag (Slave mode)"ENDAD"
   1258            *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
   1259            * @retval The new state of I2C_FLAG (SET or RESET).
   1260            */

   \                                 In section .text, align 2, keep-with-next
   1261          FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1262          {
   \                     I2C_GetFlagStatus: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
   1263            FlagStatus bitstatus = RESET;
   \   00000006   0x2400             MOVS     R4,#+0
   1264            __IO uint32_t i2creg = 0, i2cxbase = 0;
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1265          
   1266            /* Check the parameters */
   1267            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   0000000E   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40005400
   \   00000010   0x4286             CMP      R6,R0
   \   00000012   0xD00B             BEQ.N    ??I2C_GetFlagStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40005800
   \   00000016   0x4286             CMP      R6,R0
   \   00000018   0xD008             BEQ.N    ??I2C_GetFlagStatus_0
   \   0000001A   0x....             LDR.N    R0,??DataTable34  ;; 0x40005c00
   \   0000001C   0x4286             CMP      R6,R0
   \   0000001E   0xD005             BEQ.N    ??I2C_GetFlagStatus_0
   \   00000020   0xF240 0x41F3      MOVW     R1,#+1267
   \   00000024   0x.... 0x....      ADR.W    R0,?_0
   \   00000028   0x.... 0x....      BL       assert_failed
   1268            assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
   \                     ??I2C_GetFlagStatus_0: (+1)
   \   0000002C   0xF5B5 0x0F00      CMP      R5,#+8388608
   \   00000030   0xD041             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000032   0xF5B5 0x0F80      CMP      R5,#+4194304
   \   00000036   0xD03E             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000038   0xF5B5 0x1F00      CMP      R5,#+2097152
   \   0000003C   0xD03B             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000003E   0xF5B5 0x1F80      CMP      R5,#+1048576
   \   00000042   0xD038             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000044   0xF5B5 0x2F80      CMP      R5,#+262144
   \   00000048   0xD035             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000004A   0xF5B5 0x3F00      CMP      R5,#+131072
   \   0000004E   0xD032             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000050   0xF5B5 0x3F80      CMP      R5,#+65536
   \   00000054   0xD02F             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000056   0x....             LDR.N    R0,??DataTable34_18  ;; 0x10008000
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD02C             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000005C   0x....             LDR.N    R0,??DataTable34_19  ;; 0x10004000
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD029             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000062   0xF1B5 0x2F10      CMP      R5,#+268439552
   \   00000066   0xD026             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000068   0x....             LDR.N    R0,??DataTable34_20  ;; 0x10000800
   \   0000006A   0x4285             CMP      R5,R0
   \   0000006C   0xD023             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000006E   0x....             LDR.N    R0,??DataTable34_21  ;; 0x10000400
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD020             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000074   0x....             LDR.N    R0,??DataTable34_22  ;; 0x10000200
   \   00000076   0x4285             CMP      R5,R0
   \   00000078   0xD01D             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000007A   0x....             LDR.N    R0,??DataTable34_23  ;; 0x10000100
   \   0000007C   0x4285             CMP      R5,R0
   \   0000007E   0xD01A             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000080   0x....             LDR.N    R0,??DataTable34_24  ;; 0x10000080
   \   00000082   0x4285             CMP      R5,R0
   \   00000084   0xD017             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000086   0x....             LDR.N    R0,??DataTable34_25  ;; 0x10000040
   \   00000088   0x4285             CMP      R5,R0
   \   0000008A   0xD014             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000008C   0x....             LDR.N    R0,??DataTable34_26  ;; 0x10000010
   \   0000008E   0x4285             CMP      R5,R0
   \   00000090   0xD011             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000092   0x....             LDR.N    R0,??DataTable34_27  ;; 0x10000008
   \   00000094   0x4285             CMP      R5,R0
   \   00000096   0xD00E             BEQ.N    ??I2C_GetFlagStatus_1
   \   00000098   0x....             LDR.N    R0,??DataTable34_28  ;; 0x10000004
   \   0000009A   0x4285             CMP      R5,R0
   \   0000009C   0xD00B             BEQ.N    ??I2C_GetFlagStatus_1
   \   0000009E   0x....             LDR.N    R0,??DataTable34_29  ;; 0x10000002
   \   000000A0   0x4285             CMP      R5,R0
   \   000000A2   0xD008             BEQ.N    ??I2C_GetFlagStatus_1
   \   000000A4   0x....             LDR.N    R0,??DataTable34_30  ;; 0x10000001
   \   000000A6   0x4285             CMP      R5,R0
   \   000000A8   0xD005             BEQ.N    ??I2C_GetFlagStatus_1
   \   000000AA   0xF240 0x41F4      MOVW     R1,#+1268
   \   000000AE   0x.... 0x....      ADR.W    R0,?_0
   \   000000B2   0x.... 0x....      BL       assert_failed
   1269          
   1270            /* Get the I2Cx peripheral base address */
   1271            i2cxbase = (uint32_t)I2Cx;
   \                     ??I2C_GetFlagStatus_1: (+1)
   \   000000B6   0x9600             STR      R6,[SP, #+0]
   1272            
   1273            /* Read flag register index */
   1274            i2creg = I2C_FLAG >> 28;
   \   000000B8   0x0F28             LSRS     R0,R5,#+28
   \   000000BA   0x9001             STR      R0,[SP, #+4]
   1275            
   1276            /* Get bit[23:0] of the flag */
   1277            I2C_FLAG &= FLAG_MASK;
   \   000000BC   0x0228             LSLS     R0,R5,#+8
   \   000000BE   0x0A00             LSRS     R0,R0,#+8
   1278            
   1279            if(i2creg != 0)
   \   000000C0   0x9901             LDR      R1,[SP, #+4]
   \   000000C2   0x2900             CMP      R1,#+0
   \   000000C4   0xD003             BEQ.N    ??I2C_GetFlagStatus_2
   1280            {
   1281              /* Get the I2Cx SR1 register address */
   1282              i2cxbase += 0x14;
   \   000000C6   0x9900             LDR      R1,[SP, #+0]
   \   000000C8   0x3114             ADDS     R1,R1,#+20
   \   000000CA   0x9100             STR      R1,[SP, #+0]
   \   000000CC   0xE003             B.N      ??I2C_GetFlagStatus_3
   1283            }
   1284            else
   1285            {
   1286              /* Flag in I2Cx SR2 Register */
   1287              I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
   \                     ??I2C_GetFlagStatus_2: (+1)
   \   000000CE   0x0C00             LSRS     R0,R0,#+16
   1288              /* Get the I2Cx SR2 register address */
   1289              i2cxbase += 0x18;
   \   000000D0   0x9900             LDR      R1,[SP, #+0]
   \   000000D2   0x3118             ADDS     R1,R1,#+24
   \   000000D4   0x9100             STR      R1,[SP, #+0]
   1290            }
   1291            
   1292            if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
   \                     ??I2C_GetFlagStatus_3: (+1)
   \   000000D6   0x9900             LDR      R1,[SP, #+0]
   \   000000D8   0x6809             LDR      R1,[R1, #+0]
   \   000000DA   0x4201             TST      R1,R0
   \   000000DC   0xD000             BEQ.N    ??I2C_GetFlagStatus_4
   1293            {
   1294              /* I2C_FLAG is set */
   1295              bitstatus = SET;
   \   000000DE   0x2401             MOVS     R4,#+1
   1296            }
   1297            else
   1298            {
   1299              /* I2C_FLAG is reset */
   1300              bitstatus = RESET;
   1301            }
   1302            
   1303            /* Return the I2C_FLAG status */
   1304            return  bitstatus;
   \                     ??I2C_GetFlagStatus_4: (+1)
   \   000000E0   0x4620             MOV      R0,R4
   \   000000E2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1305          }
   1306          
   1307          /**
   1308            * @brief  Clears the I2Cx's pending flags.
   1309            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1310            * @param  I2C_FLAG: specifies the flag to clear. 
   1311            *          This parameter can be any combination of the following values:
   1312            *            @arg I2C_FLAG_SMBALERT: SMBus Alert flag
   1313            *            @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag
   1314            *            @arg I2C_FLAG_PECERR: PEC error in reception flag
   1315            *            @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)
   1316            *            @arg I2C_FLAG_AF: Acknowledge failure flag
   1317            *            @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)
   1318            *            @arg I2C_FLAG_BERR: Bus error flag
   1319            *   
   1320            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1321            *          to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation 
   1322            *          to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1323            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1324            *          operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the 
   1325            *          second byte of the address in DR register.
   1326            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1327            *          operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a 
   1328            *          read/write to I2C_DR register (I2C_SendData()).
   1329            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1330            *          I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to 
   1331            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1332            * @note   SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1
   1333            *          register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
   1334            *          register (I2C_SendData()).
   1335            *  
   1336            * @retval None
   1337            */

   \                                 In section .text, align 2, keep-with-next
   1338          void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
   1339          {
   \                     I2C_ClearFlag: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1340            uint32_t flagpos = 0;
   1341            /* Check the parameters */
   1342            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??I2C_ClearFlag_0
   \   0000000C   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??I2C_ClearFlag_0
   \   00000012   0x....             LDR.N    R0,??DataTable34  ;; 0x40005c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??I2C_ClearFlag_0
   \   00000018   0xF240 0x513E      MOVW     R1,#+1342
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1343            assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
   \                     ??I2C_ClearFlag_0: (+1)
   \   00000024   0xF242 0x00FF      MOVW     R0,#+8447
   \   00000028   0x4205             TST      R5,R0
   \   0000002A   0xD101             BNE.N    ??I2C_ClearFlag_1
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD105             BNE.N    ??I2C_ClearFlag_2
   \                     ??I2C_ClearFlag_1: (+1)
   \   00000030   0xF240 0x513F      MOVW     R1,#+1343
   \   00000034   0x.... 0x....      ADR.W    R0,?_0
   \   00000038   0x.... 0x....      BL       assert_failed
   1344            /* Get the I2C flag position */
   1345            flagpos = I2C_FLAG & FLAG_MASK;
   1346            /* Clear the selected I2C flag */
   1347            I2Cx->SR1 = (uint16_t)~flagpos;
   \                     ??I2C_ClearFlag_2: (+1)
   \   0000003C   0x43E8             MVNS     R0,R5
   \   0000003E   0x82A0             STRH     R0,[R4, #+20]
   1348          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1349          
   1350          /**
   1351            * @brief  Checks whether the specified I2C interrupt has occurred or not.
   1352            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1353            * @param  I2C_IT: specifies the interrupt source to check. 
   1354            *          This parameter can be one of the following values:
   1355            *            @arg I2C_IT_SMBALERT: SMBus Alert flag
   1356            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag
   1357            *            @arg I2C_IT_PECERR: PEC error in reception flag
   1358            *            @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)
   1359            *            @arg I2C_IT_AF: Acknowledge failure flag
   1360            *            @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)
   1361            *            @arg I2C_IT_BERR: Bus error flag
   1362            *            @arg I2C_IT_TXE: Data register empty flag (Transmitter)
   1363            *            @arg I2C_IT_RXNE: Data register not empty (Receiver) flag
   1364            *            @arg I2C_IT_STOPF: Stop detection flag (Slave mode)
   1365            *            @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)
   1366            *            @arg I2C_IT_BTF: Byte transfer finished flag
   1367            *            @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"
   1368            *                              Address matched flag (Slave mode)"ENDAD"
   1369            *            @arg I2C_IT_SB: Start bit flag (Master mode)
   1370            * @retval The new state of I2C_IT (SET or RESET).
   1371            */

   \                                 In section .text, align 2, keep-with-next
   1372          ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1373          {
   \                     I2C_GetITStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1374            ITStatus bitstatus = RESET;
   \   00000006   0x2600             MOVS     R6,#+0
   1375            uint32_t enablestatus = 0;
   1376          
   1377            /* Check the parameters */
   1378            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000008   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40005400
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00B             BEQ.N    ??I2C_GetITStatus_0
   \   0000000E   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40005800
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD008             BEQ.N    ??I2C_GetITStatus_0
   \   00000014   0x....             LDR.N    R0,??DataTable34  ;; 0x40005c00
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD005             BEQ.N    ??I2C_GetITStatus_0
   \   0000001A   0xF240 0x5162      MOVW     R1,#+1378
   \   0000001E   0x.... 0x....      ADR.W    R0,?_0
   \   00000022   0x.... 0x....      BL       assert_failed
   1379            assert_param(IS_I2C_GET_IT(I2C_IT));
   \                     ??I2C_GetITStatus_0: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable34_31  ;; 0x1008000
   \   00000028   0x4285             CMP      R5,R0
   \   0000002A   0xD02C             BEQ.N    ??I2C_GetITStatus_1
   \   0000002C   0x....             LDR.N    R0,??DataTable34_32  ;; 0x1004000
   \   0000002E   0x4285             CMP      R5,R0
   \   00000030   0xD029             BEQ.N    ??I2C_GetITStatus_1
   \   00000032   0x....             LDR.N    R0,??DataTable34_33  ;; 0x1001000
   \   00000034   0x4285             CMP      R5,R0
   \   00000036   0xD026             BEQ.N    ??I2C_GetITStatus_1
   \   00000038   0x....             LDR.N    R0,??DataTable34_34  ;; 0x1000800
   \   0000003A   0x4285             CMP      R5,R0
   \   0000003C   0xD023             BEQ.N    ??I2C_GetITStatus_1
   \   0000003E   0x....             LDR.N    R0,??DataTable34_35  ;; 0x1000400
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD020             BEQ.N    ??I2C_GetITStatus_1
   \   00000044   0x....             LDR.N    R0,??DataTable34_36  ;; 0x1000200
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD01D             BEQ.N    ??I2C_GetITStatus_1
   \   0000004A   0xF1B5 0x2F01      CMP      R5,#+16777472
   \   0000004E   0xD01A             BEQ.N    ??I2C_GetITStatus_1
   \   00000050   0x....             LDR.N    R0,??DataTable34_37  ;; 0x6000080
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD017             BEQ.N    ??I2C_GetITStatus_1
   \   00000056   0x....             LDR.N    R0,??DataTable34_38  ;; 0x6000040
   \   00000058   0x4285             CMP      R5,R0
   \   0000005A   0xD014             BEQ.N    ??I2C_GetITStatus_1
   \   0000005C   0x....             LDR.N    R0,??DataTable34_39  ;; 0x2000010
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xD011             BEQ.N    ??I2C_GetITStatus_1
   \   00000062   0x....             LDR.N    R0,??DataTable34_40  ;; 0x2000008
   \   00000064   0x4285             CMP      R5,R0
   \   00000066   0xD00E             BEQ.N    ??I2C_GetITStatus_1
   \   00000068   0x....             LDR.N    R0,??DataTable34_41  ;; 0x2000004
   \   0000006A   0x4285             CMP      R5,R0
   \   0000006C   0xD00B             BEQ.N    ??I2C_GetITStatus_1
   \   0000006E   0x....             LDR.N    R0,??DataTable34_42  ;; 0x2000002
   \   00000070   0x4285             CMP      R5,R0
   \   00000072   0xD008             BEQ.N    ??I2C_GetITStatus_1
   \   00000074   0x....             LDR.N    R0,??DataTable34_43  ;; 0x2000001
   \   00000076   0x4285             CMP      R5,R0
   \   00000078   0xD005             BEQ.N    ??I2C_GetITStatus_1
   \   0000007A   0xF240 0x5163      MOVW     R1,#+1379
   \   0000007E   0x.... 0x....      ADR.W    R0,?_0
   \   00000082   0x.... 0x....      BL       assert_failed
   1380          
   1381            /* Check if the interrupt source is enabled or not */
   1382            enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
   \                     ??I2C_GetITStatus_1: (+1)
   \   00000086   0x88A0             LDRH     R0,[R4, #+4]
   \   00000088   0xEA00 0x4015      AND      R0,R0,R5, LSR #+16
   \   0000008C   0xF400 0x60E0      AND      R0,R0,#0x700
   1383            
   1384            /* Get bit[23:0] of the flag */
   1385            I2C_IT &= FLAG_MASK;
   1386          
   1387            /* Check the status of the specified I2C flag */
   1388            if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
   \   00000090   0x8AA1             LDRH     R1,[R4, #+20]
   \   00000092   0x4229             TST      R1,R5
   \   00000094   0xD002             BEQ.N    ??I2C_GetITStatus_2
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD000             BEQ.N    ??I2C_GetITStatus_2
   1389            {
   1390              /* I2C_IT is set */
   1391              bitstatus = SET;
   \   0000009A   0x2601             MOVS     R6,#+1
   1392            }
   1393            else
   1394            {
   1395              /* I2C_IT is reset */
   1396              bitstatus = RESET;
   1397            }
   1398            /* Return the I2C_IT status */
   1399            return  bitstatus;
   \                     ??I2C_GetITStatus_2: (+1)
   \   0000009C   0x4630             MOV      R0,R6
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
   1400          }
   1401          
   1402          /**
   1403            * @brief  Clears the I2Cx's interrupt pending bits.
   1404            * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
   1405            * @param  I2C_IT: specifies the interrupt pending bit to clear. 
   1406            *          This parameter can be any combination of the following values:
   1407            *            @arg I2C_IT_SMBALERT: SMBus Alert interrupt
   1408            *            @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt
   1409            *            @arg I2C_IT_PECERR: PEC error in reception  interrupt
   1410            *            @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)
   1411            *            @arg I2C_IT_AF: Acknowledge failure interrupt
   1412            *            @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)
   1413            *            @arg I2C_IT_BERR: Bus error interrupt
   1414            * 
   1415            * @note   STOPF (STOP detection) is cleared by software sequence: a read operation 
   1416            *          to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1417            *          I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).
   1418            * @note   ADD10 (10-bit header sent) is cleared by software sequence: a read 
   1419            *          operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second 
   1420            *          byte of the address in I2C_DR register.
   1421            * @note   BTF (Byte Transfer Finished) is cleared by software sequence: a read 
   1422            *          operation to I2C_SR1 register (I2C_GetITStatus()) followed by a 
   1423            *          read/write to I2C_DR register (I2C_SendData()).
   1424            * @note   ADDR (Address sent) is cleared by software sequence: a read operation to 
   1425            *          I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to 
   1426            *          I2C_SR2 register ((void)(I2Cx->SR2)).
   1427            * @note   SB (Start Bit) is cleared by software sequence: a read operation to 
   1428            *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
   1429            *          I2C_DR register (I2C_SendData()).
   1430            * @retval None
   1431            */

   \                                 In section .text, align 2, keep-with-next
   1432          void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
   1433          {
   \                     I2C_ClearITPendingBit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1434            uint32_t flagpos = 0;
   1435            /* Check the parameters */
   1436            assert_param(IS_I2C_ALL_PERIPH(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable34_1  ;; 0x40005400
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00B             BEQ.N    ??I2C_ClearITPendingBit_0
   \   0000000C   0x....             LDR.N    R0,??DataTable34_2  ;; 0x40005800
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD008             BEQ.N    ??I2C_ClearITPendingBit_0
   \   00000012   0x....             LDR.N    R0,??DataTable34  ;; 0x40005c00
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD005             BEQ.N    ??I2C_ClearITPendingBit_0
   \   00000018   0xF240 0x519C      MOVW     R1,#+1436
   \   0000001C   0x.... 0x....      ADR.W    R0,?_0
   \   00000020   0x.... 0x....      BL       assert_failed
   1437            assert_param(IS_I2C_CLEAR_IT(I2C_IT));
   \                     ??I2C_ClearITPendingBit_0: (+1)
   \   00000024   0xF242 0x00FF      MOVW     R0,#+8447
   \   00000028   0x4205             TST      R5,R0
   \   0000002A   0xD101             BNE.N    ??I2C_ClearITPendingBit_1
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD105             BNE.N    ??I2C_ClearITPendingBit_2
   \                     ??I2C_ClearITPendingBit_1: (+1)
   \   00000030   0xF240 0x519D      MOVW     R1,#+1437
   \   00000034   0x.... 0x....      ADR.W    R0,?_0
   \   00000038   0x.... 0x....      BL       assert_failed
   1438          
   1439            /* Get the I2C flag position */
   1440            flagpos = I2C_IT & FLAG_MASK;
   1441          
   1442            /* Clear the selected I2C flag */
   1443            I2Cx->SR1 = (uint16_t)~flagpos;
   \                     ??I2C_ClearITPendingBit_2: (+1)
   \   0000003C   0x43E8             MVNS     R0,R5
   \   0000003E   0x82A0             STRH     R0,[R4, #+20]
   1444          }
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x40005C00         DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0x00061A81         DC32     0x61a81

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   0x000186A1         DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   0x40005C00         DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \   00000000   0x40005400         DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_2:
   \   00000000   0x40005800         DC32     0x40005800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_3:
   \   00000000   0x00060082         DC32     0x60082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_4:
   \   00000000   0x00860080         DC32     0x860080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_5:
   \   00000000   0x00020040         DC32     0x20040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_6:
   \   00000000   0x00820040         DC32     0x820040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_7:
   \   00000000   0x00120040         DC32     0x120040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_8:
   \   00000000   0x00060084         DC32     0x60084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_9:
   \   00000000   0x00860084         DC32     0x860084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_10:
   \   00000000   0x00160084         DC32     0x160084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_11:
   \   00000000   0x00030001         DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_12:
   \   00000000   0x00070082         DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_13:
   \   00000000   0x00030002         DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_14:
   \   00000000   0x00030040         DC32     0x30040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_15:
   \   00000000   0x00070084         DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_16:
   \   00000000   0x00070080         DC32     0x70080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_17:
   \   00000000   0x00030008         DC32     0x30008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_18:
   \   00000000   0x10008000         DC32     0x10008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_19:
   \   00000000   0x10004000         DC32     0x10004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_20:
   \   00000000   0x10000800         DC32     0x10000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_21:
   \   00000000   0x10000400         DC32     0x10000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_22:
   \   00000000   0x10000200         DC32     0x10000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_23:
   \   00000000   0x10000100         DC32     0x10000100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_24:
   \   00000000   0x10000080         DC32     0x10000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_25:
   \   00000000   0x10000040         DC32     0x10000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_26:
   \   00000000   0x10000010         DC32     0x10000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_27:
   \   00000000   0x10000008         DC32     0x10000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_28:
   \   00000000   0x10000004         DC32     0x10000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_29:
   \   00000000   0x10000002         DC32     0x10000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_30:
   \   00000000   0x10000001         DC32     0x10000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_31:
   \   00000000   0x01008000         DC32     0x1008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_32:
   \   00000000   0x01004000         DC32     0x1004000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_33:
   \   00000000   0x01001000         DC32     0x1001000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_34:
   \   00000000   0x01000800         DC32     0x1000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_35:
   \   00000000   0x01000400         DC32     0x1000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_36:
   \   00000000   0x01000200         DC32     0x1000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_37:
   \   00000000   0x06000080         DC32     0x6000080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_38:
   \   00000000   0x06000040         DC32     0x6000040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_39:
   \   00000000   0x02000010         DC32     0x2000010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_40:
   \   00000000   0x02000008         DC32     0x2000008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_41:
   \   00000000   0x02000004         DC32     0x2000004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_42:
   \   00000000   0x02000002         DC32     0x2000002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_43:
   \   00000000   0x02000001         DC32     0x2000001

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x44 0x3A          DC8 44H, 3AH, 5CH, 57H, 4FH, 52H, 4BH, 5CH
   \              0x5C 0x57    
   \              0x4F 0x52    
   \              0x4B 0x5C    
   \   00000008   0x46 0x69          DC8 46H, 69H, 72H, 6DH, 77H, 61H, 72H, 65H
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \   00000010   0x5F 0x4C          DC8 5FH, 4CH, 61H, 73H, 74H, 52H, 65H, 6CH
   \              0x61 0x73    
   \              0x74 0x52    
   \              0x65 0x6C    
   \   00000018   0x65 0x61          DC8 65H, 61H, 73H, 65H, 5CH, 5FH, 37H, 2EH
   \              0x73 0x65    
   \              0x5C 0x5F    
   \              0x37 0x2E    
   \   00000020   0x30 0x2E          DC8 30H, 2EH, 39H, 35H, 5CH, 4DH, 61H, 69H
   \              0x39 0x35    
   \              0x5C 0x4D    
   \              0x61 0x69    
   \   00000028   0x6E 0x4D          DC8 6EH, 4DH, 43H, 55H, 5CH, 4CH, 69H, 62H
   \              0x43 0x55    
   \              0x5C 0x4C    
   \              0x69 0x62    
   \   00000030   0x72 0x61          DC8 72H, 61H, 72H, 69H, 65H, 73H, 5CH, 53H
   \              0x72 0x69    
   \              0x65 0x73    
   \              0x5C 0x53    
   \   00000038   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 78H, 78H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x78 0x78    
   \   00000040   0x5F 0x53          DC8 5FH, 53H, 74H, 64H, 50H, 65H, 72H, 69H
   \              0x74 0x64    
   \              0x50 0x65    
   \              0x72 0x69    
   \   00000048   0x70 0x68          DC8 70H, 68H, 5FH, 44H, 72H, 69H, 76H, 65H
   \              0x5F 0x44    
   \              0x72 0x69    
   \              0x76 0x65    
   \   00000050   0x72 0x5C          DC8 72H, 5CH, 73H, 72H, 63H, 5CH, 73H, 74H
   \              0x73 0x72    
   \              0x63 0x5C    
   \              0x73 0x74    
   \   00000058   0x6D 0x33          DC8 6DH, 33H, 32H, 66H, 34H, 78H, 78H, 5FH
   \              0x32 0x66    
   \              0x34 0x78    
   \              0x78 0x5F    
   \   00000060   0x69 0x32          DC8 69H, 32H, 63H, 2EH, 63H, 0
   \              0x63 0x2E    
   \              0x63 0x00    
   \   00000066   0x00 0x00          DC8 0, 0
   1445          
   1446          /**
   1447            * @}
   1448            */
   1449          
   1450          /**
   1451            * @}
   1452            */ 
   1453          
   1454          /**
   1455            * @}
   1456            */ 
   1457          
   1458          /**
   1459            * @}
   1460            */ 
   1461          
   1462          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2C_ARPCmd
        16   -> assert_failed
      16   I2C_AcknowledgeConfig
        16   -> assert_failed
      16   I2C_AnalogFilterCmd
        16   -> assert_failed
      16   I2C_CalculatePEC
        16   -> assert_failed
      16   I2C_CheckEvent
        16   -> assert_failed
      16   I2C_ClearFlag
        16   -> assert_failed
      16   I2C_ClearITPendingBit
        16   -> assert_failed
      16   I2C_Cmd
        16   -> assert_failed
      16   I2C_DMACmd
        16   -> assert_failed
      16   I2C_DMALastTransferCmd
        16   -> assert_failed
      16   I2C_DeInit
        16   -> RCC_APB1PeriphResetCmd
        16   -> assert_failed
      16   I2C_DigitalFilterConfig
        16   -> assert_failed
      16   I2C_DualAddressCmd
        16   -> assert_failed
      16   I2C_FastModeDutyCycleConfig
        16   -> assert_failed
      16   I2C_GeneralCallCmd
        16   -> assert_failed
      16   I2C_GenerateSTART
        16   -> assert_failed
      16   I2C_GenerateSTOP
        16   -> assert_failed
      24   I2C_GetFlagStatus
        24   -> assert_failed
      16   I2C_GetITStatus
        16   -> assert_failed
       8   I2C_GetLastEvent
         8   -> assert_failed
       8   I2C_GetPEC
         8   -> assert_failed
      16   I2C_ITConfig
        16   -> assert_failed
      32   I2C_Init
        32   -> RCC_GetClocksFreq
        32   -> assert_failed
      16   I2C_NACKPositionConfig
        16   -> assert_failed
      16   I2C_OwnAddress2Config
        16   -> assert_failed
      16   I2C_PECPositionConfig
        16   -> assert_failed
      16   I2C_ReadRegister
        16   -> assert_failed
       8   I2C_ReceiveData
         8   -> assert_failed
      16   I2C_SMBusAlertConfig
        16   -> assert_failed
      16   I2C_Send7bitAddress
        16   -> assert_failed
      16   I2C_SendData
        16   -> assert_failed
      16   I2C_SoftwareResetCmd
        16   -> assert_failed
      16   I2C_StretchClockCmd
        16   -> assert_failed
       0   I2C_StructInit
      16   I2C_TransmitPEC
        16   -> assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable30
       4  ??DataTable33
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable34_10
       4  ??DataTable34_11
       4  ??DataTable34_12
       4  ??DataTable34_13
       4  ??DataTable34_14
       4  ??DataTable34_15
       4  ??DataTable34_16
       4  ??DataTable34_17
       4  ??DataTable34_18
       4  ??DataTable34_19
       4  ??DataTable34_2
       4  ??DataTable34_20
       4  ??DataTable34_21
       4  ??DataTable34_22
       4  ??DataTable34_23
       4  ??DataTable34_24
       4  ??DataTable34_25
       4  ??DataTable34_26
       4  ??DataTable34_27
       4  ??DataTable34_28
       4  ??DataTable34_29
       4  ??DataTable34_3
       4  ??DataTable34_30
       4  ??DataTable34_31
       4  ??DataTable34_32
       4  ??DataTable34_33
       4  ??DataTable34_34
       4  ??DataTable34_35
       4  ??DataTable34_36
       4  ??DataTable34_37
       4  ??DataTable34_38
       4  ??DataTable34_39
       4  ??DataTable34_4
       4  ??DataTable34_40
       4  ??DataTable34_41
       4  ??DataTable34_42
       4  ??DataTable34_43
       4  ??DataTable34_5
       4  ??DataTable34_6
       4  ??DataTable34_7
       4  ??DataTable34_8
       4  ??DataTable34_9
     104  ?_0
      86  I2C_ARPCmd
      86  I2C_AcknowledgeConfig
      86  I2C_AnalogFilterCmd
      82  I2C_CalculatePEC
     202  I2C_CheckEvent
      66  I2C_ClearFlag
      66  I2C_ClearITPendingBit
      86  I2C_Cmd
      82  I2C_DMACmd
      82  I2C_DMALastTransferCmd
     132  I2C_DeInit
      76  I2C_DigitalFilterConfig
      86  I2C_DualAddressCmd
      94  I2C_FastModeDutyCycleConfig
      86  I2C_GeneralCallCmd
      86  I2C_GenerateSTART
      86  I2C_GenerateSTOP
     228  I2C_GetFlagStatus
     160  I2C_GetITStatus
      48  I2C_GetLastEvent
      42  I2C_GetPEC
     102  I2C_ITConfig
     344  I2C_Init
      94  I2C_NACKPositionConfig
      60  I2C_OwnAddress2Config
      90  I2C_PECPositionConfig
     108  I2C_ReadRegister
      42  I2C_ReceiveData
      94  I2C_SMBusAlertConfig
      82  I2C_Send7bitAddress
      42  I2C_SendData
      84  I2C_SoftwareResetCmd
      86  I2C_StretchClockCmd
      30  I2C_StructInit
      82  I2C_TransmitPEC

 
 3 696 bytes in section .text
 
 3 696 bytes of CODE memory

Errors: none
Warnings: none
